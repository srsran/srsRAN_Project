/*
 *
 * Copyright 2021-2025 Software Radio Systems Limited
 *
 * This file is part of srsRAN.
 *
 * srsRAN is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsRAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srsran/asn1/xnap/xnap_ies.h"
using namespace asn1;
using namespace asn1::xnap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// GlobalAMF-Region-Information ::= SEQUENCE
SRSASN_CODE global_amf_region_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(amf_region_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_amf_region_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(amf_region_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_amf_region_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-ID", plmn_id.to_string());
  j.write_str("amf-region-id", amf_region_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AS-SecurityInformation ::= SEQUENCE
SRSASN_CODE as_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(key_ng_ran_star.pack(bref));
  HANDLE_CODE(pack_integer(bref, ncc, (uint8_t)0u, (uint8_t)7u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE as_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(key_ng_ran_star.unpack(bref));
  HANDLE_CODE(unpack_integer(ncc, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void as_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("key-NG-RAN-Star", key_ng_ran_star.to_string());
  j.write_int("ncc", ncc);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RACHReportList-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t rach_report_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {361};
  return map_enum_number(names, 1, idx, "id");
}
bool rach_report_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 361 == id;
}
crit_e rach_report_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 361) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
rach_report_list_item_ext_ies_o::ext_c rach_report_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 361) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rach_report_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 361) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void rach_report_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..4294967295)", c);
  j.end_obj();
}
SRSASN_CODE rach_report_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE rach_report_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  return SRSASN_SUCCESS;
}

const char* rach_report_list_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)"};
  return convert_enum_idx(names, 1, value, "rach_report_list_item_ext_ies_o::ext_c::types");
}
uint8_t rach_report_list_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "rach_report_list_item_ext_ies_o::ext_c::types");
}

// RACHReportList-Item ::= SEQUENCE
SRSASN_CODE rach_report_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(rach_report.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rach_report_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rach_report.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void rach_report_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rACHReport", rach_report.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SuccessfulHOReportList-Item ::= SEQUENCE
SRSASN_CODE successful_ho_report_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE successful_ho_report_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void successful_ho_report_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("successfulHOReport", successful_ho_report.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-UTRA-CGI ::= SEQUENCE
SRSASN_CODE e_utra_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(e_utra_ci.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE e_utra_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(e_utra_ci.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void e_utra_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.write_str("e-utra-CI", e_utra_ci.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NR-CGI ::= SEQUENCE
SRSASN_CODE nr_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(nr_ci.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(nr_ci.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.write_str("nr-CI", nr_ci.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// PacketErrorRate ::= SEQUENCE
SRSASN_CODE packet_error_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, per_scalar, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(pack_integer(bref, per_exponent, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE packet_error_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(per_scalar, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(unpack_integer(per_exponent, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void packet_error_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pER-Scalar", per_scalar);
  j.write_int("pER-Exponent", per_exponent);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AlternativeQoSParaSetItem ::= SEQUENCE
SRSASN_CODE alt_qos_para_set_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.pack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, alt_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alt_qos_para_set_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.unpack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.unpack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(alt_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alt_qos_para_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("alternativeQoSParaSetIndex", alt_qos_para_set_idx);
  if (guaranteed_flow_bit_rate_dl_present) {
    j.write_int("guaranteedFlowBitRateDL", guaranteed_flow_bit_rate_dl);
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    j.write_int("guaranteedFlowBitRateUL", guaranteed_flow_bit_rate_ul);
  }
  if (packet_delay_budget_present) {
    j.write_int("packetDelayBudget", packet_delay_budget);
  }
  if (packet_error_rate_present) {
    j.write_fieldname("packetErrorRate");
    packet_error_rate.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Dynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {215, 208, 209};
  return map_enum_number(names, 3, idx, "id");
}
bool dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {215, 208, 209};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 215:
      return crit_e::ignore;
    case 208:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dyn_5qi_descriptor_ext_ies_o::ext_c dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 215:
      ret.set(ext_c::types::extended_packet_delay_budget);
      break;
    case 208:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 209:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 215:
      return presence_e::optional;
    case 208:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::extended_packet_delay_budget:
      c = uint32_t{};
      break;
    case types::cn_packet_delay_budget_dl:
      c = uint32_t{};
      break;
    case types::cn_packet_delay_budget_ul:
      c = uint32_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget()
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget() const
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_packet_delay_budget:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dyn_5qi_descriptor_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..65535,...)", "INTEGER (0..65535,...)", "INTEGER (0..65535,...)"};
  return convert_enum_idx(names, 3, value, "dyn_5qi_descriptor_ext_ies_o::ext_c::types");
}

// MBS-ServiceAreaTAI-Item ::= SEQUENCE
SRSASN_CODE mbs_service_area_tai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_tai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_tai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-ID", plmn_id.to_string());
  j.write_str("tAC", tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NonDynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t non_dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {208, 209};
  return map_enum_number(names, 2, idx, "id");
}
bool non_dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {208, 209};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e non_dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 208:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c non_dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 208:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 209:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e non_dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 208:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c = uint32_t{};
      break;
    case types::cn_packet_delay_budget_ul:
      c = uint32_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* non_dyn_5qi_descriptor_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..65535,...)", "INTEGER (0..65535,...)"};
  return convert_enum_idx(names, 2, value, "non_dyn_5qi_descriptor_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<dyn_5qi_descriptor_ext_ies_o>;

SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_packet_delay_budget_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_packet_delay_budget_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_packet_delay_budget, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)208, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_dl, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_ul, (uint32_t)0u, (uint32_t)65535u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 215: {
        extended_packet_delay_budget_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_packet_delay_budget, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 208: {
        cn_packet_delay_budget_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_dl, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 209: {
        cn_packet_delay_budget_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_ul, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_packet_delay_budget_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", extended_packet_delay_budget);
  }
  if (cn_packet_delay_budget_dl_present) {
    j.write_int("id", 208);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_dl);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_ul);
  }
  j.end_obj();
}

// Dynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_qi_present, 1));
  HANDLE_CODE(bref.pack(delay_crit_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level_qos, (uint8_t)1u, (uint8_t)127u, true, true));
  HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.pack(bref));
  if (five_qi_present) {
    HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.pack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_qi_present, 1));
  HANDLE_CODE(bref.unpack(delay_crit_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(prio_level_qos, bref, (uint8_t)1u, (uint8_t)127u, true, true));
  HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.unpack(bref));
  if (five_qi_present) {
    HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.unpack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevelQoS", prio_level_qos);
  j.write_int("packetDelayBudget", packet_delay_budget);
  j.write_fieldname("packetErrorRate");
  packet_error_rate.to_json(j);
  if (five_qi_present) {
    j.write_int("fiveQI", five_qi);
  }
  if (delay_crit_present) {
    j.write_str("delayCritical", delay_crit.to_string());
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maximumDataBurstVolume", max_data_burst_volume);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* dyn_5qi_descriptor_s::delay_crit_opts::to_string() const
{
  static const char* names[] = {"delay-critical", "non-delay-critical"};
  return convert_enum_idx(names, 2, value, "dyn_5qi_descriptor_s::delay_crit_e_");
}

// GBRQoSFlowInfo-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t gbr_qos_flow_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {174};
  return map_enum_number(names, 1, idx, "id");
}
bool gbr_qos_flow_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 174 == id;
}
crit_e gbr_qos_flow_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 174) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
gbr_qos_flow_info_ext_ies_o::ext_c gbr_qos_flow_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 174) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gbr_qos_flow_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 174) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void gbr_qos_flow_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("AlternativeQoSParaSetList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE gbr_qos_flow_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 8, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_flow_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 8, true));
  return SRSASN_SUCCESS;
}

const char* gbr_qos_flow_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AlternativeQoSParaSetList"};
  return convert_enum_idx(names, 1, value, "gbr_qos_flow_info_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<non_dyn_5qi_descriptor_ext_ies_o>;

SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)208, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_dl, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_ul, (uint32_t)0u, (uint32_t)65535u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 208: {
        cn_packet_delay_budget_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_dl, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 209: {
        cn_packet_delay_budget_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_ul, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cn_packet_delay_budget_dl_present) {
    j.write_int("id", 208);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_dl);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_ul);
  }
  j.end_obj();
}

// NonDynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE non_dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(prio_level_qos_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (prio_level_qos_present) {
    HANDLE_CODE(pack_integer(bref, prio_level_qos, (uint8_t)1u, (uint8_t)127u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(prio_level_qos_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (prio_level_qos_present) {
    HANDLE_CODE(unpack_integer(prio_level_qos, bref, (uint8_t)1u, (uint8_t)127u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQI", five_qi);
  if (prio_level_qos_present) {
    j.write_int("priorityLevelQoS", prio_level_qos);
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maximumDataBurstVolume", max_data_burst_volume);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// QoSMonitoringDisabled ::= ENUMERATED
const char* qos_monitoring_disabled_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "qos_monitoring_disabled_e");
}

// QosMonitoringRequest ::= ENUMERATED
const char* qos_monitoring_request_opts::to_string() const
{
  static const char* names[] = {"ul", "dl", "both"};
  return convert_enum_idx(names, 3, value, "qos_monitoring_request_e");
}

// AllocationandRetentionPriority ::= SEQUENCE
SRSASN_CODE allocand_retention_prio_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(pre_emption_cap.pack(bref));
  HANDLE_CODE(pre_emption_vulnerability.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE allocand_retention_prio_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(pre_emption_cap.unpack(bref));
  HANDLE_CODE(pre_emption_vulnerability.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void allocand_retention_prio_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevel", prio_level);
  j.write_str("pre-emption-capability", pre_emption_cap.to_string());
  j.write_str("pre-emption-vulnerability", pre_emption_vulnerability.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* allocand_retention_prio_s::pre_emption_cap_opts::to_string() const
{
  static const char* names[] = {"shall-not-trigger-preemption", "may-trigger-preemption"};
  return convert_enum_idx(names, 2, value, "allocand_retention_prio_s::pre_emption_cap_e_");
}

const char* allocand_retention_prio_s::pre_emption_vulnerability_opts::to_string() const
{
  static const char* names[] = {"not-preemptable", "preemptable"};
  return convert_enum_idx(names, 2, value, "allocand_retention_prio_s::pre_emption_vulnerability_e_");
}

// GBRQoSFlowInfo ::= SEQUENCE
SRSASN_CODE gbr_qos_flow_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.pack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(max_packet_loss_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.pack(bref));
  }
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_dl, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_ul, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_flow_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_ul_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(max_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.unpack(bref));
  }
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_dl, bref, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_ul, bref, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void gbr_qos_flow_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("maxFlowBitRateDL", max_flow_bit_rate_dl);
  j.write_int("maxFlowBitRateUL", max_flow_bit_rate_ul);
  j.write_int("guaranteedFlowBitRateDL", guaranteed_flow_bit_rate_dl);
  j.write_int("guaranteedFlowBitRateUL", guaranteed_flow_bit_rate_ul);
  if (notif_ctrl_present) {
    j.write_str("notificationControl", "notification-requested");
  }
  if (max_packet_loss_rate_dl_present) {
    j.write_int("maxPacketLossRateDL", max_packet_loss_rate_dl);
  }
  if (max_packet_loss_rate_ul_present) {
    j.write_int("maxPacketLossRateUL", max_packet_loss_rate_ul);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* gbr_qos_flow_info_s::notif_ctrl_opts::to_string() const
{
  static const char* names[] = {"notification-requested"};
  return convert_enum_idx(names, 1, value, "gbr_qos_flow_info_s::notif_ctrl_e_");
}

// MBS-ServiceAreaInformation ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_service_area_cell_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_tai_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_service_area_cell_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_cell_list, 1, 8192, true));
  }
  if (mbs_service_area_tai_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_tai_list, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mbs_service_area_cell_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_cell_list_present, 1));
  bool mbs_service_area_tai_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_tai_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_service_area_cell_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_cell_list, bref, 1, 8192, true));
  }
  if (mbs_service_area_tai_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_tai_list, bref, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_service_area_cell_list.size() > 0) {
    j.start_array("mBS-ServiceAreaCell-List");
    for (const auto& e1 : mbs_service_area_cell_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_service_area_tai_list.size() > 0) {
    j.start_array("mBS-ServiceAreaTAI-List");
    for (const auto& e1 : mbs_service_area_tai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSCharacteristics ::= CHOICE
void qos_characteristics_c::destroy_()
{
  switch (type_) {
    case types::non_dyn:
      c.destroy<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn:
      c.destroy<dyn_5qi_descriptor_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void qos_characteristics_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::non_dyn:
      c.init<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn:
      c.init<dyn_5qi_descriptor_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c::qos_characteristics_c(const qos_characteristics_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::non_dyn:
      c.init(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn:
      c.init(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c& qos_characteristics_c::operator=(const qos_characteristics_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::non_dyn:
      c.set(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn:
      c.set(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }

  return *this;
}
non_dyn_5qi_descriptor_s& qos_characteristics_c::set_non_dyn()
{
  set(types::non_dyn);
  return c.get<non_dyn_5qi_descriptor_s>();
}
dyn_5qi_descriptor_s& qos_characteristics_c::set_dyn()
{
  set(types::dyn);
  return c.get<dyn_5qi_descriptor_s>();
}
protocol_ie_single_container_s<qos_characteristics_ext_ies_o>& qos_characteristics_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
}
void qos_characteristics_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::non_dyn:
      j.write_fieldname("non-dynamic");
      c.get<non_dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::dyn:
      j.write_fieldname("dynamic");
      c.get<dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_characteristics_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::non_dyn:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::dyn:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_characteristics_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::non_dyn:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::dyn:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_characteristics_c::types_opts::to_string() const
{
  static const char* names[] = {"non-dynamic", "dynamic", "choice-extension"};
  return convert_enum_idx(names, 3, value, "qos_characteristics_c::types");
}

// QoSFlowLevelQoSParameters-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flow_level_qos_params_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {154, 238, 243};
  return map_enum_number(names, 3, idx, "id");
}
bool qos_flow_level_qos_params_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {154, 238, 243};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_level_qos_params_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 154:
      return crit_e::ignore;
    case 238:
      return crit_e::ignore;
    case 243:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_level_qos_params_ext_ies_o::ext_c qos_flow_level_qos_params_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 154:
      ret.set(ext_c::types::qos_monitoring_request);
      break;
    case 238:
      ret.set(ext_c::types::qos_monitoring_report_freq);
      break;
    case 243:
      ret.set(ext_c::types::qos_monitoring_disabled);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_level_qos_params_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 154:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 243:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_level_qos_params_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::qos_monitoring_request:
      c = qos_monitoring_request_e{};
      break;
    case types::qos_monitoring_report_freq:
      c = uint16_t{};
      break;
    case types::qos_monitoring_disabled:
      c = qos_monitoring_disabled_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
}
qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request()
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_report_freq()
{
  assert_choice_type(types::qos_monitoring_report_freq, type_, "Extension");
  return c.get<uint16_t>();
}
qos_monitoring_disabled_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_disabled()
{
  assert_choice_type(types::qos_monitoring_disabled, type_, "Extension");
  return c.get<qos_monitoring_disabled_e>();
}
const qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request() const
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
const uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_report_freq() const
{
  assert_choice_type(types::qos_monitoring_report_freq, type_, "Extension");
  return c.get<uint16_t>();
}
const qos_monitoring_disabled_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_disabled() const
{
  assert_choice_type(types::qos_monitoring_disabled, type_, "Extension");
  return c.get<qos_monitoring_disabled_e>();
}
void qos_flow_level_qos_params_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::qos_monitoring_request:
      j.write_str("QosMonitoringRequest", c.get<qos_monitoring_request_e>().to_string());
      break;
    case types::qos_monitoring_report_freq:
      j.write_int("INTEGER (1..1800,...)", c.get<uint16_t>());
      break;
    case types::qos_monitoring_disabled:
      j.write_str("QoSMonitoringDisabled", "true");
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().pack(bref));
      break;
    case types::qos_monitoring_report_freq:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)1800u, true, true));
      break;
    case types::qos_monitoring_disabled:
      HANDLE_CODE(c.get<qos_monitoring_disabled_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().unpack(bref));
      break;
    case types::qos_monitoring_report_freq:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)1800u, true, true));
      break;
    case types::qos_monitoring_disabled:
      HANDLE_CODE(c.get<qos_monitoring_disabled_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_level_qos_params_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosMonitoringRequest", "INTEGER (1..1800,...)", "QoSMonitoringDisabled"};
  return convert_enum_idx(names, 3, value, "qos_flow_level_qos_params_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_level_qos_params_ext_ies_o::ext_c::types_opts::to_number() const
{
  if (value == qos_monitoring_report_freq) {
    return 1;
  }
  invalid_enum_number(value, "qos_flow_level_qos_params_ext_ies_o::ext_c::types");
  return 0;
}

// ReflectiveQoSAttribute ::= ENUMERATED
const char* reflective_qos_attribute_opts::to_string() const
{
  static const char* names[] = {"subject-to-reflective-QoS"};
  return convert_enum_idx(names, 1, value, "reflective_qos_attribute_e");
}

// MBS-ServiceAreaInformation-Item ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-Area-Session-ID", mbs_area_session_id);
  j.write_fieldname("mBS-ServiceAreaInformation");
  mbs_service_area_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MRB-ProgressInformation ::= CHOICE
void mrb_progress_info_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mrb_progress_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdcp_sn12:
      break;
    case types::pdcp_sn18:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c::mrb_progress_info_c(const mrb_progress_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdcp_sn12:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn18:
      c.init(other.c.get<uint32_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c& mrb_progress_info_c::operator=(const mrb_progress_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdcp_sn12:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn18:
      c.set(other.c.get<uint32_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }

  return *this;
}
uint16_t& mrb_progress_info_c::set_pdcp_sn12()
{
  set(types::pdcp_sn12);
  return c.get<uint16_t>();
}
uint32_t& mrb_progress_info_c::set_pdcp_sn18()
{
  set(types::pdcp_sn18);
  return c.get<uint32_t>();
}
protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>& mrb_progress_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
}
void mrb_progress_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdcp_sn12:
      j.write_int("pdcp-SN12", c.get<uint16_t>());
      break;
    case types::pdcp_sn18:
      j.write_int("pdcp-SN18", c.get<uint32_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
  j.end_obj();
}
SRSASN_CODE mrb_progress_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pdcp_sn12:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn18:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mrb_progress_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pdcp_sn12:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn18:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mrb_progress_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pdcp-SN12", "pdcp-SN18", "choice-extension"};
  return convert_enum_idx(names, 3, value, "mrb_progress_info_c::types");
}
uint8_t mrb_progress_info_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "mrb_progress_info_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_level_qos_params_ext_ies_o>;

SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += qos_monitoring_request_present ? 1 : 0;
  nof_ies += qos_monitoring_report_freq_present ? 1 : 0;
  nof_ies += qos_monitoring_disabled_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (qos_monitoring_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)154, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(qos_monitoring_request.pack(bref));
  }
  if (qos_monitoring_report_freq_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)238, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, qos_monitoring_report_freq, (uint16_t)1u, (uint16_t)1800u, true, true));
  }
  if (qos_monitoring_disabled_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)243, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(qos_monitoring_disabled.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 154: {
        qos_monitoring_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_monitoring_request.unpack(bref));
        break;
      }
      case 238: {
        qos_monitoring_report_freq_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(qos_monitoring_report_freq, bref, (uint16_t)1u, (uint16_t)1800u, true, true));
        break;
      }
      case 243: {
        qos_monitoring_disabled_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_monitoring_disabled.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_monitoring_request_present) {
    j.write_int("id", 154);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", qos_monitoring_request.to_string());
  }
  if (qos_monitoring_report_freq_present) {
    j.write_int("id", 238);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", qos_monitoring_report_freq);
  }
  if (qos_monitoring_disabled_present) {
    j.write_int("id", 243);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// QoSFlowLevelQoSParameters ::= SEQUENCE
SRSASN_CODE qos_flow_level_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(reflective_qos_present, 1));
  HANDLE_CODE(bref.pack(add_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.pack(bref));
  HANDLE_CODE(alloc_and_retention_prio.pack(bref));
  if (gbr_qos_flow_info_present) {
    HANDLE_CODE(gbr_qos_flow_info.pack(bref));
  }
  if (reflective_qos_present) {
    HANDLE_CODE(reflective_qos.pack(bref));
  }
  if (add_qos_flow_info_present) {
    HANDLE_CODE(add_qos_flow_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(reflective_qos_present, 1));
  HANDLE_CODE(bref.unpack(add_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.unpack(bref));
  HANDLE_CODE(alloc_and_retention_prio.unpack(bref));
  if (gbr_qos_flow_info_present) {
    HANDLE_CODE(gbr_qos_flow_info.unpack(bref));
  }
  if (reflective_qos_present) {
    HANDLE_CODE(reflective_qos.unpack(bref));
  }
  if (add_qos_flow_info_present) {
    HANDLE_CODE(add_qos_flow_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("qos-characteristics");
  qos_characteristics.to_json(j);
  j.write_fieldname("allocationAndRetentionPrio");
  alloc_and_retention_prio.to_json(j);
  if (gbr_qos_flow_info_present) {
    j.write_fieldname("gBRQoSFlowInfo");
    gbr_qos_flow_info.to_json(j);
  }
  if (reflective_qos_present) {
    j.write_str("reflectiveQoS", "subject-to-reflective-QoS");
  }
  if (add_qos_flow_info_present) {
    j.write_str("additionalQoSflowInfo", "more-likely");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* qos_flow_level_qos_params_s::add_qos_flow_info_opts::to_string() const
{
  static const char* names[] = {"more-likely"};
  return convert_enum_idx(names, 1, value, "qos_flow_level_qos_params_s::add_qos_flow_info_e_");
}

// MBS-MappingandDataForwardingRequestInfofromSource-Item ::= SEQUENCE
SRSASN_CODE mbs_mapand_data_forwarding_request_infofrom_source_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flow_list, 1, 64, integer_packer<uint8_t>(0, 63, true, true)));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_mapand_data_forwarding_request_infofrom_source_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flow_list, bref, 1, 64, integer_packer<uint8_t>(0, 63, true, true)));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_mapand_data_forwarding_request_infofrom_source_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.start_array("mBS-QoSFlow-List");
  for (const auto& e1 : mbs_qos_flow_list) {
    j.write_int(e1);
  }
  j.end_array();
  if (mrb_progress_info_present) {
    j.write_fieldname("mRB-ProgressInformation");
    mrb_progress_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-QoSFlowsToAdd-Item ::= SEQUENCE
SRSASN_CODE mbs_qos_flows_to_add_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(mbs_qos_flow_level_qos_params.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_qos_flows_to_add_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(mbs_qos_flow_level_qos_params.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_qos_flows_to_add_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-QosFlowIdentifier", mbs_qos_flow_id);
  j.write_fieldname("mBS-QosFlowLevelQosParameters");
  mbs_qos_flow_level_qos_params.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceArea ::= CHOICE
void mbs_service_area_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.destroy<mbs_service_area_info_list_l>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_service_area_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.init<mbs_service_area_info_list_l>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c::mbs_service_area_c(const mbs_service_area_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c& mbs_service_area_c::operator=(const mbs_service_area_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }

  return *this;
}
mbs_service_area_info_s& mbs_service_area_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<mbs_service_area_info_s>();
}
mbs_service_area_info_list_l& mbs_service_area_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_service_area_info_list_l>();
}
protocol_ie_single_container_s<mbs_service_area_ext_ies_o>& mbs_service_area_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
}
void mbs_service_area_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<mbs_service_area_info_s>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_service_area_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_service_area_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_service_area_info_list_l>(), 1, 256, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_service_area_info_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_service_area_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-extension"};
  return convert_enum_idx(names, 3, value, "mbs_service_area_c::types");
}

// Active-MBS-SessionInformation ::= SEQUENCE
SRSASN_CODE active_mbs_session_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_service_area_present, 1));
  HANDLE_CODE(bref.pack(mbs_mapand_data_forwarding_request_infofrom_source.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flows_to_add_list, 1, 64, true));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (mbs_mapand_data_forwarding_request_infofrom_source.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_mapand_data_forwarding_request_infofrom_source, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE active_mbs_session_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_service_area_present, 1));
  bool mbs_mapand_data_forwarding_request_infofrom_source_present;
  HANDLE_CODE(bref.unpack(mbs_mapand_data_forwarding_request_infofrom_source_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flows_to_add_list, bref, 1, 64, true));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.unpack(bref));
  }
  if (mbs_mapand_data_forwarding_request_infofrom_source_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_mapand_data_forwarding_request_infofrom_source, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void active_mbs_session_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("mBS-QoSFlowsToAdd-List");
  for (const auto& e1 : mbs_qos_flows_to_add_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (mbs_service_area_present) {
    j.write_fieldname("mBS-ServiceArea");
    mbs_service_area.to_json(j);
  }
  if (mbs_mapand_data_forwarding_request_infofrom_source.size() > 0) {
    j.start_array("mBS-MappingandDataForwardingRequestInfofromSource");
    for (const auto& e1 : mbs_mapand_data_forwarding_request_infofrom_source) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UserPlaneTrafficActivityReport ::= ENUMERATED
const char* user_plane_traffic_activity_report_opts::to_string() const
{
  static const char* names[] = {"inactive", "re-activated"};
  return convert_enum_idx(names, 2, value, "user_plane_traffic_activity_report_e");
}

// RANPagingFailure ::= ENUMERATED
const char* ran_paging_fail_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "ran_paging_fail_e");
}

// CSI-RS-MTC-Neighbour-Item ::= SEQUENCE
SRSASN_CODE csi_rs_mtc_neighbour_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, csi_rs_idx, (uint8_t)0u, (uint8_t)95u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE csi_rs_mtc_neighbour_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(csi_rs_idx, bref, (uint8_t)0u, (uint8_t)95u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void csi_rs_mtc_neighbour_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("csi-RS-Index", csi_rs_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CSI-RS-Neighbour-Item ::= SEQUENCE
SRSASN_CODE csi_rs_neighbour_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(csi_rs_mtc_neighbour_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (csi_rs_mtc_neighbour_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, csi_rs_mtc_neighbour_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE csi_rs_neighbour_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool csi_rs_mtc_neighbour_list_present;
  HANDLE_CODE(bref.unpack(csi_rs_mtc_neighbour_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (csi_rs_mtc_neighbour_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(csi_rs_mtc_neighbour_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void csi_rs_neighbour_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nr-cgi");
  nr_cgi.to_json(j);
  if (csi_rs_mtc_neighbour_list.size() > 0) {
    j.start_array("csi-RS-MTC-Neighbour-List");
    for (const auto& e1 : csi_rs_mtc_neighbour_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CSI-RS-MTC-Configuration-Item ::= SEQUENCE
SRSASN_CODE csi_rs_mtc_cfg_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(csi_rs_neighbour_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, csi_rs_idx, (uint8_t)0u, (uint8_t)95u, false, true));
  HANDLE_CODE(csi_rs_status.pack(bref));
  if (csi_rs_neighbour_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, csi_rs_neighbour_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE csi_rs_mtc_cfg_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool csi_rs_neighbour_list_present;
  HANDLE_CODE(bref.unpack(csi_rs_neighbour_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(csi_rs_idx, bref, (uint8_t)0u, (uint8_t)95u, false, true));
  HANDLE_CODE(csi_rs_status.unpack(bref));
  if (csi_rs_neighbour_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(csi_rs_neighbour_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void csi_rs_mtc_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("csi-RS-Index", csi_rs_idx);
  j.write_str("csi-RS-Status", csi_rs_status.to_string());
  if (csi_rs_neighbour_list.size() > 0) {
    j.start_array("csi-RS-Neighbour-List");
    for (const auto& e1 : csi_rs_neighbour_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* csi_rs_mtc_cfg_item_s::csi_rs_status_opts::to_string() const
{
  static const char* names[] = {"activated", "deactivated"};
  return convert_enum_idx(names, 2, value, "csi_rs_mtc_cfg_item_s::csi_rs_status_e_");
}

// Additional-Measurement-Timing-Configuration-Item ::= SEQUENCE
SRSASN_CODE add_meas_timing_cfg_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, add_meas_timing_cfg_idx, (uint8_t)0u, (uint8_t)16u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, csi_rs_mtc_cfg_list, 1, 96, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_meas_timing_cfg_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(add_meas_timing_cfg_idx, bref, (uint8_t)0u, (uint8_t)16u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(csi_rs_mtc_cfg_list, bref, 1, 96, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void add_meas_timing_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("additionalMeasurementTimingConfigurationIndex", add_meas_timing_cfg_idx);
  j.start_array("csi-RS-MTC-Configuration-List");
  for (const auto& e1 : csi_rs_mtc_cfg_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GTPtunnelTransportLayerInformation ::= SEQUENCE
SRSASN_CODE gtp_tunnel_transport_layer_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gtp_tunnel_transport_layer_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gtp_tunnel_transport_layer_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tnl-address", tnl_address.to_string());
  j.write_str("gtp-teid", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportLayerInformation ::= CHOICE
void up_transport_layer_info_c::destroy_()
{
  switch (type_) {
    case types::gtp_tunnel:
      c.destroy<gtp_tunnel_transport_layer_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void up_transport_layer_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gtp_tunnel:
      c.init<gtp_tunnel_transport_layer_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c::up_transport_layer_info_c(const up_transport_layer_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gtp_tunnel:
      c.init(other.c.get<gtp_tunnel_transport_layer_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c& up_transport_layer_info_c::operator=(const up_transport_layer_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gtp_tunnel:
      c.set(other.c.get<gtp_tunnel_transport_layer_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }

  return *this;
}
gtp_tunnel_transport_layer_info_s& up_transport_layer_info_c::set_gtp_tunnel()
{
  set(types::gtp_tunnel);
  return c.get<gtp_tunnel_transport_layer_info_s>();
}
protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>& up_transport_layer_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
}
void up_transport_layer_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gtp_tunnel:
      j.write_fieldname("gtpTunnel");
      c.get<gtp_tunnel_transport_layer_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
  j.end_obj();
}
SRSASN_CODE up_transport_layer_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_transport_layer_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_transport_layer_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* up_transport_layer_info_c::types_opts::to_string() const
{
  static const char* names[] = {"gtpTunnel", "choice-extension"};
  return convert_enum_idx(names, 2, value, "up_transport_layer_info_c::types");
}

// Additional-PDCP-Duplication-TNL-Item ::= SEQUENCE
SRSASN_CODE add_pdcp_dupl_tnl_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(add_pdcp_dupl_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_pdcp_dupl_tnl_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(add_pdcp_dupl_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void add_pdcp_dupl_tnl_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("additional-PDCP-Duplication-UP-TNL-Information");
  add_pdcp_dupl_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Additional-UL-NG-U-TNLatUPF-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {127};
  return map_enum_number(names, 1, idx, "id");
}
bool add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 127 == id;
}
crit_e add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 127) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::ext_c add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 127) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 127) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "add_ul_ng_u_tnl_at_up_f_item_ext_ies_o::ext_c::types");
}

// Additional-UL-NG-U-TNLatUPF-Item ::= SEQUENCE
SRSASN_CODE add_ul_ng_u_tnl_at_up_f_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(add_ul_ng_u_tnl_at_up_f.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_ul_ng_u_tnl_at_up_f_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(add_ul_ng_u_tnl_at_up_f.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void add_ul_ng_u_tnl_at_up_f_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("additional-UL-NG-U-TNLatUPF");
  add_ul_ng_u_tnl_at_up_f.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// DataForwardingResponseDRBItem ::= SEQUENCE
SRSASN_CODE data_forwarding_resp_drb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_up_tnl_present, 1));
  HANDLE_CODE(bref.pack(ul_forwarding_up_tnl_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_forwarding_up_tnl_present) {
    HANDLE_CODE(dl_forwarding_up_tnl.pack(bref));
  }
  if (ul_forwarding_up_tnl_present) {
    HANDLE_CODE(ul_forwarding_up_tnl.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_resp_drb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_up_tnl_present, 1));
  HANDLE_CODE(bref.unpack(ul_forwarding_up_tnl_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_forwarding_up_tnl_present) {
    HANDLE_CODE(dl_forwarding_up_tnl.unpack(bref));
  }
  if (ul_forwarding_up_tnl_present) {
    HANDLE_CODE(ul_forwarding_up_tnl.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_resp_drb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (dl_forwarding_up_tnl_present) {
    j.write_fieldname("dlForwardingUPTNL");
    dl_forwarding_up_tnl.to_json(j);
  }
  if (ul_forwarding_up_tnl_present) {
    j.write_fieldname("ulForwardingUPTNL");
    ul_forwarding_up_tnl.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// QoSFLowsAcceptedToBeForwarded-Item ::= SEQUENCE
SRSASN_CODE qos_f_lows_accepted_to_be_forwarded_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_f_lows_accepted_to_be_forwarded_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_f_lows_accepted_to_be_forwarded_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DataForwardingInfoFromTargetNGRANnode ::= SEQUENCE
SRSASN_CODE data_forwarding_info_from_target_ngra_nnode_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_level_dl_data_forwarding_info_present, 1));
  HANDLE_CODE(bref.pack(pdu_session_level_ul_data_forwarding_info_present, 1));
  HANDLE_CODE(bref.pack(data_forwarding_resp_drb_item_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_accepted_for_data_forwarding_list, 1, 64, true));
  if (pdu_session_level_dl_data_forwarding_info_present) {
    HANDLE_CODE(pdu_session_level_dl_data_forwarding_info.pack(bref));
  }
  if (pdu_session_level_ul_data_forwarding_info_present) {
    HANDLE_CODE(pdu_session_level_ul_data_forwarding_info.pack(bref));
  }
  if (data_forwarding_resp_drb_item_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_resp_drb_item_list, 1, 32, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_info_from_target_ngra_nnode_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdu_session_level_dl_data_forwarding_info_present, 1));
  HANDLE_CODE(bref.unpack(pdu_session_level_ul_data_forwarding_info_present, 1));
  bool data_forwarding_resp_drb_item_list_present;
  HANDLE_CODE(bref.unpack(data_forwarding_resp_drb_item_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_accepted_for_data_forwarding_list, bref, 1, 64, true));
  if (pdu_session_level_dl_data_forwarding_info_present) {
    HANDLE_CODE(pdu_session_level_dl_data_forwarding_info.unpack(bref));
  }
  if (pdu_session_level_ul_data_forwarding_info_present) {
    HANDLE_CODE(pdu_session_level_ul_data_forwarding_info.unpack(bref));
  }
  if (data_forwarding_resp_drb_item_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_resp_drb_item_list, bref, 1, 32, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_info_from_target_ngra_nnode_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("qosFlowsAcceptedForDataForwarding-List");
  for (const auto& e1 : qos_flows_accepted_for_data_forwarding_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pdu_session_level_dl_data_forwarding_info_present) {
    j.write_fieldname("pduSessionLevelDLDataForwardingInfo");
    pdu_session_level_dl_data_forwarding_info.to_json(j);
  }
  if (pdu_session_level_ul_data_forwarding_info_present) {
    j.write_fieldname("pduSessionLevelULDataForwardingInfo");
    pdu_session_level_ul_data_forwarding_info.to_json(j);
  }
  if (data_forwarding_resp_drb_item_list.size() > 0) {
    j.start_array("dataForwardingResponseDRBItemList");
    for (const auto& e1 : data_forwarding_resp_drb_item_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceChangeConfirmInfo-SNterminated-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {133};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 133 == id;
}
crit_e pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 133) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::ext_c
pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 133) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 133) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("DRB-List");
  for (const auto& e1 : c) {
    j.write_int(e1);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DRB-List"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_change_confirm_info_sn_terminated_ext_ies_o::ext_c::types");
}

// PDUSessionResourceChangeConfirmInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_change_confirm_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dataforwardinginfo_target_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_change_confirm_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dataforwardinginfo_target_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_change_confirm_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dataforwardinginfo_target_present) {
    j.write_fieldname("dataforwardinginfoTarget");
    dataforwardinginfo_target.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// AdditionalListofPDUSessionResourceChangeConfirmInfo-SNterminated-Item ::= SEQUENCE
SRSASN_CODE add_listof_pdu_session_res_change_confirm_info_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pdu_session_res_change_confirm_info_sn_terminated.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_listof_pdu_session_res_change_confirm_info_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pdu_session_res_change_confirm_info_sn_terminated.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void add_listof_pdu_session_res_change_confirm_info_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("pDUSessionResourceChangeConfirmInfo-SNterminated");
  pdu_session_res_change_confirm_info_sn_terminated.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PNI-NPN-Restricted-Information ::= ENUMERATED
const char* pni_npn_restricted_info_opts::to_string() const
{
  static const char* names[] = {"restriced", "not-restricted"};
  return convert_enum_idx(names, 2, value, "pni_npn_restricted_info_e");
}

// AllowedPNI-NPN-ID-Item ::= SEQUENCE
SRSASN_CODE allowed_pni_npn_id_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pni_npn_restricted_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, allowed_cag_id_list_per_plmn, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE allowed_pni_npn_id_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(pni_npn_restricted_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(allowed_cag_id_list_per_plmn, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void allowed_pni_npn_id_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.write_str("pni-npn-restricted-information", pni_npn_restricted_info.to_string());
  j.start_array("allowed-CAG-id-list-per-plmn");
  for (const auto& e1 : allowed_cag_id_list_per_plmn) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ENB-ID-Choice ::= CHOICE
void enb_id_choice_c::destroy_()
{
  switch (type_) {
    case types::enb_id_macro:
      c.destroy<fixed_bitstring<20, false, true>>();
      break;
    case types::enb_id_shortmacro:
      c.destroy<fixed_bitstring<18, false, true>>();
      break;
    case types::enb_id_longmacro:
      c.destroy<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void enb_id_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::enb_id_macro:
      c.init<fixed_bitstring<20, false, true>>();
      break;
    case types::enb_id_shortmacro:
      c.init<fixed_bitstring<18, false, true>>();
      break;
    case types::enb_id_longmacro:
      c.init<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_choice_c");
  }
}
enb_id_choice_c::enb_id_choice_c(const enb_id_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::enb_id_macro:
      c.init(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::enb_id_shortmacro:
      c.init(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::enb_id_longmacro:
      c.init(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_choice_c");
  }
}
enb_id_choice_c& enb_id_choice_c::operator=(const enb_id_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::enb_id_macro:
      c.set(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::enb_id_shortmacro:
      c.set(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::enb_id_longmacro:
      c.set(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_choice_c");
  }

  return *this;
}
fixed_bitstring<20, false, true>& enb_id_choice_c::set_enb_id_macro()
{
  set(types::enb_id_macro);
  return c.get<fixed_bitstring<20, false, true>>();
}
fixed_bitstring<18, false, true>& enb_id_choice_c::set_enb_id_shortmacro()
{
  set(types::enb_id_shortmacro);
  return c.get<fixed_bitstring<18, false, true>>();
}
fixed_bitstring<21, false, true>& enb_id_choice_c::set_enb_id_longmacro()
{
  set(types::enb_id_longmacro);
  return c.get<fixed_bitstring<21, false, true>>();
}
protocol_ie_single_container_s<enb_id_choice_ext_ies_o>& enb_id_choice_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>();
}
void enb_id_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::enb_id_macro:
      j.write_str("enb-ID-macro", c.get<fixed_bitstring<20, false, true>>().to_string());
      break;
    case types::enb_id_shortmacro:
      j.write_str("enb-ID-shortmacro", c.get<fixed_bitstring<18, false, true>>().to_string());
      break;
    case types::enb_id_longmacro:
      j.write_str("enb-ID-longmacro", c.get<fixed_bitstring<21, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_id_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::enb_id_macro:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().pack(bref)));
      break;
    case types::enb_id_shortmacro:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().pack(bref)));
      break;
    case types::enb_id_longmacro:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_id_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::enb_id_macro:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().unpack(bref)));
      break;
    case types::enb_id_shortmacro:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().unpack(bref)));
      break;
    case types::enb_id_longmacro:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<enb_id_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_id_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"enb-ID-macro", "enb-ID-shortmacro", "enb-ID-longmacro", "choice-extension"};
  return convert_enum_idx(names, 4, value, "enb_id_choice_c::types");
}

// GNB-ID-Choice ::= CHOICE
void gnb_id_choice_c::destroy_()
{
  switch (type_) {
    case types::gnb_id:
      c.destroy<bounded_bitstring<22, 32, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void gnb_id_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gnb_id:
      c.init<bounded_bitstring<22, 32, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_choice_c");
  }
}
gnb_id_choice_c::gnb_id_choice_c(const gnb_id_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gnb_id:
      c.init(other.c.get<bounded_bitstring<22, 32, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_choice_c");
  }
}
gnb_id_choice_c& gnb_id_choice_c::operator=(const gnb_id_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gnb_id:
      c.set(other.c.get<bounded_bitstring<22, 32, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_choice_c");
  }

  return *this;
}
bounded_bitstring<22, 32, false, true>& gnb_id_choice_c::set_gnb_id()
{
  set(types::gnb_id);
  return c.get<bounded_bitstring<22, 32, false, true>>();
}
protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>& gnb_id_choice_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>();
}
void gnb_id_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gnb_id:
      j.write_str("gnb-ID", c.get<bounded_bitstring<22, 32, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_id_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gnb_id:
      HANDLE_CODE((c.get<bounded_bitstring<22, 32, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_id_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gnb_id:
      HANDLE_CODE((c.get<bounded_bitstring<22, 32, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_id_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* gnb_id_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"gnb-ID", "choice-extension"};
  return convert_enum_idx(names, 2, value, "gnb_id_choice_c::types");
}

// GlobalgNB-ID ::= SEQUENCE
SRSASN_CODE global_gnb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(gnb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_gnb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(gnb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_gnb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.write_fieldname("gnb-id");
  gnb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalngeNB-ID ::= SEQUENCE
SRSASN_CODE globalng_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE globalng_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void globalng_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.write_fieldname("enb-id");
  enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalNG-RANNode-ID ::= CHOICE
void global_ng_ran_node_id_c::destroy_()
{
  switch (type_) {
    case types::gnb:
      c.destroy<global_gnb_id_s>();
      break;
    case types::ng_enb:
      c.destroy<globalng_enb_id_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void global_ng_ran_node_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gnb:
      c.init<global_gnb_id_s>();
      break;
    case types::ng_enb:
      c.init<globalng_enb_id_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ng_ran_node_id_c");
  }
}
global_ng_ran_node_id_c::global_ng_ran_node_id_c(const global_ng_ran_node_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gnb:
      c.init(other.c.get<global_gnb_id_s>());
      break;
    case types::ng_enb:
      c.init(other.c.get<globalng_enb_id_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ng_ran_node_id_c");
  }
}
global_ng_ran_node_id_c& global_ng_ran_node_id_c::operator=(const global_ng_ran_node_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gnb:
      c.set(other.c.get<global_gnb_id_s>());
      break;
    case types::ng_enb:
      c.set(other.c.get<globalng_enb_id_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ng_ran_node_id_c");
  }

  return *this;
}
global_gnb_id_s& global_ng_ran_node_id_c::set_gnb()
{
  set(types::gnb);
  return c.get<global_gnb_id_s>();
}
globalng_enb_id_s& global_ng_ran_node_id_c::set_ng_enb()
{
  set(types::ng_enb);
  return c.get<globalng_enb_id_s>();
}
protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>& global_ng_ran_node_id_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>();
}
void global_ng_ran_node_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gnb:
      j.write_fieldname("gNB");
      c.get<global_gnb_id_s>().to_json(j);
      break;
    case types::ng_enb:
      j.write_fieldname("ng-eNB");
      c.get<globalng_enb_id_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "global_ng_ran_node_id_c");
  }
  j.end_obj();
}
SRSASN_CODE global_ng_ran_node_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gnb:
      HANDLE_CODE(c.get<global_gnb_id_s>().pack(bref));
      break;
    case types::ng_enb:
      HANDLE_CODE(c.get<globalng_enb_id_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ng_ran_node_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ng_ran_node_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gnb:
      HANDLE_CODE(c.get<global_gnb_id_s>().unpack(bref));
      break;
    case types::ng_enb:
      HANDLE_CODE(c.get<globalng_enb_id_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<global_ng_ran_node_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ng_ran_node_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* global_ng_ran_node_id_c::types_opts::to_string() const
{
  static const char* names[] = {"gNB", "ng-eNB", "choice-extension"};
  return convert_enum_idx(names, 3, value, "global_ng_ran_node_id_c::types");
}

// NG-RAN-Cell-Identity ::= CHOICE
void ng_ran_cell_id_c::destroy_()
{
  switch (type_) {
    case types::nr:
      c.destroy<fixed_bitstring<36, false, true>>();
      break;
    case types::e_utra:
      c.destroy<fixed_bitstring<28, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ng_ran_cell_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      c.init<fixed_bitstring<36, false, true>>();
      break;
    case types::e_utra:
      c.init<fixed_bitstring<28, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_id_c");
  }
}
ng_ran_cell_id_c::ng_ran_cell_id_c(const ng_ran_cell_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<fixed_bitstring<36, false, true>>());
      break;
    case types::e_utra:
      c.init(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_id_c");
  }
}
ng_ran_cell_id_c& ng_ran_cell_id_c::operator=(const ng_ran_cell_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<fixed_bitstring<36, false, true>>());
      break;
    case types::e_utra:
      c.set(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_id_c");
  }

  return *this;
}
fixed_bitstring<36, false, true>& ng_ran_cell_id_c::set_nr()
{
  set(types::nr);
  return c.get<fixed_bitstring<36, false, true>>();
}
fixed_bitstring<28, false, true>& ng_ran_cell_id_c::set_e_utra()
{
  set(types::e_utra);
  return c.get<fixed_bitstring<28, false, true>>();
}
protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>& ng_ran_cell_id_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>();
}
void ng_ran_cell_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_str("nr", c.get<fixed_bitstring<36, false, true>>().to_string());
      break;
    case types::e_utra:
      j.write_str("e-utra", c.get<fixed_bitstring<28, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_ran_cell_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE((c.get<fixed_bitstring<36, false, true>>().pack(bref)));
      break;
    case types::e_utra:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_ran_cell_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE((c.get<fixed_bitstring<36, false, true>>().unpack(bref)));
      break;
    case types::e_utra:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_ran_cell_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_ran_cell_id_c::types_opts::to_string() const
{
  static const char* names[] = {"nr", "e-utra", "choice-extension"};
  return convert_enum_idx(names, 3, value, "ng_ran_cell_id_c::types");
}

// CellsinAoI-Item ::= SEQUENCE
SRSASN_CODE cellsin_ao_i_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(ng_ran_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cellsin_ao_i_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(ng_ran_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cellsin_ao_i_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.write_fieldname("ng-ran-cell-id");
  ng_ran_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalNG-RANNodesinAoI-Item ::= SEQUENCE
SRSASN_CODE global_ng_ran_nodesin_ao_i_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_ran_node_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ng_ran_nodesin_ao_i_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_ran_node_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_ng_ran_nodesin_ao_i_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-NG-RAN-Node-ID");
  global_ng_ran_node_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIsinAoI-Item ::= SEQUENCE
SRSASN_CODE tai_sin_ao_i_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_sin_ao_i_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_sin_ao_i_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.write_str("tAC", tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterest-Item ::= SEQUENCE
SRSASN_CODE area_of_interest_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(list_of_tai_sin_ao_i.size() > 0, 1));
  HANDLE_CODE(bref.pack(list_of_cellsin_ao_i.size() > 0, 1));
  HANDLE_CODE(bref.pack(list_of_ran_nodesin_ao_i.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (list_of_tai_sin_ao_i.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, list_of_tai_sin_ao_i, 1, 16, true));
  }
  if (list_of_cellsin_ao_i.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, list_of_cellsin_ao_i, 1, 256, true));
  }
  if (list_of_ran_nodesin_ao_i.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, list_of_ran_nodesin_ao_i, 1, 64, true));
  }
  HANDLE_CODE(pack_integer(bref, request_ref_id, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool list_of_tai_sin_ao_i_present;
  HANDLE_CODE(bref.unpack(list_of_tai_sin_ao_i_present, 1));
  bool list_of_cellsin_ao_i_present;
  HANDLE_CODE(bref.unpack(list_of_cellsin_ao_i_present, 1));
  bool list_of_ran_nodesin_ao_i_present;
  HANDLE_CODE(bref.unpack(list_of_ran_nodesin_ao_i_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (list_of_tai_sin_ao_i_present) {
    HANDLE_CODE(unpack_dyn_seq_of(list_of_tai_sin_ao_i, bref, 1, 16, true));
  }
  if (list_of_cellsin_ao_i_present) {
    HANDLE_CODE(unpack_dyn_seq_of(list_of_cellsin_ao_i, bref, 1, 256, true));
  }
  if (list_of_ran_nodesin_ao_i_present) {
    HANDLE_CODE(unpack_dyn_seq_of(list_of_ran_nodesin_ao_i, bref, 1, 64, true));
  }
  HANDLE_CODE(unpack_integer(request_ref_id, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (list_of_tai_sin_ao_i.size() > 0) {
    j.start_array("listOfTAIsinAoI");
    for (const auto& e1 : list_of_tai_sin_ao_i) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (list_of_cellsin_ao_i.size() > 0) {
    j.start_array("listOfCellsinAoI");
    for (const auto& e1 : list_of_cellsin_ao_i) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (list_of_ran_nodesin_ao_i.size() > 0) {
    j.start_array("listOfRANNodesinAoI");
    for (const auto& e1 : list_of_ran_nodesin_ao_i) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("requestReferenceID", request_ref_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIforMDT-Item ::= SEQUENCE
SRSASN_CODE tai_for_mdt_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_for_mdt_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_for_mdt_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-ID", plmn_id.to_string());
  j.write_str("tAC", tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellBasedMDT-EUTRA ::= SEQUENCE
SRSASN_CODE cell_based_mdt_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_mdt_eutra, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_mdt_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_mdt_eutra, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_mdt_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforMDT-EUTRA");
  for (const auto& e1 : cell_id_listfor_mdt_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedMDT ::= SEQUENCE
SRSASN_CODE ta_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ta_listfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ta_listfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforMDT");
  for (const auto& e1 : ta_listfor_mdt) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedMDT ::= SEQUENCE
SRSASN_CODE tai_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforMDT");
  for (const auto& e1 : tai_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfMDT-EUTRA ::= CHOICE
void area_scope_of_mdt_eutra_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_mdt_eutra_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_mdt_s>();
      break;
    default:
      break;
  }
}
void area_scope_of_mdt_eutra_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_mdt_eutra_s>();
      break;
    case types::ta_based:
      c.init<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.init<tai_based_mdt_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
}
area_scope_of_mdt_eutra_c::area_scope_of_mdt_eutra_c(const area_scope_of_mdt_eutra_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_mdt_eutra_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_mdt_s>());
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_mdt_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
}
area_scope_of_mdt_eutra_c& area_scope_of_mdt_eutra_c::operator=(const area_scope_of_mdt_eutra_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_mdt_eutra_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_mdt_s>());
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_mdt_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }

  return *this;
}
cell_based_mdt_eutra_s& area_scope_of_mdt_eutra_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_mdt_eutra_s>();
}
ta_based_mdt_s& area_scope_of_mdt_eutra_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_mdt_s>();
}
tai_based_mdt_s& area_scope_of_mdt_eutra_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_mdt_s>();
}
void area_scope_of_mdt_eutra_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_mdt_eutra_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_mdt_s>().to_json(j);
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_mdt_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_mdt_eutra_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_eutra_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().pack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_mdt_eutra_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_eutra_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().unpack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_mdt_eutra_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "tAIBased"};
  return convert_enum_idx(names, 3, value, "area_scope_of_mdt_eutra_c::types");
}

// CellBasedMDT-NR ::= SEQUENCE
SRSASN_CODE cell_based_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_mdt_nr, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_mdt_nr, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforMDT-NR");
  for (const auto& e1 : cell_id_listfor_mdt_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfMDT-NR ::= CHOICE
void area_scope_of_mdt_nr_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_mdt_nr_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_mdt_s>();
      break;
    default:
      break;
  }
}
void area_scope_of_mdt_nr_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_mdt_nr_s>();
      break;
    case types::ta_based:
      c.init<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.init<tai_based_mdt_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
}
area_scope_of_mdt_nr_c::area_scope_of_mdt_nr_c(const area_scope_of_mdt_nr_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_mdt_nr_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_mdt_s>());
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_mdt_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
}
area_scope_of_mdt_nr_c& area_scope_of_mdt_nr_c::operator=(const area_scope_of_mdt_nr_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_mdt_nr_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_mdt_s>());
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_mdt_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }

  return *this;
}
cell_based_mdt_nr_s& area_scope_of_mdt_nr_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_mdt_nr_s>();
}
ta_based_mdt_s& area_scope_of_mdt_nr_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_mdt_s>();
}
tai_based_mdt_s& area_scope_of_mdt_nr_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_mdt_s>();
}
void area_scope_of_mdt_nr_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_mdt_nr_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_mdt_s>().to_json(j);
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_mdt_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_mdt_nr_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_nr_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().pack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_mdt_nr_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_nr_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().unpack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_mdt_nr_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "tAIBased"};
  return convert_enum_idx(names, 3, value, "area_scope_of_mdt_nr_c::types");
}

// NRSCS ::= ENUMERATED
const char* nr_scs_opts::to_string() const
{
  static const char* names[] = {"scs15", "scs30", "scs60", "scs120", "scs480", "scs960"};
  return convert_enum_idx(names, 6, value, "nr_scs_e");
}
uint16_t nr_scs_opts::to_number() const
{
  static const uint16_t numbers[] = {15, 30, 60, 120, 480, 960};
  return map_enum_number(numbers, 6, value, "nr_scs_e");
}

// NRCarrierItem ::= SEQUENCE
SRSASN_CODE nr_carrier_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(carrier_scs.pack(bref));
  HANDLE_CODE(pack_integer(bref, offset_to_carrier, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(pack_integer(bref, carrier_bw, (uint16_t)0u, (uint16_t)275u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_carrier_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(carrier_scs.unpack(bref));
  HANDLE_CODE(unpack_integer(offset_to_carrier, bref, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(unpack_integer(carrier_bw, bref, (uint16_t)0u, (uint16_t)275u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_carrier_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("carrierSCS", carrier_scs.to_string());
  j.write_int("offsetToCarrier", offset_to_carrier);
  j.write_int("carrierBandwidth", carrier_bw);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// SupportedSULBandItem ::= SEQUENCE
SRSASN_CODE supported_sul_band_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sul_band_item, (uint16_t)1u, (uint16_t)1024u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_sul_band_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sul_band_item, bref, (uint16_t)1u, (uint16_t)1024u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void supported_sul_band_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sulBandItem", sul_band_item);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FrequencyShift7p5khz ::= ENUMERATED
const char* freq_shift7p5khz_opts::to_string() const
{
  static const char* names[] = {"false", "true"};
  return convert_enum_idx(names, 2, value, "freq_shift7p5khz_e");
}

// NRNRB ::= ENUMERATED
const char* nr_nrb_opts::to_string() const
{
  static const char* names[] = {"nrb11",  "nrb18",  "nrb24",  "nrb25",  "nrb31",  "nrb32",  "nrb38",
                                "nrb51",  "nrb52",  "nrb65",  "nrb66",  "nrb78",  "nrb79",  "nrb93",
                                "nrb106", "nrb107", "nrb121", "nrb132", "nrb133", "nrb135", "nrb160",
                                "nrb162", "nrb189", "nrb216", "nrb217", "nrb245", "nrb264", "nrb270",
                                "nrb273", "nrb33",  "nrb62",  "nrb124", "nrb148", "nrb248"};
  return convert_enum_idx(names, 34, value, "nr_nrb_e");
}
uint16_t nr_nrb_opts::to_number() const
{
  static const uint16_t numbers[] = {11,  18,  24,  25,  31,  32,  38,  51,  52,  65,  66,  78,  79, 93, 106, 107, 121,
                                     132, 133, 135, 160, 162, 189, 216, 217, 245, 264, 270, 273, 33, 62, 124, 148, 248};
  return map_enum_number(numbers, 34, value, "nr_nrb_e");
}

// NRFrequencyBandItem ::= SEQUENCE
SRSASN_CODE nr_freq_band_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(supported_sul_band_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_freq_band, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (supported_sul_band_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, supported_sul_band_list, 1, 32, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_band_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool supported_sul_band_list_present;
  HANDLE_CODE(bref.unpack(supported_sul_band_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_freq_band, bref, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (supported_sul_band_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(supported_sul_band_list, bref, 1, 32, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_freq_band_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nr-frequency-band", nr_freq_band);
  if (supported_sul_band_list.size() > 0) {
    j.start_array("supported-SUL-Band-List");
    for (const auto& e1 : supported_sul_band_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NRTransmissionBandwidth ::= SEQUENCE
SRSASN_CODE nr_tx_bw_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_scs.pack(bref));
  HANDLE_CODE(nr_nrb.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_tx_bw_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_scs.unpack(bref));
  HANDLE_CODE(nr_nrb.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_tx_bw_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRSCS", nr_scs.to_string());
  j.write_str("nRNRB", nr_nrb.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SUL-Information-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t sul_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {200, 202};
  return map_enum_number(names, 2, idx, "id");
}
bool sul_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {200, 202};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e sul_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 200:
      return crit_e::ignore;
    case 202:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
sul_info_ext_ies_o::ext_c sul_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 200:
      ret.set(ext_c::types::carrier_list);
      break;
    case 202:
      ret.set(ext_c::types::freq_shift7p5khz);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e sul_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 200:
      return presence_e::optional;
    case 202:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void sul_info_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::carrier_list:
      c = nr_carrier_list_l{};
      break;
    case types::freq_shift7p5khz:
      c = freq_shift7p5khz_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
  }
}
nr_carrier_list_l& sul_info_ext_ies_o::ext_c::carrier_list()
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
freq_shift7p5khz_e& sul_info_ext_ies_o::ext_c::freq_shift7p5khz()
{
  assert_choice_type(types::freq_shift7p5khz, type_, "Extension");
  return c.get<freq_shift7p5khz_e>();
}
const nr_carrier_list_l& sul_info_ext_ies_o::ext_c::carrier_list() const
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const freq_shift7p5khz_e& sul_info_ext_ies_o::ext_c::freq_shift7p5khz() const
{
  assert_choice_type(types::freq_shift7p5khz, type_, "Extension");
  return c.get<freq_shift7p5khz_e>();
}
void sul_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::freq_shift7p5khz:
      j.write_str("FrequencyShift7p5khz", c.get<freq_shift7p5khz_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE sul_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    case types::freq_shift7p5khz:
      HANDLE_CODE(c.get<freq_shift7p5khz_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE sul_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    case types::freq_shift7p5khz:
      HANDLE_CODE(c.get<freq_shift7p5khz_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* sul_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NRCarrierList", "FrequencyShift7p5khz"};
  return convert_enum_idx(names, 2, value, "sul_info_ext_ies_o::ext_c::types");
}
uint8_t sul_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  if (value == freq_shift7p5khz) {
    return 7;
  }
  invalid_enum_number(value, "sul_info_ext_ies_o::ext_c::types");
  return 0;
}

// NRFrequencyInfo-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t nr_freq_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {202};
  return map_enum_number(names, 1, idx, "id");
}
bool nr_freq_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 202 == id;
}
crit_e nr_freq_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 202) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
nr_freq_info_ext_ies_o::ext_c nr_freq_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 202) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nr_freq_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 202) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void nr_freq_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("FrequencyShift7p5khz", c.to_string());
  j.end_obj();
}
SRSASN_CODE nr_freq_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* nr_freq_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"FrequencyShift7p5khz"};
  return convert_enum_idx(names, 1, value, "nr_freq_info_ext_ies_o::ext_c::types");
}
uint8_t nr_freq_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {7};
  return map_enum_number(numbers, 1, value, "nr_freq_info_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<sul_info_ext_ies_o>;

SRSASN_CODE sul_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += carrier_list_present ? 1 : 0;
  nof_ies += freq_shift7p5khz_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)200, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, carrier_list, 1, 5, true));
  }
  if (freq_shift7p5khz_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)202, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(freq_shift7p5khz.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sul_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 200: {
        carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(carrier_list, bref, 1, 5, true));
        break;
      }
      case 202: {
        freq_shift7p5khz_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(freq_shift7p5khz.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void sul_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (carrier_list_present) {
    j.write_int("id", 200);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (freq_shift7p5khz_present) {
    j.write_int("id", 202);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", freq_shift7p5khz.to_string());
  }
  j.end_obj();
}

// SUL-Information ::= SEQUENCE
SRSASN_CODE sul_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sul_freq_info, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(sul_tx_bw.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sul_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sul_freq_info, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(sul_tx_bw.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sul_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sulFrequencyInfo", sul_freq_info);
  j.write_fieldname("sulTransmissionBandwidth");
  sul_tx_bw.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRFrequencyInfo ::= SEQUENCE
SRSASN_CODE nr_freq_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sul_info_present, 1));
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (sul_info_present) {
    HANDLE_CODE(sul_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, freq_band_list, 1, 32, true));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(sul_info_present, 1));
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (sul_info_present) {
    HANDLE_CODE(sul_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(freq_band_list, bref, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void nr_freq_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nrARFCN", nr_arfcn);
  if (sul_info_present) {
    j.write_fieldname("sul-information");
    sul_info.to_json(j);
  }
  j.start_array("frequencyBand-List");
  for (const auto& e1 : freq_band_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// AreaScopeOfNeighCellsItem ::= SEQUENCE
SRSASN_CODE area_scope_of_neigh_cells_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pci_list_for_mdt.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.pack(bref));
  if (pci_list_for_mdt.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, pci_list_for_mdt, 1, 32, integer_packer<uint16_t>(0, 1007, true, true)));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_neigh_cells_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool pci_list_for_mdt_present;
  HANDLE_CODE(bref.unpack(pci_list_for_mdt_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.unpack(bref));
  if (pci_list_for_mdt_present) {
    HANDLE_CODE(unpack_dyn_seq_of(pci_list_for_mdt, bref, 1, 32, integer_packer<uint16_t>(0, 1007, true, true)));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_scope_of_neigh_cells_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nrFrequencyInfo");
  nr_freq_info.to_json(j);
  if (pci_list_for_mdt.size() > 0) {
    j.start_array("pciListForMDT");
    for (const auto& e1 : pci_list_for_mdt) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalNG-RANCell-ID ::= SEQUENCE
SRSASN_CODE global_ng_ran_cell_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(ng_ran_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ng_ran_cell_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(ng_ran_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_ng_ran_cell_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.write_fieldname("ng-RAN-Cell-id");
  ng_ran_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAI-Item ::= SEQUENCE
SRSASN_CODE tai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tac.pack(bref));
  HANDLE_CODE(plmn_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tac.unpack(bref));
  HANDLE_CODE(plmn_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tAC", tac.to_string());
  j.write_str("pLMN-Identity", plmn_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellBasedQMC ::= SEQUENCE
SRSASN_CODE cell_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_qmc, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_qmc, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforQMC");
  for (const auto& e1 : cell_id_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PLMNAreaBasedQMC ::= SEQUENCE
SRSASN_CODE plmn_area_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, plmn_listfor_qmc, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_area_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(plmn_listfor_qmc, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void plmn_area_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("plmnListforQMC");
  for (const auto& e1 : plmn_listfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedQMC ::= SEQUENCE
SRSASN_CODE ta_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ta_listfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ta_listfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforQMC");
  for (const auto& e1 : ta_listfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedQMC ::= SEQUENCE
SRSASN_CODE tai_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforQMC");
  for (const auto& e1 : tai_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfQMC ::= CHOICE
void area_scope_of_qmc_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_qmc_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.destroy<plmn_area_based_qmc_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void area_scope_of_qmc_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_qmc_s>();
      break;
    case types::ta_based:
      c.init<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.init<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.init<plmn_area_based_qmc_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c::area_scope_of_qmc_c(const area_scope_of_qmc_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_qmc_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.init(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c& area_scope_of_qmc_c::operator=(const area_scope_of_qmc_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_qmc_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.set(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }

  return *this;
}
cell_based_qmc_s& area_scope_of_qmc_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_qmc_s>();
}
ta_based_qmc_s& area_scope_of_qmc_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_qmc_s>();
}
tai_based_qmc_s& area_scope_of_qmc_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_qmc_s>();
}
plmn_area_based_qmc_s& area_scope_of_qmc_c::set_plmn_area_based()
{
  set(types::plmn_area_based);
  return c.get<plmn_area_based_qmc_s>();
}
protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>& area_scope_of_qmc_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
}
void area_scope_of_qmc_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_qmc_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_qmc_s>().to_json(j);
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_qmc_s>().to_json(j);
      break;
    case types::plmn_area_based:
      j.write_fieldname("pLMNAreaBased");
      c.get<plmn_area_based_qmc_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_qmc_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_qmc_s>().pack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().pack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_qmc_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_qmc_s>().unpack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().unpack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_qmc_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "tAIBased", "pLMNAreaBased", "choice-extension"};
  return convert_enum_idx(names, 5, value, "area_scope_of_qmc_c::types");
}

// NPNPagingAssistanceInformation-PNI-NPN ::= SEQUENCE
SRSASN_CODE npn_paging_assist_info_pni_npn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, allowed_pni_npn_id_list, 1, 16, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_paging_assist_info_pni_npn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(allowed_pni_npn_id_list, bref, 1, 16, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_paging_assist_info_pni_npn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("allowedPNI-NPN-ID-List");
  for (const auto& e1 : allowed_pni_npn_id_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NPNPagingAssistanceInformation ::= CHOICE
void npn_paging_assist_info_c::destroy_()
{
  switch (type_) {
    case types::pni_npn_info:
      c.destroy<npn_paging_assist_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_paging_assist_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pni_npn_info:
      c.init<npn_paging_assist_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
}
npn_paging_assist_info_c::npn_paging_assist_info_c(const npn_paging_assist_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pni_npn_info:
      c.init(other.c.get<npn_paging_assist_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
}
npn_paging_assist_info_c& npn_paging_assist_info_c::operator=(const npn_paging_assist_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pni_npn_info:
      c.set(other.c.get<npn_paging_assist_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }

  return *this;
}
npn_paging_assist_info_pni_npn_s& npn_paging_assist_info_c::set_pni_npn_info()
{
  set(types::pni_npn_info);
  return c.get<npn_paging_assist_info_pni_npn_s>();
}
protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>& npn_paging_assist_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
}
void npn_paging_assist_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pni_npn_info:
      j.write_fieldname("pni-npn-Information");
      c.get<npn_paging_assist_info_pni_npn_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_paging_assist_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pni_npn_info:
      HANDLE_CODE(c.get<npn_paging_assist_info_pni_npn_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_paging_assist_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pni_npn_info:
      HANDLE_CODE(c.get<npn_paging_assist_info_pni_npn_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_paging_assist_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pni-npn-Information", "choice-extension"};
  return convert_enum_idx(names, 2, value, "npn_paging_assist_info_c::types");
}

// AssistanceDataForRANPaging-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t assist_data_for_ran_paging_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool assist_data_for_ran_paging_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e assist_data_for_ran_paging_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
assist_data_for_ran_paging_ext_ies_o::ext_c assist_data_for_ran_paging_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e assist_data_for_ran_paging_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void assist_data_for_ran_paging_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("NPNPagingAssistanceInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE assist_data_for_ran_paging_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_ran_paging_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* assist_data_for_ran_paging_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPNPagingAssistanceInformation"};
  return convert_enum_idx(names, 1, value, "assist_data_for_ran_paging_ext_ies_o::ext_c::types");
}

// RANPagingAttemptInfo ::= SEQUENCE
SRSASN_CODE ran_paging_attempt_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, paging_attempt_count, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(pack_integer(bref, intended_nof_paging_attempts, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_paging_attempt_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(paging_attempt_count, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(unpack_integer(intended_nof_paging_attempts, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ran_paging_attempt_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pagingAttemptCount", paging_attempt_count);
  j.write_int("intendedNumberOfPagingAttempts", intended_nof_paging_attempts);
  if (next_paging_area_scope_present) {
    j.write_str("nextPagingAreaScope", next_paging_area_scope.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ran_paging_attempt_info_s::next_paging_area_scope_opts::to_string() const
{
  static const char* names[] = {"same", "changed"};
  return convert_enum_idx(names, 2, value, "ran_paging_attempt_info_s::next_paging_area_scope_e_");
}

// AssistanceDataForRANPaging ::= SEQUENCE
SRSASN_CODE assist_data_for_ran_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ran_paging_attempt_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ran_paging_attempt_info_present) {
    HANDLE_CODE(ran_paging_attempt_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_ran_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ran_paging_attempt_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ran_paging_attempt_info_present) {
    HANDLE_CODE(ran_paging_attempt_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_ran_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ran_paging_attempt_info_present) {
    j.write_fieldname("ran-paging-attempt-info");
    ran_paging_attempt_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// Associated-QoSFlowInfo-Item ::= SEQUENCE
SRSASN_CODE associated_qos_flow_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(pack_integer(bref, associated_unicast_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_qos_flow_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(unpack_integer(associated_unicast_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void associated_qos_flow_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-QoSFlowIdentifier", mbs_qos_flow_id);
  j.write_int("associatedUnicastQoSFlowIdentifier", associated_unicast_qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AvailableRVQoEMetrics ::= SEQUENCE
SRSASN_CODE available_rv_qo_e_metrics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(buffer_level_present, 1));
  HANDLE_CODE(bref.pack(playout_delay_for_media_startup_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (buffer_level_present) {
    HANDLE_CODE(buffer_level.pack(bref));
  }
  if (playout_delay_for_media_startup_present) {
    HANDLE_CODE(playout_delay_for_media_startup.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE available_rv_qo_e_metrics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(buffer_level_present, 1));
  HANDLE_CODE(bref.unpack(playout_delay_for_media_startup_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (buffer_level_present) {
    HANDLE_CODE(buffer_level.unpack(bref));
  }
  if (playout_delay_for_media_startup_present) {
    HANDLE_CODE(playout_delay_for_media_startup.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void available_rv_qo_e_metrics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (buffer_level_present) {
    j.write_str("bufferLevel", "true");
  }
  if (playout_delay_for_media_startup_present) {
    j.write_str("playoutDelayForMediaStartup", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* available_rv_qo_e_metrics_s::buffer_level_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "available_rv_qo_e_metrics_s::buffer_level_e_");
}

const char* available_rv_qo_e_metrics_s::playout_delay_for_media_startup_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "available_rv_qo_e_metrics_s::playout_delay_for_media_startup_e_");
}

// BAPControlPDURLCCH-Item ::= SEQUENCE
SRSASN_CODE bap_ctrl_pdu_rlc_ch_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  HANDLE_CODE(nexthop_bap_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bap_ctrl_pdu_rlc_ch_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  HANDLE_CODE(nexthop_bap_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bap_ctrl_pdu_rlc_ch_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCCHID", bh_rlc_ch_id.to_string());
  j.write_str("nexthopBAPAddress", nexthop_bap_address.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BAPRoutingID ::= SEQUENCE
SRSASN_CODE bap_routing_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bap_address.pack(bref));
  HANDLE_CODE(bap_path_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bap_routing_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bap_address.unpack(bref));
  HANDLE_CODE(bap_path_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bap_routing_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bAPAddress", bap_address.to_string());
  j.write_str("bAPPathID", bap_path_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHInfo-Item ::= SEQUENCE
SRSASN_CODE bh_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, bh_info_idx, (uint16_t)1u, (uint16_t)1024u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(bh_info_idx, bref, (uint16_t)1u, (uint16_t)1024u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("bHInfoIndex", bh_info_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BPLMN-ID-Info-EUTRA-Item ::= SEQUENCE
SRSASN_CODE bplmn_id_info_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmns, 1, 6, true));
  HANDLE_CODE(tac.pack(bref));
  HANDLE_CODE(e_utra_ci.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bplmn_id_info_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmns, bref, 1, 6, true));
  HANDLE_CODE(tac.unpack(bref));
  HANDLE_CODE(e_utra_ci.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bplmn_id_info_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("broadcastPLMNs");
  for (const auto& e1 : broadcast_plmns) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.write_str("tac", tac.to_string());
  j.write_str("e-utraCI", e_utra_ci.to_string());
  if (ranac_present) {
    j.write_int("ranac", ranac);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// BroadcastCAG-Identifier-Item ::= SEQUENCE
SRSASN_CODE broadcast_cag_id_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(cag_id.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_cag_id_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(cag_id.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_cag_id_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cag-Identifier", cag_id.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// BroadcastNID-Item ::= SEQUENCE
SRSASN_CODE broadcast_n_id_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(nid.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_n_id_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(nid.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_n_id_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nid", nid.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// BroadcastPNI-NPN-ID-Information-Item ::= SEQUENCE
SRSASN_CODE broadcast_pni_npn_id_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_cag_id_list, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_pni_npn_id_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_cag_id_list, bref, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_pni_npn_id_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.start_array("broadcastCAG-Identifier-List");
  for (const auto& e1 : broadcast_cag_id_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// BroadcastSNPNID ::= SEQUENCE
SRSASN_CODE broadcast_sn_pn_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_n_id_list, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_sn_pn_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_n_id_list, bref, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_sn_pn_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.start_array("broadcastNID-List");
  for (const auto& e1 : broadcast_n_id_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NPN-Broadcast-Information-PNI-NPN ::= SEQUENCE
SRSASN_CODE npn_broadcast_info_pni_npn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_pni_npn_id_info, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_broadcast_info_pni_npn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(broadcast_pni_npn_id_info, bref, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_broadcast_info_pni_npn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("broadcastPNI-NPN-ID-Information");
  for (const auto& e1 : broadcast_pni_npn_id_info) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NPN-Broadcast-Information-SNPN ::= SEQUENCE
SRSASN_CODE npn_broadcast_info_sn_pn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_sn_pn_id_list, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_broadcast_info_sn_pn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(broadcast_sn_pn_id_list, bref, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_broadcast_info_sn_pn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("broadcastSNPNID-List");
  for (const auto& e1 : broadcast_sn_pn_id_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ConfiguredTACIndication ::= ENUMERATED
const char* cfg_tac_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cfg_tac_ind_e");
}

// NPN-Broadcast-Information ::= CHOICE
void npn_broadcast_info_c::destroy_()
{
  switch (type_) {
    case types::snpn_info:
      c.destroy<npn_broadcast_info_sn_pn_s>();
      break;
    case types::pni_npn_info:
      c.destroy<npn_broadcast_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_broadcast_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::snpn_info:
      c.init<npn_broadcast_info_sn_pn_s>();
      break;
    case types::pni_npn_info:
      c.init<npn_broadcast_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }
}
npn_broadcast_info_c::npn_broadcast_info_c(const npn_broadcast_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::snpn_info:
      c.init(other.c.get<npn_broadcast_info_sn_pn_s>());
      break;
    case types::pni_npn_info:
      c.init(other.c.get<npn_broadcast_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }
}
npn_broadcast_info_c& npn_broadcast_info_c::operator=(const npn_broadcast_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::snpn_info:
      c.set(other.c.get<npn_broadcast_info_sn_pn_s>());
      break;
    case types::pni_npn_info:
      c.set(other.c.get<npn_broadcast_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }

  return *this;
}
npn_broadcast_info_sn_pn_s& npn_broadcast_info_c::set_snpn_info()
{
  set(types::snpn_info);
  return c.get<npn_broadcast_info_sn_pn_s>();
}
npn_broadcast_info_pni_npn_s& npn_broadcast_info_c::set_pni_npn_info()
{
  set(types::pni_npn_info);
  return c.get<npn_broadcast_info_pni_npn_s>();
}
protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>& npn_broadcast_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
}
void npn_broadcast_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::snpn_info:
      j.write_fieldname("snpn-Information");
      c.get<npn_broadcast_info_sn_pn_s>().to_json(j);
      break;
    case types::pni_npn_info:
      j.write_fieldname("pni-npn-Information");
      c.get<npn_broadcast_info_pni_npn_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_broadcast_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::snpn_info:
      HANDLE_CODE(c.get<npn_broadcast_info_sn_pn_s>().pack(bref));
      break;
    case types::pni_npn_info:
      HANDLE_CODE(c.get<npn_broadcast_info_pni_npn_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_broadcast_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::snpn_info:
      HANDLE_CODE(c.get<npn_broadcast_info_sn_pn_s>().unpack(bref));
      break;
    case types::pni_npn_info:
      HANDLE_CODE(c.get<npn_broadcast_info_pni_npn_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_broadcast_info_c::types_opts::to_string() const
{
  static const char* names[] = {"snpn-Information", "pni-npn-Information", "choice-extension"};
  return convert_enum_idx(names, 3, value, "npn_broadcast_info_c::types");
}

// BPLMN-ID-Info-NR-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t bplmn_id_info_nr_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {233, 220};
  return map_enum_number(names, 2, idx, "id");
}
bool bplmn_id_info_nr_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {233, 220};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e bplmn_id_info_nr_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 233:
      return crit_e::ignore;
    case 220:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
bplmn_id_info_nr_item_ext_ies_o::ext_c bplmn_id_info_nr_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 233:
      ret.set(ext_c::types::cfg_tac_ind);
      break;
    case 220:
      ret.set(ext_c::types::npn_broadcast_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e bplmn_id_info_nr_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 233:
      return presence_e::optional;
    case 220:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void bplmn_id_info_nr_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cfg_tac_ind:
      c = cfg_tac_ind_e{};
      break;
    case types::npn_broadcast_info:
      c = npn_broadcast_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_nr_item_ext_ies_o::ext_c");
  }
}
cfg_tac_ind_e& bplmn_id_info_nr_item_ext_ies_o::ext_c::cfg_tac_ind()
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
npn_broadcast_info_c& bplmn_id_info_nr_item_ext_ies_o::ext_c::npn_broadcast_info()
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
const cfg_tac_ind_e& bplmn_id_info_nr_item_ext_ies_o::ext_c::cfg_tac_ind() const
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
const npn_broadcast_info_c& bplmn_id_info_nr_item_ext_ies_o::ext_c::npn_broadcast_info() const
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
void bplmn_id_info_nr_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cfg_tac_ind:
      j.write_str("ConfiguredTACIndication", "true");
      break;
    case types::npn_broadcast_info:
      j.write_fieldname("NPN-Broadcast-Information");
      c.get<npn_broadcast_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_nr_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE bplmn_id_info_nr_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().pack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_nr_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE bplmn_id_info_nr_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().unpack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_nr_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* bplmn_id_info_nr_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ConfiguredTACIndication", "NPN-Broadcast-Information"};
  return convert_enum_idx(names, 2, value, "bplmn_id_info_nr_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<bplmn_id_info_nr_item_ext_ies_o>;

SRSASN_CODE bplmn_id_info_nr_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cfg_tac_ind_present ? 1 : 0;
  nof_ies += npn_broadcast_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cfg_tac_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)233, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cfg_tac_ind.pack(bref));
  }
  if (npn_broadcast_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)220, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_broadcast_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bplmn_id_info_nr_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 233: {
        cfg_tac_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cfg_tac_ind.unpack(bref));
        break;
      }
      case 220: {
        npn_broadcast_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_broadcast_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void bplmn_id_info_nr_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cfg_tac_ind_present) {
    j.write_int("id", 233);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (npn_broadcast_info_present) {
    j.write_int("id", 220);
    j.write_str("criticality", "reject");
    npn_broadcast_info.to_json(j);
  }
  j.end_obj();
}

// BPLMN-ID-Info-NR-Item ::= SEQUENCE
SRSASN_CODE bplmn_id_info_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmns, 1, 12, true));
  HANDLE_CODE(tac.pack(bref));
  HANDLE_CODE(nr_ci.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bplmn_id_info_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmns, bref, 1, 12, true));
  HANDLE_CODE(tac.unpack(bref));
  HANDLE_CODE(nr_ci.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bplmn_id_info_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("broadcastPLMNs");
  for (const auto& e1 : broadcast_plmns) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.write_str("tac", tac.to_string());
  j.write_str("nr-CI", nr_ci.to_string());
  if (ranac_present) {
    j.write_int("ranac", ranac);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// BeamMeasurementsReportQuantity ::= SEQUENCE
SRSASN_CODE beam_meass_report_quant_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rsrp.pack(bref));
  HANDLE_CODE(rsrq.pack(bref));
  HANDLE_CODE(sinr.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE beam_meass_report_quant_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rsrp.unpack(bref));
  HANDLE_CODE(rsrq.unpack(bref));
  HANDLE_CODE(sinr.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void beam_meass_report_quant_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rSRP", "true");
  j.write_str("rSRQ", "true");
  j.write_str("sINR", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* beam_meass_report_quant_s::rsrp_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::rsrp_e_");
}

const char* beam_meass_report_quant_s::rsrq_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::rsrq_e_");
}

const char* beam_meass_report_quant_s::sinr_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::sinr_e_");
}

// BeamMeasurementsReportConfiguration ::= SEQUENCE
SRSASN_CODE beam_meass_report_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(beam_meass_report_quant_present, 1));
  HANDLE_CODE(bref.pack(max_nrof_rs_idxes_to_report_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (beam_meass_report_quant_present) {
    HANDLE_CODE(beam_meass_report_quant.pack(bref));
  }
  if (max_nrof_rs_idxes_to_report_present) {
    HANDLE_CODE(pack_integer(bref, max_nrof_rs_idxes_to_report, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE beam_meass_report_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(beam_meass_report_quant_present, 1));
  HANDLE_CODE(bref.unpack(max_nrof_rs_idxes_to_report_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (beam_meass_report_quant_present) {
    HANDLE_CODE(beam_meass_report_quant.unpack(bref));
  }
  if (max_nrof_rs_idxes_to_report_present) {
    HANDLE_CODE(unpack_integer(max_nrof_rs_idxes_to_report, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void beam_meass_report_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (beam_meass_report_quant_present) {
    j.write_fieldname("beamMeasurementsReportQuantity");
    beam_meass_report_quant.to_json(j);
  }
  if (max_nrof_rs_idxes_to_report_present) {
    j.write_int("maxNrofRS-IndexesToReport", max_nrof_rs_idxes_to_report);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BluetoothMeasConfig ::= ENUMERATED
const char* bluetooth_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "bluetooth_meas_cfg_e");
}

// BluetoothMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE bluetooth_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(bt_rssi_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  if (bluetooth_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, bluetooth_meas_cfg_name_list, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bluetooth_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool bluetooth_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(bt_rssi_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  if (bluetooth_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(bluetooth_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bluetooth_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bluetoothMeasConfig", "setup");
  if (bluetooth_meas_cfg_name_list.size() > 0) {
    j.start_array("bluetoothMeasConfigNameList");
    for (const auto& e1 : bluetooth_meas_cfg_name_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (bt_rssi_present) {
    j.write_str("bt-rssi", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* bluetooth_meas_cfg_s::bt_rssi_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "bluetooth_meas_cfg_s::bt_rssi_e_");
}

// HSNADownlink ::= ENUMERATED
const char* h_sn_a_dl_opts::to_string() const
{
  static const char* names[] = {"hard", "soft", "notavailable"};
  return convert_enum_idx(names, 3, value, "h_sn_a_dl_e");
}

// HSNAFlexible ::= ENUMERATED
const char* h_sn_a_flex_opts::to_string() const
{
  static const char* names[] = {"hard", "soft", "notavailable"};
  return convert_enum_idx(names, 3, value, "h_sn_a_flex_e");
}

// HSNAUplink ::= ENUMERATED
const char* h_sn_a_ul_opts::to_string() const
{
  static const char* names[] = {"hard", "soft", "notavailable"};
  return convert_enum_idx(names, 3, value, "h_sn_a_ul_e");
}

// FreqDomainSlotHSNAconfiguration-List-Item ::= SEQUENCE
SRSASN_CODE freq_domain_slot_h_sn_acfg_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, slot_idx, (uint16_t)1u, (uint16_t)5120u, false, true));
  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.pack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.pack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_domain_slot_h_sn_acfg_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(slot_idx, bref, (uint16_t)1u, (uint16_t)5120u, false, true));
  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.unpack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.unpack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void freq_domain_slot_h_sn_acfg_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("slotIndex", slot_idx);
  if (hsn_a_dl_present) {
    j.write_str("hSNADownlink", hsn_a_dl.to_string());
  }
  if (hsn_a_ul_present) {
    j.write_str("hSNAUplink", hsn_a_ul.to_string());
  }
  if (hsn_a_flex_present) {
    j.write_str("hSNAFlexible", hsn_a_flex.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Permutation ::= ENUMERATED
const char* permutation_opts::to_string() const
{
  static const char* names[] = {"dfu", "ufd"};
  return convert_enum_idx(names, 2, value, "permutation_e");
}

// ExplicitFormat ::= SEQUENCE
SRSASN_CODE explicit_format_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(noof_dl_symbols_present, 1));
  HANDLE_CODE(bref.pack(noof_ul_symbols_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(permutation.pack(bref));
  if (noof_dl_symbols_present) {
    HANDLE_CODE(pack_integer(bref, noof_dl_symbols, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (noof_ul_symbols_present) {
    HANDLE_CODE(pack_integer(bref, noof_ul_symbols, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE explicit_format_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(noof_dl_symbols_present, 1));
  HANDLE_CODE(bref.unpack(noof_ul_symbols_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(permutation.unpack(bref));
  if (noof_dl_symbols_present) {
    HANDLE_CODE(unpack_integer(noof_dl_symbols, bref, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (noof_ul_symbols_present) {
    HANDLE_CODE(unpack_integer(noof_ul_symbols, bref, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void explicit_format_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("permutation", permutation.to_string());
  if (noof_dl_symbols_present) {
    j.write_int("noofDownlinkSymbols", noof_dl_symbols);
  }
  if (noof_ul_symbols_present) {
    j.write_int("noofUplinkSymbols", noof_ul_symbols);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ImplicitFormat ::= SEQUENCE
SRSASN_CODE implicit_format_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, du_f_slotformat_idx, (uint8_t)0u, (uint8_t)254u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE implicit_format_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(du_f_slotformat_idx, bref, (uint8_t)0u, (uint8_t)254u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void implicit_format_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dUFSlotformatIndex", du_f_slotformat_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DUF-Slot-Config-Item ::= CHOICE
void du_f_slot_cfg_item_c::destroy_()
{
  switch (type_) {
    case types::explicit_format:
      c.destroy<explicit_format_s>();
      break;
    case types::implicit_format:
      c.destroy<implicit_format_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void du_f_slot_cfg_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::explicit_format:
      c.init<explicit_format_s>();
      break;
    case types::implicit_format:
      c.init<implicit_format_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }
}
du_f_slot_cfg_item_c::du_f_slot_cfg_item_c(const du_f_slot_cfg_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::explicit_format:
      c.init(other.c.get<explicit_format_s>());
      break;
    case types::implicit_format:
      c.init(other.c.get<implicit_format_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }
}
du_f_slot_cfg_item_c& du_f_slot_cfg_item_c::operator=(const du_f_slot_cfg_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::explicit_format:
      c.set(other.c.get<explicit_format_s>());
      break;
    case types::implicit_format:
      c.set(other.c.get<implicit_format_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }

  return *this;
}
explicit_format_s& du_f_slot_cfg_item_c::set_explicit_format()
{
  set(types::explicit_format);
  return c.get<explicit_format_s>();
}
implicit_format_s& du_f_slot_cfg_item_c::set_implicit_format()
{
  set(types::implicit_format);
  return c.get<implicit_format_s>();
}
protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>& du_f_slot_cfg_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
}
void du_f_slot_cfg_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::explicit_format:
      j.write_fieldname("explicitFormat");
      c.get<explicit_format_s>().to_json(j);
      break;
    case types::implicit_format:
      j.write_fieldname("implicitFormat");
      c.get<implicit_format_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }
  j.end_obj();
}
SRSASN_CODE du_f_slot_cfg_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::explicit_format:
      HANDLE_CODE(c.get<explicit_format_s>().pack(bref));
      break;
    case types::implicit_format:
      HANDLE_CODE(c.get<implicit_format_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE du_f_slot_cfg_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::explicit_format:
      HANDLE_CODE(c.get<explicit_format_s>().unpack(bref));
      break;
    case types::implicit_format:
      HANDLE_CODE(c.get<implicit_format_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* du_f_slot_cfg_item_c::types_opts::to_string() const
{
  static const char* names[] = {"explicitFormat", "implicitFormat", "choice-extension"};
  return convert_enum_idx(names, 3, value, "du_f_slot_cfg_item_c::types");
}

// FreqDomainHSNAconfiguration-List-Item ::= SEQUENCE
SRSASN_CODE freq_domain_h_sn_acfg_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, rbset_idx, (uint8_t)0u, (uint8_t)7u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, freq_domain_slot_h_sn_acfg_list, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_domain_h_sn_acfg_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(rbset_idx, bref, (uint8_t)0u, (uint8_t)7u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(freq_domain_slot_h_sn_acfg_list, bref, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void freq_domain_h_sn_acfg_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("rBsetIndex", rbset_idx);
  j.start_array("freqDomainSlotHSNAconfiguration-List");
  for (const auto& e1 : freq_domain_slot_h_sn_acfg_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HSNASlotConfigItem ::= SEQUENCE
SRSASN_CODE hs_nas_lot_cfg_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.pack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.pack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE hs_nas_lot_cfg_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.unpack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.unpack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void hs_nas_lot_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (hsn_a_dl_present) {
    j.write_str("hSNADownlink", hsn_a_dl.to_string());
  }
  if (hsn_a_ul_present) {
    j.write_str("hSNAUplink", hsn_a_ul.to_string());
  }
  if (hsn_a_flex_present) {
    j.write_str("hSNAFlexible", hsn_a_flex.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NACellResourceConfiguration-Item ::= SEQUENCE
SRSASN_CODE na_cell_res_cfg_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nadownlin_present, 1));
  HANDLE_CODE(bref.pack(naul_present, 1));
  HANDLE_CODE(bref.pack(naflex_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (nadownlin_present) {
    HANDLE_CODE(nadownlin.pack(bref));
  }
  if (naul_present) {
    HANDLE_CODE(naul.pack(bref));
  }
  if (naflex_present) {
    HANDLE_CODE(naflex.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE na_cell_res_cfg_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nadownlin_present, 1));
  HANDLE_CODE(bref.unpack(naul_present, 1));
  HANDLE_CODE(bref.unpack(naflex_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (nadownlin_present) {
    HANDLE_CODE(nadownlin.unpack(bref));
  }
  if (naul_present) {
    HANDLE_CODE(naul.unpack(bref));
  }
  if (naflex_present) {
    HANDLE_CODE(naflex.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void na_cell_res_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (nadownlin_present) {
    j.write_str("nAdownlin", nadownlin.to_string());
  }
  if (naul_present) {
    j.write_str("nAuplink", naul.to_string());
  }
  if (naflex_present) {
    j.write_str("nAflexible", naflex.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* na_cell_res_cfg_item_s::nadownlin_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "na_cell_res_cfg_item_s::nadownlin_e_");
}

const char* na_cell_res_cfg_item_s::naul_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "na_cell_res_cfg_item_s::naul_e_");
}

const char* na_cell_res_cfg_item_s::naflex_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "na_cell_res_cfg_item_s::naflex_e_");
}

// SSB-subcarrierSpacing ::= ENUMERATED
const char* ssb_subcarrier_spacing_opts::to_string() const
{
  static const char* names[] = {"kHz15", "kHz30", "kHz120", "kHz240", "spare3", "spare2", "spare1"};
  return convert_enum_idx(names, 7, value, "ssb_subcarrier_spacing_e");
}
uint8_t ssb_subcarrier_spacing_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 120, 240};
  return map_enum_number(numbers, 4, value, "ssb_subcarrier_spacing_e");
}

// DU-RX-MT-RX ::= ENUMERATED
const char* du_rx_mt_rx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_rx_mt_rx_e");
}

// DU-RX-MT-TX ::= ENUMERATED
const char* du_rx_mt_tx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_rx_mt_tx_e");
}

// DU-TX-MT-RX ::= ENUMERATED
const char* du_tx_mt_rx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_tx_mt_rx_e");
}

// DU-TX-MT-TX ::= ENUMERATED
const char* du_tx_mt_tx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_tx_mt_tx_e");
}

// DUFTransmissionPeriodicity ::= ENUMERATED
const char* du_f_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms0p5", "ms0p625", "ms1", "ms1p25", "ms2", "ms2p5", "ms5", "ms10"};
  return convert_enum_idx(names, 8, value, "du_f_tx_periodicity_e");
}

// HSNATransmissionPeriodicity ::= ENUMERATED
const char* h_sn_a_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {
      "ms0p5", "ms0p625", "ms1", "ms1p25", "ms2", "ms2p5", "ms5", "ms10", "ms20", "ms40", "ms80", "ms160"};
  return convert_enum_idx(names, 12, value, "h_sn_a_tx_periodicity_e");
}

// RBsetConfiguration ::= SEQUENCE
SRSASN_CODE r_bset_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.pack(bref));
  HANDLE_CODE(rbset_size.pack(bref));
  HANDLE_CODE(pack_integer(bref, numof_rb_sets, (uint8_t)1u, (uint8_t)8u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE r_bset_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.unpack(bref));
  HANDLE_CODE(rbset_size.unpack(bref));
  HANDLE_CODE(unpack_integer(numof_rb_sets, bref, (uint8_t)1u, (uint8_t)8u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void r_bset_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("subcarrierSpacing", subcarrier_spacing.to_string());
  j.write_str("rBsetSize", rbset_size.to_string());
  j.write_int("numberofRBSets", numof_rb_sets);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* r_bset_cfg_s::rbset_size_opts::to_string() const
{
  static const char* names[] = {"rb2", "rb4", "rb8", "rb16", "rb32", "rb64"};
  return convert_enum_idx(names, 6, value, "r_bset_cfg_s::rbset_size_e_");
}
uint8_t r_bset_cfg_s::rbset_size_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4, 8, 16, 32, 64};
  return map_enum_number(numbers, 6, value, "r_bset_cfg_s::rbset_size_e_");
}

// SSB-transmissionBitmap ::= CHOICE
void ssb_tx_bitmap_c::destroy_()
{
  switch (type_) {
    case types::short_bitmap:
      c.destroy<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ssb_tx_bitmap_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::short_bitmap:
      c.init<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }
}
ssb_tx_bitmap_c::ssb_tx_bitmap_c(const ssb_tx_bitmap_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::short_bitmap:
      c.init(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }
}
ssb_tx_bitmap_c& ssb_tx_bitmap_c::operator=(const ssb_tx_bitmap_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::short_bitmap:
      c.set(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }

  return *this;
}
fixed_bitstring<4, false, true>& ssb_tx_bitmap_c::set_short_bitmap()
{
  set(types::short_bitmap);
  return c.get<fixed_bitstring<4, false, true>>();
}
fixed_bitstring<8, false, true>& ssb_tx_bitmap_c::set_medium_bitmap()
{
  set(types::medium_bitmap);
  return c.get<fixed_bitstring<8, false, true>>();
}
fixed_bitstring<64, false, true>& ssb_tx_bitmap_c::set_long_bitmap()
{
  set(types::long_bitmap);
  return c.get<fixed_bitstring<64, false, true>>();
}
protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>& ssb_tx_bitmap_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
}
void ssb_tx_bitmap_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::short_bitmap:
      j.write_str("shortBitmap", c.get<fixed_bitstring<4, false, true>>().to_string());
      break;
    case types::medium_bitmap:
      j.write_str("mediumBitmap", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::long_bitmap:
      j.write_str("longBitmap", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }
  j.end_obj();
}
SRSASN_CODE ssb_tx_bitmap_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().pack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_tx_bitmap_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().unpack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ssb_tx_bitmap_c::types_opts::to_string() const
{
  static const char* names[] = {"shortBitmap", "mediumBitmap", "longBitmap", "choice-extension"};
  return convert_enum_idx(names, 4, value, "ssb_tx_bitmap_c::types");
}

// SSB-transmissionPeriodicity ::= ENUMERATED
const char* ssb_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {"sf10", "sf20", "sf40", "sf80", "sf160", "sf320", "sf640"};
  return convert_enum_idx(names, 7, value, "ssb_tx_periodicity_e");
}
uint16_t ssb_tx_periodicity_opts::to_number() const
{
  static const uint16_t numbers[] = {10, 20, 40, 80, 160, 320, 640};
  return map_enum_number(numbers, 7, value, "ssb_tx_periodicity_e");
}

// GNB-DU-Cell-Resource-Configuration ::= SEQUENCE
SRSASN_CODE gnb_du_cell_res_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(du_f_tx_periodicity_present, 1));
  HANDLE_CODE(bref.pack(du_f_slot_cfg_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(hnsa_slot_cfg_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(rbset_cfg_present, 1));
  HANDLE_CODE(bref.pack(freq_domain_h_sn_acfg_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(na_cell_res_cfg_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.pack(bref));
  if (du_f_tx_periodicity_present) {
    HANDLE_CODE(du_f_tx_periodicity.pack(bref));
  }
  if (du_f_slot_cfg_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, du_f_slot_cfg_list, 1, 320, true));
  }
  HANDLE_CODE(hsn_a_tx_periodicity.pack(bref));
  if (hnsa_slot_cfg_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, hnsa_slot_cfg_list, 1, 5120, true));
  }
  if (rbset_cfg_present) {
    HANDLE_CODE(rbset_cfg.pack(bref));
  }
  if (freq_domain_h_sn_acfg_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, freq_domain_h_sn_acfg_list, 1, 5120, true));
  }
  if (na_cell_res_cfg_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, na_cell_res_cfg_list, 1, 5120, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_cell_res_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(du_f_tx_periodicity_present, 1));
  bool du_f_slot_cfg_list_present;
  HANDLE_CODE(bref.unpack(du_f_slot_cfg_list_present, 1));
  bool hnsa_slot_cfg_list_present;
  HANDLE_CODE(bref.unpack(hnsa_slot_cfg_list_present, 1));
  HANDLE_CODE(bref.unpack(rbset_cfg_present, 1));
  bool freq_domain_h_sn_acfg_list_present;
  HANDLE_CODE(bref.unpack(freq_domain_h_sn_acfg_list_present, 1));
  bool na_cell_res_cfg_list_present;
  HANDLE_CODE(bref.unpack(na_cell_res_cfg_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.unpack(bref));
  if (du_f_tx_periodicity_present) {
    HANDLE_CODE(du_f_tx_periodicity.unpack(bref));
  }
  if (du_f_slot_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(du_f_slot_cfg_list, bref, 1, 320, true));
  }
  HANDLE_CODE(hsn_a_tx_periodicity.unpack(bref));
  if (hnsa_slot_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(hnsa_slot_cfg_list, bref, 1, 5120, true));
  }
  if (rbset_cfg_present) {
    HANDLE_CODE(rbset_cfg.unpack(bref));
  }
  if (freq_domain_h_sn_acfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(freq_domain_h_sn_acfg_list, bref, 1, 5120, true));
  }
  if (na_cell_res_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(na_cell_res_cfg_list, bref, 1, 5120, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_du_cell_res_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("subcarrierSpacing", subcarrier_spacing.to_string());
  if (du_f_tx_periodicity_present) {
    j.write_str("dUFTransmissionPeriodicity", du_f_tx_periodicity.to_string());
  }
  if (du_f_slot_cfg_list.size() > 0) {
    j.start_array("dUF-Slot-Config-List");
    for (const auto& e1 : du_f_slot_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_str("hSNATransmissionPeriodicity", hsn_a_tx_periodicity.to_string());
  if (hnsa_slot_cfg_list.size() > 0) {
    j.start_array("hNSASlotConfigList");
    for (const auto& e1 : hnsa_slot_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rbset_cfg_present) {
    j.write_fieldname("rBsetConfiguration");
    rbset_cfg.to_json(j);
  }
  if (freq_domain_h_sn_acfg_list.size() > 0) {
    j.start_array("freqDomainHSNAconfiguration-List");
    for (const auto& e1 : freq_domain_h_sn_acfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (na_cell_res_cfg_list.size() > 0) {
    j.start_array("nACellResourceConfigurationList");
    for (const auto& e1 : na_cell_res_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-MT-Cell-List-Item ::= SEQUENCE
SRSASN_CODE iab_mt_cell_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cell_id.pack(bref));
  HANDLE_CODE(du_rx_mt_rx.pack(bref));
  HANDLE_CODE(du_tx_mt_tx.pack(bref));
  HANDLE_CODE(du_rx_mt_tx.pack(bref));
  HANDLE_CODE(du_tx_mt_rx.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_mt_cell_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cell_id.unpack(bref));
  HANDLE_CODE(du_rx_mt_rx.unpack(bref));
  HANDLE_CODE(du_tx_mt_tx.unpack(bref));
  HANDLE_CODE(du_rx_mt_tx.unpack(bref));
  HANDLE_CODE(du_tx_mt_rx.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_mt_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRCellIdentity", nr_cell_id.to_string());
  j.write_str("dU-RX-MT-RX", du_rx_mt_rx.to_string());
  j.write_str("dU-TX-MT-TX", du_tx_mt_tx.to_string());
  j.write_str("dU-RX-MT-TX", du_rx_mt_tx.to_string());
  j.write_str("dU-TX-MT-RX", du_tx_mt_rx.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-STC-Info-Item ::= SEQUENCE
SRSASN_CODE iab_stc_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_freq_info, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(ssb_subcarrier_spacing.pack(bref));
  HANDLE_CODE(ssb_tx_periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, ssb_tx_timing_offset, (uint8_t)0u, (uint8_t)127u, true, true));
  HANDLE_CODE(ssb_tx_bitmap.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_stc_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_freq_info, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(ssb_subcarrier_spacing.unpack(bref));
  HANDLE_CODE(ssb_tx_periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(ssb_tx_timing_offset, bref, (uint8_t)0u, (uint8_t)127u, true, true));
  HANDLE_CODE(ssb_tx_bitmap.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_stc_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSB-freqInfo", ssb_freq_info);
  j.write_str("sSB-subcarrierSpacing", ssb_subcarrier_spacing.to_string());
  j.write_str("sSB-transmissionPeriodicity", ssb_tx_periodicity.to_string());
  j.write_int("sSB-transmissionTimingOffset", ssb_tx_timing_offset);
  j.write_fieldname("sSB-transmissionBitmap");
  ssb_tx_bitmap.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-DU-Cell-Resource-Configuration-FDD-Info ::= SEQUENCE
SRSASN_CODE iab_du_cell_res_cfg_fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_freq_info_present, 1));
  HANDLE_CODE(bref.pack(dl_freq_info_present, 1));
  HANDLE_CODE(bref.pack(ul_tx_bw_present, 1));
  HANDLE_CODE(bref.pack(dl_tx_bw_present, 1));
  HANDLE_CODE(bref.pack(ul_carrier_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(dl_carrier_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_ul.pack(bref));
  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_dl.pack(bref));
  if (ul_freq_info_present) {
    HANDLE_CODE(ul_freq_info.pack(bref));
  }
  if (dl_freq_info_present) {
    HANDLE_CODE(dl_freq_info.pack(bref));
  }
  if (ul_tx_bw_present) {
    HANDLE_CODE(ul_tx_bw.pack(bref));
  }
  if (dl_tx_bw_present) {
    HANDLE_CODE(dl_tx_bw.pack(bref));
  }
  if (ul_carrier_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ul_carrier_list, 1, 5, true));
  }
  if (dl_carrier_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, dl_carrier_list, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(dl_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_tx_bw_present, 1));
  HANDLE_CODE(bref.unpack(dl_tx_bw_present, 1));
  bool ul_carrier_list_present;
  HANDLE_CODE(bref.unpack(ul_carrier_list_present, 1));
  bool dl_carrier_list_present;
  HANDLE_CODE(bref.unpack(dl_carrier_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_ul.unpack(bref));
  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_dl.unpack(bref));
  if (ul_freq_info_present) {
    HANDLE_CODE(ul_freq_info.unpack(bref));
  }
  if (dl_freq_info_present) {
    HANDLE_CODE(dl_freq_info.unpack(bref));
  }
  if (ul_tx_bw_present) {
    HANDLE_CODE(ul_tx_bw.unpack(bref));
  }
  if (dl_tx_bw_present) {
    HANDLE_CODE(dl_tx_bw.unpack(bref));
  }
  if (ul_carrier_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ul_carrier_list, bref, 1, 5, true));
  }
  if (dl_carrier_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(dl_carrier_list, bref, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_du_cell_res_cfg_fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gNB-DU-Cell-Resource-Configuration-FDD-UL");
  gnb_du_cell_res_cfg_fdd_ul.to_json(j);
  j.write_fieldname("gNB-DU-Cell-Resource-Configuration-FDD-DL");
  gnb_du_cell_res_cfg_fdd_dl.to_json(j);
  if (ul_freq_info_present) {
    j.write_fieldname("uLFrequencyInfo");
    ul_freq_info.to_json(j);
  }
  if (dl_freq_info_present) {
    j.write_fieldname("dLFrequencyInfo");
    dl_freq_info.to_json(j);
  }
  if (ul_tx_bw_present) {
    j.write_fieldname("uLTransmissionBandwidth");
    ul_tx_bw.to_json(j);
  }
  if (dl_tx_bw_present) {
    j.write_fieldname("dlTransmissionBandwidth");
    dl_tx_bw.to_json(j);
  }
  if (ul_carrier_list.size() > 0) {
    j.start_array("uLCarrierList");
    for (const auto& e1 : ul_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dl_carrier_list.size() > 0) {
    j.start_array("dlCarrierList");
    for (const auto& e1 : dl_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-DU-Cell-Resource-Configuration-TDD-Info ::= SEQUENCE
SRSASN_CODE iab_du_cell_res_cfg_tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(freq_info_present, 1));
  HANDLE_CODE(bref.pack(tx_bw_present, 1));
  HANDLE_CODE(bref.pack(carrier_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_res_cfg_tdd.pack(bref));
  if (freq_info_present) {
    HANDLE_CODE(freq_info.pack(bref));
  }
  if (tx_bw_present) {
    HANDLE_CODE(tx_bw.pack(bref));
  }
  if (carrier_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, carrier_list, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(freq_info_present, 1));
  HANDLE_CODE(bref.unpack(tx_bw_present, 1));
  bool carrier_list_present;
  HANDLE_CODE(bref.unpack(carrier_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_res_cfg_tdd.unpack(bref));
  if (freq_info_present) {
    HANDLE_CODE(freq_info.unpack(bref));
  }
  if (tx_bw_present) {
    HANDLE_CODE(tx_bw.unpack(bref));
  }
  if (carrier_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(carrier_list, bref, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_du_cell_res_cfg_tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gNB-DU-Cell-Resource-Configuration-TDD");
  gnb_du_cell_res_cfg_tdd.to_json(j);
  if (freq_info_present) {
    j.write_fieldname("frequencyInfo");
    freq_info.to_json(j);
  }
  if (tx_bw_present) {
    j.write_fieldname("transmissionBandwidth");
    tx_bw.to_json(j);
  }
  if (carrier_list.size() > 0) {
    j.start_array("carrierList");
    for (const auto& e1 : carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-DU-Cell-Resource-Configuration-Mode-Info ::= CHOICE
void iab_du_cell_res_cfg_mode_info_c::destroy_()
{
  switch (type_) {
    case types::tdd:
      c.destroy<iab_du_cell_res_cfg_tdd_info_s>();
      break;
    case types::fdd:
      c.destroy<iab_du_cell_res_cfg_fdd_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void iab_du_cell_res_cfg_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tdd:
      c.init<iab_du_cell_res_cfg_tdd_info_s>();
      break;
    case types::fdd:
      c.init<iab_du_cell_res_cfg_fdd_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }
}
iab_du_cell_res_cfg_mode_info_c::iab_du_cell_res_cfg_mode_info_c(const iab_du_cell_res_cfg_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tdd:
      c.init(other.c.get<iab_du_cell_res_cfg_tdd_info_s>());
      break;
    case types::fdd:
      c.init(other.c.get<iab_du_cell_res_cfg_fdd_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }
}
iab_du_cell_res_cfg_mode_info_c&
iab_du_cell_res_cfg_mode_info_c::operator=(const iab_du_cell_res_cfg_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tdd:
      c.set(other.c.get<iab_du_cell_res_cfg_tdd_info_s>());
      break;
    case types::fdd:
      c.set(other.c.get<iab_du_cell_res_cfg_fdd_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }

  return *this;
}
iab_du_cell_res_cfg_tdd_info_s& iab_du_cell_res_cfg_mode_info_c::set_tdd()
{
  set(types::tdd);
  return c.get<iab_du_cell_res_cfg_tdd_info_s>();
}
iab_du_cell_res_cfg_fdd_info_s& iab_du_cell_res_cfg_mode_info_c::set_fdd()
{
  set(types::fdd);
  return c.get<iab_du_cell_res_cfg_fdd_info_s>();
}
protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>&
iab_du_cell_res_cfg_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
}
void iab_du_cell_res_cfg_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tdd:
      j.write_fieldname("tDD");
      c.get<iab_du_cell_res_cfg_tdd_info_s>().to_json(j);
      break;
    case types::fdd:
      j.write_fieldname("fDD");
      c.get<iab_du_cell_res_cfg_fdd_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_du_cell_res_cfg_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::tdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_tdd_info_s>().pack(bref));
      break;
    case types::fdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_fdd_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::tdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_tdd_info_s>().unpack(bref));
      break;
    case types::fdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_fdd_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* iab_du_cell_res_cfg_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"tDD", "fDD", "choice-extension"};
  return convert_enum_idx(names, 3, value, "iab_du_cell_res_cfg_mode_info_c::types");
}

// IAB-STC-Info ::= SEQUENCE
SRSASN_CODE iab_stc_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, iab_stc_info_list, 1, 45, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_stc_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(iab_stc_info_list, bref, 1, 45, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_stc_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("iAB-STC-Info-List");
  for (const auto& e1 : iab_stc_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MultiplexingInfo ::= SEQUENCE
SRSASN_CODE mux_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, iab_mt_cell_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mux_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(iab_mt_cell_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mux_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("iAB-MT-Cell-List");
  for (const auto& e1 : iab_mt_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABCellInformation ::= SEQUENCE
SRSASN_CODE iab_cell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(iab_du_cell_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.pack(iab_stc_info_present, 1));
  HANDLE_CODE(bref.pack(rach_cfg_common.size() > 0, 1));
  HANDLE_CODE(bref.pack(rach_cfg_common_iab.size() > 0, 1));
  HANDLE_CODE(bref.pack(csi_rs_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(sr_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(pdcch_cfg_sib1.size() > 0, 1));
  HANDLE_CODE(bref.pack(scs_common.size() > 0, 1));
  HANDLE_CODE(bref.pack(mux_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (iab_du_cell_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_du_cell_res_cfg_mode_info.pack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.pack(bref));
  }
  if (rach_cfg_common.size() > 0) {
    HANDLE_CODE(rach_cfg_common.pack(bref));
  }
  if (rach_cfg_common_iab.size() > 0) {
    HANDLE_CODE(rach_cfg_common_iab.pack(bref));
  }
  if (csi_rs_cfg.size() > 0) {
    HANDLE_CODE(csi_rs_cfg.pack(bref));
  }
  if (sr_cfg.size() > 0) {
    HANDLE_CODE(sr_cfg.pack(bref));
  }
  if (pdcch_cfg_sib1.size() > 0) {
    HANDLE_CODE(pdcch_cfg_sib1.pack(bref));
  }
  if (scs_common.size() > 0) {
    HANDLE_CODE(scs_common.pack(bref));
  }
  if (mux_info_present) {
    HANDLE_CODE(mux_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_cell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(iab_du_cell_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.unpack(iab_stc_info_present, 1));
  bool rach_cfg_common_present;
  HANDLE_CODE(bref.unpack(rach_cfg_common_present, 1));
  bool rach_cfg_common_iab_present;
  HANDLE_CODE(bref.unpack(rach_cfg_common_iab_present, 1));
  bool csi_rs_cfg_present;
  HANDLE_CODE(bref.unpack(csi_rs_cfg_present, 1));
  bool sr_cfg_present;
  HANDLE_CODE(bref.unpack(sr_cfg_present, 1));
  bool pdcch_cfg_sib1_present;
  HANDLE_CODE(bref.unpack(pdcch_cfg_sib1_present, 1));
  bool scs_common_present;
  HANDLE_CODE(bref.unpack(scs_common_present, 1));
  HANDLE_CODE(bref.unpack(mux_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (iab_du_cell_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_du_cell_res_cfg_mode_info.unpack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.unpack(bref));
  }
  if (rach_cfg_common_present) {
    HANDLE_CODE(rach_cfg_common.unpack(bref));
  }
  if (rach_cfg_common_iab_present) {
    HANDLE_CODE(rach_cfg_common_iab.unpack(bref));
  }
  if (csi_rs_cfg_present) {
    HANDLE_CODE(csi_rs_cfg.unpack(bref));
  }
  if (sr_cfg_present) {
    HANDLE_CODE(sr_cfg.unpack(bref));
  }
  if (pdcch_cfg_sib1_present) {
    HANDLE_CODE(pdcch_cfg_sib1.unpack(bref));
  }
  if (scs_common_present) {
    HANDLE_CODE(scs_common.unpack(bref));
  }
  if (mux_info_present) {
    HANDLE_CODE(mux_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_cell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (iab_du_cell_res_cfg_mode_info_present) {
    j.write_fieldname("iAB-DU-Cell-Resource-Configuration-Mode-Info");
    iab_du_cell_res_cfg_mode_info.to_json(j);
  }
  if (iab_stc_info_present) {
    j.write_fieldname("iAB-STC-Info");
    iab_stc_info.to_json(j);
  }
  if (rach_cfg_common.size() > 0) {
    j.write_str("rACH-Config-Common", rach_cfg_common.to_string());
  }
  if (rach_cfg_common_iab.size() > 0) {
    j.write_str("rACH-Config-Common-IAB", rach_cfg_common_iab.to_string());
  }
  if (csi_rs_cfg.size() > 0) {
    j.write_str("cSI-RS-Configuration", csi_rs_cfg.to_string());
  }
  if (sr_cfg.size() > 0) {
    j.write_str("sR-Configuration", sr_cfg.to_string());
  }
  if (pdcch_cfg_sib1.size() > 0) {
    j.write_str("pDCCH-ConfigSIB1", pdcch_cfg_sib1.to_string());
  }
  if (scs_common.size() > 0) {
    j.write_str("sCS-Common", scs_common.to_string());
  }
  if (mux_info_present) {
    j.write_fieldname("multiplexingInfo");
    mux_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// S-NSSAI ::= SEQUENCE
SRSASN_CODE s_nssai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sd_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sst.pack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s_nssai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(sd_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sst.unpack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void s_nssai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sst", sst.to_string());
  if (sd_present) {
    j.write_str("sd", sd.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-Support-SNPN ::= SEQUENCE
SRSASN_CODE npn_support_sn_pn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(nid.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_support_sn_pn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(nid.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_support_sn_pn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nid", nid.to_string());
  if (ie_ext_present) {
    j.write_fieldname("ie-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// TAINSAGSupportItem ::= SEQUENCE
SRSASN_CODE tai_nsag_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nsag_id, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, nsag_slice_support_list, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_nsag_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nsag_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(nsag_slice_support_list, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_nsag_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nSAG-ID", nsag_id);
  j.start_array("nSAGSliceSupportList");
  for (const auto& e1 : nsag_slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-Support ::= CHOICE
void npn_support_c::destroy_()
{
  switch (type_) {
    case types::sn_pn:
      c.destroy<npn_support_sn_pn_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_support_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sn_pn:
      c.init<npn_support_sn_pn_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
}
npn_support_c::npn_support_c(const npn_support_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sn_pn:
      c.init(other.c.get<npn_support_sn_pn_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
}
npn_support_c& npn_support_c::operator=(const npn_support_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sn_pn:
      c.set(other.c.get<npn_support_sn_pn_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }

  return *this;
}
npn_support_sn_pn_s& npn_support_c::set_sn_pn()
{
  set(types::sn_pn);
  return c.get<npn_support_sn_pn_s>();
}
protocol_ie_single_container_s<npn_support_ext_ies_o>& npn_support_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
}
void npn_support_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sn_pn:
      j.write_fieldname("sNPN");
      c.get<npn_support_sn_pn_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_support_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sn_pn:
      HANDLE_CODE(c.get<npn_support_sn_pn_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_support_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sn_pn:
      HANDLE_CODE(c.get<npn_support_sn_pn_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_support_c::types_opts::to_string() const
{
  static const char* names[] = {"sNPN", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "npn_support_c::types");
}

// BroadcastPLMNinTAISupport-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t broadcast_plmn_in_tai_support_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {223, 231, 364};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_plmn_in_tai_support_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {223, 231, 364};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_plmn_in_tai_support_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 223:
      return crit_e::reject;
    case 231:
      return crit_e::reject;
    case 364:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c
broadcast_plmn_in_tai_support_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 223:
      ret.set(ext_c::types::npn_support);
      break;
    case 231:
      ret.set(ext_c::types::extended_tai_slice_support_list);
      break;
    case 364:
      ret.set(ext_c::types::tai_nsag_support_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_plmn_in_tai_support_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 223:
      return presence_e::optional;
    case 231:
      return presence_e::optional;
    case 364:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::npn_support:
      c = npn_support_c{};
      break;
    case types::extended_tai_slice_support_list:
      c = extended_slice_support_list_l{};
      break;
    case types::tai_nsag_support_list:
      c = tai_nsag_support_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c");
  }
}
npn_support_c& broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::npn_support()
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
extended_slice_support_list_l& broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::extended_tai_slice_support_list()
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
tai_nsag_support_list_l& broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::tai_nsag_support_list()
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<tai_nsag_support_list_l>();
}
const npn_support_c& broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::npn_support() const
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
const extended_slice_support_list_l&
broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::extended_tai_slice_support_list() const
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
const tai_nsag_support_list_l& broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::tai_nsag_support_list() const
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<tai_nsag_support_list_l>();
}
void broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_support:
      j.write_fieldname("NPN-Support");
      c.get<npn_support_c>().to_json(j);
      break;
    case types::extended_tai_slice_support_list:
      j.start_array("ExtendedSliceSupportList");
      for (const auto& e1 : c.get<extended_slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_nsag_support_list:
      j.start_array("TAINSAGSupportList");
      for (const auto& e1 : c.get<tai_nsag_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().pack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_slice_support_list_l>(), 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_nsag_support_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().unpack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_slice_support_list_l>(), bref, 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_nsag_support_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPN-Support", "ExtendedSliceSupportList", "TAINSAGSupportList"};
  return convert_enum_idx(names, 3, value, "broadcast_plmn_in_tai_support_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<broadcast_plmn_in_tai_support_item_ext_ies_o>;

SRSASN_CODE broadcast_plmn_in_tai_support_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_support_present ? 1 : 0;
  nof_ies += extended_tai_slice_support_list_present ? 1 : 0;
  nof_ies += tai_nsag_support_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)223, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_support.pack(bref));
  }
  if (extended_tai_slice_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)231, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_tai_slice_support_list, 1, 65535, true));
  }
  if (tai_nsag_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)364, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_nsag_support_list, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_in_tai_support_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 223: {
        npn_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_support.unpack(bref));
        break;
      }
      case 231: {
        extended_tai_slice_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_tai_slice_support_list, bref, 1, 65535, true));
        break;
      }
      case 364: {
        tai_nsag_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_nsag_support_list, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void broadcast_plmn_in_tai_support_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_support_present) {
    j.write_int("id", 223);
    j.write_str("criticality", "reject");
    npn_support.to_json(j);
  }
  if (extended_tai_slice_support_list_present) {
    j.write_int("id", 231);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : extended_tai_slice_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (tai_nsag_support_list_present) {
    j.write_int("id", 364);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : tai_nsag_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// BroadcastPLMNinTAISupport-Item ::= SEQUENCE
SRSASN_CODE broadcast_plmn_in_tai_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, tai_slice_support_list, 1, 1024, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_in_tai_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(tai_slice_support_list, bref, 1, 1024, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_plmn_in_tai_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.start_array("tAISliceSupport-List");
  for (const auto& e1 : tai_slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// CHOExecutionCondition-Item ::= SEQUENCE
SRSASN_CODE cho_execution_condition_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(meas_obj_container.pack(bref));
  HANDLE_CODE(report_cfg_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cho_execution_condition_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(meas_obj_container.unpack(bref));
  HANDLE_CODE(report_cfg_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cho_execution_condition_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("measObjectContainer", meas_obj_container.to_string());
  j.write_str("reportConfigContainer", report_cfg_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CHOCandidateCell-Item ::= SEQUENCE
SRSASN_CODE cho_candidate_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cho_candidate_cell_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cho_execution_condition_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cho_candidate_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cho_candidate_cell_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cho_execution_condition_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cho_candidate_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("choCandidateCellID");
  cho_candidate_cell_id.to_json(j);
  j.start_array("choExecutionCondition-List");
  for (const auto& e1 : cho_execution_condition_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CHOConfiguration ::= SEQUENCE
SRSASN_CODE cho_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cho_candidate_cell_list, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cho_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cho_candidate_cell_list, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cho_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("choCandidateCell-List");
  for (const auto& e1 : cho_candidate_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Target-CGI ::= CHOICE
void target_cgi_c::destroy_()
{
  switch (type_) {
    case types::nr:
      c.destroy<nr_cgi_s>();
      break;
    case types::e_utra:
      c.destroy<e_utra_cgi_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<target_cgi_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void target_cgi_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      c.init<nr_cgi_s>();
      break;
    case types::e_utra:
      c.init<e_utra_cgi_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<target_cgi_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_cgi_c");
  }
}
target_cgi_c::target_cgi_c(const target_cgi_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<nr_cgi_s>());
      break;
    case types::e_utra:
      c.init(other.c.get<e_utra_cgi_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<target_cgi_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_cgi_c");
  }
}
target_cgi_c& target_cgi_c::operator=(const target_cgi_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<nr_cgi_s>());
      break;
    case types::e_utra:
      c.set(other.c.get<e_utra_cgi_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<target_cgi_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_cgi_c");
  }

  return *this;
}
nr_cgi_s& target_cgi_c::set_nr()
{
  set(types::nr);
  return c.get<nr_cgi_s>();
}
e_utra_cgi_s& target_cgi_c::set_e_utra()
{
  set(types::e_utra);
  return c.get<e_utra_cgi_s>();
}
protocol_ie_single_container_s<target_cgi_ext_ies_o>& target_cgi_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<target_cgi_ext_ies_o>>();
}
void target_cgi_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_fieldname("nr");
      c.get<nr_cgi_s>().to_json(j);
      break;
    case types::e_utra:
      j.write_fieldname("e-utra");
      c.get<e_utra_cgi_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<target_cgi_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "target_cgi_c");
  }
  j.end_obj();
}
SRSASN_CODE target_cgi_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<nr_cgi_s>().pack(bref));
      break;
    case types::e_utra:
      HANDLE_CODE(c.get<e_utra_cgi_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<target_cgi_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_cgi_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_cgi_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<nr_cgi_s>().unpack(bref));
      break;
    case types::e_utra:
      HANDLE_CODE(c.get<e_utra_cgi_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<target_cgi_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_cgi_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_cgi_c::types_opts::to_string() const
{
  static const char* names[] = {"nr", "e-utra", "choice-extension"};
  return convert_enum_idx(names, 3, value, "target_cgi_c::types");
}

// CHOinformation-Ack ::= SEQUENCE
SRSASN_CODE ch_oinfo_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_ch_ooperations_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(requested_target_cell_global_id.pack(bref));
  if (max_ch_ooperations_present) {
    HANDLE_CODE(pack_integer(bref, max_ch_ooperations, (uint8_t)1u, (uint8_t)8u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ch_oinfo_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_ch_ooperations_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(requested_target_cell_global_id.unpack(bref));
  if (max_ch_ooperations_present) {
    HANDLE_CODE(unpack_integer(max_ch_ooperations, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ch_oinfo_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("requestedTargetCellGlobalID");
  requested_target_cell_global_id.to_json(j);
  if (max_ch_ooperations_present) {
    j.write_int("maxCHOoperations", max_ch_ooperations);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CHOinformation-AddReq ::= SEQUENCE
SRSASN_CODE ch_oinfo_add_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cho_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(source_m_ngran_node_id.pack(bref));
  HANDLE_CODE(pack_integer(bref, source_m_ngran_node_ue_xn_ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (cho_estimated_arrival_probability_present) {
    HANDLE_CODE(pack_integer(bref, cho_estimated_arrival_probability, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ch_oinfo_add_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cho_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(source_m_ngran_node_id.unpack(bref));
  HANDLE_CODE(unpack_integer(source_m_ngran_node_ue_xn_ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (cho_estimated_arrival_probability_present) {
    HANDLE_CODE(unpack_integer(cho_estimated_arrival_probability, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ch_oinfo_add_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("source-M-NGRAN-node-ID");
  source_m_ngran_node_id.to_json(j);
  j.write_int("source-M-NGRAN-node-UE-XnAP-ID", source_m_ngran_node_ue_xn_ap_id);
  if (cho_estimated_arrival_probability_present) {
    j.write_int("cHO-EstimatedArrivalProbability", cho_estimated_arrival_probability);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CHOinformation-ModReq ::= SEQUENCE
SRSASN_CODE ch_oinfo_mod_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cho_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(conditional_recfg.pack(bref));
  if (cho_estimated_arrival_probability_present) {
    HANDLE_CODE(pack_integer(bref, cho_estimated_arrival_probability, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ch_oinfo_mod_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cho_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(conditional_recfg.unpack(bref));
  if (cho_estimated_arrival_probability_present) {
    HANDLE_CODE(unpack_integer(cho_estimated_arrival_probability, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ch_oinfo_mod_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("conditionalReconfig", "intra-mn-cho");
  if (cho_estimated_arrival_probability_present) {
    j.write_int("cHO-EstimatedArrivalProbability", cho_estimated_arrival_probability);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ch_oinfo_mod_req_s::conditional_recfg_opts::to_string() const
{
  static const char* names[] = {"intra-mn-cho"};
  return convert_enum_idx(names, 1, value, "ch_oinfo_mod_req_s::conditional_recfg_e_");
}

// CHOtrigger ::= ENUMERATED
const char* ch_otrigger_opts::to_string() const
{
  static const char* names[] = {"cho-initiation", "cho-replace"};
  return convert_enum_idx(names, 2, value, "ch_otrigger_e");
}

// CHOinformation-Req ::= SEQUENCE
SRSASN_CODE ch_oinfo_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(target_ng_ra_nnode_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.pack(cho_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cho_trigger.pack(bref));
  if (target_ng_ra_nnode_ue_xn_ap_id_present) {
    HANDLE_CODE(pack_integer(bref, target_ng_ra_nnode_ue_xn_ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (cho_estimated_arrival_probability_present) {
    HANDLE_CODE(pack_integer(bref, cho_estimated_arrival_probability, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ch_oinfo_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(target_ng_ra_nnode_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.unpack(cho_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cho_trigger.unpack(bref));
  if (target_ng_ra_nnode_ue_xn_ap_id_present) {
    HANDLE_CODE(unpack_integer(target_ng_ra_nnode_ue_xn_ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (cho_estimated_arrival_probability_present) {
    HANDLE_CODE(unpack_integer(cho_estimated_arrival_probability, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ch_oinfo_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cho-trigger", cho_trigger.to_string());
  if (target_ng_ra_nnode_ue_xn_ap_id_present) {
    j.write_int("targetNG-RANnodeUEXnAPID", target_ng_ra_nnode_ue_xn_ap_id);
  }
  if (cho_estimated_arrival_probability_present) {
    j.write_int("cHO-EstimatedArrivalProbability", cho_estimated_arrival_probability);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNTypeRestrictionsForEquivalentItem ::= SEQUENCE
SRSASN_CODE cn_type_restricts_for_equivalent_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(cn_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cn_type_restricts_for_equivalent_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(cn_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cn_type_restricts_for_equivalent_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-Identity", plmn_id.to_string());
  j.write_str("cn-Type", cn_type.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* cn_type_restricts_for_equivalent_item_s::cn_type_opts::to_string() const
{
  static const char* names[] = {"epc-forbidden", "fiveGC-forbidden"};
  return convert_enum_idx(names, 2, value, "cn_type_restricts_for_equivalent_item_s::cn_type_e_");
}
uint8_t cn_type_restricts_for_equivalent_item_s::cn_type_opts::to_number() const
{
  if (value == five_gc_forbidden) {
    return 5;
  }
  invalid_enum_number(value, "cn_type_restricts_for_equivalent_item_s::cn_type_e_");
  return 0;
}

// COUNT-PDCP-SN12 ::= SEQUENCE
SRSASN_CODE count_pdcp_sn12_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn12, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn_pdcp_sn12, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE count_pdcp_sn12_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn12, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(unpack_integer(hfn_pdcp_sn12, bref, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void count_pdcp_sn12_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pdcp-SN12", pdcp_sn12);
  j.write_int("hfn-PDCP-SN12", hfn_pdcp_sn12);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// COUNT-PDCP-SN18 ::= SEQUENCE
SRSASN_CODE count_pdcp_sn18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn18, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn_pdcp_sn18, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE count_pdcp_sn18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn18, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(unpack_integer(hfn_pdcp_sn18, bref, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void count_pdcp_sn18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pdcp-SN18", pdcp_sn18);
  j.write_int("hfn-PDCP-SN18", hfn_pdcp_sn18);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPACcandidatePSCells-item ::= SEQUENCE
SRSASN_CODE cp_a_ccandidate_p_scells_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pscell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_a_ccandidate_p_scells_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pscell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_a_ccandidate_p_scells_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("pscell-id");
  pscell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPACInformationModRequired ::= SEQUENCE
SRSASN_CODE cp_ac_info_mod_required_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_pscells, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_ac_info_mod_required_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(candidate_pscells, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_ac_info_mod_required_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("candidate-pscells");
  for (const auto& e1 : candidate_pscells) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPAInformationAck ::= SEQUENCE
SRSASN_CODE cp_a_info_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_pscells, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_a_info_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(candidate_pscells, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_a_info_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("candidate-pscells");
  for (const auto& e1 : candidate_pscells) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPAInformationModReq ::= SEQUENCE
SRSASN_CODE cp_a_info_mod_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_no_of_pscells_present, 1));
  HANDLE_CODE(bref.pack(cpac_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (max_no_of_pscells_present) {
    HANDLE_CODE(pack_integer(bref, max_no_of_pscells, (uint8_t)1u, (uint8_t)8u, true, true));
  }
  if (cpac_estimated_arrival_probability_present) {
    HANDLE_CODE(pack_integer(bref, cpac_estimated_arrival_probability, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_a_info_mod_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_no_of_pscells_present, 1));
  HANDLE_CODE(bref.unpack(cpac_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (max_no_of_pscells_present) {
    HANDLE_CODE(unpack_integer(max_no_of_pscells, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  }
  if (cpac_estimated_arrival_probability_present) {
    HANDLE_CODE(unpack_integer(cpac_estimated_arrival_probability, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_a_info_mod_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (max_no_of_pscells_present) {
    j.write_int("max-no-of-pscells", max_no_of_pscells);
  }
  if (cpac_estimated_arrival_probability_present) {
    j.write_int("cpac-EstimatedArrivalProbability", cpac_estimated_arrival_probability);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPAInformationModReqAck ::= SEQUENCE
SRSASN_CODE cp_a_info_mod_req_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_pscells, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_a_info_mod_req_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(candidate_pscells, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_a_info_mod_req_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("candidate-pscells");
  for (const auto& e1 : candidate_pscells) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPAInformationRequest ::= SEQUENCE
SRSASN_CODE cp_a_info_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cpac_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, max_no_of_pscells, (uint8_t)1u, (uint8_t)8u, true, true));
  if (cpac_estimated_arrival_probability_present) {
    HANDLE_CODE(pack_integer(bref, cpac_estimated_arrival_probability, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_a_info_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cpac_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(max_no_of_pscells, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  if (cpac_estimated_arrival_probability_present) {
    HANDLE_CODE(unpack_integer(cpac_estimated_arrival_probability, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_a_info_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("max-no-of-pscells", max_no_of_pscells);
  if (cpac_estimated_arrival_probability_present) {
    j.write_int("cpac-EstimatedArrivalProbability", cpac_estimated_arrival_probability);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPC-target-SN-confirm-list-Item ::= SEQUENCE
SRSASN_CODE cp_c_target_sn_confirm_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_s_ng_ra_nnode_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_pscells, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_c_target_sn_confirm_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_s_ng_ra_nnode_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(candidate_pscells, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_c_target_sn_confirm_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("target-S-NG-RANnodeID");
  target_s_ng_ra_nnode_id.to_json(j);
  j.start_array("candidate-pscells");
  for (const auto& e1 : candidate_pscells) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPCInformationUpdatePSCells-item ::= SEQUENCE
SRSASN_CODE c_pci_nformation_upd_p_scells_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pscell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE c_pci_nformation_upd_p_scells_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pscell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void c_pci_nformation_upd_p_scells_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("pscell-id");
  pscell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPC-target-SN-mod-item ::= SEQUENCE
SRSASN_CODE cp_c_target_sn_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_s_ng_ra_nnode_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_pscells, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_c_target_sn_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_s_ng_ra_nnode_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(candidate_pscells, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_c_target_sn_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("target-S-NG-RANnodeID");
  target_s_ng_ra_nnode_id.to_json(j);
  j.start_array("candidate-pscells");
  for (const auto& e1 : candidate_pscells) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPCindicator ::= ENUMERATED
const char* cp_cind_opts::to_string() const
{
  static const char* names[] = {"cpc-initiation", "cpc-modification", "cpc-cancellation"};
  return convert_enum_idx(names, 3, value, "cp_cind_e");
}

// CPC-target-SN-required-list-Item ::= SEQUENCE
SRSASN_CODE cp_c_target_sn_required_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cpac_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_s_ng_ra_nnode_id.pack(bref));
  HANDLE_CODE(cpc_ind.pack(bref));
  HANDLE_CODE(pack_integer(bref, max_no_of_pscells, (uint8_t)1u, (uint8_t)8u, true, true));
  if (cpac_estimated_arrival_probability_present) {
    HANDLE_CODE(pack_integer(bref, cpac_estimated_arrival_probability, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  HANDLE_CODE(sn_to_mn_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_c_target_sn_required_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cpac_estimated_arrival_probability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_s_ng_ra_nnode_id.unpack(bref));
  HANDLE_CODE(cpc_ind.unpack(bref));
  HANDLE_CODE(unpack_integer(max_no_of_pscells, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  if (cpac_estimated_arrival_probability_present) {
    HANDLE_CODE(unpack_integer(cpac_estimated_arrival_probability, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  }
  HANDLE_CODE(sn_to_mn_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_c_target_sn_required_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("target-S-NG-RANnodeID");
  target_s_ng_ra_nnode_id.to_json(j);
  j.write_str("cpc-indicator", cpc_ind.to_string());
  j.write_int("max-no-of-pscells", max_no_of_pscells);
  if (cpac_estimated_arrival_probability_present) {
    j.write_int("cpac-EstimatedArrivalProbability", cpac_estimated_arrival_probability);
  }
  j.write_str("sN-to-MN-Container", sn_to_mn_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CauseMisc ::= ENUMERATED
const char* cause_misc_opts::to_string() const
{
  static const char* names[] = {"control-processing-overload",
                                "hardware-failure",
                                "o-and-M-intervention",
                                "not-enough-user-plane-processing-resources",
                                "unspecified"};
  return convert_enum_idx(names, 5, value, "cause_misc_e");
}

// CauseProtocol ::= ENUMERATED
const char* cause_protocol_opts::to_string() const
{
  static const char* names[] = {"transfer-syntax-error",
                                "abstract-syntax-error-reject",
                                "abstract-syntax-error-ignore-and-notify",
                                "message-not-compatible-with-receiver-state",
                                "semantic-error",
                                "abstract-syntax-error-falsely-constructed-message",
                                "unspecified"};
  return convert_enum_idx(names, 7, value, "cause_protocol_e");
}

// CauseRadioNetworkLayer ::= ENUMERATED
const char* cause_radio_network_layer_opts::to_string() const
{
  static const char* names[] = {"cell-not-available",
                                "handover-desirable-for-radio-reasons",
                                "handover-target-not-allowed",
                                "invalid-AMF-Set-ID",
                                "no-radio-resources-available-in-target-cell",
                                "partial-handover",
                                "reduce-load-in-serving-cell",
                                "resource-optimisation-handover",
                                "time-critical-handover",
                                "tXnRELOCoverall-expiry",
                                "tXnRELOCprep-expiry",
                                "unknown-GUAMI-ID",
                                "unknown-local-NG-RAN-node-UE-XnAP-ID",
                                "inconsistent-remote-NG-RAN-node-UE-XnAP-ID",
                                "encryption-and-or-integrity-protection-algorithms-not-supported",
                                "not-used-causes-value-1",
                                "multiple-PDU-session-ID-instances",
                                "unknown-PDU-session-ID",
                                "unknown-QoS-Flow-ID",
                                "multiple-QoS-Flow-ID-instances",
                                "switch-off-ongoing",
                                "not-supported-5QI-value",
                                "tXnDCoverall-expiry",
                                "tXnDCprep-expiry",
                                "action-desirable-for-radio-reasons",
                                "reduce-load",
                                "resource-optimisation",
                                "time-critical-action",
                                "target-not-allowed",
                                "no-radio-resources-available",
                                "invalid-QoS-combination",
                                "encryption-algorithms-not-supported",
                                "procedure-cancelled",
                                "rRM-purpose",
                                "improve-user-bit-rate",
                                "user-inactivity",
                                "radio-connection-with-UE-lost",
                                "failure-in-the-radio-interface-procedure",
                                "bearer-option-not-supported",
                                "up-integrity-protection-not-possible",
                                "up-confidentiality-protection-not-possible",
                                "resources-not-available-for-the-slice-s",
                                "ue-max-IP-data-rate-reason",
                                "cP-integrity-protection-failure",
                                "uP-integrity-protection-failure",
                                "slice-not-supported-by-NG-RAN",
                                "mN-Mobility",
                                "sN-Mobility",
                                "count-reaches-max-value",
                                "unknown-old-NG-RAN-node-UE-XnAP-ID",
                                "pDCP-Overload",
                                "drb-id-not-available",
                                "unspecified",
                                "ue-context-id-not-known",
                                "non-relocation-of-context",
                                "cho-cpc-resources-tobechanged",
                                "rSN-not-available-for-the-UP",
                                "npn-access-denied",
                                "report-characteristics-empty",
                                "existing-measurement-ID",
                                "measurement-temporarily-not-available",
                                "measurement-not-supported-for-the-object",
                                "ue-power-saving",
                                "unknown-NG-RAN-node2-Measurement-ID",
                                "insufficient-ue-capabilities",
                                "normal-release",
                                "value-out-of-allowed-range",
                                "scg-activation-deactivation-failure",
                                "scg-deactivation-failure-due-to-data-transmission"};
  return convert_enum_idx(names, 69, value, "cause_radio_network_layer_e");
}
int8_t cause_radio_network_layer_opts::to_number() const
{
  switch (value) {
    case not_used_causes_value_neg1:
      return -1;
    case not_supported_5qi_value:
      return -5;
    case unknown_ng_ran_node2_meas_id:
      return 2;
    default:
      invalid_enum_number(value, "cause_radio_network_layer_e");
  }
  return 0;
}

// CauseTransportLayer ::= ENUMERATED
const char* cause_transport_layer_opts::to_string() const
{
  static const char* names[] = {"transport-resource-unavailable", "unspecified"};
  return convert_enum_idx(names, 2, value, "cause_transport_layer_e");
}

// Cause ::= CHOICE
void cause_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cause_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::radio_network:
      break;
    case types::transport:
      break;
    case types::protocol:
      break;
    case types::misc:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c::cause_c(const cause_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::radio_network:
      c.init(other.c.get<cause_radio_network_layer_e>());
      break;
    case types::transport:
      c.init(other.c.get<cause_transport_layer_e>());
      break;
    case types::protocol:
      c.init(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.init(other.c.get<cause_misc_e>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c& cause_c::operator=(const cause_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::radio_network:
      c.set(other.c.get<cause_radio_network_layer_e>());
      break;
    case types::transport:
      c.set(other.c.get<cause_transport_layer_e>());
      break;
    case types::protocol:
      c.set(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.set(other.c.get<cause_misc_e>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }

  return *this;
}
cause_radio_network_layer_e& cause_c::set_radio_network()
{
  set(types::radio_network);
  return c.get<cause_radio_network_layer_e>();
}
cause_transport_layer_e& cause_c::set_transport()
{
  set(types::transport);
  return c.get<cause_transport_layer_e>();
}
cause_protocol_e& cause_c::set_protocol()
{
  set(types::protocol);
  return c.get<cause_protocol_e>();
}
cause_misc_e& cause_c::set_misc()
{
  set(types::misc);
  return c.get<cause_misc_e>();
}
protocol_ie_single_container_s<cause_ext_ies_o>& cause_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cause_ext_ies_o>>();
}
void cause_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::radio_network:
      j.write_str("radioNetwork", c.get<cause_radio_network_layer_e>().to_string());
      break;
    case types::transport:
      j.write_str("transport", c.get<cause_transport_layer_e>().to_string());
      break;
    case types::protocol:
      j.write_str("protocol", c.get<cause_protocol_e>().to_string());
      break;
    case types::misc:
      j.write_str("misc", c.get<cause_misc_e>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
  j.end_obj();
}
SRSASN_CODE cause_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_layer_e>().pack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_layer_e>().pack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().pack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cause_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_layer_e>().unpack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_layer_e>().unpack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().unpack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cause_c::types_opts::to_string() const
{
  static const char* names[] = {"radioNetwork", "transport", "protocol", "misc", "choice-extension"};
  return convert_enum_idx(names, 5, value, "cause_c::types");
}
uint8_t cause_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {2};
  return map_enum_number(numbers, 1, value, "cause_c::types");
}

// CPCInformationConfirm ::= SEQUENCE
SRSASN_CODE c_pci_nformation_confirm_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cpc_target_sn_confirm_list, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE c_pci_nformation_confirm_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cpc_target_sn_confirm_list, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void c_pci_nformation_confirm_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cpc-target-sn-confirm-list");
  for (const auto& e1 : cpc_target_sn_confirm_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPCInformationRequired ::= SEQUENCE
SRSASN_CODE c_pci_nformation_required_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cpc_target_sn_required_list, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE c_pci_nformation_required_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cpc_target_sn_required_list, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void c_pci_nformation_required_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cpc-target-sn-required-list");
  for (const auto& e1 : cpc_target_sn_required_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPCInformationUpdate ::= SEQUENCE
SRSASN_CODE c_pci_nformation_upd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cpc_target_sn_list, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE c_pci_nformation_upd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cpc_target_sn_list, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void c_pci_nformation_upd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cpc-target-sn-list");
  for (const auto& e1 : cpc_target_sn_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EndpointIPAddressAndPort ::= SEQUENCE
SRSASN_CODE endpoint_ip_address_and_port_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(endpoint_ip_address.pack(bref));
  HANDLE_CODE(port_num.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE endpoint_ip_address_and_port_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(endpoint_ip_address.unpack(bref));
  HANDLE_CODE(port_num.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void endpoint_ip_address_and_port_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("endpointIPAddress", endpoint_ip_address.to_string());
  j.write_str("portNumber", port_num.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPTransportLayerInformation-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-IES
uint32_t cp_transport_layer_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {139};
  return map_enum_number(names, 1, idx, "id");
}
bool cp_transport_layer_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 139 == id;
}
crit_e cp_transport_layer_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 139) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
cp_transport_layer_info_ext_ies_o::value_c cp_transport_layer_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 139) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cp_transport_layer_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 139) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void cp_transport_layer_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("EndpointIPAddressAndPort");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE cp_transport_layer_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_transport_layer_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* cp_transport_layer_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"EndpointIPAddressAndPort"};
  return convert_enum_idx(names, 1, value, "cp_transport_layer_info_ext_ies_o::value_c::types");
}

template struct asn1::protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>;

// CPTransportLayerInformation ::= CHOICE
void cp_transport_layer_info_c::destroy_()
{
  switch (type_) {
    case types::endpoint_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cp_transport_layer_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::endpoint_ip_address:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
}
cp_transport_layer_info_c::cp_transport_layer_info_c(const cp_transport_layer_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::endpoint_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
}
cp_transport_layer_info_c& cp_transport_layer_info_c::operator=(const cp_transport_layer_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::endpoint_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }

  return *this;
}
bounded_bitstring<1, 160, true, true>& cp_transport_layer_info_c::set_endpoint_ip_address()
{
  set(types::endpoint_ip_address);
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>& cp_transport_layer_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
}
void cp_transport_layer_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::endpoint_ip_address:
      j.write_str("endpointIPAddress", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
  j.end_obj();
}
SRSASN_CODE cp_transport_layer_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_transport_layer_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cp_transport_layer_info_c::types_opts::to_string() const
{
  static const char* names[] = {"endpointIPAddress", "choice-extension"};
  return convert_enum_idx(names, 2, value, "cp_transport_layer_info_c::types");
}

// SSBAreaCapacityValue-List-Item ::= SEQUENCE
SRSASN_CODE ssb_area_capacity_value_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_area_capacity_value_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_area_capacity_value_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_int("ssbAreaCapacityValue", ssb_area_capacity_value);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CapacityValueInfo ::= SEQUENCE
SRSASN_CODE capacity_value_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ssb_area_capacity_value_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ssb_area_capacity_value_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ssb_area_capacity_value_list, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE capacity_value_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ssb_area_capacity_value_list_present;
  HANDLE_CODE(bref.unpack(ssb_area_capacity_value_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ssb_area_capacity_value_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ssb_area_capacity_value_list, bref, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void capacity_value_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("capacityValue", capacity_value);
  if (ssb_area_capacity_value_list.size() > 0) {
    j.start_array("ssbAreaCapacityValueList");
    for (const auto& e1 : ssb_area_capacity_value_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// Cell-Type-Choice ::= CHOICE
void cell_type_choice_c::destroy_()
{
  switch (type_) {
    case types::ng_ran_e_utra:
      c.destroy<fixed_bitstring<28, false, true>>();
      break;
    case types::ng_ran_nr:
      c.destroy<fixed_bitstring<36, false, true>>();
      break;
    case types::e_utran:
      c.destroy<fixed_bitstring<28, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cell_type_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ng_ran_e_utra:
      c.init<fixed_bitstring<28, false, true>>();
      break;
    case types::ng_ran_nr:
      c.init<fixed_bitstring<36, false, true>>();
      break;
    case types::e_utran:
      c.init<fixed_bitstring<28, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_type_choice_c");
  }
}
cell_type_choice_c::cell_type_choice_c(const cell_type_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ng_ran_e_utra:
      c.init(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::ng_ran_nr:
      c.init(other.c.get<fixed_bitstring<36, false, true>>());
      break;
    case types::e_utran:
      c.init(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_type_choice_c");
  }
}
cell_type_choice_c& cell_type_choice_c::operator=(const cell_type_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ng_ran_e_utra:
      c.set(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::ng_ran_nr:
      c.set(other.c.get<fixed_bitstring<36, false, true>>());
      break;
    case types::e_utran:
      c.set(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_type_choice_c");
  }

  return *this;
}
fixed_bitstring<28, false, true>& cell_type_choice_c::set_ng_ran_e_utra()
{
  set(types::ng_ran_e_utra);
  return c.get<fixed_bitstring<28, false, true>>();
}
fixed_bitstring<36, false, true>& cell_type_choice_c::set_ng_ran_nr()
{
  set(types::ng_ran_nr);
  return c.get<fixed_bitstring<36, false, true>>();
}
fixed_bitstring<28, false, true>& cell_type_choice_c::set_e_utran()
{
  set(types::e_utran);
  return c.get<fixed_bitstring<28, false, true>>();
}
protocol_ie_single_container_s<cell_type_choice_ext_ies_o>& cell_type_choice_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>();
}
void cell_type_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ng_ran_e_utra:
      j.write_str("ng-ran-e-utra", c.get<fixed_bitstring<28, false, true>>().to_string());
      break;
    case types::ng_ran_nr:
      j.write_str("ng-ran-nr", c.get<fixed_bitstring<36, false, true>>().to_string());
      break;
    case types::e_utran:
      j.write_str("e-utran", c.get<fixed_bitstring<28, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cell_type_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_type_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ng_ran_e_utra:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().pack(bref)));
      break;
    case types::ng_ran_nr:
      HANDLE_CODE((c.get<fixed_bitstring<36, false, true>>().pack(bref)));
      break;
    case types::e_utran:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_type_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_type_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ng_ran_e_utra:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().unpack(bref)));
      break;
    case types::ng_ran_nr:
      HANDLE_CODE((c.get<fixed_bitstring<36, false, true>>().unpack(bref)));
      break;
    case types::e_utran:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_type_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_type_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_type_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"ng-ran-e-utra", "ng-ran-nr", "e-utran", "choice-extension"};
  return convert_enum_idx(names, 4, value, "cell_type_choice_c::types");
}

// TypeOfError ::= ENUMERATED
const char* type_of_error_opts::to_string() const
{
  static const char* names[] = {"not-understood", "missing"};
  return convert_enum_idx(names, 2, value, "type_of_error_e");
}

SRSASN_CODE crit_diagnostics_ie_list_item_s_::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.pack(bref));
  HANDLE_CODE(pack_integer(bref, ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_ie_list_item_s_::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.unpack(bref));
  HANDLE_CODE(unpack_integer(ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_ie_list_item_s_::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iECriticality", ie_crit.to_string());
  j.write_int("iE-ID", ie_id);
  j.write_str("typeOfError", type_of_error.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TriggeringMessage ::= ENUMERATED
const char* trigger_msg_opts::to_string() const
{
  static const char* names[] = {"initiating-message", "successful-outcome", "unsuccessful-outcome"};
  return convert_enum_idx(names, 3, value, "trigger_msg_e");
}

// CriticalityDiagnostics ::= SEQUENCE
SRSASN_CODE crit_diagnostics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(proc_code_present, 1));
  HANDLE_CODE(bref.pack(trigger_msg_present, 1));
  HANDLE_CODE(bref.pack(proc_crit_present, 1));
  HANDLE_CODE(bref.pack(ies_crit_diagnostics.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.pack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.pack(bref));
  }
  if (ies_crit_diagnostics.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ies_crit_diagnostics, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(proc_code_present, 1));
  HANDLE_CODE(bref.unpack(trigger_msg_present, 1));
  HANDLE_CODE(bref.unpack(proc_crit_present, 1));
  bool ies_crit_diagnostics_present;
  HANDLE_CODE(bref.unpack(ies_crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.unpack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.unpack(bref));
  }
  if (ies_crit_diagnostics_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ies_crit_diagnostics, bref, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (proc_code_present) {
    j.write_int("procedureCode", proc_code);
  }
  if (trigger_msg_present) {
    j.write_str("triggeringMessage", trigger_msg.to_string());
  }
  if (proc_crit_present) {
    j.write_str("procedureCriticality", proc_crit.to_string());
  }
  if (ies_crit_diagnostics.size() > 0) {
    j.start_array("iEsCriticalityDiagnostics");
    for (const auto& e1 : ies_crit_diagnostics) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellAssistanceInfo-EUTRA ::= CHOICE
void cell_assist_info_eutra_c::destroy_()
{
  switch (type_) {
    case types::limited_eutra_list:
      c.destroy<limited_eutra_list_l_>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cell_assist_info_eutra_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::limited_eutra_list:
      c.init<limited_eutra_list_l_>();
      break;
    case types::full_list:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_eutra_c");
  }
}
cell_assist_info_eutra_c::cell_assist_info_eutra_c(const cell_assist_info_eutra_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::limited_eutra_list:
      c.init(other.c.get<limited_eutra_list_l_>());
      break;
    case types::full_list:
      c.init(other.c.get<full_list_e_>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_eutra_c");
  }
}
cell_assist_info_eutra_c& cell_assist_info_eutra_c::operator=(const cell_assist_info_eutra_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::limited_eutra_list:
      c.set(other.c.get<limited_eutra_list_l_>());
      break;
    case types::full_list:
      c.set(other.c.get<full_list_e_>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_eutra_c");
  }

  return *this;
}
cell_assist_info_eutra_c::limited_eutra_list_l_& cell_assist_info_eutra_c::set_limited_eutra_list()
{
  set(types::limited_eutra_list);
  return c.get<limited_eutra_list_l_>();
}
cell_assist_info_eutra_c::full_list_e_& cell_assist_info_eutra_c::set_full_list()
{
  set(types::full_list);
  return c.get<full_list_e_>();
}
protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>& cell_assist_info_eutra_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>();
}
void cell_assist_info_eutra_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::limited_eutra_list:
      j.start_array("limitedEUTRA-List");
      for (const auto& e1 : c.get<limited_eutra_list_l_>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::full_list:
      j.write_str("full-List", "all-served-cells-E-UTRA");
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_eutra_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_assist_info_eutra_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::limited_eutra_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<limited_eutra_list_l_>(), 1, 16384, true));
      break;
    case types::full_list:
      HANDLE_CODE(c.get<full_list_e_>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_eutra_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_assist_info_eutra_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::limited_eutra_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<limited_eutra_list_l_>(), bref, 1, 16384, true));
      break;
    case types::full_list:
      HANDLE_CODE(c.get<full_list_e_>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_assist_info_eutra_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_eutra_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_assist_info_eutra_c::full_list_opts::to_string() const
{
  static const char* names[] = {"all-served-cells-E-UTRA"};
  return convert_enum_idx(names, 1, value, "cell_assist_info_eutra_c::full_list_e_");
}

const char* cell_assist_info_eutra_c::types_opts::to_string() const
{
  static const char* names[] = {"limitedEUTRA-List", "full-List", "choice-extension"};
  return convert_enum_idx(names, 3, value, "cell_assist_info_eutra_c::types");
}

// CellAndCapacityAssistanceInfo-EUTRA ::= SEQUENCE
SRSASN_CODE cell_and_capacity_assist_info_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_cell_list_size_present, 1));
  HANDLE_CODE(bref.pack(cell_assist_info_eutra_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (max_cell_list_size_present) {
    HANDLE_CODE(pack_integer(bref, max_cell_list_size, (uint16_t)1u, (uint16_t)16384u, true, true));
  }
  if (cell_assist_info_eutra_present) {
    HANDLE_CODE(cell_assist_info_eutra.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_and_capacity_assist_info_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_cell_list_size_present, 1));
  HANDLE_CODE(bref.unpack(cell_assist_info_eutra_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (max_cell_list_size_present) {
    HANDLE_CODE(unpack_integer(max_cell_list_size, bref, (uint16_t)1u, (uint16_t)16384u, true, true));
  }
  if (cell_assist_info_eutra_present) {
    HANDLE_CODE(cell_assist_info_eutra.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_and_capacity_assist_info_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (max_cell_list_size_present) {
    j.write_int("maximumCellListSize", max_cell_list_size);
  }
  if (cell_assist_info_eutra_present) {
    j.write_fieldname("cellAssistanceInfo-EUTRA");
    cell_assist_info_eutra.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellAssistanceInfo-NR ::= CHOICE
void cell_assist_info_nr_c::destroy_()
{
  switch (type_) {
    case types::limited_nr_list:
      c.destroy<limited_nr_list_l_>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cell_assist_info_nr_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::limited_nr_list:
      c.init<limited_nr_list_l_>();
      break;
    case types::full_list:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_nr_c");
  }
}
cell_assist_info_nr_c::cell_assist_info_nr_c(const cell_assist_info_nr_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::limited_nr_list:
      c.init(other.c.get<limited_nr_list_l_>());
      break;
    case types::full_list:
      c.init(other.c.get<full_list_e_>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_nr_c");
  }
}
cell_assist_info_nr_c& cell_assist_info_nr_c::operator=(const cell_assist_info_nr_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::limited_nr_list:
      c.set(other.c.get<limited_nr_list_l_>());
      break;
    case types::full_list:
      c.set(other.c.get<full_list_e_>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_nr_c");
  }

  return *this;
}
cell_assist_info_nr_c::limited_nr_list_l_& cell_assist_info_nr_c::set_limited_nr_list()
{
  set(types::limited_nr_list);
  return c.get<limited_nr_list_l_>();
}
cell_assist_info_nr_c::full_list_e_& cell_assist_info_nr_c::set_full_list()
{
  set(types::full_list);
  return c.get<full_list_e_>();
}
protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>& cell_assist_info_nr_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>();
}
void cell_assist_info_nr_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::limited_nr_list:
      j.start_array("limitedNR-List");
      for (const auto& e1 : c.get<limited_nr_list_l_>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::full_list:
      j.write_str("full-List", "all-served-cells-NR");
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_nr_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_assist_info_nr_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::limited_nr_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<limited_nr_list_l_>(), 1, 16384, true));
      break;
    case types::full_list:
      HANDLE_CODE(c.get<full_list_e_>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_nr_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_assist_info_nr_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::limited_nr_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<limited_nr_list_l_>(), bref, 1, 16384, true));
      break;
    case types::full_list:
      HANDLE_CODE(c.get<full_list_e_>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_assist_info_nr_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_assist_info_nr_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_assist_info_nr_c::full_list_opts::to_string() const
{
  static const char* names[] = {"all-served-cells-NR"};
  return convert_enum_idx(names, 1, value, "cell_assist_info_nr_c::full_list_e_");
}

const char* cell_assist_info_nr_c::types_opts::to_string() const
{
  static const char* names[] = {"limitedNR-List", "full-List", "choice-extension"};
  return convert_enum_idx(names, 3, value, "cell_assist_info_nr_c::types");
}

// CellAndCapacityAssistanceInfo-NR ::= SEQUENCE
SRSASN_CODE cell_and_capacity_assist_info_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_cell_list_size_present, 1));
  HANDLE_CODE(bref.pack(cell_assist_info_nr_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (max_cell_list_size_present) {
    HANDLE_CODE(pack_integer(bref, max_cell_list_size, (uint16_t)1u, (uint16_t)16384u, true, true));
  }
  if (cell_assist_info_nr_present) {
    HANDLE_CODE(cell_assist_info_nr.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_and_capacity_assist_info_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_cell_list_size_present, 1));
  HANDLE_CODE(bref.unpack(cell_assist_info_nr_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (max_cell_list_size_present) {
    HANDLE_CODE(unpack_integer(max_cell_list_size, bref, (uint16_t)1u, (uint16_t)16384u, true, true));
  }
  if (cell_assist_info_nr_present) {
    HANDLE_CODE(cell_assist_info_nr.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_and_capacity_assist_info_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (max_cell_list_size_present) {
    j.write_int("maximumCellListSize", max_cell_list_size);
  }
  if (cell_assist_info_nr_present) {
    j.write_fieldname("cellAssistanceInfo-NR");
    cell_assist_info_nr.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SNSSAIRadioResourceStatus-Item ::= SEQUENCE
SRSASN_CODE snssai_rr_status_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  HANDLE_CODE(pack_integer(bref, slice_dl_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, slice_ul_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, slice_dl_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, slice_ul_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, slice_dl_total_prb_alloc, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, slice_ul_total_prb_alloc, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE snssai_rr_status_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  HANDLE_CODE(unpack_integer(slice_dl_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(slice_ul_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(slice_dl_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(slice_ul_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(slice_dl_total_prb_alloc, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(slice_ul_total_prb_alloc, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void snssai_rr_status_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  j.write_int("slice-DL-GBR-PRB-Usage", slice_dl_gbr_prb_usage);
  j.write_int("slice-UL-GBR-PRB-Usage", slice_ul_gbr_prb_usage);
  j.write_int("slice-DL-non-GBR-PRB-Usage", slice_dl_non_gbr_prb_usage);
  j.write_int("slice-UL-non-GBR-PRB-Usage", slice_ul_non_gbr_prb_usage);
  j.write_int("slice-DL-Total-PRB-Allocation", slice_dl_total_prb_alloc);
  j.write_int("slice-UL-Total-PRB-Allocation", slice_ul_total_prb_alloc);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBAreaRadioResourceStatus-List-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t ssb_area_rr_status_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {240, 241};
  return map_enum_number(names, 2, idx, "id");
}
bool ssb_area_rr_status_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {240, 241};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ssb_area_rr_status_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 240:
      return crit_e::ignore;
    case 241:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ssb_area_rr_status_list_item_ext_ies_o::ext_c ssb_area_rr_status_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 240:
      ret.set(ext_c::types::dl_sched_pdcch_cce_usage);
      break;
    case 241:
      ret.set(ext_c::types::ul_sched_pdcch_cce_usage);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ssb_area_rr_status_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 240:
      return presence_e::optional;
    case 241:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ssb_area_rr_status_list_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      c = uint8_t{};
      break;
    case types::ul_sched_pdcch_cce_usage:
      c = uint8_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_area_rr_status_list_item_ext_ies_o::ext_c");
  }
}
uint8_t& ssb_area_rr_status_list_item_ext_ies_o::ext_c::dl_sched_pdcch_cce_usage()
{
  assert_choice_type(types::dl_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
uint8_t& ssb_area_rr_status_list_item_ext_ies_o::ext_c::ul_sched_pdcch_cce_usage()
{
  assert_choice_type(types::ul_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
const uint8_t& ssb_area_rr_status_list_item_ext_ies_o::ext_c::dl_sched_pdcch_cce_usage() const
{
  assert_choice_type(types::dl_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
const uint8_t& ssb_area_rr_status_list_item_ext_ies_o::ext_c::ul_sched_pdcch_cce_usage() const
{
  assert_choice_type(types::ul_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
void ssb_area_rr_status_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      j.write_int("INTEGER (0..100)", c.get<uint8_t>());
      break;
    case types::ul_sched_pdcch_cce_usage:
      j.write_int("INTEGER (0..100)", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ssb_area_rr_status_list_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ssb_area_rr_status_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    case types::ul_sched_pdcch_cce_usage:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_area_rr_status_list_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_area_rr_status_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    case types::ul_sched_pdcch_cce_usage:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_area_rr_status_list_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ssb_area_rr_status_list_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..100)", "INTEGER (0..100)"};
  return convert_enum_idx(names, 2, value, "ssb_area_rr_status_list_item_ext_ies_o::ext_c::types");
}

// SliceRadioResourceStatus-Item ::= SEQUENCE
SRSASN_CODE slice_rr_status_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, snssai_rr_status_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_rr_status_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(snssai_rr_status_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_rr_status_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-Identity", plmn_id.to_string());
  j.start_array("sNSSAIRadioResourceStatus-List");
  for (const auto& e1 : snssai_rr_status_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MIMOPRBusageInformation ::= SEQUENCE
SRSASN_CODE mimo_prb_usage_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mimo_prb_usage_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mimo_prb_usage_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dl-GBR-PRB-usage-for-MIMO", dl_gbr_prb_usage_for_mimo);
  j.write_int("ul-GBR-PRB-usage-for-MIMO", ul_gbr_prb_usage_for_mimo);
  j.write_int("dl-non-GBR-PRB-usage-for-MIMO", dl_non_gbr_prb_usage_for_mimo);
  j.write_int("ul-non-GBR-PRB-usage-for-MIMO", ul_non_gbr_prb_usage_for_mimo);
  j.write_int("dl-Total-PRB-usage-for-MIMO", dl_total_prb_usage_for_mimo);
  j.write_int("ul-Total-PRB-usage-for-MIMO", ul_total_prb_usage_for_mimo);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SNSSAIAvailableCapacity-Item ::= SEQUENCE
SRSASN_CODE snssai_available_capacity_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  HANDLE_CODE(pack_integer(bref, slice_available_capacity_value_dl, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, slice_available_capacity_value_ul, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE snssai_available_capacity_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  HANDLE_CODE(unpack_integer(slice_available_capacity_value_dl, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(slice_available_capacity_value_ul, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void snssai_available_capacity_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  j.write_int("sliceAvailableCapacityValueDownlink", slice_available_capacity_value_dl);
  j.write_int("sliceAvailableCapacityValueUplink", slice_available_capacity_value_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<ssb_area_rr_status_list_item_ext_ies_o>;

SRSASN_CODE ssb_area_rr_status_list_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += dl_sched_pdcch_cce_usage_present ? 1 : 0;
  nof_ies += ul_sched_pdcch_cce_usage_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (dl_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)240, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, dl_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)241, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ul_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_area_rr_status_list_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 240: {
        dl_sched_pdcch_cce_usage_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(dl_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
        break;
      }
      case 241: {
        ul_sched_pdcch_cce_usage_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ul_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ssb_area_rr_status_list_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_sched_pdcch_cce_usage_present) {
    j.write_int("id", 240);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", dl_sched_pdcch_cce_usage);
  }
  if (ul_sched_pdcch_cce_usage_present) {
    j.write_int("id", 241);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", ul_sched_pdcch_cce_usage);
  }
  j.end_obj();
}

// SSBAreaRadioResourceStatus-List-Item ::= SEQUENCE
SRSASN_CODE ssb_area_rr_status_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_dl_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_ul_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_d_l_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_u_l_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_d_l_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_u_l_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_area_rr_status_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_dl_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_ul_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_d_l_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_u_l_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_d_l_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_u_l_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_area_rr_status_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_int("ssb-Area-DL-GBR-PRB-usage", ssb_area_dl_gbr_prb_usage);
  j.write_int("ssb-Area-UL-GBR-PRB-usage", ssb_area_ul_gbr_prb_usage);
  j.write_int("ssb-Area-dL-non-GBR-PRB-usage", ssb_area_d_l_non_gbr_prb_usage);
  j.write_int("ssb-Area-uL-non-GBR-PRB-usage", ssb_area_u_l_non_gbr_prb_usage);
  j.write_int("ssb-Area-dL-Total-PRB-usage", ssb_area_d_l_total_prb_usage);
  j.write_int("ssb-Area-uL-Total-PRB-usage", ssb_area_u_l_total_prb_usage);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompositeAvailableCapacity ::= SEQUENCE
SRSASN_CODE composite_available_capacity_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(pack_integer(bref, cell_capacity_class_value, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(capacity_value_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(unpack_integer(cell_capacity_class_value, bref, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(capacity_value_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void composite_available_capacity_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cell_capacity_class_value_present) {
    j.write_int("cellCapacityClassValue", cell_capacity_class_value);
  }
  j.write_fieldname("capacityValueInfo");
  capacity_value_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GNB-RadioResourceStatus-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t gnb_rr_status_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {277, 295};
  return map_enum_number(names, 2, idx, "id");
}
bool gnb_rr_status_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {277, 295};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e gnb_rr_status_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 277:
      return crit_e::ignore;
    case 295:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
gnb_rr_status_ext_ies_o::ext_c gnb_rr_status_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 277:
      ret.set(ext_c::types::slice_rr_status_list);
      break;
    case 295:
      ret.set(ext_c::types::mimo_prb_usage_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gnb_rr_status_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 277:
      return presence_e::optional;
    case 295:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void gnb_rr_status_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::slice_rr_status_list:
      c = slice_rr_status_list_l{};
      break;
    case types::mimo_prb_usage_info:
      c = mimo_prb_usage_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rr_status_ext_ies_o::ext_c");
  }
}
slice_rr_status_list_l& gnb_rr_status_ext_ies_o::ext_c::slice_rr_status_list()
{
  assert_choice_type(types::slice_rr_status_list, type_, "Extension");
  return c.get<slice_rr_status_list_l>();
}
mimo_prb_usage_info_s& gnb_rr_status_ext_ies_o::ext_c::mimo_prb_usage_info()
{
  assert_choice_type(types::mimo_prb_usage_info, type_, "Extension");
  return c.get<mimo_prb_usage_info_s>();
}
const slice_rr_status_list_l& gnb_rr_status_ext_ies_o::ext_c::slice_rr_status_list() const
{
  assert_choice_type(types::slice_rr_status_list, type_, "Extension");
  return c.get<slice_rr_status_list_l>();
}
const mimo_prb_usage_info_s& gnb_rr_status_ext_ies_o::ext_c::mimo_prb_usage_info() const
{
  assert_choice_type(types::mimo_prb_usage_info, type_, "Extension");
  return c.get<mimo_prb_usage_info_s>();
}
void gnb_rr_status_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::slice_rr_status_list:
      j.start_array("SliceRadioResourceStatus-List");
      for (const auto& e1 : c.get<slice_rr_status_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mimo_prb_usage_info:
      j.write_fieldname("MIMOPRBusageInformation");
      c.get<mimo_prb_usage_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rr_status_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_rr_status_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::slice_rr_status_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<slice_rr_status_list_l>(), 1, 12, true));
      break;
    case types::mimo_prb_usage_info:
      HANDLE_CODE(c.get<mimo_prb_usage_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rr_status_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_rr_status_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::slice_rr_status_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<slice_rr_status_list_l>(), bref, 1, 12, true));
      break;
    case types::mimo_prb_usage_info:
      HANDLE_CODE(c.get<mimo_prb_usage_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rr_status_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* gnb_rr_status_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SliceRadioResourceStatus-List", "MIMOPRBusageInformation"};
  return convert_enum_idx(names, 2, value, "gnb_rr_status_ext_ies_o::ext_c::types");
}

// NG-eNB-RadioResourceStatus-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t ng_enb_rr_status_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {240, 241};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_enb_rr_status_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {240, 241};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_enb_rr_status_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 240:
      return crit_e::ignore;
    case 241:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_enb_rr_status_ext_ies_o::ext_c ng_enb_rr_status_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 240:
      ret.set(ext_c::types::dl_sched_pdcch_cce_usage);
      break;
    case 241:
      ret.set(ext_c::types::ul_sched_pdcch_cce_usage);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_enb_rr_status_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 240:
      return presence_e::optional;
    case 241:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ng_enb_rr_status_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      c = uint8_t{};
      break;
    case types::ul_sched_pdcch_cce_usage:
      c = uint8_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_rr_status_ext_ies_o::ext_c");
  }
}
uint8_t& ng_enb_rr_status_ext_ies_o::ext_c::dl_sched_pdcch_cce_usage()
{
  assert_choice_type(types::dl_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
uint8_t& ng_enb_rr_status_ext_ies_o::ext_c::ul_sched_pdcch_cce_usage()
{
  assert_choice_type(types::ul_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
const uint8_t& ng_enb_rr_status_ext_ies_o::ext_c::dl_sched_pdcch_cce_usage() const
{
  assert_choice_type(types::dl_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
const uint8_t& ng_enb_rr_status_ext_ies_o::ext_c::ul_sched_pdcch_cce_usage() const
{
  assert_choice_type(types::ul_sched_pdcch_cce_usage, type_, "Extension");
  return c.get<uint8_t>();
}
void ng_enb_rr_status_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      j.write_int("INTEGER (0..100)", c.get<uint8_t>());
      break;
    case types::ul_sched_pdcch_cce_usage:
      j.write_int("INTEGER (0..100)", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_rr_status_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_enb_rr_status_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    case types::ul_sched_pdcch_cce_usage:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_rr_status_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_enb_rr_status_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_sched_pdcch_cce_usage:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    case types::ul_sched_pdcch_cce_usage:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)100u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_rr_status_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_enb_rr_status_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..100)", "INTEGER (0..100)"};
  return convert_enum_idx(names, 2, value, "ng_enb_rr_status_ext_ies_o::ext_c::types");
}

// NR-U-Channel-Item ::= SEQUENCE
SRSASN_CODE nr_u_ch_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_u_ch_id, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(pack_integer(bref, ch_occupancy_time_percentage_dl, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(pack_integer(bref, energy_detection_thres, (int8_t)-100, (int8_t)-50, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_u_ch_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_u_ch_id, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(unpack_integer(ch_occupancy_time_percentage_dl, bref, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(unpack_integer(energy_detection_thres, bref, (int8_t)-100, (int8_t)-50, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_u_ch_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nR-U-ChannelID", nr_u_ch_id);
  j.write_int("channelOccupancyTimePercentageDL", ch_occupancy_time_percentage_dl);
  j.write_int("energyDetectionThreshold", energy_detection_thres);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// CompositeAvailableCapacityGroup-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t composite_available_capacity_group_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {278};
  return map_enum_number(names, 1, idx, "id");
}
bool composite_available_capacity_group_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 278 == id;
}
crit_e composite_available_capacity_group_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 278) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
composite_available_capacity_group_ext_ies_o::ext_c
composite_available_capacity_group_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 278) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e composite_available_capacity_group_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 278) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void composite_available_capacity_group_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CompositeAvailableCapacity");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE composite_available_capacity_group_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_group_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* composite_available_capacity_group_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"CompositeAvailableCapacity"};
  return convert_enum_idx(names, 1, value, "composite_available_capacity_group_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<gnb_rr_status_ext_ies_o>;

SRSASN_CODE gnb_rr_status_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += slice_rr_status_list_present ? 1 : 0;
  nof_ies += mimo_prb_usage_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (slice_rr_status_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)277, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, slice_rr_status_list, 1, 12, true));
  }
  if (mimo_prb_usage_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mimo_prb_usage_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_rr_status_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 277: {
        slice_rr_status_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(slice_rr_status_list, bref, 1, 12, true));
        break;
      }
      case 295: {
        mimo_prb_usage_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mimo_prb_usage_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void gnb_rr_status_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (slice_rr_status_list_present) {
    j.write_int("id", 277);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : slice_rr_status_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mimo_prb_usage_info_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "ignore");
    mimo_prb_usage_info.to_json(j);
  }
  j.end_obj();
}

// GNB-RadioResourceStatus ::= SEQUENCE
SRSASN_CODE gnb_rr_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ssb_area_rr_status_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_rr_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ssb_area_rr_status_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("ssbAreaRadioResourceStatus-List");
  for (const auto& e1 : ssb_area_rr_status_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<ng_enb_rr_status_ext_ies_o>;

SRSASN_CODE ng_enb_rr_status_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += dl_sched_pdcch_cce_usage_present ? 1 : 0;
  nof_ies += ul_sched_pdcch_cce_usage_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (dl_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)240, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, dl_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)241, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ul_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_enb_rr_status_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 240: {
        dl_sched_pdcch_cce_usage_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(dl_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
        break;
      }
      case 241: {
        ul_sched_pdcch_cce_usage_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ul_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ng_enb_rr_status_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_sched_pdcch_cce_usage_present) {
    j.write_int("id", 240);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", dl_sched_pdcch_cce_usage);
  }
  if (ul_sched_pdcch_cce_usage_present) {
    j.write_int("id", 241);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", ul_sched_pdcch_cce_usage);
  }
  j.end_obj();
}

// NG-eNB-RadioResourceStatus ::= SEQUENCE
SRSASN_CODE ng_enb_rr_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_enb_rr_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ng_enb_rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dL-GBR-PRB-usage", dl_gbr_prb_usage);
  j.write_int("uL-GBR-PRB-usage", ul_gbr_prb_usage);
  j.write_int("dL-non-GBR-PRB-usage", dl_non_gbr_prb_usage);
  j.write_int("uL-non-GBR-PRB-usage", ul_non_gbr_prb_usage);
  j.write_int("dL-Total-PRB-usage", dl_total_prb_usage);
  j.write_int("uL-Total-PRB-usage", ul_total_prb_usage);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceAvailableCapacity-Item ::= SEQUENCE
SRSASN_CODE slice_available_capacity_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, snssai_available_capacity_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_available_capacity_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(snssai_available_capacity_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_available_capacity_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("sNSSAIAvailableCapacity-List");
  for (const auto& e1 : snssai_available_capacity_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellMeasurementResult-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t cell_meas_result_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {283};
  return map_enum_number(names, 1, idx, "id");
}
bool cell_meas_result_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 283 == id;
}
crit_e cell_meas_result_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 283) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
cell_meas_result_item_ext_ies_o::ext_c cell_meas_result_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 283) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cell_meas_result_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 283) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void cell_meas_result_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("NR-U-Channel-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE cell_meas_result_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 16, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_meas_result_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 16, true));
  return SRSASN_SUCCESS;
}

const char* cell_meas_result_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NR-U-Channel-List"};
  return convert_enum_idx(names, 1, value, "cell_meas_result_item_ext_ies_o::ext_c::types");
}

// CompositeAvailableCapacityGroup ::= SEQUENCE
SRSASN_CODE composite_available_capacity_group_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(composite_available_capacity_dl.pack(bref));
  HANDLE_CODE(composite_available_capacity_ul.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_group_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(composite_available_capacity_dl.unpack(bref));
  HANDLE_CODE(composite_available_capacity_ul.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void composite_available_capacity_group_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("compositeAvailableCapacityDownlink");
  composite_available_capacity_dl.to_json(j);
  j.write_fieldname("compositeAvailableCapacityUplink");
  composite_available_capacity_ul.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// RRCConnections ::= SEQUENCE
SRSASN_CODE rrc_conns_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, noof_rrc_conns, (uint32_t)1u, (uint32_t)65536u, true, true));
  HANDLE_CODE(pack_integer(bref, available_rrc_conn_capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_conns_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(noof_rrc_conns, bref, (uint32_t)1u, (uint32_t)65536u, true, true));
  HANDLE_CODE(unpack_integer(available_rrc_conn_capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rrc_conns_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("noofRRCConnections", noof_rrc_conns);
  j.write_int("availableRRCConnectionCapacityValue", available_rrc_conn_capacity_value);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RadioResourceStatus ::= CHOICE
void rr_status_c::destroy_()
{
  switch (type_) {
    case types::ng_enb_rr_status:
      c.destroy<ng_enb_rr_status_s>();
      break;
    case types::gnb_rr_status:
      c.destroy<gnb_rr_status_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<rr_status_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void rr_status_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ng_enb_rr_status:
      c.init<ng_enb_rr_status_s>();
      break;
    case types::gnb_rr_status:
      c.init<gnb_rr_status_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<rr_status_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_c");
  }
}
rr_status_c::rr_status_c(const rr_status_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ng_enb_rr_status:
      c.init(other.c.get<ng_enb_rr_status_s>());
      break;
    case types::gnb_rr_status:
      c.init(other.c.get<gnb_rr_status_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<rr_status_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_c");
  }
}
rr_status_c& rr_status_c::operator=(const rr_status_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ng_enb_rr_status:
      c.set(other.c.get<ng_enb_rr_status_s>());
      break;
    case types::gnb_rr_status:
      c.set(other.c.get<gnb_rr_status_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<rr_status_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_c");
  }

  return *this;
}
ng_enb_rr_status_s& rr_status_c::set_ng_enb_rr_status()
{
  set(types::ng_enb_rr_status);
  return c.get<ng_enb_rr_status_s>();
}
gnb_rr_status_s& rr_status_c::set_gnb_rr_status()
{
  set(types::gnb_rr_status);
  return c.get<gnb_rr_status_s>();
}
protocol_ie_single_container_s<rr_status_ext_ies_o>& rr_status_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<rr_status_ext_ies_o>>();
}
void rr_status_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ng_enb_rr_status:
      j.write_fieldname("ng-eNB-RadioResourceStatus");
      c.get<ng_enb_rr_status_s>().to_json(j);
      break;
    case types::gnb_rr_status:
      j.write_fieldname("gNB-RadioResourceStatus");
      c.get<gnb_rr_status_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<rr_status_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_c");
  }
  j.end_obj();
}
SRSASN_CODE rr_status_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ng_enb_rr_status:
      HANDLE_CODE(c.get<ng_enb_rr_status_s>().pack(bref));
      break;
    case types::gnb_rr_status:
      HANDLE_CODE(c.get<gnb_rr_status_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rr_status_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rr_status_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ng_enb_rr_status:
      HANDLE_CODE(c.get<ng_enb_rr_status_s>().unpack(bref));
      break;
    case types::gnb_rr_status:
      HANDLE_CODE(c.get<gnb_rr_status_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rr_status_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* rr_status_c::types_opts::to_string() const
{
  static const char* names[] = {"ng-eNB-RadioResourceStatus", "gNB-RadioResourceStatus", "choice-extension"};
  return convert_enum_idx(names, 3, value, "rr_status_c::types");
}

// TNLCapacityIndicator ::= SEQUENCE
SRSASN_CODE tnl_capacity_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_tnl_offered_capacity, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(pack_integer(bref, dl_tnl_available_capacity, (uint8_t)1u, (uint8_t)100u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_tnl_offered_capacity, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_tnl_available_capacity, (uint8_t)1u, (uint8_t)100u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_capacity_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_tnl_offered_capacity, bref, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(unpack_integer(dl_tnl_available_capacity, bref, (uint8_t)1u, (uint8_t)100u, true, true));
  HANDLE_CODE(unpack_integer(ul_tnl_offered_capacity, bref, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(unpack_integer(ul_tnl_available_capacity, bref, (uint8_t)1u, (uint8_t)100u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_capacity_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dLTNLOfferedCapacity", dl_tnl_offered_capacity);
  j.write_int("dLTNLAvailableCapacity", dl_tnl_available_capacity);
  j.write_int("uLTNLOfferedCapacity", ul_tnl_offered_capacity);
  j.write_int("uLTNLAvailableCapacity", ul_tnl_available_capacity);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellMeasurementResult-Item ::= SEQUENCE
SRSASN_CODE cell_meas_result_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(rr_status_present, 1));
  HANDLE_CODE(bref.pack(tnl_capacity_ind_present, 1));
  HANDLE_CODE(bref.pack(composite_available_capacity_group_present, 1));
  HANDLE_CODE(bref.pack(slice_available_capacity.size() > 0, 1));
  HANDLE_CODE(bref.pack(numof_active_ues_present, 1));
  HANDLE_CODE(bref.pack(rrc_conns_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(cell_id.pack(bref));
  if (rr_status_present) {
    HANDLE_CODE(rr_status.pack(bref));
  }
  if (tnl_capacity_ind_present) {
    HANDLE_CODE(tnl_capacity_ind.pack(bref));
  }
  if (composite_available_capacity_group_present) {
    HANDLE_CODE(composite_available_capacity_group.pack(bref));
  }
  if (slice_available_capacity.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, slice_available_capacity, 1, 12, true));
  }
  if (numof_active_ues_present) {
    HANDLE_CODE(pack_integer(bref, numof_active_ues, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (rrc_conns_present) {
    HANDLE_CODE(rrc_conns.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_meas_result_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(rr_status_present, 1));
  HANDLE_CODE(bref.unpack(tnl_capacity_ind_present, 1));
  HANDLE_CODE(bref.unpack(composite_available_capacity_group_present, 1));
  bool slice_available_capacity_present;
  HANDLE_CODE(bref.unpack(slice_available_capacity_present, 1));
  HANDLE_CODE(bref.unpack(numof_active_ues_present, 1));
  HANDLE_CODE(bref.unpack(rrc_conns_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.unpack(bref));
  if (rr_status_present) {
    HANDLE_CODE(rr_status.unpack(bref));
  }
  if (tnl_capacity_ind_present) {
    HANDLE_CODE(tnl_capacity_ind.unpack(bref));
  }
  if (composite_available_capacity_group_present) {
    HANDLE_CODE(composite_available_capacity_group.unpack(bref));
  }
  if (slice_available_capacity_present) {
    HANDLE_CODE(unpack_dyn_seq_of(slice_available_capacity, bref, 1, 12, true));
  }
  if (numof_active_ues_present) {
    HANDLE_CODE(unpack_integer(numof_active_ues, bref, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (rrc_conns_present) {
    HANDLE_CODE(rrc_conns.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void cell_meas_result_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cell-ID");
  cell_id.to_json(j);
  if (rr_status_present) {
    j.write_fieldname("radioResourceStatus");
    rr_status.to_json(j);
  }
  if (tnl_capacity_ind_present) {
    j.write_fieldname("tNLCapacityIndicator");
    tnl_capacity_ind.to_json(j);
  }
  if (composite_available_capacity_group_present) {
    j.write_fieldname("compositeAvailableCapacityGroup");
    composite_available_capacity_group.to_json(j);
  }
  if (slice_available_capacity.size() > 0) {
    j.start_array("sliceAvailableCapacity");
    for (const auto& e1 : slice_available_capacity) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (numof_active_ues_present) {
    j.write_int("numberofActiveUEs", numof_active_ues);
  }
  if (rrc_conns_present) {
    j.write_fieldname("rRCConnections");
    rrc_conns.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// GlobalCell-ID ::= SEQUENCE
SRSASN_CODE global_cell_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(cell_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_cell_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(cell_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_cell_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  j.write_fieldname("cell-type");
  cell_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ReplacingCells-Item ::= SEQUENCE
SRSASN_CODE replacing_cells_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_ran_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE replacing_cells_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_ran_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void replacing_cells_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalNG-RANCell-ID");
  global_ng_ran_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellReplacingInfo ::= SEQUENCE
SRSASN_CODE cell_replacing_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, replacing_cells, 0, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_replacing_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(replacing_cells, bref, 0, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_replacing_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("replacingCells");
  for (const auto& e1 : replacing_cells) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SNSSAI-Item ::= SEQUENCE
SRSASN_CODE snssai_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE snssai_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void snssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBToReport-List-Item ::= SEQUENCE
SRSASN_CODE ssb_to_report_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_to_report_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_to_report_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceToReport-List-Item ::= SEQUENCE
SRSASN_CODE slice_to_report_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, snssai_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_to_report_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(snssai_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_to_report_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("sNSSAIlist");
  for (const auto& e1 : snssai_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellToReport-Item ::= SEQUENCE
SRSASN_CODE cell_to_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ssb_to_report_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(slice_to_report_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.pack(bref));
  if (ssb_to_report_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ssb_to_report_list, 1, 64, true));
  }
  if (slice_to_report_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, slice_to_report_list, 1, 12, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_to_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ssb_to_report_list_present;
  HANDLE_CODE(bref.unpack(ssb_to_report_list_present, 1));
  bool slice_to_report_list_present;
  HANDLE_CODE(bref.unpack(slice_to_report_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.unpack(bref));
  if (ssb_to_report_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ssb_to_report_list, bref, 1, 64, true));
  }
  if (slice_to_report_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(slice_to_report_list, bref, 1, 12, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cell-ID");
  cell_id.to_json(j);
  if (ssb_to_report_list.size() > 0) {
    j.start_array("sSBToReport-List");
    for (const auto& e1 : ssb_to_report_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (slice_to_report_list.size() > 0) {
    j.start_array("sliceToReport-List");
    for (const auto& e1 : slice_to_report_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PrivacyIndicator ::= ENUMERATED
const char* privacy_ind_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT", "logged-MDT"};
  return convert_enum_idx(names, 2, value, "privacy_ind_e");
}

// TargetCellList-Item ::= SEQUENCE
SRSASN_CODE target_cell_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_cell.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_cell_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_cell.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("target-cell");
  target_cell.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SymbolAllocation-in-Slot-BothDLandUL-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {320};
  return map_enum_number(names, 1, idx, "id");
}
bool symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 320 == id;
}
crit_e symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 320) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::ext_c
symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 320) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 320) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("Permutation", c.to_string());
  j.end_obj();
}
SRSASN_CODE symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Permutation"};
  return convert_enum_idx(names, 1, value, "symbol_alloc_in_slot_both_dl_and_ul_ext_ies_o::ext_c::types");
}

// SymbolAllocation-in-Slot-AllDL ::= SEQUENCE
SRSASN_CODE symbol_alloc_in_slot_all_dl_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE symbol_alloc_in_slot_all_dl_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void symbol_alloc_in_slot_all_dl_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// SymbolAllocation-in-Slot-AllUL ::= SEQUENCE
SRSASN_CODE symbol_alloc_in_slot_all_ul_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE symbol_alloc_in_slot_all_ul_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void symbol_alloc_in_slot_all_ul_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// SymbolAllocation-in-Slot-BothDLandUL ::= SEQUENCE
SRSASN_CODE symbol_alloc_in_slot_both_dl_and_ul_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, numof_dl_symbols, (uint8_t)0u, (uint8_t)13u, false, true));
  HANDLE_CODE(pack_integer(bref, numof_ul_symbols, (uint8_t)0u, (uint8_t)13u, false, true));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE symbol_alloc_in_slot_both_dl_and_ul_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(numof_dl_symbols, bref, (uint8_t)0u, (uint8_t)13u, false, true));
  HANDLE_CODE(unpack_integer(numof_ul_symbols, bref, (uint8_t)0u, (uint8_t)13u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void symbol_alloc_in_slot_both_dl_and_ul_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("numberofDLSymbols", numof_dl_symbols);
  j.write_int("numberofULSymbols", numof_ul_symbols);
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// SymbolAllocation-in-Slot ::= CHOICE
void symbol_alloc_in_slot_c::destroy_()
{
  switch (type_) {
    case types::all_dl:
      c.destroy<symbol_alloc_in_slot_all_dl_s>();
      break;
    case types::all_ul:
      c.destroy<symbol_alloc_in_slot_all_ul_s>();
      break;
    case types::both_dl_and_ul:
      c.destroy<symbol_alloc_in_slot_both_dl_and_ul_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void symbol_alloc_in_slot_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::all_dl:
      c.init<symbol_alloc_in_slot_all_dl_s>();
      break;
    case types::all_ul:
      c.init<symbol_alloc_in_slot_all_ul_s>();
      break;
    case types::both_dl_and_ul:
      c.init<symbol_alloc_in_slot_both_dl_and_ul_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }
}
symbol_alloc_in_slot_c::symbol_alloc_in_slot_c(const symbol_alloc_in_slot_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::all_dl:
      c.init(other.c.get<symbol_alloc_in_slot_all_dl_s>());
      break;
    case types::all_ul:
      c.init(other.c.get<symbol_alloc_in_slot_all_ul_s>());
      break;
    case types::both_dl_and_ul:
      c.init(other.c.get<symbol_alloc_in_slot_both_dl_and_ul_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }
}
symbol_alloc_in_slot_c& symbol_alloc_in_slot_c::operator=(const symbol_alloc_in_slot_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::all_dl:
      c.set(other.c.get<symbol_alloc_in_slot_all_dl_s>());
      break;
    case types::all_ul:
      c.set(other.c.get<symbol_alloc_in_slot_all_ul_s>());
      break;
    case types::both_dl_and_ul:
      c.set(other.c.get<symbol_alloc_in_slot_both_dl_and_ul_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }

  return *this;
}
symbol_alloc_in_slot_all_dl_s& symbol_alloc_in_slot_c::set_all_dl()
{
  set(types::all_dl);
  return c.get<symbol_alloc_in_slot_all_dl_s>();
}
symbol_alloc_in_slot_all_ul_s& symbol_alloc_in_slot_c::set_all_ul()
{
  set(types::all_ul);
  return c.get<symbol_alloc_in_slot_all_ul_s>();
}
symbol_alloc_in_slot_both_dl_and_ul_s& symbol_alloc_in_slot_c::set_both_dl_and_ul()
{
  set(types::both_dl_and_ul);
  return c.get<symbol_alloc_in_slot_both_dl_and_ul_s>();
}
protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>& symbol_alloc_in_slot_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
}
void symbol_alloc_in_slot_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::all_dl:
      j.write_fieldname("allDL");
      c.get<symbol_alloc_in_slot_all_dl_s>().to_json(j);
      break;
    case types::all_ul:
      j.write_fieldname("allUL");
      c.get<symbol_alloc_in_slot_all_ul_s>().to_json(j);
      break;
    case types::both_dl_and_ul:
      j.write_fieldname("bothDLandUL");
      c.get<symbol_alloc_in_slot_both_dl_and_ul_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }
  j.end_obj();
}
SRSASN_CODE symbol_alloc_in_slot_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::all_dl:
      HANDLE_CODE(c.get<symbol_alloc_in_slot_all_dl_s>().pack(bref));
      break;
    case types::all_ul:
      HANDLE_CODE(c.get<symbol_alloc_in_slot_all_ul_s>().pack(bref));
      break;
    case types::both_dl_and_ul:
      HANDLE_CODE(c.get<symbol_alloc_in_slot_both_dl_and_ul_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE symbol_alloc_in_slot_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::all_dl:
      HANDLE_CODE(c.get<symbol_alloc_in_slot_all_dl_s>().unpack(bref));
      break;
    case types::all_ul:
      HANDLE_CODE(c.get<symbol_alloc_in_slot_all_ul_s>().unpack(bref));
      break;
    case types::both_dl_and_ul:
      HANDLE_CODE(c.get<symbol_alloc_in_slot_both_dl_and_ul_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* symbol_alloc_in_slot_c::types_opts::to_string() const
{
  static const char* names[] = {"allDL", "allUL", "bothDLandUL", "choice-extension"};
  return convert_enum_idx(names, 4, value, "symbol_alloc_in_slot_c::types");
}

// SlotConfiguration-List-Item ::= SEQUENCE
SRSASN_CODE slot_cfg_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, slot_idx, (uint16_t)0u, (uint16_t)5119u, false, true));
  HANDLE_CODE(symbol_alloc_in_slot.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slot_cfg_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(slot_idx, bref, (uint16_t)0u, (uint16_t)5119u, false, true));
  HANDLE_CODE(symbol_alloc_in_slot.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slot_cfg_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("slotIndex", slot_idx);
  j.write_fieldname("symbolAllocation-in-Slot");
  symbol_alloc_in_slot.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRCyclicPrefix ::= ENUMERATED
const char* nr_cp_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "nr_cp_e");
}

// NRDL-ULTransmissionPeriodicity ::= ENUMERATED
const char* nr_dl_ul_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms0p5",
                                "ms0p625",
                                "ms1",
                                "ms1p25",
                                "ms2",
                                "ms2p5",
                                "ms3",
                                "ms4",
                                "ms5",
                                "ms10",
                                "ms20",
                                "ms40",
                                "ms60",
                                "ms80",
                                "ms100",
                                "ms120",
                                "ms140",
                                "ms160"};
  return convert_enum_idx(names, 18, value, "nr_dl_ul_tx_periodicity_e");
}

// Bandwidth ::= ENUMERATED
const char* bw_opts::to_string() const
{
  static const char* names[] = {"mhz10", "mhz20", "mhz40", "mhz60", "mhz80"};
  return convert_enum_idx(names, 5, value, "bw_e");
}
uint8_t bw_opts::to_number() const
{
  static const uint8_t numbers[] = {10, 20, 40, 60, 80};
  return map_enum_number(numbers, 5, value, "bw_e");
}

// IntendedTDD-DL-ULConfiguration-NR ::= SEQUENCE
SRSASN_CODE intended_tdd_dl_ul_cfg_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nrscs.pack(bref));
  HANDLE_CODE(nr_cp.pack(bref));
  HANDLE_CODE(nr_dl_ul_tx_periodicity.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, slot_cfg_list, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intended_tdd_dl_ul_cfg_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nrscs.unpack(bref));
  HANDLE_CODE(nr_cp.unpack(bref));
  HANDLE_CODE(nr_dl_ul_tx_periodicity.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(slot_cfg_list, bref, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intended_tdd_dl_ul_cfg_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nrscs", nrscs.to_string());
  j.write_str("nrCyclicPrefix", nr_cp.to_string());
  j.write_str("nrDL-ULTransmissionPeriodicity", nr_dl_ul_tx_periodicity.to_string());
  j.start_array("slotConfiguration-List");
  for (const auto& e1 : slot_cfg_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NR-U-ChannelInfo-Item ::= SEQUENCE
SRSASN_CODE nr_u_ch_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_u_ch_id, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(pack_integer(bref, nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(bw.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_u_ch_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_u_ch_id, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(unpack_integer(nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(bw.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_u_ch_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nR-U-ChannelID", nr_u_ch_id);
  j.write_int("nRARFCN", nr_arfcn);
  j.write_str("bandwidth", bw.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NRModeInfoFDD-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t nr_mode_info_fdd_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {201, 230, 318, 319};
  return map_enum_number(names, 4, idx, "id");
}
bool nr_mode_info_fdd_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {201, 230, 318, 319};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nr_mode_info_fdd_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 201:
      return crit_e::ignore;
    case 230:
      return crit_e::ignore;
    case 318:
      return crit_e::ignore;
    case 319:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
nr_mode_info_fdd_ext_ies_o::ext_c nr_mode_info_fdd_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 201:
      ret.set(ext_c::types::ul_carrier_list);
      break;
    case 230:
      ret.set(ext_c::types::dl_carrier_list);
      break;
    case 318:
      ret.set(ext_c::types::ul_gnb_du_cell_res_cfg);
      break;
    case 319:
      ret.set(ext_c::types::dl_gnb_du_cell_res_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nr_mode_info_fdd_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 201:
      return presence_e::optional;
    case 230:
      return presence_e::optional;
    case 318:
      return presence_e::optional;
    case 319:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void nr_mode_info_fdd_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ul_carrier_list:
      c = nr_carrier_list_l{};
      break;
    case types::dl_carrier_list:
      c = nr_carrier_list_l{};
      break;
    case types::ul_gnb_du_cell_res_cfg:
      c = gnb_du_cell_res_cfg_s{};
      break;
    case types::dl_gnb_du_cell_res_cfg:
      c = gnb_du_cell_res_cfg_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_fdd_ext_ies_o::ext_c");
  }
}
nr_carrier_list_l& nr_mode_info_fdd_ext_ies_o::ext_c::ul_carrier_list()
{
  assert_choice_type(types::ul_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
nr_carrier_list_l& nr_mode_info_fdd_ext_ies_o::ext_c::dl_carrier_list()
{
  assert_choice_type(types::dl_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
gnb_du_cell_res_cfg_s& nr_mode_info_fdd_ext_ies_o::ext_c::ul_gnb_du_cell_res_cfg()
{
  assert_choice_type(types::ul_gnb_du_cell_res_cfg, type_, "Extension");
  return c.get<gnb_du_cell_res_cfg_s>();
}
gnb_du_cell_res_cfg_s& nr_mode_info_fdd_ext_ies_o::ext_c::dl_gnb_du_cell_res_cfg()
{
  assert_choice_type(types::dl_gnb_du_cell_res_cfg, type_, "Extension");
  return c.get<gnb_du_cell_res_cfg_s>();
}
const nr_carrier_list_l& nr_mode_info_fdd_ext_ies_o::ext_c::ul_carrier_list() const
{
  assert_choice_type(types::ul_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const nr_carrier_list_l& nr_mode_info_fdd_ext_ies_o::ext_c::dl_carrier_list() const
{
  assert_choice_type(types::dl_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const gnb_du_cell_res_cfg_s& nr_mode_info_fdd_ext_ies_o::ext_c::ul_gnb_du_cell_res_cfg() const
{
  assert_choice_type(types::ul_gnb_du_cell_res_cfg, type_, "Extension");
  return c.get<gnb_du_cell_res_cfg_s>();
}
const gnb_du_cell_res_cfg_s& nr_mode_info_fdd_ext_ies_o::ext_c::dl_gnb_du_cell_res_cfg() const
{
  assert_choice_type(types::dl_gnb_du_cell_res_cfg, type_, "Extension");
  return c.get<gnb_du_cell_res_cfg_s>();
}
void nr_mode_info_fdd_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::dl_carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ul_gnb_du_cell_res_cfg:
      j.write_fieldname("GNB-DU-Cell-Resource-Configuration");
      c.get<gnb_du_cell_res_cfg_s>().to_json(j);
      break;
    case types::dl_gnb_du_cell_res_cfg:
      j.write_fieldname("GNB-DU-Cell-Resource-Configuration");
      c.get<gnb_du_cell_res_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_fdd_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE nr_mode_info_fdd_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    case types::dl_carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    case types::ul_gnb_du_cell_res_cfg:
      HANDLE_CODE(c.get<gnb_du_cell_res_cfg_s>().pack(bref));
      break;
    case types::dl_gnb_du_cell_res_cfg:
      HANDLE_CODE(c.get<gnb_du_cell_res_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_fdd_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_fdd_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    case types::dl_carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    case types::ul_gnb_du_cell_res_cfg:
      HANDLE_CODE(c.get<gnb_du_cell_res_cfg_s>().unpack(bref));
      break;
    case types::dl_gnb_du_cell_res_cfg:
      HANDLE_CODE(c.get<gnb_du_cell_res_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_fdd_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nr_mode_info_fdd_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {
      "NRCarrierList", "NRCarrierList", "GNB-DU-Cell-Resource-Configuration", "GNB-DU-Cell-Resource-Configuration"};
  return convert_enum_idx(names, 4, value, "nr_mode_info_fdd_ext_ies_o::ext_c::types");
}

// NRModeInfoTDD-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t nr_mode_info_tdd_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {140, 199, 200, 317};
  return map_enum_number(names, 4, idx, "id");
}
bool nr_mode_info_tdd_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {140, 199, 200, 317};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nr_mode_info_tdd_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 140:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 200:
      return crit_e::ignore;
    case 317:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
nr_mode_info_tdd_ext_ies_o::ext_c nr_mode_info_tdd_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 140:
      ret.set(ext_c::types::intended_tdd_dl_ul_cfg_nr);
      break;
    case 199:
      ret.set(ext_c::types::tdd_ul_dl_cfg_common_nr);
      break;
    case 200:
      ret.set(ext_c::types::carrier_list);
      break;
    case 317:
      ret.set(ext_c::types::tdd_gnb_du_cell_res_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nr_mode_info_tdd_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 140:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 200:
      return presence_e::optional;
    case 317:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void nr_mode_info_tdd_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg_nr:
      c = intended_tdd_dl_ul_cfg_nr_s{};
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      c = unbounded_octstring<true>{};
      break;
    case types::carrier_list:
      c = nr_carrier_list_l{};
      break;
    case types::tdd_gnb_du_cell_res_cfg:
      c = gnb_du_cell_res_cfg_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_tdd_ext_ies_o::ext_c");
  }
}
intended_tdd_dl_ul_cfg_nr_s& nr_mode_info_tdd_ext_ies_o::ext_c::intended_tdd_dl_ul_cfg_nr()
{
  assert_choice_type(types::intended_tdd_dl_ul_cfg_nr, type_, "Extension");
  return c.get<intended_tdd_dl_ul_cfg_nr_s>();
}
unbounded_octstring<true>& nr_mode_info_tdd_ext_ies_o::ext_c::tdd_ul_dl_cfg_common_nr()
{
  assert_choice_type(types::tdd_ul_dl_cfg_common_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
nr_carrier_list_l& nr_mode_info_tdd_ext_ies_o::ext_c::carrier_list()
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
gnb_du_cell_res_cfg_s& nr_mode_info_tdd_ext_ies_o::ext_c::tdd_gnb_du_cell_res_cfg()
{
  assert_choice_type(types::tdd_gnb_du_cell_res_cfg, type_, "Extension");
  return c.get<gnb_du_cell_res_cfg_s>();
}
const intended_tdd_dl_ul_cfg_nr_s& nr_mode_info_tdd_ext_ies_o::ext_c::intended_tdd_dl_ul_cfg_nr() const
{
  assert_choice_type(types::intended_tdd_dl_ul_cfg_nr, type_, "Extension");
  return c.get<intended_tdd_dl_ul_cfg_nr_s>();
}
const unbounded_octstring<true>& nr_mode_info_tdd_ext_ies_o::ext_c::tdd_ul_dl_cfg_common_nr() const
{
  assert_choice_type(types::tdd_ul_dl_cfg_common_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const nr_carrier_list_l& nr_mode_info_tdd_ext_ies_o::ext_c::carrier_list() const
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const gnb_du_cell_res_cfg_s& nr_mode_info_tdd_ext_ies_o::ext_c::tdd_gnb_du_cell_res_cfg() const
{
  assert_choice_type(types::tdd_gnb_du_cell_res_cfg, type_, "Extension");
  return c.get<gnb_du_cell_res_cfg_s>();
}
void nr_mode_info_tdd_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg_nr:
      j.write_fieldname("IntendedTDD-DL-ULConfiguration-NR");
      c.get<intended_tdd_dl_ul_cfg_nr_s>().to_json(j);
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tdd_gnb_du_cell_res_cfg:
      j.write_fieldname("GNB-DU-Cell-Resource-Configuration");
      c.get<gnb_du_cell_res_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_tdd_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE nr_mode_info_tdd_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg_nr:
      HANDLE_CODE(c.get<intended_tdd_dl_ul_cfg_nr_s>().pack(bref));
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    case types::tdd_gnb_du_cell_res_cfg:
      HANDLE_CODE(c.get<gnb_du_cell_res_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_tdd_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_tdd_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg_nr:
      HANDLE_CODE(c.get<intended_tdd_dl_ul_cfg_nr_s>().unpack(bref));
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    case types::tdd_gnb_du_cell_res_cfg:
      HANDLE_CODE(c.get<gnb_du_cell_res_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_tdd_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nr_mode_info_tdd_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {
      "IntendedTDD-DL-ULConfiguration-NR", "OCTET STRING", "NRCarrierList", "GNB-DU-Cell-Resource-Configuration"};
  return convert_enum_idx(names, 4, value, "nr_mode_info_tdd_ext_ies_o::ext_c::types");
}

// NeighbourInformation-NR-ModeFDDInfo ::= SEQUENCE
SRSASN_CODE neighbour_info_nr_mode_fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_nr_freq_info.pack(bref));
  HANDLE_CODE(dl_nr_fequ_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_info_nr_mode_fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_nr_freq_info.unpack(bref));
  HANDLE_CODE(dl_nr_fequ_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_info_nr_mode_fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ul-NR-FreqInfo");
  ul_nr_freq_info.to_json(j);
  j.write_fieldname("dl-NR-FequInfo");
  dl_nr_fequ_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("ie-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NeighbourInformation-NR-ModeTDDInfo ::= SEQUENCE
SRSASN_CODE neighbour_info_nr_mode_tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_info_nr_mode_tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_info_nr_mode_tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nr-FreqInfo");
  nr_freq_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("ie-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CSI-RSTransmissionIndication ::= ENUMERATED
const char* csi_rs_tx_ind_opts::to_string() const
{
  static const char* names[] = {"activated", "deactivated"};
  return convert_enum_idx(names, 2, value, "csi_rs_tx_ind_e");
}

// Connectivity-Support ::= SEQUENCE
SRSASN_CODE connect_support_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(endc_support.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE connect_support_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(endc_support.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void connect_support_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eNDC-Support", endc_support.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* connect_support_s::endc_support_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "connect_support_s::endc_support_e_");
}

template struct asn1::protocol_ext_field_s<nr_mode_info_fdd_ext_ies_o>;

SRSASN_CODE nr_mode_info_fdd_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ul_carrier_list_present ? 1 : 0;
  nof_ies += dl_carrier_list_present ? 1 : 0;
  nof_ies += ul_gnb_du_cell_res_cfg_present ? 1 : 0;
  nof_ies += dl_gnb_du_cell_res_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ul_carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)201, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ul_carrier_list, 1, 5, true));
  }
  if (dl_carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)230, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, dl_carrier_list, 1, 5, true));
  }
  if (ul_gnb_du_cell_res_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)318, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_gnb_du_cell_res_cfg.pack(bref));
  }
  if (dl_gnb_du_cell_res_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)319, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_gnb_du_cell_res_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_fdd_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 201: {
        ul_carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ul_carrier_list, bref, 1, 5, true));
        break;
      }
      case 230: {
        dl_carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(dl_carrier_list, bref, 1, 5, true));
        break;
      }
      case 318: {
        ul_gnb_du_cell_res_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_gnb_du_cell_res_cfg.unpack(bref));
        break;
      }
      case 319: {
        dl_gnb_du_cell_res_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_gnb_du_cell_res_cfg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void nr_mode_info_fdd_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_carrier_list_present) {
    j.write_int("id", 201);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : ul_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dl_carrier_list_present) {
    j.write_int("id", 230);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : dl_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ul_gnb_du_cell_res_cfg_present) {
    j.write_int("id", 318);
    j.write_str("criticality", "ignore");
    ul_gnb_du_cell_res_cfg.to_json(j);
  }
  if (dl_gnb_du_cell_res_cfg_present) {
    j.write_int("id", 319);
    j.write_str("criticality", "ignore");
    dl_gnb_du_cell_res_cfg.to_json(j);
  }
  j.end_obj();
}

// NRModeInfoFDD ::= SEQUENCE
SRSASN_CODE nr_mode_info_fdd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ul_nr_freq_info.pack(bref));
  HANDLE_CODE(dl_nr_freq_info.pack(bref));
  HANDLE_CODE(ul_nr_transmisson_bw.pack(bref));
  HANDLE_CODE(dl_nr_transmisson_bw.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_fdd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ul_nr_freq_info.unpack(bref));
  HANDLE_CODE(dl_nr_freq_info.unpack(bref));
  HANDLE_CODE(ul_nr_transmisson_bw.unpack(bref));
  HANDLE_CODE(dl_nr_transmisson_bw.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_mode_info_fdd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ulNRFrequencyInfo");
  ul_nr_freq_info.to_json(j);
  j.write_fieldname("dlNRFrequencyInfo");
  dl_nr_freq_info.to_json(j);
  j.write_fieldname("ulNRTransmissonBandwidth");
  ul_nr_transmisson_bw.to_json(j);
  j.write_fieldname("dlNRTransmissonBandwidth");
  dl_nr_transmisson_bw.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<nr_mode_info_tdd_ext_ies_o>;

SRSASN_CODE nr_mode_info_tdd_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += intended_tdd_dl_ul_cfg_nr_present ? 1 : 0;
  nof_ies += tdd_ul_dl_cfg_common_nr_present ? 1 : 0;
  nof_ies += carrier_list_present ? 1 : 0;
  nof_ies += tdd_gnb_du_cell_res_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (intended_tdd_dl_ul_cfg_nr_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)140, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(intended_tdd_dl_ul_cfg_nr.pack(bref));
  }
  if (tdd_ul_dl_cfg_common_nr_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)199, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tdd_ul_dl_cfg_common_nr.pack(bref));
  }
  if (carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)200, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, carrier_list, 1, 5, true));
  }
  if (tdd_gnb_du_cell_res_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)317, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tdd_gnb_du_cell_res_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_tdd_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 140: {
        intended_tdd_dl_ul_cfg_nr_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intended_tdd_dl_ul_cfg_nr.unpack(bref));
        break;
      }
      case 199: {
        tdd_ul_dl_cfg_common_nr_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tdd_ul_dl_cfg_common_nr.unpack(bref));
        break;
      }
      case 200: {
        carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(carrier_list, bref, 1, 5, true));
        break;
      }
      case 317: {
        tdd_gnb_du_cell_res_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tdd_gnb_du_cell_res_cfg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void nr_mode_info_tdd_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (intended_tdd_dl_ul_cfg_nr_present) {
    j.write_int("id", 140);
    j.write_str("criticality", "ignore");
    intended_tdd_dl_ul_cfg_nr.to_json(j);
  }
  if (tdd_ul_dl_cfg_common_nr_present) {
    j.write_int("id", 199);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", tdd_ul_dl_cfg_common_nr.to_string());
  }
  if (carrier_list_present) {
    j.write_int("id", 200);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (tdd_gnb_du_cell_res_cfg_present) {
    j.write_int("id", 317);
    j.write_str("criticality", "ignore");
    tdd_gnb_du_cell_res_cfg.to_json(j);
  }
  j.end_obj();
}

// NRModeInfoTDD ::= SEQUENCE
SRSASN_CODE nr_mode_info_tdd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(nr_freq_info.pack(bref));
  HANDLE_CODE(nr_transmisson_bw.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_tdd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(nr_freq_info.unpack(bref));
  HANDLE_CODE(nr_transmisson_bw.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_mode_info_tdd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nrFrequencyInfo");
  nr_freq_info.to_json(j);
  j.write_fieldname("nrTransmissonBandwidth");
  nr_transmisson_bw.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NeighbourInformation-NR-ModeInfo ::= CHOICE
void neighbour_info_nr_mode_info_c::destroy_()
{
  switch (type_) {
    case types::fdd_info:
      c.destroy<neighbour_info_nr_mode_fdd_info_s>();
      break;
    case types::tdd_info:
      c.destroy<neighbour_info_nr_mode_tdd_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void neighbour_info_nr_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd_info:
      c.init<neighbour_info_nr_mode_fdd_info_s>();
      break;
    case types::tdd_info:
      c.init<neighbour_info_nr_mode_tdd_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "neighbour_info_nr_mode_info_c");
  }
}
neighbour_info_nr_mode_info_c::neighbour_info_nr_mode_info_c(const neighbour_info_nr_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd_info:
      c.init(other.c.get<neighbour_info_nr_mode_fdd_info_s>());
      break;
    case types::tdd_info:
      c.init(other.c.get<neighbour_info_nr_mode_tdd_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "neighbour_info_nr_mode_info_c");
  }
}
neighbour_info_nr_mode_info_c& neighbour_info_nr_mode_info_c::operator=(const neighbour_info_nr_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd_info:
      c.set(other.c.get<neighbour_info_nr_mode_fdd_info_s>());
      break;
    case types::tdd_info:
      c.set(other.c.get<neighbour_info_nr_mode_tdd_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "neighbour_info_nr_mode_info_c");
  }

  return *this;
}
neighbour_info_nr_mode_fdd_info_s& neighbour_info_nr_mode_info_c::set_fdd_info()
{
  set(types::fdd_info);
  return c.get<neighbour_info_nr_mode_fdd_info_s>();
}
neighbour_info_nr_mode_tdd_info_s& neighbour_info_nr_mode_info_c::set_tdd_info()
{
  set(types::tdd_info);
  return c.get<neighbour_info_nr_mode_tdd_info_s>();
}
protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>& neighbour_info_nr_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>();
}
void neighbour_info_nr_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd_info:
      j.write_fieldname("fdd-info");
      c.get<neighbour_info_nr_mode_fdd_info_s>().to_json(j);
      break;
    case types::tdd_info:
      j.write_fieldname("tdd-info");
      c.get<neighbour_info_nr_mode_tdd_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "neighbour_info_nr_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE neighbour_info_nr_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd_info:
      HANDLE_CODE(c.get<neighbour_info_nr_mode_fdd_info_s>().pack(bref));
      break;
    case types::tdd_info:
      HANDLE_CODE(c.get<neighbour_info_nr_mode_tdd_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "neighbour_info_nr_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_info_nr_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd_info:
      HANDLE_CODE(c.get<neighbour_info_nr_mode_fdd_info_s>().unpack(bref));
      break;
    case types::tdd_info:
      HANDLE_CODE(c.get<neighbour_info_nr_mode_tdd_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<neighbour_info_nr_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "neighbour_info_nr_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* neighbour_info_nr_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fdd-info", "tdd-info", "choice-extension"};
  return convert_enum_idx(names, 3, value, "neighbour_info_nr_mode_info_c::types");
}

// SFN-Offset ::= SEQUENCE
SRSASN_CODE sfn_offset_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sfn_time_offset.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sfn_offset_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sfn_time_offset.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sfn_offset_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sFN-Time-Offset", sfn_time_offset.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSB-PositionsInBurst ::= CHOICE
void ssb_positions_in_burst_c::destroy_()
{
  switch (type_) {
    case types::short_bitmap:
      c.destroy<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ssb_positions_in_burst_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::short_bitmap:
      c.init<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }
}
ssb_positions_in_burst_c::ssb_positions_in_burst_c(const ssb_positions_in_burst_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::short_bitmap:
      c.init(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }
}
ssb_positions_in_burst_c& ssb_positions_in_burst_c::operator=(const ssb_positions_in_burst_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::short_bitmap:
      c.set(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }

  return *this;
}
fixed_bitstring<4, false, true>& ssb_positions_in_burst_c::set_short_bitmap()
{
  set(types::short_bitmap);
  return c.get<fixed_bitstring<4, false, true>>();
}
fixed_bitstring<8, false, true>& ssb_positions_in_burst_c::set_medium_bitmap()
{
  set(types::medium_bitmap);
  return c.get<fixed_bitstring<8, false, true>>();
}
fixed_bitstring<64, false, true>& ssb_positions_in_burst_c::set_long_bitmap()
{
  set(types::long_bitmap);
  return c.get<fixed_bitstring<64, false, true>>();
}
protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>& ssb_positions_in_burst_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
}
void ssb_positions_in_burst_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::short_bitmap:
      j.write_str("shortBitmap", c.get<fixed_bitstring<4, false, true>>().to_string());
      break;
    case types::medium_bitmap:
      j.write_str("mediumBitmap", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::long_bitmap:
      j.write_str("longBitmap", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }
  j.end_obj();
}
SRSASN_CODE ssb_positions_in_burst_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().pack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_positions_in_burst_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().unpack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ssb_positions_in_burst_c::types_opts::to_string() const
{
  static const char* names[] = {"shortBitmap", "mediumBitmap", "longBitmap", "choice-extension"};
  return convert_enum_idx(names, 4, value, "ssb_positions_in_burst_c::types");
}

// ServedCellSpecificInfoReq-NR-Item ::= SEQUENCE
SRSASN_CODE served_cell_specific_info_req_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_mtc_list_request_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (add_mtc_list_request_ind_present) {
    HANDLE_CODE(add_mtc_list_request_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_specific_info_req_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(add_mtc_list_request_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (add_mtc_list_request_ind_present) {
    HANDLE_CODE(add_mtc_list_request_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cell_specific_info_req_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (add_mtc_list_request_ind_present) {
    j.write_str("additionalMTCListRequestIndicator", "additionalMTCListRequested");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* served_cell_specific_info_req_nr_item_s::add_mtc_list_request_ind_opts::to_string() const
{
  static const char* names[] = {"additionalMTCListRequested"};
  return convert_enum_idx(names, 1, value, "served_cell_specific_info_req_nr_item_s::add_mtc_list_request_ind_e_");
}

// NRModeInfo ::= CHOICE
void nr_mode_info_c::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<nr_mode_info_fdd_s>();
      break;
    case types::tdd:
      c.destroy<nr_mode_info_tdd_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void nr_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<nr_mode_info_fdd_s>();
      break;
    case types::tdd:
      c.init<nr_mode_info_tdd_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }
}
nr_mode_info_c::nr_mode_info_c(const nr_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<nr_mode_info_fdd_s>());
      break;
    case types::tdd:
      c.init(other.c.get<nr_mode_info_tdd_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }
}
nr_mode_info_c& nr_mode_info_c::operator=(const nr_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<nr_mode_info_fdd_s>());
      break;
    case types::tdd:
      c.set(other.c.get<nr_mode_info_tdd_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }

  return *this;
}
nr_mode_info_fdd_s& nr_mode_info_c::set_fdd()
{
  set(types::fdd);
  return c.get<nr_mode_info_fdd_s>();
}
nr_mode_info_tdd_s& nr_mode_info_c::set_tdd()
{
  set(types::tdd);
  return c.get<nr_mode_info_tdd_s>();
}
protocol_ie_single_container_s<nr_mode_info_ext_ies_o>& nr_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
}
void nr_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fdd");
      c.get<nr_mode_info_fdd_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tdd");
      c.get<nr_mode_info_tdd_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE nr_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<nr_mode_info_fdd_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<nr_mode_info_tdd_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<nr_mode_info_fdd_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<nr_mode_info_tdd_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nr_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fdd", "tdd", "choice-extension"};
  return convert_enum_idx(names, 3, value, "nr_mode_info_c::types");
}

// NeighbourInformation-E-UTRA-Item ::= SEQUENCE
SRSASN_CODE neighbour_info_e_utra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, e_utra_pci, (uint16_t)0u, (uint16_t)503u, true, true));
  HANDLE_CODE(e_utra_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, earfcn, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(tac.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_info_e_utra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(e_utra_pci, bref, (uint16_t)0u, (uint16_t)503u, true, true));
  HANDLE_CODE(e_utra_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(earfcn, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(tac.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_info_e_utra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-utra-PCI", e_utra_pci);
  j.write_fieldname("e-utra-cgi");
  e_utra_cgi.to_json(j);
  j.write_int("earfcn", earfcn);
  j.write_str("tac", tac.to_string());
  if (ranac_present) {
    j.write_int("ranac", ranac);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NeighbourInformation-NR-Item ::= SEQUENCE
SRSASN_CODE neighbour_info_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_pci, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(nr_mode_info.pack(bref));
  HANDLE_CODE(connect_support.pack(bref));
  HANDLE_CODE(meas_timing_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_info_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nr_pci, bref, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(nr_mode_info.unpack(bref));
  HANDLE_CODE(connect_support.unpack(bref));
  HANDLE_CODE(meas_timing_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_info_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nr-PCI", nr_pci);
  j.write_fieldname("nr-cgi");
  nr_cgi.to_json(j);
  j.write_str("tac", tac.to_string());
  if (ranac_present) {
    j.write_int("ranac", ranac);
  }
  j.write_fieldname("nr-mode-info");
  nr_mode_info.to_json(j);
  j.write_fieldname("connectivitySupport");
  connect_support.to_json(j);
  j.write_str("measurementTimingConfiguration", meas_timing_cfg.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedCellInformation-NR-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t served_cell_info_nr_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {129, 233, 203, 204, 220, 228, 242, 272, 292, 339, 350};
  return map_enum_number(names, 11, idx, "id");
}
bool served_cell_info_nr_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {129, 233, 203, 204, 220, 228, 242, 272, 292, 339, 350};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e served_cell_info_nr_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 129:
      return crit_e::ignore;
    case 233:
      return crit_e::ignore;
    case 203:
      return crit_e::ignore;
    case 204:
      return crit_e::ignore;
    case 220:
      return crit_e::reject;
    case 228:
      return crit_e::ignore;
    case 242:
      return crit_e::ignore;
    case 272:
      return crit_e::ignore;
    case 292:
      return crit_e::ignore;
    case 339:
      return crit_e::ignore;
    case 350:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
served_cell_info_nr_ext_ies_o::ext_c served_cell_info_nr_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 129:
      ret.set(ext_c::types::bplmn_id_info_nr);
      break;
    case 233:
      ret.set(ext_c::types::cfg_tac_ind);
      break;
    case 203:
      ret.set(ext_c::types::ssb_positions_in_burst);
      break;
    case 204:
      ret.set(ext_c::types::nr_cell_prach_cfg);
      break;
    case 220:
      ret.set(ext_c::types::npn_broadcast_info);
      break;
    case 228:
      ret.set(ext_c::types::csi_rs_tx_ind);
      break;
    case 242:
      ret.set(ext_c::types::sfn_offset);
      break;
    case 272:
      ret.set(ext_c::types::supported_mbs_fsa_id_list);
      break;
    case 292:
      ret.set(ext_c::types::nr_u_ch_info_list);
      break;
    case 339:
      ret.set(ext_c::types::add_meas_timing_cfg_list);
      break;
    case 350:
      ret.set(ext_c::types::redcap_bcast_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cell_info_nr_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 129:
      return presence_e::optional;
    case 233:
      return presence_e::optional;
    case 203:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 220:
      return presence_e::optional;
    case 228:
      return presence_e::optional;
    case 242:
      return presence_e::optional;
    case 272:
      return presence_e::optional;
    case 292:
      return presence_e::optional;
    case 339:
      return presence_e::optional;
    case 350:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void served_cell_info_nr_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::bplmn_id_info_nr:
      c = bplmn_id_info_nr_l{};
      break;
    case types::cfg_tac_ind:
      c = cfg_tac_ind_e{};
      break;
    case types::ssb_positions_in_burst:
      c = ssb_positions_in_burst_c{};
      break;
    case types::nr_cell_prach_cfg:
      c = unbounded_octstring<true>{};
      break;
    case types::npn_broadcast_info:
      c = npn_broadcast_info_c{};
      break;
    case types::csi_rs_tx_ind:
      c = csi_rs_tx_ind_e{};
      break;
    case types::sfn_offset:
      c = sfn_offset_s{};
      break;
    case types::supported_mbs_fsa_id_list:
      c = supported_mbs_fsa_id_list_l{};
      break;
    case types::nr_u_ch_info_list:
      c = nr_u_ch_info_list_l{};
      break;
    case types::add_meas_timing_cfg_list:
      c = add_meas_timing_cfg_list_l{};
      break;
    case types::redcap_bcast_info:
      c = fixed_bitstring<8, false, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_nr_ext_ies_o::ext_c");
  }
}
bplmn_id_info_nr_l& served_cell_info_nr_ext_ies_o::ext_c::bplmn_id_info_nr()
{
  assert_choice_type(types::bplmn_id_info_nr, type_, "Extension");
  return c.get<bplmn_id_info_nr_l>();
}
cfg_tac_ind_e& served_cell_info_nr_ext_ies_o::ext_c::cfg_tac_ind()
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
ssb_positions_in_burst_c& served_cell_info_nr_ext_ies_o::ext_c::ssb_positions_in_burst()
{
  assert_choice_type(types::ssb_positions_in_burst, type_, "Extension");
  return c.get<ssb_positions_in_burst_c>();
}
unbounded_octstring<true>& served_cell_info_nr_ext_ies_o::ext_c::nr_cell_prach_cfg()
{
  assert_choice_type(types::nr_cell_prach_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
npn_broadcast_info_c& served_cell_info_nr_ext_ies_o::ext_c::npn_broadcast_info()
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
csi_rs_tx_ind_e& served_cell_info_nr_ext_ies_o::ext_c::csi_rs_tx_ind()
{
  assert_choice_type(types::csi_rs_tx_ind, type_, "Extension");
  return c.get<csi_rs_tx_ind_e>();
}
sfn_offset_s& served_cell_info_nr_ext_ies_o::ext_c::sfn_offset()
{
  assert_choice_type(types::sfn_offset, type_, "Extension");
  return c.get<sfn_offset_s>();
}
supported_mbs_fsa_id_list_l& served_cell_info_nr_ext_ies_o::ext_c::supported_mbs_fsa_id_list()
{
  assert_choice_type(types::supported_mbs_fsa_id_list, type_, "Extension");
  return c.get<supported_mbs_fsa_id_list_l>();
}
nr_u_ch_info_list_l& served_cell_info_nr_ext_ies_o::ext_c::nr_u_ch_info_list()
{
  assert_choice_type(types::nr_u_ch_info_list, type_, "Extension");
  return c.get<nr_u_ch_info_list_l>();
}
add_meas_timing_cfg_list_l& served_cell_info_nr_ext_ies_o::ext_c::add_meas_timing_cfg_list()
{
  assert_choice_type(types::add_meas_timing_cfg_list, type_, "Extension");
  return c.get<add_meas_timing_cfg_list_l>();
}
fixed_bitstring<8, false, true>& served_cell_info_nr_ext_ies_o::ext_c::redcap_bcast_info()
{
  assert_choice_type(types::redcap_bcast_info, type_, "Extension");
  return c.get<fixed_bitstring<8, false, true>>();
}
const bplmn_id_info_nr_l& served_cell_info_nr_ext_ies_o::ext_c::bplmn_id_info_nr() const
{
  assert_choice_type(types::bplmn_id_info_nr, type_, "Extension");
  return c.get<bplmn_id_info_nr_l>();
}
const cfg_tac_ind_e& served_cell_info_nr_ext_ies_o::ext_c::cfg_tac_ind() const
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
const ssb_positions_in_burst_c& served_cell_info_nr_ext_ies_o::ext_c::ssb_positions_in_burst() const
{
  assert_choice_type(types::ssb_positions_in_burst, type_, "Extension");
  return c.get<ssb_positions_in_burst_c>();
}
const unbounded_octstring<true>& served_cell_info_nr_ext_ies_o::ext_c::nr_cell_prach_cfg() const
{
  assert_choice_type(types::nr_cell_prach_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const npn_broadcast_info_c& served_cell_info_nr_ext_ies_o::ext_c::npn_broadcast_info() const
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
const csi_rs_tx_ind_e& served_cell_info_nr_ext_ies_o::ext_c::csi_rs_tx_ind() const
{
  assert_choice_type(types::csi_rs_tx_ind, type_, "Extension");
  return c.get<csi_rs_tx_ind_e>();
}
const sfn_offset_s& served_cell_info_nr_ext_ies_o::ext_c::sfn_offset() const
{
  assert_choice_type(types::sfn_offset, type_, "Extension");
  return c.get<sfn_offset_s>();
}
const supported_mbs_fsa_id_list_l& served_cell_info_nr_ext_ies_o::ext_c::supported_mbs_fsa_id_list() const
{
  assert_choice_type(types::supported_mbs_fsa_id_list, type_, "Extension");
  return c.get<supported_mbs_fsa_id_list_l>();
}
const nr_u_ch_info_list_l& served_cell_info_nr_ext_ies_o::ext_c::nr_u_ch_info_list() const
{
  assert_choice_type(types::nr_u_ch_info_list, type_, "Extension");
  return c.get<nr_u_ch_info_list_l>();
}
const add_meas_timing_cfg_list_l& served_cell_info_nr_ext_ies_o::ext_c::add_meas_timing_cfg_list() const
{
  assert_choice_type(types::add_meas_timing_cfg_list, type_, "Extension");
  return c.get<add_meas_timing_cfg_list_l>();
}
const fixed_bitstring<8, false, true>& served_cell_info_nr_ext_ies_o::ext_c::redcap_bcast_info() const
{
  assert_choice_type(types::redcap_bcast_info, type_, "Extension");
  return c.get<fixed_bitstring<8, false, true>>();
}
void served_cell_info_nr_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::bplmn_id_info_nr:
      j.start_array("BPLMN-ID-Info-NR");
      for (const auto& e1 : c.get<bplmn_id_info_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cfg_tac_ind:
      j.write_str("ConfiguredTACIndication", "true");
      break;
    case types::ssb_positions_in_burst:
      j.write_fieldname("SSB-PositionsInBurst");
      c.get<ssb_positions_in_burst_c>().to_json(j);
      break;
    case types::nr_cell_prach_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::npn_broadcast_info:
      j.write_fieldname("NPN-Broadcast-Information");
      c.get<npn_broadcast_info_c>().to_json(j);
      break;
    case types::csi_rs_tx_ind:
      j.write_str("CSI-RSTransmissionIndication", c.get<csi_rs_tx_ind_e>().to_string());
      break;
    case types::sfn_offset:
      j.write_fieldname("SFN-Offset");
      c.get<sfn_offset_s>().to_json(j);
      break;
    case types::supported_mbs_fsa_id_list:
      j.start_array("Supported-MBS-FSA-ID-List");
      for (const auto& e1 : c.get<supported_mbs_fsa_id_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::nr_u_ch_info_list:
      j.start_array("NR-U-ChannelInfo-List");
      for (const auto& e1 : c.get<nr_u_ch_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::add_meas_timing_cfg_list:
      j.start_array("Additional-Measurement-Timing-Configuration-List");
      for (const auto& e1 : c.get<add_meas_timing_cfg_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redcap_bcast_info:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_nr_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE served_cell_info_nr_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bplmn_id_info_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<bplmn_id_info_nr_l>(), 1, 12, true));
      break;
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().pack(bref));
      break;
    case types::ssb_positions_in_burst:
      HANDLE_CODE(c.get<ssb_positions_in_burst_c>().pack(bref));
      break;
    case types::nr_cell_prach_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().pack(bref));
      break;
    case types::csi_rs_tx_ind:
      HANDLE_CODE(c.get<csi_rs_tx_ind_e>().pack(bref));
      break;
    case types::sfn_offset:
      HANDLE_CODE(c.get<sfn_offset_s>().pack(bref));
      break;
    case types::supported_mbs_fsa_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_mbs_fsa_id_list_l>(), 1, 256, true));
      break;
    case types::nr_u_ch_info_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_u_ch_info_list_l>(), 1, 16, true));
      break;
    case types::add_meas_timing_cfg_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_meas_timing_cfg_list_l>(), 1, 16, true));
      break;
    case types::redcap_bcast_info:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_nr_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_nr_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bplmn_id_info_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<bplmn_id_info_nr_l>(), bref, 1, 12, true));
      break;
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().unpack(bref));
      break;
    case types::ssb_positions_in_burst:
      HANDLE_CODE(c.get<ssb_positions_in_burst_c>().unpack(bref));
      break;
    case types::nr_cell_prach_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().unpack(bref));
      break;
    case types::csi_rs_tx_ind:
      HANDLE_CODE(c.get<csi_rs_tx_ind_e>().unpack(bref));
      break;
    case types::sfn_offset:
      HANDLE_CODE(c.get<sfn_offset_s>().unpack(bref));
      break;
    case types::supported_mbs_fsa_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_mbs_fsa_id_list_l>(), bref, 1, 256, true));
      break;
    case types::nr_u_ch_info_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_u_ch_info_list_l>(), bref, 1, 16, true));
      break;
    case types::add_meas_timing_cfg_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_meas_timing_cfg_list_l>(), bref, 1, 16, true));
      break;
    case types::redcap_bcast_info:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_nr_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* served_cell_info_nr_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"BPLMN-ID-Info-NR",
                                "ConfiguredTACIndication",
                                "SSB-PositionsInBurst",
                                "OCTET STRING",
                                "NPN-Broadcast-Information",
                                "CSI-RSTransmissionIndication",
                                "SFN-Offset",
                                "Supported-MBS-FSA-ID-List",
                                "NR-U-ChannelInfo-List",
                                "Additional-Measurement-Timing-Configuration-List",
                                "BIT STRING"};
  return convert_enum_idx(names, 11, value, "served_cell_info_nr_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<served_cell_info_nr_ext_ies_o>;

SRSASN_CODE served_cell_info_nr_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += bplmn_id_info_nr_present ? 1 : 0;
  nof_ies += cfg_tac_ind_present ? 1 : 0;
  nof_ies += ssb_positions_in_burst_present ? 1 : 0;
  nof_ies += nr_cell_prach_cfg_present ? 1 : 0;
  nof_ies += npn_broadcast_info_present ? 1 : 0;
  nof_ies += csi_rs_tx_ind_present ? 1 : 0;
  nof_ies += sfn_offset_present ? 1 : 0;
  nof_ies += supported_mbs_fsa_id_list_present ? 1 : 0;
  nof_ies += nr_u_ch_info_list_present ? 1 : 0;
  nof_ies += add_meas_timing_cfg_list_present ? 1 : 0;
  nof_ies += redcap_bcast_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (bplmn_id_info_nr_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)129, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, bplmn_id_info_nr, 1, 12, true));
  }
  if (cfg_tac_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)233, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cfg_tac_ind.pack(bref));
  }
  if (ssb_positions_in_burst_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)203, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ssb_positions_in_burst.pack(bref));
  }
  if (nr_cell_prach_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)204, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_cell_prach_cfg.pack(bref));
  }
  if (npn_broadcast_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)220, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_broadcast_info.pack(bref));
  }
  if (csi_rs_tx_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)228, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(csi_rs_tx_ind.pack(bref));
  }
  if (sfn_offset_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)242, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sfn_offset.pack(bref));
  }
  if (supported_mbs_fsa_id_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)272, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, supported_mbs_fsa_id_list, 1, 256, true));
  }
  if (nr_u_ch_info_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)292, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, nr_u_ch_info_list, 1, 16, true));
  }
  if (add_meas_timing_cfg_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)339, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_meas_timing_cfg_list, 1, 16, true));
  }
  if (redcap_bcast_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)350, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redcap_bcast_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_nr_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 129: {
        bplmn_id_info_nr_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(bplmn_id_info_nr, bref, 1, 12, true));
        break;
      }
      case 233: {
        cfg_tac_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cfg_tac_ind.unpack(bref));
        break;
      }
      case 203: {
        ssb_positions_in_burst_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ssb_positions_in_burst.unpack(bref));
        break;
      }
      case 204: {
        nr_cell_prach_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_cell_prach_cfg.unpack(bref));
        break;
      }
      case 220: {
        npn_broadcast_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_broadcast_info.unpack(bref));
        break;
      }
      case 228: {
        csi_rs_tx_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(csi_rs_tx_ind.unpack(bref));
        break;
      }
      case 242: {
        sfn_offset_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sfn_offset.unpack(bref));
        break;
      }
      case 272: {
        supported_mbs_fsa_id_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(supported_mbs_fsa_id_list, bref, 1, 256, true));
        break;
      }
      case 292: {
        nr_u_ch_info_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(nr_u_ch_info_list, bref, 1, 16, true));
        break;
      }
      case 339: {
        add_meas_timing_cfg_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_meas_timing_cfg_list, bref, 1, 16, true));
        break;
      }
      case 350: {
        redcap_bcast_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redcap_bcast_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_nr_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (bplmn_id_info_nr_present) {
    j.write_int("id", 129);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : bplmn_id_info_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (cfg_tac_ind_present) {
    j.write_int("id", 233);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (ssb_positions_in_burst_present) {
    j.write_int("id", 203);
    j.write_str("criticality", "ignore");
    ssb_positions_in_burst.to_json(j);
  }
  if (nr_cell_prach_cfg_present) {
    j.write_int("id", 204);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", nr_cell_prach_cfg.to_string());
  }
  if (npn_broadcast_info_present) {
    j.write_int("id", 220);
    j.write_str("criticality", "reject");
    npn_broadcast_info.to_json(j);
  }
  if (csi_rs_tx_ind_present) {
    j.write_int("id", 228);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", csi_rs_tx_ind.to_string());
  }
  if (sfn_offset_present) {
    j.write_int("id", 242);
    j.write_str("criticality", "ignore");
    sfn_offset.to_json(j);
  }
  if (supported_mbs_fsa_id_list_present) {
    j.write_int("id", 272);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : supported_mbs_fsa_id_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (nr_u_ch_info_list_present) {
    j.write_int("id", 292);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : nr_u_ch_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (add_meas_timing_cfg_list_present) {
    j.write_int("id", 339);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_meas_timing_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redcap_bcast_info_present) {
    j.write_int("id", 350);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redcap_bcast_info.to_string());
  }
  j.end_obj();
}

// ServedCellInformation-NR ::= SEQUENCE
SRSASN_CODE served_cell_info_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_pci, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(cell_id.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmn, 1, 12, true));
  HANDLE_CODE(nr_mode_info.pack(bref));
  HANDLE_CODE(meas_timing_cfg.pack(bref));
  HANDLE_CODE(connect_support.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nr_pci, bref, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(cell_id.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmn, bref, 1, 12, true));
  HANDLE_CODE(nr_mode_info.unpack(bref));
  HANDLE_CODE(meas_timing_cfg.unpack(bref));
  HANDLE_CODE(connect_support.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nrPCI", nr_pci);
  j.write_fieldname("cellID");
  cell_id.to_json(j);
  j.write_str("tac", tac.to_string());
  if (ranac_present) {
    j.write_int("ranac", ranac);
  }
  j.start_array("broadcastPLMN");
  for (const auto& e1 : broadcast_plmn) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.write_fieldname("nrModeInfo");
  nr_mode_info.to_json(j);
  j.write_str("measurementTimingConfiguration", meas_timing_cfg.to_string());
  j.write_fieldname("connectivitySupport");
  connect_support.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedCells-NR-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t served_cells_nr_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {347};
  return map_enum_number(names, 1, idx, "id");
}
bool served_cells_nr_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 347 == id;
}
crit_e served_cells_nr_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 347) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
served_cells_nr_item_ext_ies_o::ext_c served_cells_nr_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 347) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cells_nr_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 347) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void served_cells_nr_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("ServedCellSpecificInfoReq-NR");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE served_cells_nr_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 16384, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_nr_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 16384, true));
  return SRSASN_SUCCESS;
}

const char* served_cells_nr_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ServedCellSpecificInfoReq-NR"};
  return convert_enum_idx(names, 1, value, "served_cells_nr_item_ext_ies_o::ext_c::types");
}

// ServedCells-NR-Item ::= SEQUENCE
SRSASN_CODE served_cells_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(neighbour_info_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(neighbour_info_e_utra.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(served_cell_info_nr.pack(bref));
  if (neighbour_info_nr.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_nr, 1, 1024, true));
  }
  if (neighbour_info_e_utra.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_e_utra, 1, 1024, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool neighbour_info_nr_present;
  HANDLE_CODE(bref.unpack(neighbour_info_nr_present, 1));
  bool neighbour_info_e_utra_present;
  HANDLE_CODE(bref.unpack(neighbour_info_e_utra_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(served_cell_info_nr.unpack(bref));
  if (neighbour_info_nr_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_nr, bref, 1, 1024, true));
  }
  if (neighbour_info_e_utra_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_e_utra, bref, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void served_cells_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("served-cell-info-NR");
  served_cell_info_nr.to_json(j);
  if (neighbour_info_nr.size() > 0) {
    j.start_array("neighbour-info-NR");
    for (const auto& e1 : neighbour_info_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (neighbour_info_e_utra.size() > 0) {
    j.start_array("neighbour-info-E-UTRA");
    for (const auto& e1 : neighbour_info_e_utra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// ServedCells-ToModify-NR-Item ::= SEQUENCE
SRSASN_CODE served_cells_to_modify_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(neighbour_info_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(neighbour_info_e_utra.size() > 0, 1));
  HANDLE_CODE(bref.pack(deactivation_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(old_nr_cgi.pack(bref));
  HANDLE_CODE(served_cell_info_nr.pack(bref));
  if (neighbour_info_nr.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_nr, 1, 1024, true));
  }
  if (neighbour_info_e_utra.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_e_utra, 1, 1024, true));
  }
  if (deactivation_ind_present) {
    HANDLE_CODE(deactivation_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_modify_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool neighbour_info_nr_present;
  HANDLE_CODE(bref.unpack(neighbour_info_nr_present, 1));
  bool neighbour_info_e_utra_present;
  HANDLE_CODE(bref.unpack(neighbour_info_e_utra_present, 1));
  HANDLE_CODE(bref.unpack(deactivation_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(old_nr_cgi.unpack(bref));
  HANDLE_CODE(served_cell_info_nr.unpack(bref));
  if (neighbour_info_nr_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_nr, bref, 1, 1024, true));
  }
  if (neighbour_info_e_utra_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_e_utra, bref, 1, 1024, true));
  }
  if (deactivation_ind_present) {
    HANDLE_CODE(deactivation_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cells_to_modify_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("old-NR-CGI");
  old_nr_cgi.to_json(j);
  j.write_fieldname("served-cell-info-NR");
  served_cell_info_nr.to_json(j);
  if (neighbour_info_nr.size() > 0) {
    j.start_array("neighbour-info-NR");
    for (const auto& e1 : neighbour_info_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (neighbour_info_e_utra.size() > 0) {
    j.start_array("neighbour-info-E-UTRA");
    for (const auto& e1 : neighbour_info_e_utra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (deactivation_ind_present) {
    j.write_str("deactivation-indication", "deactivated");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* served_cells_to_modify_nr_item_s::deactivation_ind_opts::to_string() const
{
  static const char* names[] = {"deactivated"};
  return convert_enum_idx(names, 1, value, "served_cells_to_modify_nr_item_s::deactivation_ind_e_");
}

// ServedCellsToUpdate-NR ::= SEQUENCE
SRSASN_CODE served_cells_to_upd_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(served_cells_to_add_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(served_cells_to_modify_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(served_cells_to_delete_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (served_cells_to_add_nr.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, served_cells_to_add_nr, 1, 16384, true));
  }
  if (served_cells_to_modify_nr.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, served_cells_to_modify_nr, 1, 16384, true));
  }
  if (served_cells_to_delete_nr.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, served_cells_to_delete_nr, 1, 16384, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_upd_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool served_cells_to_add_nr_present;
  HANDLE_CODE(bref.unpack(served_cells_to_add_nr_present, 1));
  bool served_cells_to_modify_nr_present;
  HANDLE_CODE(bref.unpack(served_cells_to_modify_nr_present, 1));
  bool served_cells_to_delete_nr_present;
  HANDLE_CODE(bref.unpack(served_cells_to_delete_nr_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (served_cells_to_add_nr_present) {
    HANDLE_CODE(unpack_dyn_seq_of(served_cells_to_add_nr, bref, 1, 16384, true));
  }
  if (served_cells_to_modify_nr_present) {
    HANDLE_CODE(unpack_dyn_seq_of(served_cells_to_modify_nr, bref, 1, 16384, true));
  }
  if (served_cells_to_delete_nr_present) {
    HANDLE_CODE(unpack_dyn_seq_of(served_cells_to_delete_nr, bref, 1, 16384, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cells_to_upd_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (served_cells_to_add_nr.size() > 0) {
    j.start_array("served-Cells-ToAdd-NR");
    for (const auto& e1 : served_cells_to_add_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (served_cells_to_modify_nr.size() > 0) {
    j.start_array("served-Cells-ToModify-NR");
    for (const auto& e1 : served_cells_to_modify_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (served_cells_to_delete_nr.size() > 0) {
    j.start_array("served-Cells-ToDelete-NR");
    for (const auto& e1 : served_cells_to_delete_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CyclicPrefix-E-UTRA-DL ::= ENUMERATED
const char* cp_e_utra_dl_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "cp_e_utra_dl_e");
}

// CyclicPrefix-E-UTRA-UL ::= ENUMERATED
const char* cp_e_utra_ul_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "cp_e_utra_ul_e");
}

// NBIoT-UL-DL-AlignmentOffset ::= ENUMERATED
const char* nb_iot_ul_dl_align_offset_opts::to_string() const
{
  static const char* names[] = {"khz-7dot5", "khz0", "khz7dot5"};
  return convert_enum_idx(names, 3, value, "nb_iot_ul_dl_align_offset_e");
}
float nb_iot_ul_dl_align_offset_opts::to_number() const
{
  static const float numbers[] = {-7.5, 0.0, 7.5};
  return map_enum_number(numbers, 3, value, "nb_iot_ul_dl_align_offset_e");
}
const char* nb_iot_ul_dl_align_offset_opts::to_number_string() const
{
  static const char* number_strs[] = {"-7.5", "0", "7.5"};
  return convert_enum_idx(number_strs, 3, value, "nb_iot_ul_dl_align_offset_e");
}

// NPRACH-CP-Length ::= ENUMERATED
const char* nprach_cp_len_opts::to_string() const
{
  static const char* names[] = {"us66dot7", "us266dot7"};
  return convert_enum_idx(names, 2, value, "nprach_cp_len_e");
}
float nprach_cp_len_opts::to_number() const
{
  static const float numbers[] = {66.7, 266.7};
  return map_enum_number(numbers, 2, value, "nprach_cp_len_e");
}
const char* nprach_cp_len_opts::to_number_string() const
{
  static const char* number_strs[] = {"66.7", "266.7"};
  return convert_enum_idx(number_strs, 2, value, "nprach_cp_len_e");
}

// NPRACH-preambleFormat ::= ENUMERATED
const char* nprach_preamb_format_opts::to_string() const
{
  static const char* names[] = {"fmt0", "fmt1", "fmt2", "fmt0a", "fmt1a"};
  return convert_enum_idx(names, 5, value, "nprach_preamb_format_e");
}

SRSASN_CODE non_anchor_carrier_freqlist_item_s_::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(non_anchor_carrier_frquency.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_anchor_carrier_freqlist_item_s_::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(non_anchor_carrier_frquency.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_anchor_carrier_freqlist_item_s_::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("non-anchorCarrierFrquency", non_anchor_carrier_frquency.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// OffsetOfNbiotChannelNumberToEARFCN ::= ENUMERATED
const char* offset_of_nbiot_ch_num_to_earfcn_opts::to_string() const
{
  static const char* names[] = {"minusTen", "minusNine", "minusEightDotFive", "minusEight", "minusSeven",
                                "minusSix", "minusFive", "minusFourDotFive",  "minusFour",  "minusThree",
                                "minusTwo", "minusOne",  "minusZeroDotFive",  "zero",       "one",
                                "two",      "three",     "threeDotFive",      "four",       "five",
                                "six",      "seven",     "sevenDotFive",      "eight",      "nine"};
  return convert_enum_idx(names, 25, value, "offset_of_nbiot_ch_num_to_earfcn_e");
}

// ProtectedE-UTRAFootprintTimePattern ::= SEQUENCE
SRSASN_CODE protected_e_utra_footprint_time_pattern_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, protected_footprint_timeperiodicity, (uint16_t)1u, (uint16_t)320u, true, true));
  HANDLE_CODE(pack_integer(bref, protected_footrpint_start_time, (uint8_t)1u, (uint8_t)20u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE protected_e_utra_footprint_time_pattern_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(protected_footprint_timeperiodicity, bref, (uint16_t)1u, (uint16_t)320u, true, true));
  HANDLE_CODE(unpack_integer(protected_footrpint_start_time, bref, (uint8_t)1u, (uint8_t)20u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void protected_e_utra_footprint_time_pattern_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("protectedFootprintTimeperiodicity", protected_footprint_timeperiodicity);
  j.write_int("protectedFootrpintStartTime", protected_footrpint_start_time);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SpecialSubframePatterns-E-UTRA ::= ENUMERATED
const char* special_sf_patterns_e_utra_opts::to_string() const
{
  static const char* names[] = {
      "ssp0", "ssp1", "ssp2", "ssp3", "ssp4", "ssp5", "ssp6", "ssp7", "ssp8", "ssp9", "ssp10"};
  return convert_enum_idx(names, 11, value, "special_sf_patterns_e_utra_e");
}
uint8_t special_sf_patterns_e_utra_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  return map_enum_number(numbers, 11, value, "special_sf_patterns_e_utra_e");
}

// E-UTRATransmissionBandwidth ::= ENUMERATED
const char* e_utra_tx_bw_opts::to_string() const
{
  static const char* names[] = {"bw6", "bw15", "bw25", "bw50", "bw75", "bw100", "bw1"};
  return convert_enum_idx(names, 7, value, "e_utra_tx_bw_e");
}
uint8_t e_utra_tx_bw_opts::to_number() const
{
  static const uint8_t numbers[] = {6, 15, 25, 50, 75, 100, 1};
  return map_enum_number(numbers, 7, value, "e_utra_tx_bw_e");
}

// MBSFNSubframeAllocation-E-UTRA ::= CHOICE
void mbsfn_sf_alloc_e_utra_c::destroy_()
{
  switch (type_) {
    case types::oneframe:
      c.destroy<fixed_bitstring<6, false, true>>();
      break;
    case types::fourframes:
      c.destroy<fixed_bitstring<24, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbsfn_sf_alloc_e_utra_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::oneframe:
      c.init<fixed_bitstring<6, false, true>>();
      break;
    case types::fourframes:
      c.init<fixed_bitstring<24, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbsfn_sf_alloc_e_utra_c");
  }
}
mbsfn_sf_alloc_e_utra_c::mbsfn_sf_alloc_e_utra_c(const mbsfn_sf_alloc_e_utra_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::oneframe:
      c.init(other.c.get<fixed_bitstring<6, false, true>>());
      break;
    case types::fourframes:
      c.init(other.c.get<fixed_bitstring<24, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbsfn_sf_alloc_e_utra_c");
  }
}
mbsfn_sf_alloc_e_utra_c& mbsfn_sf_alloc_e_utra_c::operator=(const mbsfn_sf_alloc_e_utra_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::oneframe:
      c.set(other.c.get<fixed_bitstring<6, false, true>>());
      break;
    case types::fourframes:
      c.set(other.c.get<fixed_bitstring<24, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbsfn_sf_alloc_e_utra_c");
  }

  return *this;
}
fixed_bitstring<6, false, true>& mbsfn_sf_alloc_e_utra_c::set_oneframe()
{
  set(types::oneframe);
  return c.get<fixed_bitstring<6, false, true>>();
}
fixed_bitstring<24, false, true>& mbsfn_sf_alloc_e_utra_c::set_fourframes()
{
  set(types::fourframes);
  return c.get<fixed_bitstring<24, false, true>>();
}
protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>& mbsfn_sf_alloc_e_utra_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>();
}
void mbsfn_sf_alloc_e_utra_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::oneframe:
      j.write_str("oneframe", c.get<fixed_bitstring<6, false, true>>().to_string());
      break;
    case types::fourframes:
      j.write_str("fourframes", c.get<fixed_bitstring<24, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbsfn_sf_alloc_e_utra_c");
  }
  j.end_obj();
}
SRSASN_CODE mbsfn_sf_alloc_e_utra_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::oneframe:
      HANDLE_CODE((c.get<fixed_bitstring<6, false, true>>().pack(bref)));
      break;
    case types::fourframes:
      HANDLE_CODE((c.get<fixed_bitstring<24, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbsfn_sf_alloc_e_utra_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbsfn_sf_alloc_e_utra_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::oneframe:
      HANDLE_CODE((c.get<fixed_bitstring<6, false, true>>().unpack(bref)));
      break;
    case types::fourframes:
      HANDLE_CODE((c.get<fixed_bitstring<24, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbsfn_sf_alloc_e_utra_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbsfn_sf_alloc_e_utra_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbsfn_sf_alloc_e_utra_c::types_opts::to_string() const
{
  static const char* names[] = {"oneframe", "fourframes", "choice-extension"};
  return convert_enum_idx(names, 3, value, "mbsfn_sf_alloc_e_utra_c::types");
}
uint8_t mbsfn_sf_alloc_e_utra_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 4};
  return map_enum_number(numbers, 2, value, "mbsfn_sf_alloc_e_utra_c::types");
}

// NPRACHConfiguration-FDD ::= SEQUENCE
SRSASN_CODE nprach_cfg_fdd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(anchor_carrier_edt_nprach_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(anchor_carrier_format2_nprach_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(anchor_carrier_format2_edt_nprach_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(non_anchor_carrier_nprach_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(non_anchor_carrier_format2_nprach_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nprach_cp_len.pack(bref));
  HANDLE_CODE(anchor_carrier_nprach_cfg.pack(bref));
  if (anchor_carrier_edt_nprach_cfg.size() > 0) {
    HANDLE_CODE(anchor_carrier_edt_nprach_cfg.pack(bref));
  }
  if (anchor_carrier_format2_nprach_cfg.size() > 0) {
    HANDLE_CODE(anchor_carrier_format2_nprach_cfg.pack(bref));
  }
  if (anchor_carrier_format2_edt_nprach_cfg.size() > 0) {
    HANDLE_CODE(anchor_carrier_format2_edt_nprach_cfg.pack(bref));
  }
  if (non_anchor_carrier_nprach_cfg.size() > 0) {
    HANDLE_CODE(non_anchor_carrier_nprach_cfg.pack(bref));
  }
  if (non_anchor_carrier_format2_nprach_cfg.size() > 0) {
    HANDLE_CODE(non_anchor_carrier_format2_nprach_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nprach_cfg_fdd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool anchor_carrier_edt_nprach_cfg_present;
  HANDLE_CODE(bref.unpack(anchor_carrier_edt_nprach_cfg_present, 1));
  bool anchor_carrier_format2_nprach_cfg_present;
  HANDLE_CODE(bref.unpack(anchor_carrier_format2_nprach_cfg_present, 1));
  bool anchor_carrier_format2_edt_nprach_cfg_present;
  HANDLE_CODE(bref.unpack(anchor_carrier_format2_edt_nprach_cfg_present, 1));
  bool non_anchor_carrier_nprach_cfg_present;
  HANDLE_CODE(bref.unpack(non_anchor_carrier_nprach_cfg_present, 1));
  bool non_anchor_carrier_format2_nprach_cfg_present;
  HANDLE_CODE(bref.unpack(non_anchor_carrier_format2_nprach_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nprach_cp_len.unpack(bref));
  HANDLE_CODE(anchor_carrier_nprach_cfg.unpack(bref));
  if (anchor_carrier_edt_nprach_cfg_present) {
    HANDLE_CODE(anchor_carrier_edt_nprach_cfg.unpack(bref));
  }
  if (anchor_carrier_format2_nprach_cfg_present) {
    HANDLE_CODE(anchor_carrier_format2_nprach_cfg.unpack(bref));
  }
  if (anchor_carrier_format2_edt_nprach_cfg_present) {
    HANDLE_CODE(anchor_carrier_format2_edt_nprach_cfg.unpack(bref));
  }
  if (non_anchor_carrier_nprach_cfg_present) {
    HANDLE_CODE(non_anchor_carrier_nprach_cfg.unpack(bref));
  }
  if (non_anchor_carrier_format2_nprach_cfg_present) {
    HANDLE_CODE(non_anchor_carrier_format2_nprach_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nprach_cfg_fdd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nprach-CP-length", nprach_cp_len.to_string());
  j.write_str("anchorCarrier-NPRACHConfig", anchor_carrier_nprach_cfg.to_string());
  if (anchor_carrier_edt_nprach_cfg.size() > 0) {
    j.write_str("anchorCarrier-EDT-NPRACHConfig", anchor_carrier_edt_nprach_cfg.to_string());
  }
  if (anchor_carrier_format2_nprach_cfg.size() > 0) {
    j.write_str("anchorCarrier-Format2-NPRACHConfig", anchor_carrier_format2_nprach_cfg.to_string());
  }
  if (anchor_carrier_format2_edt_nprach_cfg.size() > 0) {
    j.write_str("anchorCarrier-Format2-EDT-NPRACHConfig", anchor_carrier_format2_edt_nprach_cfg.to_string());
  }
  if (non_anchor_carrier_nprach_cfg.size() > 0) {
    j.write_str("non-anchorCarrier-NPRACHConfig", non_anchor_carrier_nprach_cfg.to_string());
  }
  if (non_anchor_carrier_format2_nprach_cfg.size() > 0) {
    j.write_str("non-anchorCarrier-Format2-NPRACHConfig", non_anchor_carrier_format2_nprach_cfg.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPRACHConfiguration-TDD ::= SEQUENCE
SRSASN_CODE nprach_cfg_tdd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(non_anchor_carrier_fequency_cfglist.size() > 0, 1));
  HANDLE_CODE(bref.pack(non_anchor_carrier_nprach_cfg_tdd.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nprach_preamb_format.pack(bref));
  HANDLE_CODE(anchor_carrier_nprach_cfg_tdd.pack(bref));
  if (non_anchor_carrier_fequency_cfglist.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, non_anchor_carrier_fequency_cfglist, 1, 15, true));
  }
  if (non_anchor_carrier_nprach_cfg_tdd.size() > 0) {
    HANDLE_CODE(non_anchor_carrier_nprach_cfg_tdd.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nprach_cfg_tdd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool non_anchor_carrier_fequency_cfglist_present;
  HANDLE_CODE(bref.unpack(non_anchor_carrier_fequency_cfglist_present, 1));
  bool non_anchor_carrier_nprach_cfg_tdd_present;
  HANDLE_CODE(bref.unpack(non_anchor_carrier_nprach_cfg_tdd_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nprach_preamb_format.unpack(bref));
  HANDLE_CODE(anchor_carrier_nprach_cfg_tdd.unpack(bref));
  if (non_anchor_carrier_fequency_cfglist_present) {
    HANDLE_CODE(unpack_dyn_seq_of(non_anchor_carrier_fequency_cfglist, bref, 1, 15, true));
  }
  if (non_anchor_carrier_nprach_cfg_tdd_present) {
    HANDLE_CODE(non_anchor_carrier_nprach_cfg_tdd.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nprach_cfg_tdd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nprach-preambleFormat", nprach_preamb_format.to_string());
  j.write_str("anchorCarrier-NPRACHConfigTDD", anchor_carrier_nprach_cfg_tdd.to_string());
  if (non_anchor_carrier_fequency_cfglist.size() > 0) {
    j.start_array("non-anchorCarrierFequencyConfiglist");
    for (const auto& e1 : non_anchor_carrier_fequency_cfglist) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (non_anchor_carrier_nprach_cfg_tdd.size() > 0) {
    j.write_str("non-anchorCarrier-NPRACHConfigTDD", non_anchor_carrier_nprach_cfg_tdd.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ProtectedE-UTRAResource-Item ::= SEQUENCE
SRSASN_CODE protected_e_utra_res_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(res_type.pack(bref));
  HANDLE_CODE(intra_prb_protected_res_footprint.pack(bref));
  HANDLE_CODE(protected_footprint_freq_pattern.pack(bref));
  HANDLE_CODE(protected_footprint_time_pattern.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE protected_e_utra_res_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(res_type.unpack(bref));
  HANDLE_CODE(intra_prb_protected_res_footprint.unpack(bref));
  HANDLE_CODE(protected_footprint_freq_pattern.unpack(bref));
  HANDLE_CODE(protected_footprint_time_pattern.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void protected_e_utra_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("resourceType", res_type.to_string());
  j.write_str("intra-PRBProtectedResourceFootprint", intra_prb_protected_res_footprint.to_string());
  j.write_str("protectedFootprintFrequencyPattern", protected_footprint_freq_pattern.to_string());
  j.write_fieldname("protectedFootprintTimePattern");
  protected_footprint_time_pattern.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* protected_e_utra_res_item_s::res_type_opts::to_string() const
{
  static const char* names[] = {"downlinknonCRS", "cRS", "uplink"};
  return convert_enum_idx(names, 3, value, "protected_e_utra_res_item_s::res_type_e_");
}

// ServedCellInformation-E-UTRA-FDDInfo-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t served_cell_info_e_utra_fdd_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {166, 167};
  return map_enum_number(names, 2, idx, "id");
}
bool served_cell_info_e_utra_fdd_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {166, 167};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e served_cell_info_e_utra_fdd_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 166:
      return crit_e::reject;
    case 167:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c
served_cell_info_e_utra_fdd_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 166:
      ret.set(ext_c::types::offset_of_nbiot_ch_num_to_dl_earfcn);
      break;
    case 167:
      ret.set(ext_c::types::offset_of_nbiot_ch_num_to_ul_earfcn);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cell_info_e_utra_fdd_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 166:
      return presence_e::optional;
    case 167:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      c = offset_of_nbiot_ch_num_to_earfcn_e{};
      break;
    case types::offset_of_nbiot_ch_num_to_ul_earfcn:
      c = offset_of_nbiot_ch_num_to_earfcn_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c");
  }
}
offset_of_nbiot_ch_num_to_earfcn_e&
served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::offset_of_nbiot_ch_num_to_dl_earfcn()
{
  assert_choice_type(types::offset_of_nbiot_ch_num_to_dl_earfcn, type_, "Extension");
  return c.get<offset_of_nbiot_ch_num_to_earfcn_e>();
}
offset_of_nbiot_ch_num_to_earfcn_e&
served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::offset_of_nbiot_ch_num_to_ul_earfcn()
{
  assert_choice_type(types::offset_of_nbiot_ch_num_to_ul_earfcn, type_, "Extension");
  return c.get<offset_of_nbiot_ch_num_to_earfcn_e>();
}
const offset_of_nbiot_ch_num_to_earfcn_e&
served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::offset_of_nbiot_ch_num_to_dl_earfcn() const
{
  assert_choice_type(types::offset_of_nbiot_ch_num_to_dl_earfcn, type_, "Extension");
  return c.get<offset_of_nbiot_ch_num_to_earfcn_e>();
}
const offset_of_nbiot_ch_num_to_earfcn_e&
served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::offset_of_nbiot_ch_num_to_ul_earfcn() const
{
  assert_choice_type(types::offset_of_nbiot_ch_num_to_ul_earfcn, type_, "Extension");
  return c.get<offset_of_nbiot_ch_num_to_earfcn_e>();
}
void served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      j.write_str("OffsetOfNbiotChannelNumberToEARFCN", c.get<offset_of_nbiot_ch_num_to_earfcn_e>().to_string());
      break;
    case types::offset_of_nbiot_ch_num_to_ul_earfcn:
      j.write_str("OffsetOfNbiotChannelNumberToEARFCN", c.get<offset_of_nbiot_ch_num_to_earfcn_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      HANDLE_CODE(c.get<offset_of_nbiot_ch_num_to_earfcn_e>().pack(bref));
      break;
    case types::offset_of_nbiot_ch_num_to_ul_earfcn:
      HANDLE_CODE(c.get<offset_of_nbiot_ch_num_to_earfcn_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      HANDLE_CODE(c.get<offset_of_nbiot_ch_num_to_earfcn_e>().unpack(bref));
      break;
    case types::offset_of_nbiot_ch_num_to_ul_earfcn:
      HANDLE_CODE(c.get<offset_of_nbiot_ch_num_to_earfcn_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OffsetOfNbiotChannelNumberToEARFCN", "OffsetOfNbiotChannelNumberToEARFCN"};
  return convert_enum_idx(names, 2, value, "served_cell_info_e_utra_fdd_info_ext_ies_o::ext_c::types");
}

// ServedCellInformation-E-UTRA-TDDInfo-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t served_cell_info_e_utra_tdd_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {166, 168};
  return map_enum_number(names, 2, idx, "id");
}
bool served_cell_info_e_utra_tdd_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {166, 168};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e served_cell_info_e_utra_tdd_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 166:
      return crit_e::reject;
    case 168:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c
served_cell_info_e_utra_tdd_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 166:
      ret.set(ext_c::types::offset_of_nbiot_ch_num_to_dl_earfcn);
      break;
    case 168:
      ret.set(ext_c::types::nb_iot_ul_dl_align_offset);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cell_info_e_utra_tdd_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 166:
      return presence_e::optional;
    case 168:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      c = offset_of_nbiot_ch_num_to_earfcn_e{};
      break;
    case types::nb_iot_ul_dl_align_offset:
      c = nb_iot_ul_dl_align_offset_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c");
  }
}
offset_of_nbiot_ch_num_to_earfcn_e&
served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::offset_of_nbiot_ch_num_to_dl_earfcn()
{
  assert_choice_type(types::offset_of_nbiot_ch_num_to_dl_earfcn, type_, "Extension");
  return c.get<offset_of_nbiot_ch_num_to_earfcn_e>();
}
nb_iot_ul_dl_align_offset_e& served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::nb_iot_ul_dl_align_offset()
{
  assert_choice_type(types::nb_iot_ul_dl_align_offset, type_, "Extension");
  return c.get<nb_iot_ul_dl_align_offset_e>();
}
const offset_of_nbiot_ch_num_to_earfcn_e&
served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::offset_of_nbiot_ch_num_to_dl_earfcn() const
{
  assert_choice_type(types::offset_of_nbiot_ch_num_to_dl_earfcn, type_, "Extension");
  return c.get<offset_of_nbiot_ch_num_to_earfcn_e>();
}
const nb_iot_ul_dl_align_offset_e& served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::nb_iot_ul_dl_align_offset() const
{
  assert_choice_type(types::nb_iot_ul_dl_align_offset, type_, "Extension");
  return c.get<nb_iot_ul_dl_align_offset_e>();
}
void served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      j.write_str("OffsetOfNbiotChannelNumberToEARFCN", c.get<offset_of_nbiot_ch_num_to_earfcn_e>().to_string());
      break;
    case types::nb_iot_ul_dl_align_offset:
      j.write_str("NBIoT-UL-DL-AlignmentOffset", c.get<nb_iot_ul_dl_align_offset_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      HANDLE_CODE(c.get<offset_of_nbiot_ch_num_to_earfcn_e>().pack(bref));
      break;
    case types::nb_iot_ul_dl_align_offset:
      HANDLE_CODE(c.get<nb_iot_ul_dl_align_offset_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::offset_of_nbiot_ch_num_to_dl_earfcn:
      HANDLE_CODE(c.get<offset_of_nbiot_ch_num_to_earfcn_e>().unpack(bref));
      break;
    case types::nb_iot_ul_dl_align_offset:
      HANDLE_CODE(c.get<nb_iot_ul_dl_align_offset_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OffsetOfNbiotChannelNumberToEARFCN", "NBIoT-UL-DL-AlignmentOffset"};
  return convert_enum_idx(names, 2, value, "served_cell_info_e_utra_tdd_info_ext_ies_o::ext_c::types");
}

// SpecialSubframeInfo-E-UTRA ::= SEQUENCE
SRSASN_CODE special_sf_info_e_utra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(special_sf_pattern.pack(bref));
  HANDLE_CODE(cp_dl.pack(bref));
  HANDLE_CODE(cp_ul.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE special_sf_info_e_utra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(special_sf_pattern.unpack(bref));
  HANDLE_CODE(cp_dl.unpack(bref));
  HANDLE_CODE(cp_ul.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void special_sf_info_e_utra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("specialSubframePattern", special_sf_pattern.to_string());
  j.write_str("cyclicPrefixDL", cp_dl.to_string());
  j.write_str("cyclicPrefixUL", cp_ul.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSFNSubframeInfo-E-UTRA-Item ::= SEQUENCE
SRSASN_CODE mbsfn_sf_info_e_utra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(radioframe_alloc_period.pack(bref));
  HANDLE_CODE(pack_integer(bref, radioframe_alloc_offset, (uint8_t)0u, (uint8_t)7u, true, true));
  HANDLE_CODE(sf_alloc.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbsfn_sf_info_e_utra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(radioframe_alloc_period.unpack(bref));
  HANDLE_CODE(unpack_integer(radioframe_alloc_offset, bref, (uint8_t)0u, (uint8_t)7u, true, true));
  HANDLE_CODE(sf_alloc.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbsfn_sf_info_e_utra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("radioframeAllocationPeriod", radioframe_alloc_period.to_string());
  j.write_int("radioframeAllocationOffset", radioframe_alloc_offset);
  j.write_fieldname("subframeAllocation");
  sf_alloc.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* mbsfn_sf_info_e_utra_item_s::radioframe_alloc_period_opts::to_string() const
{
  static const char* names[] = {"n1", "n2", "n4", "n8", "n16", "n32"};
  return convert_enum_idx(names, 6, value, "mbsfn_sf_info_e_utra_item_s::radioframe_alloc_period_e_");
}
uint8_t mbsfn_sf_info_e_utra_item_s::radioframe_alloc_period_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4, 8, 16, 32};
  return map_enum_number(numbers, 6, value, "mbsfn_sf_info_e_utra_item_s::radioframe_alloc_period_e_");
}

// NPRACHConfiguration ::= SEQUENCE
SRSASN_CODE nprach_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(fdd_or_tdd.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nprach_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(fdd_or_tdd.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nprach_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("fdd-or-tdd");
  fdd_or_tdd.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

void nprach_cfg_s::fdd_or_tdd_c_::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<nprach_cfg_fdd_s>();
      break;
    case types::tdd:
      c.destroy<nprach_cfg_tdd_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void nprach_cfg_s::fdd_or_tdd_c_::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<nprach_cfg_fdd_s>();
      break;
    case types::tdd:
      c.init<nprach_cfg_tdd_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nprach_cfg_s::fdd_or_tdd_c_");
  }
}
nprach_cfg_s::fdd_or_tdd_c_::fdd_or_tdd_c_(const nprach_cfg_s::fdd_or_tdd_c_& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<nprach_cfg_fdd_s>());
      break;
    case types::tdd:
      c.init(other.c.get<nprach_cfg_tdd_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nprach_cfg_s::fdd_or_tdd_c_");
  }
}
nprach_cfg_s::fdd_or_tdd_c_& nprach_cfg_s::fdd_or_tdd_c_::operator=(const nprach_cfg_s::fdd_or_tdd_c_& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<nprach_cfg_fdd_s>());
      break;
    case types::tdd:
      c.set(other.c.get<nprach_cfg_tdd_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nprach_cfg_s::fdd_or_tdd_c_");
  }

  return *this;
}
nprach_cfg_fdd_s& nprach_cfg_s::fdd_or_tdd_c_::set_fdd()
{
  set(types::fdd);
  return c.get<nprach_cfg_fdd_s>();
}
nprach_cfg_tdd_s& nprach_cfg_s::fdd_or_tdd_c_::set_tdd()
{
  set(types::tdd);
  return c.get<nprach_cfg_tdd_s>();
}
protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>& nprach_cfg_s::fdd_or_tdd_c_::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>();
}
void nprach_cfg_s::fdd_or_tdd_c_::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fdd");
      c.get<nprach_cfg_fdd_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tdd");
      c.get<nprach_cfg_tdd_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nprach_cfg_s::fdd_or_tdd_c_");
  }
  j.end_obj();
}
SRSASN_CODE nprach_cfg_s::fdd_or_tdd_c_::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<nprach_cfg_fdd_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<nprach_cfg_tdd_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nprach_cfg_s::fdd_or_tdd_c_");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nprach_cfg_s::fdd_or_tdd_c_::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<nprach_cfg_fdd_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<nprach_cfg_tdd_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<fdd_or_tdd_in_nprach_cfg_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nprach_cfg_s::fdd_or_tdd_c_");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nprach_cfg_s::fdd_or_tdd_c_::types_opts::to_string() const
{
  static const char* names[] = {"fdd", "tdd", "choice-extension"};
  return convert_enum_idx(names, 3, value, "nprach_cfg_s::fdd_or_tdd_c_::types");
}

template struct asn1::protocol_ext_field_s<served_cell_info_e_utra_fdd_info_ext_ies_o>;

SRSASN_CODE served_cell_info_e_utra_fdd_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += offset_of_nbiot_ch_num_to_dl_earfcn_present ? 1 : 0;
  nof_ies += offset_of_nbiot_ch_num_to_ul_earfcn_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (offset_of_nbiot_ch_num_to_dl_earfcn_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)166, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(offset_of_nbiot_ch_num_to_dl_earfcn.pack(bref));
  }
  if (offset_of_nbiot_ch_num_to_ul_earfcn_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)167, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(offset_of_nbiot_ch_num_to_ul_earfcn.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_fdd_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 166: {
        offset_of_nbiot_ch_num_to_dl_earfcn_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(offset_of_nbiot_ch_num_to_dl_earfcn.unpack(bref));
        break;
      }
      case 167: {
        offset_of_nbiot_ch_num_to_ul_earfcn_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(offset_of_nbiot_ch_num_to_ul_earfcn.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_e_utra_fdd_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (offset_of_nbiot_ch_num_to_dl_earfcn_present) {
    j.write_int("id", 166);
    j.write_str("criticality", "reject");
    j.write_str("Extension", offset_of_nbiot_ch_num_to_dl_earfcn.to_string());
  }
  if (offset_of_nbiot_ch_num_to_ul_earfcn_present) {
    j.write_int("id", 167);
    j.write_str("criticality", "reject");
    j.write_str("Extension", offset_of_nbiot_ch_num_to_ul_earfcn.to_string());
  }
  j.end_obj();
}

// ServedCellInformation-E-UTRA-FDDInfo ::= SEQUENCE
SRSASN_CODE served_cell_info_e_utra_fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ul_earfcn, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_earfcn, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(ul_e_utra_tx_bw.pack(bref));
  HANDLE_CODE(dl_e_utra_tx_bw.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ul_earfcn, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(unpack_integer(dl_earfcn, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(ul_e_utra_tx_bw.unpack(bref));
  HANDLE_CODE(dl_e_utra_tx_bw.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_e_utra_fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("ul-earfcn", ul_earfcn);
  j.write_int("dl-earfcn", dl_earfcn);
  j.write_str("ul-e-utraTxBW", ul_e_utra_tx_bw.to_string());
  j.write_str("dl-e-utraTxBW", dl_e_utra_tx_bw.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<served_cell_info_e_utra_tdd_info_ext_ies_o>;

SRSASN_CODE served_cell_info_e_utra_tdd_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += offset_of_nbiot_ch_num_to_dl_earfcn_present ? 1 : 0;
  nof_ies += nb_iot_ul_dl_align_offset_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (offset_of_nbiot_ch_num_to_dl_earfcn_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)166, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(offset_of_nbiot_ch_num_to_dl_earfcn.pack(bref));
  }
  if (nb_iot_ul_dl_align_offset_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)168, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_ul_dl_align_offset.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_tdd_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 166: {
        offset_of_nbiot_ch_num_to_dl_earfcn_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(offset_of_nbiot_ch_num_to_dl_earfcn.unpack(bref));
        break;
      }
      case 168: {
        nb_iot_ul_dl_align_offset_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_ul_dl_align_offset.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_e_utra_tdd_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (offset_of_nbiot_ch_num_to_dl_earfcn_present) {
    j.write_int("id", 166);
    j.write_str("criticality", "reject");
    j.write_str("Extension", offset_of_nbiot_ch_num_to_dl_earfcn.to_string());
  }
  if (nb_iot_ul_dl_align_offset_present) {
    j.write_int("id", 168);
    j.write_str("criticality", "reject");
    j.write_str("Extension", nb_iot_ul_dl_align_offset.to_string());
  }
  j.end_obj();
}

// ServedCellInformation-E-UTRA-TDDInfo ::= SEQUENCE
SRSASN_CODE served_cell_info_e_utra_tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, earfcn, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(e_utra_tx_bw.pack(bref));
  HANDLE_CODE(sf_assignmnet.pack(bref));
  HANDLE_CODE(special_sf_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(earfcn, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(e_utra_tx_bw.unpack(bref));
  HANDLE_CODE(sf_assignmnet.unpack(bref));
  HANDLE_CODE(special_sf_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_e_utra_tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("earfcn", earfcn);
  j.write_str("e-utraTxBW", e_utra_tx_bw.to_string());
  j.write_str("subframeAssignmnet", sf_assignmnet.to_string());
  j.write_fieldname("specialSubframeInfo");
  special_sf_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* served_cell_info_e_utra_tdd_info_s::sf_assignmnet_opts::to_string() const
{
  static const char* names[] = {"sa0", "sa1", "sa2", "sa3", "sa4", "sa5", "sa6"};
  return convert_enum_idx(names, 7, value, "served_cell_info_e_utra_tdd_info_s::sf_assignmnet_e_");
}
uint8_t served_cell_info_e_utra_tdd_info_s::sf_assignmnet_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5, 6};
  return map_enum_number(numbers, 7, value, "served_cell_info_e_utra_tdd_info_s::sf_assignmnet_e_");
}

// E-UTRAPRACHConfiguration ::= SEQUENCE
SRSASN_CODE e_utraprach_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(prach_cfg_idx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, root_seq_idx, (uint16_t)0u, (uint16_t)837u, false, true));
  HANDLE_CODE(pack_integer(bref, zero_correlation_idx, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(high_speed_flag.pack(bref));
  HANDLE_CODE(pack_integer(bref, prach_freq_offset, (uint8_t)0u, (uint8_t)94u, false, true));
  if (prach_cfg_idx_present) {
    HANDLE_CODE(pack_integer(bref, prach_cfg_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE e_utraprach_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(prach_cfg_idx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(root_seq_idx, bref, (uint16_t)0u, (uint16_t)837u, false, true));
  HANDLE_CODE(unpack_integer(zero_correlation_idx, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(high_speed_flag.unpack(bref));
  HANDLE_CODE(unpack_integer(prach_freq_offset, bref, (uint8_t)0u, (uint8_t)94u, false, true));
  if (prach_cfg_idx_present) {
    HANDLE_CODE(unpack_integer(prach_cfg_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void e_utraprach_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("rootSequenceIndex", root_seq_idx);
  j.write_int("zeroCorrelationIndex", zero_correlation_idx);
  j.write_str("highSpeedFlag", high_speed_flag.to_string());
  j.write_int("prach-FreqOffset", prach_freq_offset);
  if (prach_cfg_idx_present) {
    j.write_int("prach-ConfigIndex", prach_cfg_idx);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* e_utraprach_cfg_s::high_speed_flag_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "e_utraprach_cfg_s::high_speed_flag_e_");
}

// NumberOfAntennaPorts-E-UTRA ::= ENUMERATED
const char* nof_ant_ports_e_utra_opts::to_string() const
{
  static const char* names[] = {"an1", "an2", "an4"};
  return convert_enum_idx(names, 3, value, "nof_ant_ports_e_utra_e");
}
uint8_t nof_ant_ports_e_utra_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4};
  return map_enum_number(numbers, 3, value, "nof_ant_ports_e_utra_e");
}

// ProtectedE-UTRAResourceIndication ::= SEQUENCE
SRSASN_CODE protected_e_utra_res_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbsfn_ctrl_region_len_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, activation_sfn, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, protected_res_list, 1, 16, true));
  if (mbsfn_ctrl_region_len_present) {
    HANDLE_CODE(pack_integer(bref, mbsfn_ctrl_region_len, (uint8_t)0u, (uint8_t)3u, false, true));
  }
  HANDLE_CODE(pack_integer(bref, pdcch_region_len, (uint8_t)1u, (uint8_t)3u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE protected_e_utra_res_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbsfn_ctrl_region_len_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(activation_sfn, bref, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(protected_res_list, bref, 1, 16, true));
  if (mbsfn_ctrl_region_len_present) {
    HANDLE_CODE(unpack_integer(mbsfn_ctrl_region_len, bref, (uint8_t)0u, (uint8_t)3u, false, true));
  }
  HANDLE_CODE(unpack_integer(pdcch_region_len, bref, (uint8_t)1u, (uint8_t)3u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void protected_e_utra_res_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("activationSFN", activation_sfn);
  j.start_array("protectedResourceList");
  for (const auto& e1 : protected_res_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (mbsfn_ctrl_region_len_present) {
    j.write_int("mbsfnControlRegionLength", mbsfn_ctrl_region_len);
  }
  j.write_int("pDCCHRegionLength", pdcch_region_len);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedCellInformation-E-UTRA-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t served_cell_info_e_utra_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {128, 237};
  return map_enum_number(names, 2, idx, "id");
}
bool served_cell_info_e_utra_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {128, 237};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e served_cell_info_e_utra_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 128:
      return crit_e::ignore;
    case 237:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
served_cell_info_e_utra_ext_ies_o::ext_c served_cell_info_e_utra_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 128:
      ret.set(ext_c::types::bplmn_id_info_eutra);
      break;
    case 237:
      ret.set(ext_c::types::nprach_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cell_info_e_utra_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 128:
      return presence_e::optional;
    case 237:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void served_cell_info_e_utra_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::bplmn_id_info_eutra:
      c = bplmn_id_info_eutra_l{};
      break;
    case types::nprach_cfg:
      c = nprach_cfg_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_ext_ies_o::ext_c");
  }
}
bplmn_id_info_eutra_l& served_cell_info_e_utra_ext_ies_o::ext_c::bplmn_id_info_eutra()
{
  assert_choice_type(types::bplmn_id_info_eutra, type_, "Extension");
  return c.get<bplmn_id_info_eutra_l>();
}
nprach_cfg_s& served_cell_info_e_utra_ext_ies_o::ext_c::nprach_cfg()
{
  assert_choice_type(types::nprach_cfg, type_, "Extension");
  return c.get<nprach_cfg_s>();
}
const bplmn_id_info_eutra_l& served_cell_info_e_utra_ext_ies_o::ext_c::bplmn_id_info_eutra() const
{
  assert_choice_type(types::bplmn_id_info_eutra, type_, "Extension");
  return c.get<bplmn_id_info_eutra_l>();
}
const nprach_cfg_s& served_cell_info_e_utra_ext_ies_o::ext_c::nprach_cfg() const
{
  assert_choice_type(types::nprach_cfg, type_, "Extension");
  return c.get<nprach_cfg_s>();
}
void served_cell_info_e_utra_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::bplmn_id_info_eutra:
      j.start_array("BPLMN-ID-Info-EUTRA");
      for (const auto& e1 : c.get<bplmn_id_info_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nprach_cfg:
      j.write_fieldname("NPRACHConfiguration");
      c.get<nprach_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE served_cell_info_e_utra_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bplmn_id_info_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<bplmn_id_info_eutra_l>(), 1, 6, true));
      break;
    case types::nprach_cfg:
      HANDLE_CODE(c.get<nprach_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bplmn_id_info_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<bplmn_id_info_eutra_l>(), bref, 1, 6, true));
      break;
    case types::nprach_cfg:
      HANDLE_CODE(c.get<nprach_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* served_cell_info_e_utra_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"BPLMN-ID-Info-EUTRA", "NPRACHConfiguration"};
  return convert_enum_idx(names, 2, value, "served_cell_info_e_utra_ext_ies_o::ext_c::types");
}

// ServedCellInformation-E-UTRA-ModeInfo ::= CHOICE
void served_cell_info_e_utra_mode_info_c::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<served_cell_info_e_utra_fdd_info_s>();
      break;
    case types::tdd:
      c.destroy<served_cell_info_e_utra_tdd_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void served_cell_info_e_utra_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<served_cell_info_e_utra_fdd_info_s>();
      break;
    case types::tdd:
      c.init<served_cell_info_e_utra_tdd_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_mode_info_c");
  }
}
served_cell_info_e_utra_mode_info_c::served_cell_info_e_utra_mode_info_c(
    const served_cell_info_e_utra_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<served_cell_info_e_utra_fdd_info_s>());
      break;
    case types::tdd:
      c.init(other.c.get<served_cell_info_e_utra_tdd_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_mode_info_c");
  }
}
served_cell_info_e_utra_mode_info_c&
served_cell_info_e_utra_mode_info_c::operator=(const served_cell_info_e_utra_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<served_cell_info_e_utra_fdd_info_s>());
      break;
    case types::tdd:
      c.set(other.c.get<served_cell_info_e_utra_tdd_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_mode_info_c");
  }

  return *this;
}
served_cell_info_e_utra_fdd_info_s& served_cell_info_e_utra_mode_info_c::set_fdd()
{
  set(types::fdd);
  return c.get<served_cell_info_e_utra_fdd_info_s>();
}
served_cell_info_e_utra_tdd_info_s& served_cell_info_e_utra_mode_info_c::set_tdd()
{
  set(types::tdd);
  return c.get<served_cell_info_e_utra_tdd_info_s>();
}
protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>&
served_cell_info_e_utra_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>();
}
void served_cell_info_e_utra_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fdd");
      c.get<served_cell_info_e_utra_fdd_info_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tdd");
      c.get<served_cell_info_e_utra_tdd_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE served_cell_info_e_utra_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<served_cell_info_e_utra_fdd_info_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<served_cell_info_e_utra_tdd_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<served_cell_info_e_utra_fdd_info_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<served_cell_info_e_utra_tdd_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<served_cell_info_e_utra_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_e_utra_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* served_cell_info_e_utra_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fdd", "tdd", "choice-extension"};
  return convert_enum_idx(names, 3, value, "served_cell_info_e_utra_mode_info_c::types");
}

// ServedCellInformation-E-UTRA-perBPLMN ::= SEQUENCE
SRSASN_CODE served_cell_info_e_utra_per_bplmn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_per_bplmn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_e_utra_per_bplmn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-id", plmn_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Served-cells-ToModify-E-UTRA-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t served_cells_to_modify_e_utra_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {242};
  return map_enum_number(names, 1, idx, "id");
}
bool served_cells_to_modify_e_utra_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 242 == id;
}
crit_e served_cells_to_modify_e_utra_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 242) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
served_cells_to_modify_e_utra_item_ext_ies_o::ext_c
served_cells_to_modify_e_utra_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 242) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cells_to_modify_e_utra_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 242) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void served_cells_to_modify_e_utra_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SFN-Offset");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE served_cells_to_modify_e_utra_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_modify_e_utra_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* served_cells_to_modify_e_utra_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SFN-Offset"};
  return convert_enum_idx(names, 1, value, "served_cells_to_modify_e_utra_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<served_cell_info_e_utra_ext_ies_o>;

SRSASN_CODE served_cell_info_e_utra_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += bplmn_id_info_eutra_present ? 1 : 0;
  nof_ies += nprach_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (bplmn_id_info_eutra_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)128, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, bplmn_id_info_eutra, 1, 6, true));
  }
  if (nprach_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)237, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nprach_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 128: {
        bplmn_id_info_eutra_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(bplmn_id_info_eutra, bref, 1, 6, true));
        break;
      }
      case 237: {
        nprach_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nprach_cfg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_e_utra_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (bplmn_id_info_eutra_present) {
    j.write_int("id", 128);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : bplmn_id_info_eutra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (nprach_cfg_present) {
    j.write_int("id", 237);
    j.write_str("criticality", "ignore");
    nprach_cfg.to_json(j);
  }
  j.end_obj();
}

// ServedCellInformation-E-UTRA ::= SEQUENCE
SRSASN_CODE served_cell_info_e_utra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(numof_ant_ports_present, 1));
  HANDLE_CODE(bref.pack(prach_cfg_present, 1));
  HANDLE_CODE(bref.pack(mbsfn_sf_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(multiband_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(freq_band_ind_prio_present, 1));
  HANDLE_CODE(bref.pack(bw_reduced_si_present, 1));
  HANDLE_CODE(bref.pack(protected_e_utra_res_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, e_utra_pci, (uint16_t)0u, (uint16_t)503u, true, true));
  HANDLE_CODE(e_utra_cgi.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmns, 1, 12, true));
  HANDLE_CODE(e_utra_mode_info.pack(bref));
  if (numof_ant_ports_present) {
    HANDLE_CODE(numof_ant_ports.pack(bref));
  }
  if (prach_cfg_present) {
    HANDLE_CODE(prach_cfg.pack(bref));
  }
  if (mbsfn_sf_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbsfn_sf_info, 1, 8, true));
  }
  if (multiband_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, multiband_info, 1, 16, integer_packer<uint16_t>(1, 256, true, true)));
  }
  if (freq_band_ind_prio_present) {
    HANDLE_CODE(freq_band_ind_prio.pack(bref));
  }
  if (bw_reduced_si_present) {
    HANDLE_CODE(bw_reduced_si.pack(bref));
  }
  if (protected_e_utra_res_ind_present) {
    HANDLE_CODE(protected_e_utra_res_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_e_utra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(numof_ant_ports_present, 1));
  HANDLE_CODE(bref.unpack(prach_cfg_present, 1));
  bool mbsfn_sf_info_present;
  HANDLE_CODE(bref.unpack(mbsfn_sf_info_present, 1));
  bool multiband_info_present;
  HANDLE_CODE(bref.unpack(multiband_info_present, 1));
  HANDLE_CODE(bref.unpack(freq_band_ind_prio_present, 1));
  HANDLE_CODE(bref.unpack(bw_reduced_si_present, 1));
  HANDLE_CODE(bref.unpack(protected_e_utra_res_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(e_utra_pci, bref, (uint16_t)0u, (uint16_t)503u, true, true));
  HANDLE_CODE(e_utra_cgi.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmns, bref, 1, 12, true));
  HANDLE_CODE(e_utra_mode_info.unpack(bref));
  if (numof_ant_ports_present) {
    HANDLE_CODE(numof_ant_ports.unpack(bref));
  }
  if (prach_cfg_present) {
    HANDLE_CODE(prach_cfg.unpack(bref));
  }
  if (mbsfn_sf_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbsfn_sf_info, bref, 1, 8, true));
  }
  if (multiband_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(multiband_info, bref, 1, 16, integer_packer<uint16_t>(1, 256, true, true)));
  }
  if (freq_band_ind_prio_present) {
    HANDLE_CODE(freq_band_ind_prio.unpack(bref));
  }
  if (bw_reduced_si_present) {
    HANDLE_CODE(bw_reduced_si.unpack(bref));
  }
  if (protected_e_utra_res_ind_present) {
    HANDLE_CODE(protected_e_utra_res_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_e_utra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-utra-pci", e_utra_pci);
  j.write_fieldname("e-utra-cgi");
  e_utra_cgi.to_json(j);
  j.write_str("tac", tac.to_string());
  if (ranac_present) {
    j.write_int("ranac", ranac);
  }
  j.start_array("broadcastPLMNs");
  for (const auto& e1 : broadcast_plmns) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("e-utra-mode-info");
  e_utra_mode_info.to_json(j);
  if (numof_ant_ports_present) {
    j.write_str("numberofAntennaPorts", numof_ant_ports.to_string());
  }
  if (prach_cfg_present) {
    j.write_fieldname("prach-configuration");
    prach_cfg.to_json(j);
  }
  if (mbsfn_sf_info.size() > 0) {
    j.start_array("mBSFNsubframeInfo");
    for (const auto& e1 : mbsfn_sf_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (multiband_info.size() > 0) {
    j.start_array("multibandInfo");
    for (const auto& e1 : multiband_info) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (freq_band_ind_prio_present) {
    j.write_str("freqBandIndicatorPriority", freq_band_ind_prio.to_string());
  }
  if (bw_reduced_si_present) {
    j.write_str("bandwidthReducedSI", "scheduled");
  }
  if (protected_e_utra_res_ind_present) {
    j.write_fieldname("protectedE-UTRAResourceIndication");
    protected_e_utra_res_ind.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* served_cell_info_e_utra_s::freq_band_ind_prio_opts::to_string() const
{
  static const char* names[] = {"not-broadcast", "broadcast"};
  return convert_enum_idx(names, 2, value, "served_cell_info_e_utra_s::freq_band_ind_prio_e_");
}

const char* served_cell_info_e_utra_s::bw_reduced_si_opts::to_string() const
{
  static const char* names[] = {"scheduled"};
  return convert_enum_idx(names, 1, value, "served_cell_info_e_utra_s::bw_reduced_si_e_");
}

// ServedCells-E-UTRA-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t served_cells_e_utra_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {242};
  return map_enum_number(names, 1, idx, "id");
}
bool served_cells_e_utra_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 242 == id;
}
crit_e served_cells_e_utra_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 242) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
served_cells_e_utra_item_ext_ies_o::ext_c served_cells_e_utra_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 242) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cells_e_utra_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 242) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void served_cells_e_utra_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SFN-Offset");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE served_cells_e_utra_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_e_utra_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* served_cells_e_utra_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SFN-Offset"};
  return convert_enum_idx(names, 1, value, "served_cells_e_utra_item_ext_ies_o::ext_c::types");
}

// ServedCells-E-UTRA-Item ::= SEQUENCE
SRSASN_CODE served_cells_e_utra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(neighbour_info_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(neighbour_info_e_utra.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(served_cell_info_e_utra.pack(bref));
  if (neighbour_info_nr.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_nr, 1, 1024, true));
  }
  if (neighbour_info_e_utra.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_e_utra, 1, 1024, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_e_utra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool neighbour_info_nr_present;
  HANDLE_CODE(bref.unpack(neighbour_info_nr_present, 1));
  bool neighbour_info_e_utra_present;
  HANDLE_CODE(bref.unpack(neighbour_info_e_utra_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(served_cell_info_e_utra.unpack(bref));
  if (neighbour_info_nr_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_nr, bref, 1, 1024, true));
  }
  if (neighbour_info_e_utra_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_e_utra, bref, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void served_cells_e_utra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("served-cell-info-E-UTRA");
  served_cell_info_e_utra.to_json(j);
  if (neighbour_info_nr.size() > 0) {
    j.start_array("neighbour-info-NR");
    for (const auto& e1 : neighbour_info_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (neighbour_info_e_utra.size() > 0) {
    j.start_array("neighbour-info-E-UTRA");
    for (const auto& e1 : neighbour_info_e_utra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// ServedCells-ToModify-E-UTRA-Item ::= SEQUENCE
SRSASN_CODE served_cells_to_modify_e_utra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(neighbour_info_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(neighbour_info_e_utra.size() > 0, 1));
  HANDLE_CODE(bref.pack(deactivation_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(old_ecgi.pack(bref));
  HANDLE_CODE(served_cell_info_e_utra.pack(bref));
  if (neighbour_info_nr.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_nr, 1, 1024, true));
  }
  if (neighbour_info_e_utra.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_info_e_utra, 1, 1024, true));
  }
  if (deactivation_ind_present) {
    HANDLE_CODE(deactivation_ind.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_modify_e_utra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool neighbour_info_nr_present;
  HANDLE_CODE(bref.unpack(neighbour_info_nr_present, 1));
  bool neighbour_info_e_utra_present;
  HANDLE_CODE(bref.unpack(neighbour_info_e_utra_present, 1));
  HANDLE_CODE(bref.unpack(deactivation_ind_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(old_ecgi.unpack(bref));
  HANDLE_CODE(served_cell_info_e_utra.unpack(bref));
  if (neighbour_info_nr_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_nr, bref, 1, 1024, true));
  }
  if (neighbour_info_e_utra_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_info_e_utra, bref, 1, 1024, true));
  }
  if (deactivation_ind_present) {
    HANDLE_CODE(deactivation_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void served_cells_to_modify_e_utra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("old-ECGI");
  old_ecgi.to_json(j);
  j.write_fieldname("served-cell-info-E-UTRA");
  served_cell_info_e_utra.to_json(j);
  if (neighbour_info_nr.size() > 0) {
    j.start_array("neighbour-info-NR");
    for (const auto& e1 : neighbour_info_nr) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (neighbour_info_e_utra.size() > 0) {
    j.start_array("neighbour-info-E-UTRA");
    for (const auto& e1 : neighbour_info_e_utra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (deactivation_ind_present) {
    j.write_str("deactivation-indication", "deactivated");
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* served_cells_to_modify_e_utra_item_s::deactivation_ind_opts::to_string() const
{
  static const char* names[] = {"deactivated"};
  return convert_enum_idx(names, 1, value, "served_cells_to_modify_e_utra_item_s::deactivation_ind_e_");
}

// ServedCellsToUpdate-E-UTRA ::= SEQUENCE
SRSASN_CODE served_cells_to_upd_e_utra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(served_cells_to_add_e_utra.size() > 0, 1));
  HANDLE_CODE(bref.pack(served_cells_to_modify_e_utra.size() > 0, 1));
  HANDLE_CODE(bref.pack(served_cells_to_delete_e_utra.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (served_cells_to_add_e_utra.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, served_cells_to_add_e_utra, 1, 16384, true));
  }
  if (served_cells_to_modify_e_utra.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, served_cells_to_modify_e_utra, 1, 16384, true));
  }
  if (served_cells_to_delete_e_utra.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, served_cells_to_delete_e_utra, 1, 16384, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_upd_e_utra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool served_cells_to_add_e_utra_present;
  HANDLE_CODE(bref.unpack(served_cells_to_add_e_utra_present, 1));
  bool served_cells_to_modify_e_utra_present;
  HANDLE_CODE(bref.unpack(served_cells_to_modify_e_utra_present, 1));
  bool served_cells_to_delete_e_utra_present;
  HANDLE_CODE(bref.unpack(served_cells_to_delete_e_utra_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (served_cells_to_add_e_utra_present) {
    HANDLE_CODE(unpack_dyn_seq_of(served_cells_to_add_e_utra, bref, 1, 16384, true));
  }
  if (served_cells_to_modify_e_utra_present) {
    HANDLE_CODE(unpack_dyn_seq_of(served_cells_to_modify_e_utra, bref, 1, 16384, true));
  }
  if (served_cells_to_delete_e_utra_present) {
    HANDLE_CODE(unpack_dyn_seq_of(served_cells_to_delete_e_utra, bref, 1, 16384, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cells_to_upd_e_utra_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (served_cells_to_add_e_utra.size() > 0) {
    j.start_array("served-Cells-ToAdd-E-UTRA");
    for (const auto& e1 : served_cells_to_add_e_utra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (served_cells_to_modify_e_utra.size() > 0) {
    j.start_array("served-Cells-ToModify-E-UTRA");
    for (const auto& e1 : served_cells_to_modify_e_utra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (served_cells_to_delete_e_utra.size() > 0) {
    j.start_array("served-Cells-ToDelete-E-UTRA");
    for (const auto& e1 : served_cells_to_delete_e_utra) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CoverageModificationCause ::= ENUMERATED
const char* coverage_mod_cause_opts::to_string() const
{
  static const char* names[] = {"coverage", "cell-edge-capacity"};
  return convert_enum_idx(names, 2, value, "coverage_mod_cause_e");
}

// SSB-Coverage-Modification-List-Item ::= SEQUENCE
SRSASN_CODE ssb_coverage_mod_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_coverage_state, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_coverage_mod_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(ssb_coverage_state, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_coverage_mod_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_int("sSBCoverageState", ssb_coverage_state);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// CellDeploymentStatusIndicator ::= ENUMERATED
const char* cell_deployment_status_ind_opts::to_string() const
{
  static const char* names[] = {"pre-change-notification"};
  return convert_enum_idx(names, 1, value, "cell_deployment_status_ind_e");
}

// Coverage-Modification-List-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t coverage_mod_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {368};
  return map_enum_number(names, 1, idx, "id");
}
bool coverage_mod_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 368 == id;
}
crit_e coverage_mod_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 368) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
coverage_mod_list_item_ext_ies_o::ext_c coverage_mod_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 368) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e coverage_mod_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 368) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void coverage_mod_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("CoverageModificationCause", c.to_string());
  j.end_obj();
}
SRSASN_CODE coverage_mod_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE coverage_mod_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* coverage_mod_list_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"CoverageModificationCause"};
  return convert_enum_idx(names, 1, value, "coverage_mod_list_item_ext_ies_o::ext_c::types");
}

// Coverage-Modification-List-Item ::= SEQUENCE
SRSASN_CODE coverage_mod_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cell_deployment_status_ind_present, 1));
  HANDLE_CODE(bref.pack(cell_replacing_info_present, 1));
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(global_ng_ran_cell_id.pack(bref));
  HANDLE_CODE(pack_integer(bref, cell_coverage_state, (uint8_t)0u, (uint8_t)63u, true, true));
  if (cell_deployment_status_ind_present) {
    HANDLE_CODE(cell_deployment_status_ind.pack(bref));
  }
  if (cell_replacing_info_present) {
    HANDLE_CODE(cell_replacing_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, ssb_coverage_mod_list, 0, 64, true));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE coverage_mod_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cell_deployment_status_ind_present, 1));
  HANDLE_CODE(bref.unpack(cell_replacing_info_present, 1));
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(global_ng_ran_cell_id.unpack(bref));
  HANDLE_CODE(unpack_integer(cell_coverage_state, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (cell_deployment_status_ind_present) {
    HANDLE_CODE(cell_deployment_status_ind.unpack(bref));
  }
  if (cell_replacing_info_present) {
    HANDLE_CODE(cell_replacing_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(ssb_coverage_mod_list, bref, 0, 64, true));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void coverage_mod_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalNG-RANCell-ID");
  global_ng_ran_cell_id.to_json(j);
  j.write_int("cellCoverageState", cell_coverage_state);
  if (cell_deployment_status_ind_present) {
    j.write_str("cellDeploymentStatusIndicator", "pre-change-notification");
  }
  if (cell_replacing_info_present) {
    j.write_fieldname("cellReplacingInfo");
    cell_replacing_info.to_json(j);
  }
  j.start_array("sSB-Coverage-Modification-List");
  for (const auto& e1 : ssb_coverage_mod_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// DAPSRequestInfo ::= SEQUENCE
SRSASN_CODE daps_request_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(daps_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_request_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(daps_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_request_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dapsIndicator", "daps-HO-required");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* daps_request_info_s::daps_ind_opts::to_string() const
{
  static const char* names[] = {"daps-HO-required"};
  return convert_enum_idx(names, 1, value, "daps_request_info_s::daps_ind_e_");
}

// DAPSResponseInfo-Item ::= SEQUENCE
SRSASN_CODE daps_resp_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(daps_resp_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_resp_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(daps_resp_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_resp_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drbID", drb_id);
  j.write_str("dapsResponseIndicator", daps_resp_ind.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* daps_resp_info_item_s::daps_resp_ind_opts::to_string() const
{
  static const char* names[] = {"daps-HO-accepted", "daps-HO-not-accepted"};
  return convert_enum_idx(names, 2, value, "daps_resp_info_item_s::daps_resp_ind_e_");
}

// DLCountChoice ::= CHOICE
void dl_count_choice_c::destroy_()
{
  switch (type_) {
    case types::count12bits:
      c.destroy<count_pdcp_sn12_s>();
      break;
    case types::count18bits:
      c.destroy<count_pdcp_sn18_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void dl_count_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::count12bits:
      c.init<count_pdcp_sn12_s>();
      break;
    case types::count18bits:
      c.init<count_pdcp_sn18_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_count_choice_c");
  }
}
dl_count_choice_c::dl_count_choice_c(const dl_count_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::count12bits:
      c.init(other.c.get<count_pdcp_sn12_s>());
      break;
    case types::count18bits:
      c.init(other.c.get<count_pdcp_sn18_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_count_choice_c");
  }
}
dl_count_choice_c& dl_count_choice_c::operator=(const dl_count_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::count12bits:
      c.set(other.c.get<count_pdcp_sn12_s>());
      break;
    case types::count18bits:
      c.set(other.c.get<count_pdcp_sn18_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_count_choice_c");
  }

  return *this;
}
count_pdcp_sn12_s& dl_count_choice_c::set_count12bits()
{
  set(types::count12bits);
  return c.get<count_pdcp_sn12_s>();
}
count_pdcp_sn18_s& dl_count_choice_c::set_count18bits()
{
  set(types::count18bits);
  return c.get<count_pdcp_sn18_s>();
}
protocol_ie_single_container_s<dl_count_choice_ext_ies_o>& dl_count_choice_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>();
}
void dl_count_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::count12bits:
      j.write_fieldname("count12bits");
      c.get<count_pdcp_sn12_s>().to_json(j);
      break;
    case types::count18bits:
      j.write_fieldname("count18bits");
      c.get<count_pdcp_sn18_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_count_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_count_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::count12bits:
      HANDLE_CODE(c.get<count_pdcp_sn12_s>().pack(bref));
      break;
    case types::count18bits:
      HANDLE_CODE(c.get<count_pdcp_sn18_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_count_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_count_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::count12bits:
      HANDLE_CODE(c.get<count_pdcp_sn12_s>().unpack(bref));
      break;
    case types::count18bits:
      HANDLE_CODE(c.get<count_pdcp_sn18_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_count_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_count_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_count_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"count12bits", "count18bits", "choice-extension"};
  return convert_enum_idx(names, 3, value, "dl_count_choice_c::types");
}
uint8_t dl_count_choice_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "dl_count_choice_c::types");
}

// DRBsSubjectToDLDiscarding-Item ::= SEQUENCE
SRSASN_CODE drbs_subject_to_dl_discarding_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(dl_count.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_dl_discarding_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(dl_count.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_subject_to_dl_discarding_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drbID", drb_id);
  j.write_fieldname("dlCount");
  dl_count.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DLF1Terminating-BHInfo ::= SEQUENCE
SRSASN_CODE dl_f1_terminating_bh_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(egress_bap_routing_id.pack(bref));
  HANDLE_CODE(egress_bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_f1_terminating_bh_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(egress_bap_routing_id.unpack(bref));
  HANDLE_CODE(egress_bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_f1_terminating_bh_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("egressBAPRoutingID");
  egress_bap_routing_id.to_json(j);
  j.write_str("egressBHRLCCHID", egress_bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-QoS-Mapping-Information ::= SEQUENCE
SRSASN_CODE iab_qos_map_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dscp_present, 1));
  HANDLE_CODE(bref.pack(flow_label_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dscp_present) {
    HANDLE_CODE(dscp.pack(bref));
  }
  if (flow_label_present) {
    HANDLE_CODE(flow_label.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_qos_map_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dscp_present, 1));
  HANDLE_CODE(bref.unpack(flow_label_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dscp_present) {
    HANDLE_CODE(dscp.unpack(bref));
  }
  if (flow_label_present) {
    HANDLE_CODE(flow_label.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_qos_map_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dscp_present) {
    j.write_str("dscp", dscp.to_string());
  }
  if (flow_label_present) {
    j.write_str("flow-label", flow_label.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DLNonF1Terminating-BHInfo ::= SEQUENCE
SRSASN_CODE dl_non_f1_terminating_bh_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.pack(bref));
  HANDLE_CODE(ingress_bh_rlc_ch_id.pack(bref));
  HANDLE_CODE(priorhop_bap_address.pack(bref));
  HANDLE_CODE(iabqos_map_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_f1_terminating_bh_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.unpack(bref));
  HANDLE_CODE(ingress_bh_rlc_ch_id.unpack(bref));
  HANDLE_CODE(priorhop_bap_address.unpack(bref));
  HANDLE_CODE(iabqos_map_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_non_f1_terminating_bh_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ingressBAPRoutingID");
  ingress_bap_routing_id.to_json(j);
  j.write_str("ingressBHRLCCHID", ingress_bh_rlc_ch_id.to_string());
  j.write_str("priorhopBAPAddress", priorhop_bap_address.to_string());
  j.write_fieldname("iabqosMappingInformation");
  iabqos_map_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RLCMode ::= ENUMERATED
const char* rlc_mode_opts::to_string() const
{
  static const char* names[] = {
      "rlc-am", "rlc-um-bidirectional", "rlc-um-unidirectional-ul", "rlc-um-unidirectional-dl"};
  return convert_enum_idx(names, 4, value, "rlc_mode_e");
}

// DRB-List-withCause-Item ::= SEQUENCE
SRSASN_CODE drb_list_with_cause_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(rlc_mode_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(cause.pack(bref));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_list_with_cause_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(rlc_mode_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(cause.unpack(bref));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_list_with_cause_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-id", drb_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (rlc_mode_present) {
    j.write_str("rLC-Mode", rlc_mode.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBBStatusTransfer12bitsSN ::= SEQUENCE
SRSASN_CODE drb_b_status_transfer12bits_sn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(receive_statusof_pdcp_sdu_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (receive_statusof_pdcp_sdu_present) {
    HANDLE_CODE(receive_statusof_pdcp_sdu.pack(bref));
  }
  HANDLE_CODE(count_value.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_b_status_transfer12bits_sn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(receive_statusof_pdcp_sdu_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (receive_statusof_pdcp_sdu_present) {
    HANDLE_CODE(receive_statusof_pdcp_sdu.unpack(bref));
  }
  HANDLE_CODE(count_value.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_b_status_transfer12bits_sn_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (receive_statusof_pdcp_sdu_present) {
    j.write_str("receiveStatusofPDCPSDU", receive_statusof_pdcp_sdu.to_string());
  }
  j.write_fieldname("cOUNTValue");
  count_value.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBBStatusTransfer18bitsSN ::= SEQUENCE
SRSASN_CODE drb_b_status_transfer18bits_sn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(receive_statusof_pdcp_sdu_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (receive_statusof_pdcp_sdu_present) {
    HANDLE_CODE(receive_statusof_pdcp_sdu.pack(bref));
  }
  HANDLE_CODE(count_value.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_b_status_transfer18bits_sn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(receive_statusof_pdcp_sdu_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (receive_statusof_pdcp_sdu_present) {
    HANDLE_CODE(receive_statusof_pdcp_sdu.unpack(bref));
  }
  HANDLE_CODE(count_value.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_b_status_transfer18bits_sn_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (receive_statusof_pdcp_sdu_present) {
    j.write_str("receiveStatusofPDCPSDU", receive_statusof_pdcp_sdu.to_string());
  }
  j.write_fieldname("cOUNTValue");
  count_value.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBBStatusTransferChoice ::= CHOICE
void drb_b_status_transfer_choice_c::destroy_()
{
  switch (type_) {
    case types::pdcp_sn_12bits:
      c.destroy<drb_b_status_transfer12bits_sn_s>();
      break;
    case types::pdcp_sn_18bits:
      c.destroy<drb_b_status_transfer18bits_sn_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void drb_b_status_transfer_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdcp_sn_12bits:
      c.init<drb_b_status_transfer12bits_sn_s>();
      break;
    case types::pdcp_sn_18bits:
      c.init<drb_b_status_transfer18bits_sn_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_b_status_transfer_choice_c");
  }
}
drb_b_status_transfer_choice_c::drb_b_status_transfer_choice_c(const drb_b_status_transfer_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdcp_sn_12bits:
      c.init(other.c.get<drb_b_status_transfer12bits_sn_s>());
      break;
    case types::pdcp_sn_18bits:
      c.init(other.c.get<drb_b_status_transfer18bits_sn_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_b_status_transfer_choice_c");
  }
}
drb_b_status_transfer_choice_c& drb_b_status_transfer_choice_c::operator=(const drb_b_status_transfer_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdcp_sn_12bits:
      c.set(other.c.get<drb_b_status_transfer12bits_sn_s>());
      break;
    case types::pdcp_sn_18bits:
      c.set(other.c.get<drb_b_status_transfer18bits_sn_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_b_status_transfer_choice_c");
  }

  return *this;
}
drb_b_status_transfer12bits_sn_s& drb_b_status_transfer_choice_c::set_pdcp_sn_12bits()
{
  set(types::pdcp_sn_12bits);
  return c.get<drb_b_status_transfer12bits_sn_s>();
}
drb_b_status_transfer18bits_sn_s& drb_b_status_transfer_choice_c::set_pdcp_sn_18bits()
{
  set(types::pdcp_sn_18bits);
  return c.get<drb_b_status_transfer18bits_sn_s>();
}
protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>& drb_b_status_transfer_choice_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>();
}
void drb_b_status_transfer_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdcp_sn_12bits:
      j.write_fieldname("pdcp-sn-12bits");
      c.get<drb_b_status_transfer12bits_sn_s>().to_json(j);
      break;
    case types::pdcp_sn_18bits:
      j.write_fieldname("pdcp-sn-18bits");
      c.get<drb_b_status_transfer18bits_sn_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drb_b_status_transfer_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE drb_b_status_transfer_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pdcp_sn_12bits:
      HANDLE_CODE(c.get<drb_b_status_transfer12bits_sn_s>().pack(bref));
      break;
    case types::pdcp_sn_18bits:
      HANDLE_CODE(c.get<drb_b_status_transfer18bits_sn_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_b_status_transfer_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_b_status_transfer_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pdcp_sn_12bits:
      HANDLE_CODE(c.get<drb_b_status_transfer12bits_sn_s>().unpack(bref));
      break;
    case types::pdcp_sn_18bits:
      HANDLE_CODE(c.get<drb_b_status_transfer18bits_sn_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_b_status_transfer_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_b_status_transfer_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drb_b_status_transfer_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"pdcp-sn-12bits", "pdcp-sn-18bits", "choice-extension"};
  return convert_enum_idx(names, 3, value, "drb_b_status_transfer_choice_c::types");
}
int8_t drb_b_status_transfer_choice_c::types_opts::to_number() const
{
  static const int8_t numbers[] = {-12, -18};
  return map_enum_number(numbers, 2, value, "drb_b_status_transfer_choice_c::types");
}

// QoSFlowMappingIndication ::= ENUMERATED
const char* qos_flow_map_ind_opts::to_string() const
{
  static const char* names[] = {"ul", "dl"};
  return convert_enum_idx(names, 2, value, "qos_flow_map_ind_e");
}

// QoSFlow-Item ::= SEQUENCE
SRSASN_CODE qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, qfi, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(qfi, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qfi", qfi);
  if (qos_flow_map_ind_present) {
    j.write_str("qosFlowMappingIndication", qos_flow_map_ind.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBToQoSFlowMapping-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drb_to_qos_flow_map_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {163};
  return map_enum_number(names, 1, idx, "id");
}
bool drb_to_qos_flow_map_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 163 == id;
}
crit_e drb_to_qos_flow_map_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 163) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drb_to_qos_flow_map_item_ext_ies_o::ext_c drb_to_qos_flow_map_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 163) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drb_to_qos_flow_map_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 163) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drb_to_qos_flow_map_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("DAPSRequestInfo");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE drb_to_qos_flow_map_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_to_qos_flow_map_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* drb_to_qos_flow_map_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DAPSRequestInfo"};
  return convert_enum_idx(names, 1, value, "drb_to_qos_flow_map_item_ext_ies_o::ext_c::types");
}

// DRBToQoSFlowMapping-Item ::= SEQUENCE
SRSASN_CODE drb_to_qos_flow_map_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(rlc_mode_present, 1));
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_list, 1, 64, true));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_to_qos_flow_map_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(rlc_mode_present, 1));
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_list, bref, 1, 64, true));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drb_to_qos_flow_map_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  j.start_array("qosFlows-List");
  for (const auto& e1 : qos_flows_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (rlc_mode_present) {
    j.write_str("rLC-Mode", rlc_mode.to_string());
  }
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// QoS-Mapping-Information ::= SEQUENCE
SRSASN_CODE qos_map_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dscp_present, 1));
  HANDLE_CODE(bref.pack(flow_label_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dscp_present) {
    HANDLE_CODE(dscp.pack(bref));
  }
  if (flow_label_present) {
    HANDLE_CODE(flow_label.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_map_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dscp_present, 1));
  HANDLE_CODE(bref.unpack(flow_label_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dscp_present) {
    HANDLE_CODE(dscp.unpack(bref));
  }
  if (flow_label_present) {
    HANDLE_CODE(flow_label.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_map_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dscp_present) {
    j.write_str("dscp", dscp.to_string());
  }
  if (flow_label_present) {
    j.write_str("flow-label", flow_label.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportParametersItem-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t up_transport_params_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {250};
  return map_enum_number(names, 1, idx, "id");
}
bool up_transport_params_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 250 == id;
}
crit_e up_transport_params_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 250) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
up_transport_params_item_ext_ies_o::ext_c up_transport_params_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 250) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e up_transport_params_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 250) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void up_transport_params_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("QoS-Mapping-Information");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE up_transport_params_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_params_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* up_transport_params_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QoS-Mapping-Information"};
  return convert_enum_idx(names, 1, value, "up_transport_params_item_ext_ies_o::ext_c::types");
}

// UPTransportParametersItem ::= SEQUENCE
SRSASN_CODE up_transport_params_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(up_tnl_info.pack(bref));
  HANDLE_CODE(pack_integer(bref, cell_group_id, (uint8_t)0u, (uint8_t)3u, false, true));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_params_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(up_tnl_info.unpack(bref));
  HANDLE_CODE(unpack_integer(cell_group_id, bref, (uint8_t)0u, (uint8_t)3u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void up_transport_params_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("upTNLInfo");
  up_tnl_info.to_json(j);
  j.write_int("cellGroupID", cell_group_id);
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// DRBsAdmittedList-ModConfirm-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 216 == id;
}
crit_e drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 216) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::ext_c
drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 216) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 216) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("Additional-PDCP-Duplication-TNL-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 2, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 2, true));
  return SRSASN_SUCCESS;
}

const char* drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List"};
  return convert_enum_idx(names, 1, value, "drbs_admitted_list_mod_confirm_sn_terminated_item_ext_ies_o::ext_c::types");
}

// DRBsAdmittedList-ModConfirm-SNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_admitted_list_mod_confirm_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mn_dl_cg_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(secondary_mn_dl_cg_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (mn_dl_cg_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mn_dl_cg_up_tnl_info, 1, 4, true));
  }
  if (secondary_mn_dl_cg_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_mn_dl_cg_up_tnl_info, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_mod_confirm_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mn_dl_cg_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(mn_dl_cg_up_tnl_info_present, 1));
  bool secondary_mn_dl_cg_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_mn_dl_cg_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (mn_dl_cg_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mn_dl_cg_up_tnl_info, bref, 1, 4, true));
  }
  if (secondary_mn_dl_cg_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_mn_dl_cg_up_tnl_info, bref, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_admitted_list_mod_confirm_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (mn_dl_cg_up_tnl_info.size() > 0) {
    j.start_array("mN-DL-CG-UP-TNLInfo");
    for (const auto& e1 : mn_dl_cg_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (secondary_mn_dl_cg_up_tnl_info.size() > 0) {
    j.start_array("secondary-MN-DL-CG-UP-TNLInfo");
    for (const auto& e1 : secondary_mn_dl_cg_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QoSFlowsMappedtoDRB-SetupResponse-MNterminated-Item ::= SEQUENCE
SRSASN_CODE qos_flows_mappedto_drb_setup_resp_m_nterminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(pack_integer(bref, current_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_mappedto_drb_setup_resp_m_nterminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(unpack_integer(current_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_mappedto_drb_setup_resp_m_nterminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSFlowIdentifier", qos_flow_id);
  j.write_int("currentQoSParaSetIndex", current_qos_para_set_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsAdmittedList-ModificationResponse-MNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 239};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 239};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 239:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c
drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 239:
      ret.set(ext_c::types::qos_flows_mappedto_drb_setup_resp_m_nterminated);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 239:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      c = qos_flows_mappedto_drb_setup_resp_m_nterminated_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l& drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
qos_flows_mappedto_drb_setup_resp_m_nterminated_l&
drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::qos_flows_mappedto_drb_setup_resp_m_nterminated()
{
  assert_choice_type(types::qos_flows_mappedto_drb_setup_resp_m_nterminated, type_, "Extension");
  return c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const qos_flows_mappedto_drb_setup_resp_m_nterminated_l&
drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::qos_flows_mappedto_drb_setup_resp_m_nterminated() const
{
  assert_choice_type(types::qos_flows_mappedto_drb_setup_resp_m_nterminated, type_, "Extension");
  return c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>();
}
void drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      j.start_array("QoSFlowsMappedtoDRB-SetupResponse-MNterminated");
      for (const auto& e1 : c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List",
                                "QoSFlowsMappedtoDRB-SetupResponse-MNterminated"};
  return convert_enum_idx(names, 2, value, "drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_o>;

SRSASN_CODE drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += qos_flows_mappedto_drb_setup_resp_m_nterminated_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (qos_flows_mappedto_drb_setup_resp_m_nterminated_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)239, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_setup_resp_m_nterminated, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 239: {
        qos_flows_mappedto_drb_setup_resp_m_nterminated_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_setup_resp_m_nterminated, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_admitted_list_mod_resp_m_nterminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flows_mappedto_drb_setup_resp_m_nterminated_present) {
    j.write_int("id", 239);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : qos_flows_mappedto_drb_setup_resp_m_nterminated) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// DRBsAdmittedList-ModificationResponse-MNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_admitted_list_mod_resp_m_nterminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sn_dl_scg_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(secondary_sn_dl_scg_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (sn_dl_scg_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sn_dl_scg_up_tnl_info, 1, 4, true));
  }
  if (secondary_sn_dl_scg_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_sn_dl_scg_up_tnl_info, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_mod_resp_m_nterminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sn_dl_scg_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(sn_dl_scg_up_tnl_info_present, 1));
  bool secondary_sn_dl_scg_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_sn_dl_scg_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (sn_dl_scg_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sn_dl_scg_up_tnl_info, bref, 1, 4, true));
  }
  if (secondary_sn_dl_scg_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_sn_dl_scg_up_tnl_info, bref, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_admitted_list_mod_resp_m_nterminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (sn_dl_scg_up_tnl_info.size() > 0) {
    j.start_array("sN-DL-SCG-UP-TNLInfo");
    for (const auto& e1 : sn_dl_scg_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (secondary_sn_dl_scg_up_tnl_info.size() > 0) {
    j.start_array("secondary-SN-DL-SCG-UP-TNLInfo");
    for (const auto& e1 : secondary_sn_dl_scg_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsAdmittedList-SetupResponse-MNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 239};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 239};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 239:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c
drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 239:
      ret.set(ext_c::types::qos_flows_mappedto_drb_setup_resp_m_nterminated);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 239:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      c = qos_flows_mappedto_drb_setup_resp_m_nterminated_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l& drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
qos_flows_mappedto_drb_setup_resp_m_nterminated_l&
drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::qos_flows_mappedto_drb_setup_resp_m_nterminated()
{
  assert_choice_type(types::qos_flows_mappedto_drb_setup_resp_m_nterminated, type_, "Extension");
  return c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const qos_flows_mappedto_drb_setup_resp_m_nterminated_l&
drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::qos_flows_mappedto_drb_setup_resp_m_nterminated()
    const
{
  assert_choice_type(types::qos_flows_mappedto_drb_setup_resp_m_nterminated, type_, "Extension");
  return c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>();
}
void drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      j.start_array("QoSFlowsMappedtoDRB-SetupResponse-MNterminated");
      for (const auto& e1 : c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::qos_flows_mappedto_drb_setup_resp_m_nterminated:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flows_mappedto_drb_setup_resp_m_nterminated_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List",
                                "QoSFlowsMappedtoDRB-SetupResponse-MNterminated"};
  return convert_enum_idx(names, 2, value, "drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_o>;

SRSASN_CODE drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += qos_flows_mappedto_drb_setup_resp_m_nterminated_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (qos_flows_mappedto_drb_setup_resp_m_nterminated_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)239, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_setup_resp_m_nterminated, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 239: {
        qos_flows_mappedto_drb_setup_resp_m_nterminated_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_setup_resp_m_nterminated, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_admitted_list_setup_resp_m_nterminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flows_mappedto_drb_setup_resp_m_nterminated_present) {
    j.write_int("id", 239);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : qos_flows_mappedto_drb_setup_resp_m_nterminated) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// DRBsAdmittedList-SetupResponse-MNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_admitted_list_setup_resp_m_nterminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(secondary_sn_dl_scg_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, sn_dl_scg_up_tnl_info, 1, 4, true));
  if (secondary_sn_dl_scg_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_sn_dl_scg_up_tnl_info, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_admitted_list_setup_resp_m_nterminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool secondary_sn_dl_scg_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_sn_dl_scg_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(sn_dl_scg_up_tnl_info, bref, 1, 4, true));
  if (secondary_sn_dl_scg_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_sn_dl_scg_up_tnl_info, bref, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_admitted_list_setup_resp_m_nterminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  j.start_array("sN-DL-SCG-UP-TNLInfo");
  for (const auto& e1 : sn_dl_scg_up_tnl_info) {
    e1.to_json(j);
  }
  j.end_array();
  if (secondary_sn_dl_scg_up_tnl_info.size() > 0) {
    j.start_array("secondary-SN-DL-SCG-UP-TNLInfo");
    for (const auto& e1 : secondary_sn_dl_scg_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsSubjectToEarlyStatusTransfer-Item ::= SEQUENCE
SRSASN_CODE drbs_subject_to_early_status_transfer_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(dl_count.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_early_status_transfer_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(dl_count.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_subject_to_early_status_transfer_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drbID", drb_id);
  j.write_fieldname("dlCount");
  dl_count.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBsSubjectToStatusTransfer-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_subject_to_status_transfer_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {120};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_subject_to_status_transfer_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 120 == id;
}
crit_e drbs_subject_to_status_transfer_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 120) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_subject_to_status_transfer_item_ext_ies_o::ext_c
drbs_subject_to_status_transfer_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 120) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_subject_to_status_transfer_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 120) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("QoSFlows-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 64, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 64, true));
  return SRSASN_SUCCESS;
}

const char* drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QoSFlows-List"};
  return convert_enum_idx(names, 1, value, "drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::types");
}

// DRBsSubjectToStatusTransfer-Item ::= SEQUENCE
SRSASN_CODE drbs_subject_to_status_transfer_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pdcp_status_transfer_ul.pack(bref));
  HANDLE_CODE(pdcp_status_transfer_dl.pack(bref));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_status_transfer_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pdcp_status_transfer_ul.unpack(bref));
  HANDLE_CODE(pdcp_status_transfer_dl.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_subject_to_status_transfer_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drbID", drb_id);
  j.write_fieldname("pdcpStatusTransfer-UL");
  pdcp_status_transfer_ul.to_json(j);
  j.write_fieldname("pdcpStatusTransfer-DL");
  pdcp_status_transfer_dl.to_json(j);
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// Reestablishment-Indication ::= ENUMERATED
const char* reest_ind_opts::to_string() const
{
  static const char* names[] = {"reestablished"};
  return convert_enum_idx(names, 1, value, "reest_ind_e");
}

// DRBsToBeModified-List-ModRqd-MNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 216 == id;
}
crit_e drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 216) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::ext_c
drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 216) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 216) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("Additional-PDCP-Duplication-TNL-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 2, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 2, true));
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List"};
  return convert_enum_idx(
      names, 1, value, "drbs_to_be_modified_list_mod_rqd_m_nterminated_item_ext_ies_o::ext_c::types");
}

// RLC-Status ::= SEQUENCE
SRSASN_CODE rlc_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(reest_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlc_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(reest_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlc_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reestablishment-Indication", "reestablished");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeModified-List-ModRqd-MNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_m_nterminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(secondary_sn_dl_scg_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(rlc_status_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(sn_dl_scg_up_tnl_info.pack(bref));
  if (secondary_sn_dl_scg_up_tnl_info_present) {
    HANDLE_CODE(secondary_sn_dl_scg_up_tnl_info.pack(bref));
  }
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (rlc_status_present) {
    HANDLE_CODE(rlc_status.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_m_nterminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(secondary_sn_dl_scg_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  HANDLE_CODE(bref.unpack(rlc_status_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(sn_dl_scg_up_tnl_info.unpack(bref));
  if (secondary_sn_dl_scg_up_tnl_info_present) {
    HANDLE_CODE(secondary_sn_dl_scg_up_tnl_info.unpack(bref));
  }
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (rlc_status_present) {
    HANDLE_CODE(rlc_status.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_mod_rqd_m_nterminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  j.write_fieldname("sN-DL-SCG-UP-TNLInfo");
  sn_dl_scg_up_tnl_info.to_json(j);
  if (secondary_sn_dl_scg_up_tnl_info_present) {
    j.write_fieldname("secondary-SN-DL-SCG-UP-TNLInfo");
    secondary_sn_dl_scg_up_tnl_info.to_json(j);
  }
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  if (rlc_status_present) {
    j.write_fieldname("rlc-status");
    rlc_status.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// RLCDuplicationState-Item ::= SEQUENCE
SRSASN_CODE rlc_dupl_state_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dupl_state.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlc_dupl_state_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dupl_state.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlc_dupl_state_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("duplicationState", dupl_state.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* rlc_dupl_state_item_s::dupl_state_opts::to_string() const
{
  static const char* names[] = {"active", "inactive"};
  return convert_enum_idx(names, 2, value, "rlc_dupl_state_item_s::dupl_state_e_");
}

// QoSFlowsModifiedMappedtoDRB-ModRqd-SNterminated-Item ::= SEQUENCE
SRSASN_CODE qos_flows_modified_mappedto_drb_mod_rqd_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mcg_requested_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (mcg_requested_gbr_qos_flow_info_present) {
    HANDLE_CODE(mcg_requested_gbr_qos_flow_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_modified_mappedto_drb_mod_rqd_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mcg_requested_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (mcg_requested_gbr_qos_flow_info_present) {
    HANDLE_CODE(mcg_requested_gbr_qos_flow_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_modified_mappedto_drb_mod_rqd_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSFlowIdentifier", qos_flow_id);
  if (mcg_requested_gbr_qos_flow_info_present) {
    j.write_fieldname("mCGRequestedGBRQoSFlowInfo");
    mcg_requested_gbr_qos_flow_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RLCDuplicationInformation ::= SEQUENCE
SRSASN_CODE rlc_dupl_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(rlc_primary_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, rlc_dupl_state_list, 1, 3, true));
  if (rlc_primary_ind_present) {
    HANDLE_CODE(rlc_primary_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlc_dupl_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(rlc_primary_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(rlc_dupl_state_list, bref, 1, 3, true));
  if (rlc_primary_ind_present) {
    HANDLE_CODE(rlc_primary_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlc_dupl_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("rLCDuplicationStateList");
  for (const auto& e1 : rlc_dupl_state_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (rlc_primary_ind_present) {
    j.write_str("rLC-PrimaryIndicator", rlc_primary_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* rlc_dupl_info_s::rlc_primary_ind_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "rlc_dupl_info_s::rlc_primary_ind_e_");
}

// UL-UE-Configuration ::= ENUMERATED
const char* ul_ue_cfg_opts::to_string() const
{
  static const char* names[] = {"no-data", "shared", "only"};
  return convert_enum_idx(names, 3, value, "ul_ue_cfg_e");
}

// DRBsToBeModified-List-ModRqd-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 219};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 219};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c
drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 219:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::rlc_dupl_info:
      c = rlc_dupl_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
void drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List", "RLCDuplicationInformation"};
  return convert_enum_idx(
      names, 2, value, "drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::types");
}

// DuplicationActivation ::= ENUMERATED
const char* dupl_activation_opts::to_string() const
{
  static const char* names[] = {"active", "inactive"};
  return convert_enum_idx(names, 2, value, "dupl_activation_e");
}

// PDCPDuplicationConfiguration ::= ENUMERATED
const char* pdcp_dupl_cfg_opts::to_string() const
{
  static const char* names[] = {"configured", "de-configured"};
  return convert_enum_idx(names, 2, value, "pdcp_dupl_cfg_e");
}

// ULConfiguration ::= SEQUENCE
SRSASN_CODE ul_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_pdcp.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_pdcp.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uL-PDCP", ul_pdcp.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_o>;

SRSASN_CODE drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 219: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_mod_rqd_sn_terminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeModified-List-ModRqd-SNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(drb_qos_present, 1));
  HANDLE_CODE(bref.pack(secondary_sn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(pdcp_dupl_cfg_present, 1));
  HANDLE_CODE(bref.pack(dupl_activation_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_mappedto_drb_mod_rqd_sn_terminated.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (sn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (drb_qos_present) {
    HANDLE_CODE(drb_qos.pack(bref));
  }
  if (secondary_sn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_sn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  if (pdcp_dupl_cfg_present) {
    HANDLE_CODE(pdcp_dupl_cfg.pack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  if (qos_flows_mappedto_drb_mod_rqd_sn_terminated.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_mod_rqd_sn_terminated, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_rqd_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(sn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(drb_qos_present, 1));
  bool secondary_sn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_sn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(pdcp_dupl_cfg_present, 1));
  HANDLE_CODE(bref.unpack(dupl_activation_present, 1));
  bool qos_flows_mappedto_drb_mod_rqd_sn_terminated_present;
  HANDLE_CODE(bref.unpack(qos_flows_mappedto_drb_mod_rqd_sn_terminated_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (sn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (drb_qos_present) {
    HANDLE_CODE(drb_qos.unpack(bref));
  }
  if (secondary_sn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  if (pdcp_dupl_cfg_present) {
    HANDLE_CODE(pdcp_dupl_cfg.unpack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.unpack(bref));
  }
  if (qos_flows_mappedto_drb_mod_rqd_sn_terminated_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_mod_rqd_sn_terminated, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_mod_rqd_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (sn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("sN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : sn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drb_qos_present) {
    j.write_fieldname("dRB-QoS");
    drb_qos.to_json(j);
  }
  if (secondary_sn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("secondary-SN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : secondary_sn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ul_cfg_present) {
    j.write_fieldname("uL-Configuration");
    ul_cfg.to_json(j);
  }
  if (pdcp_dupl_cfg_present) {
    j.write_str("pdcpDuplicationConfiguration", pdcp_dupl_cfg.to_string());
  }
  if (dupl_activation_present) {
    j.write_str("duplicationActivation", dupl_activation.to_string());
  }
  if (qos_flows_mappedto_drb_mod_rqd_sn_terminated.size() > 0) {
    j.start_array("qoSFlowsMappedtoDRB-ModRqd-SNterminated");
    for (const auto& e1 : qos_flows_mappedto_drb_mod_rqd_sn_terminated) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeModified-List-Modified-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 216 == id;
}
crit_e drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 216) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::ext_c
drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 216) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 216) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("Additional-PDCP-Duplication-TNL-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 2, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 2, true));
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List"};
  return convert_enum_idx(
      names, 1, value, "drbs_to_be_modified_list_modified_sn_terminated_item_ext_ies_o::ext_c::types");
}

// DRBsToBeModified-List-Modified-SNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_modified_list_modified_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mn_dl_scg_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(secondary_mn_dl_scg_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(rlc_status_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (mn_dl_scg_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mn_dl_scg_up_tnl_info, 1, 4, true));
  }
  if (secondary_mn_dl_scg_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_mn_dl_scg_up_tnl_info, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (rlc_status_present) {
    HANDLE_CODE(rlc_status.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_modified_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mn_dl_scg_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(mn_dl_scg_up_tnl_info_present, 1));
  bool secondary_mn_dl_scg_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_mn_dl_scg_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  HANDLE_CODE(bref.unpack(rlc_status_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (mn_dl_scg_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mn_dl_scg_up_tnl_info, bref, 1, 4, true));
  }
  if (secondary_mn_dl_scg_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_mn_dl_scg_up_tnl_info, bref, 1, 4, true));
  }
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  if (rlc_status_present) {
    HANDLE_CODE(rlc_status.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_modified_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (mn_dl_scg_up_tnl_info.size() > 0) {
    j.start_array("mN-DL-SCG-UP-TNLInfo");
    for (const auto& e1 : mn_dl_scg_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (secondary_mn_dl_scg_up_tnl_info.size() > 0) {
    j.start_array("secondary-MN-DL-SCG-UP-TNLInfo");
    for (const auto& e1 : secondary_mn_dl_scg_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  if (rlc_status_present) {
    j.write_fieldname("rlc-status");
    rlc_status.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// TSCAssistanceInformation-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t tsc_assist_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {324};
  return map_enum_number(names, 1, idx, "id");
}
bool tsc_assist_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 324 == id;
}
crit_e tsc_assist_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 324) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
tsc_assist_info_ext_ies_o::ext_c tsc_assist_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 324) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e tsc_assist_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 324) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void tsc_assist_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..1920000,...)", c);
  j.end_obj();
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}

const char* tsc_assist_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1920000,...)"};
  return convert_enum_idx(names, 1, value, "tsc_assist_info_ext_ies_o::ext_c::types");
}
uint8_t tsc_assist_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "tsc_assist_info_ext_ies_o::ext_c::types");
}

// TSCAssistanceInformation ::= SEQUENCE
SRSASN_CODE tsc_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(burst_arrival_time.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, periodicity, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time.size() > 0) {
    HANDLE_CODE(burst_arrival_time.pack(bref));
  }
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool burst_arrival_time_present;
  HANDLE_CODE(bref.unpack(burst_arrival_time_present, 1));
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(periodicity, bref, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time_present) {
    HANDLE_CODE(burst_arrival_time.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void tsc_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("periodicity", periodicity);
  if (burst_arrival_time.size() > 0) {
    j.write_str("burstArrivalTime", burst_arrival_time.to_string());
  }
  if (ie_ext.size() > 0) {
    j.write_fieldname("ie-Extension");
  }
  j.end_obj();
}

// TSCTrafficCharacteristics ::= SEQUENCE
SRSASN_CODE tsc_traffic_characteristics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.pack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.pack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_traffic_characteristics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.unpack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.unpack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tsc_traffic_characteristics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_assist_info_dl_present) {
    j.write_fieldname("tSCAssistanceInformationDownlink");
    tsc_assist_info_dl.to_json(j);
  }
  if (tsc_assist_info_ul_present) {
    j.write_fieldname("tSCAssistanceInformationUplink");
    tsc_assist_info_ul.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("ie-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsMappedtoDRB-Setup-MNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {212};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 212 == id;
}
crit_e qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 212) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::ext_c
qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 212) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 212) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TSCTrafficCharacteristics");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics"};
  return convert_enum_idx(names, 1, value, "qos_flows_mappedto_drb_setup_m_nterminated_item_ext_ies_o::ext_c::types");
}

// QoSFlowsMappedtoDRB-Setup-MNterminated-Item ::= SEQUENCE
SRSASN_CODE qos_flows_mappedto_drb_setup_m_nterminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_mappedto_drb_setup_m_nterminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_flow_map_ind_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_mappedto_drb_setup_m_nterminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSFlowIdentifier", qos_flow_id);
  j.write_fieldname("qoSFlowLevelQoSParameters");
  qos_flow_level_qos_params.to_json(j);
  if (qos_flow_map_ind_present) {
    j.write_str("qosFlowMappingIndication", qos_flow_map_ind.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// DRBsToBeModifiedList-Modification-MNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 219};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 219};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c
drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 219:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::rlc_dupl_info:
      c = rlc_dupl_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
void drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List", "RLCDuplicationInformation"};
  return convert_enum_idx(names, 2, value, "drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_o>;

SRSASN_CODE drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 219: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_mod_m_nterminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeModifiedList-Modification-MNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_modified_list_mod_m_nterminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(drb_qos_present, 1));
  HANDLE_CODE(bref.pack(secondary_mn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(pdcp_dupl_cfg_present, 1));
  HANDLE_CODE(bref.pack(dupl_activation_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_mappedto_drb_setup_m_nterminated.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (mn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (drb_qos_present) {
    HANDLE_CODE(drb_qos.pack(bref));
  }
  if (secondary_mn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_mn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  if (pdcp_dupl_cfg_present) {
    HANDLE_CODE(pdcp_dupl_cfg.pack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  if (qos_flows_mappedto_drb_setup_m_nterminated.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_setup_m_nterminated, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_m_nterminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(mn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(drb_qos_present, 1));
  bool secondary_mn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_mn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(pdcp_dupl_cfg_present, 1));
  HANDLE_CODE(bref.unpack(dupl_activation_present, 1));
  bool qos_flows_mappedto_drb_setup_m_nterminated_present;
  HANDLE_CODE(bref.unpack(qos_flows_mappedto_drb_setup_m_nterminated_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (mn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (drb_qos_present) {
    HANDLE_CODE(drb_qos.unpack(bref));
  }
  if (secondary_mn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_mn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  if (pdcp_dupl_cfg_present) {
    HANDLE_CODE(pdcp_dupl_cfg.unpack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.unpack(bref));
  }
  if (qos_flows_mappedto_drb_setup_m_nterminated_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_setup_m_nterminated, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_mod_m_nterminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (mn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("mN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : mn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drb_qos_present) {
    j.write_fieldname("dRB-QoS");
    drb_qos.to_json(j);
  }
  if (secondary_mn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("secondary-MN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : secondary_mn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ul_cfg_present) {
    j.write_fieldname("uL-Configuration");
    ul_cfg.to_json(j);
  }
  if (pdcp_dupl_cfg_present) {
    j.write_str("pdcpDuplicationConfiguration", pdcp_dupl_cfg.to_string());
  }
  if (dupl_activation_present) {
    j.write_str("duplicationActivation", dupl_activation.to_string());
  }
  if (qos_flows_mappedto_drb_setup_m_nterminated.size() > 0) {
    j.start_array("qoSFlowsMappedtoDRB-Setup-MNterminated");
    for (const auto& e1 : qos_flows_mappedto_drb_setup_m_nterminated) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsMappedtoDRB-SetupResponse-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175, 255};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {175, 255};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 175:
      return crit_e::ignore;
    case 255:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c
qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 175:
      ret.set(ext_c::types::current_qos_para_set_idx);
      break;
    case 255:
      ret.set(ext_c::types::source_dl_forwarding_ip_address);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 175:
      return presence_e::optional;
    case 255:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::current_qos_para_set_idx:
      c = uint8_t{};
      break;
    case types::source_dl_forwarding_ip_address:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
  }
}
uint8_t& qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::current_qos_para_set_idx()
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
bounded_bitstring<1, 160, true, true>&
qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::source_dl_forwarding_ip_address()
{
  assert_choice_type(types::source_dl_forwarding_ip_address, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const uint8_t& qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::current_qos_para_set_idx() const
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
const bounded_bitstring<1, 160, true, true>&
qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::source_dl_forwarding_ip_address() const
{
  assert_choice_type(types::source_dl_forwarding_ip_address, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
void qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::current_qos_para_set_idx:
      j.write_int("INTEGER (1..8,...)", c.get<uint8_t>());
      break;
    case types::source_dl_forwarding_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::current_qos_para_set_idx:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    case types::source_dl_forwarding_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::current_qos_para_set_idx:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    case types::source_dl_forwarding_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)", "BIT STRING"};
  return convert_enum_idx(
      names, 2, value, "qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(
      numbers, 1, value, "qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_o>;

SRSASN_CODE qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += current_qos_para_set_idx_present ? 1 : 0;
  nof_ies += source_dl_forwarding_ip_address_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (current_qos_para_set_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)175, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, current_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  }
  if (source_dl_forwarding_ip_address_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)255, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_dl_forwarding_ip_address.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 175: {
        current_qos_para_set_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(current_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
        break;
      }
      case 255: {
        source_dl_forwarding_ip_address_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_dl_forwarding_ip_address.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flows_mappedto_drb_setup_resp_sn_terminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (current_qos_para_set_idx_present) {
    j.write_int("id", 175);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", current_qos_para_set_idx);
  }
  if (source_dl_forwarding_ip_address_present) {
    j.write_int("id", 255);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", source_dl_forwarding_ip_address.to_string());
  }
  j.end_obj();
}

// QoSFlowsMappedtoDRB-SetupResponse-SNterminated-Item ::= SEQUENCE
SRSASN_CODE qos_flows_mappedto_drb_setup_resp_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mcg_requested_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (mcg_requested_gbr_qos_flow_info_present) {
    HANDLE_CODE(mcg_requested_gbr_qos_flow_info.pack(bref));
  }
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_mappedto_drb_setup_resp_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mcg_requested_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (mcg_requested_gbr_qos_flow_info_present) {
    HANDLE_CODE(mcg_requested_gbr_qos_flow_info.unpack(bref));
  }
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_mappedto_drb_setup_resp_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSFlowIdentifier", qos_flow_id);
  if (mcg_requested_gbr_qos_flow_info_present) {
    j.write_fieldname("mCGRequestedGBRQoSFlowInfo");
    mcg_requested_gbr_qos_flow_info.to_json(j);
  }
  if (qos_flow_map_ind_present) {
    j.write_str("qosFlowMappingIndication", qos_flow_map_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeModifiedList-ModificationResponse-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 219, 234, 235, 236};
  return map_enum_number(names, 5, idx, "id");
}
bool drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 219, 234, 235, 236};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 235:
      return crit_e::ignore;
    case 236:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c
drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 219:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    case 234:
      ret.set(ext_c::types::secondary_sn_ul_pdcp_up_tnl_info);
      break;
    case 235:
      ret.set(ext_c::types::pdcp_dupl_cfg);
      break;
    case 236:
      ret.set(ext_c::types::dupl_activation);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 235:
      return presence_e::optional;
    case 236:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::rlc_dupl_info:
      c = rlc_dupl_info_s{};
      break;
    case types::secondary_sn_ul_pdcp_up_tnl_info:
      c = up_transport_params_l{};
      break;
    case types::pdcp_dupl_cfg:
      c = pdcp_dupl_cfg_e{};
      break;
    case types::dupl_activation:
      c = dupl_activation_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l&
drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
up_transport_params_l&
drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::secondary_sn_ul_pdcp_up_tnl_info()
{
  assert_choice_type(types::secondary_sn_ul_pdcp_up_tnl_info, type_, "Extension");
  return c.get<up_transport_params_l>();
}
pdcp_dupl_cfg_e& drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::pdcp_dupl_cfg()
{
  assert_choice_type(types::pdcp_dupl_cfg, type_, "Extension");
  return c.get<pdcp_dupl_cfg_e>();
}
dupl_activation_e& drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::dupl_activation()
{
  assert_choice_type(types::dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const up_transport_params_l&
drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::secondary_sn_ul_pdcp_up_tnl_info() const
{
  assert_choice_type(types::secondary_sn_ul_pdcp_up_tnl_info, type_, "Extension");
  return c.get<up_transport_params_l>();
}
const pdcp_dupl_cfg_e& drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::pdcp_dupl_cfg() const
{
  assert_choice_type(types::pdcp_dupl_cfg, type_, "Extension");
  return c.get<pdcp_dupl_cfg_e>();
}
const dupl_activation_e& drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::dupl_activation() const
{
  assert_choice_type(types::dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
void drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    case types::secondary_sn_ul_pdcp_up_tnl_info:
      j.start_array("UPTransportParameters");
      for (const auto& e1 : c.get<up_transport_params_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdcp_dupl_cfg:
      j.write_str("PDCPDuplicationConfiguration", c.get<pdcp_dupl_cfg_e>().to_string());
      break;
    case types::dupl_activation:
      j.write_str("DuplicationActivation", c.get<dupl_activation_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    case types::secondary_sn_ul_pdcp_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_params_l>(), 1, 4, true));
      break;
    case types::pdcp_dupl_cfg:
      HANDLE_CODE(c.get<pdcp_dupl_cfg_e>().pack(bref));
      break;
    case types::dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    case types::secondary_sn_ul_pdcp_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_params_l>(), bref, 1, 4, true));
      break;
    case types::pdcp_dupl_cfg:
      HANDLE_CODE(c.get<pdcp_dupl_cfg_e>().unpack(bref));
      break;
    case types::dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List",
                                "RLCDuplicationInformation",
                                "UPTransportParameters",
                                "PDCPDuplicationConfiguration",
                                "DuplicationActivation"};
  return convert_enum_idx(
      names, 5, value, "drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_o>;

SRSASN_CODE drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  nof_ies += secondary_sn_ul_pdcp_up_tnl_info_present ? 1 : 0;
  nof_ies += pdcp_dupl_cfg_present ? 1 : 0;
  nof_ies += dupl_activation_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }
  if (secondary_sn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_sn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (pdcp_dupl_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)235, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdcp_dupl_cfg.pack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)236, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dupl_activation.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 219: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      case 234: {
        secondary_sn_ul_pdcp_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(secondary_sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
        break;
      }
      case 235: {
        pdcp_dupl_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdcp_dupl_cfg.unpack(bref));
        break;
      }
      case 236: {
        dupl_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dupl_activation.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_mod_resp_sn_terminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  if (secondary_sn_ul_pdcp_up_tnl_info_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : secondary_sn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdcp_dupl_cfg_present) {
    j.write_int("id", 235);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", pdcp_dupl_cfg.to_string());
  }
  if (dupl_activation_present) {
    j.write_int("id", 236);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", dupl_activation.to_string());
  }
  j.end_obj();
}

// DRBsToBeModifiedList-ModificationResponse-SNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_modified_list_mod_resp_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(drb_qos_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_mappedto_drb_setup_resp_sn_terminated.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (sn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (drb_qos_present) {
    HANDLE_CODE(drb_qos.pack(bref));
  }
  if (qos_flows_mappedto_drb_setup_resp_sn_terminated.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_setup_resp_sn_terminated, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_list_mod_resp_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(sn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(drb_qos_present, 1));
  bool qos_flows_mappedto_drb_setup_resp_sn_terminated_present;
  HANDLE_CODE(bref.unpack(qos_flows_mappedto_drb_setup_resp_sn_terminated_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (sn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (drb_qos_present) {
    HANDLE_CODE(drb_qos.unpack(bref));
  }
  if (qos_flows_mappedto_drb_setup_resp_sn_terminated_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_setup_resp_sn_terminated, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_list_mod_resp_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (sn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("sN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : sn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drb_qos_present) {
    j.write_fieldname("dRB-QoS");
    drb_qos.to_json(j);
  }
  if (qos_flows_mappedto_drb_setup_resp_sn_terminated.size() > 0) {
    j.start_array("qoSFlowsMappedtoDRB-SetupResponse-SNterminated");
    for (const auto& e1 : qos_flows_mappedto_drb_setup_resp_sn_terminated) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsSetupMappedtoDRB-ModRqd-SNterminated-Item ::= SEQUENCE
SRSASN_CODE qos_flows_setup_mappedto_drb_mod_rqd_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mcg_requested_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (mcg_requested_gbr_qos_flow_info_present) {
    HANDLE_CODE(mcg_requested_gbr_qos_flow_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_setup_mappedto_drb_mod_rqd_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mcg_requested_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (mcg_requested_gbr_qos_flow_info_present) {
    HANDLE_CODE(mcg_requested_gbr_qos_flow_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_setup_mappedto_drb_mod_rqd_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSFlowIdentifier", qos_flow_id);
  if (mcg_requested_gbr_qos_flow_info_present) {
    j.write_fieldname("mCGRequestedGBRQoSFlowInfo");
    mcg_requested_gbr_qos_flow_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeSetup-List-ModRqd-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 219};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 219};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c
drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 219:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::rlc_dupl_info:
      c = rlc_dupl_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
void drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List", "RLCDuplicationInformation"};
  return convert_enum_idx(names, 2, value, "drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o::ext_c::types");
}

// PDCPSNLength ::= SEQUENCE
SRSASN_CODE pdcp_sn_len_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ul_pdcp_sn_len.pack(bref));
  HANDLE_CODE(dl_pdcp_sn_len.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdcp_sn_len_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ul_pdcp_sn_len.unpack(bref));
  HANDLE_CODE(dl_pdcp_sn_len.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdcp_sn_len_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ulPDCPSNLength", ul_pdcp_sn_len.to_string());
  j.write_str("dlPDCPSNLength", dl_pdcp_sn_len.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* pdcp_sn_len_s::ul_pdcp_sn_len_opts::to_string() const
{
  static const char* names[] = {"v12bits", "v18bits"};
  return convert_enum_idx(names, 2, value, "pdcp_sn_len_s::ul_pdcp_sn_len_e_");
}
uint8_t pdcp_sn_len_s::ul_pdcp_sn_len_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "pdcp_sn_len_s::ul_pdcp_sn_len_e_");
}

const char* pdcp_sn_len_s::dl_pdcp_sn_len_opts::to_string() const
{
  static const char* names[] = {"v12bits", "v18bits"};
  return convert_enum_idx(names, 2, value, "pdcp_sn_len_s::dl_pdcp_sn_len_e_");
}
uint8_t pdcp_sn_len_s::dl_pdcp_sn_len_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "pdcp_sn_len_s::dl_pdcp_sn_len_e_");
}

template struct asn1::protocol_ext_field_s<drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_o>;

SRSASN_CODE drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 219: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_list_mod_rqd_sn_terminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeSetup-List-ModRqd-SNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_setup_list_mod_rqd_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdcp_sn_len_present, 1));
  HANDLE_CODE(bref.pack(secondary_sn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(dupl_activation_present, 1));
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (pdcp_sn_len_present) {
    HANDLE_CODE(pdcp_sn_len.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, sn_ul_pdcp_up_tnl_info, 1, 4, true));
  HANDLE_CODE(drb_qos.pack(bref));
  if (secondary_sn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_sn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_mod_rqd_sn_terminated, 1, 64, true));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_mod_rqd_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdcp_sn_len_present, 1));
  bool secondary_sn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_sn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(dupl_activation_present, 1));
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (pdcp_sn_len_present) {
    HANDLE_CODE(pdcp_sn_len.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  HANDLE_CODE(drb_qos.unpack(bref));
  if (secondary_sn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.unpack(bref));
  }
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_mod_rqd_sn_terminated, bref, 1, 64, true));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_list_mod_rqd_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (pdcp_sn_len_present) {
    j.write_fieldname("pDCP-SNLength");
    pdcp_sn_len.to_json(j);
  }
  j.start_array("sn-UL-PDCP-UPTNLinfo");
  for (const auto& e1 : sn_ul_pdcp_up_tnl_info) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("dRB-QoS");
  drb_qos.to_json(j);
  if (secondary_sn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("secondary-SN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : secondary_sn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dupl_activation_present) {
    j.write_str("duplicationActivation", dupl_activation.to_string());
  }
  if (ul_cfg_present) {
    j.write_fieldname("uL-Configuration");
    ul_cfg.to_json(j);
  }
  j.start_array("qoSFlowsMappedtoDRB-ModRqd-SNterminated");
  for (const auto& e1 : qos_flows_mappedto_drb_mod_rqd_sn_terminated) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("rLC-Mode", rlc_mode.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeSetupList-BearerSetupComplete-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {125};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 125 == id;
}
crit_e drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 125) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::ext_c
drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 125) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 125) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("UPTransportLayerInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char*
drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformation"};
  return convert_enum_idx(
      names, 1, value, "drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_ext_ies_o::ext_c::types");
}

// DRBsToBeSetupList-BearerSetupComplete-SNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(mn_xn_u_tnl_infoat_m.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(mn_xn_u_tnl_infoat_m.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_list_bearer_setup_complete_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.write_fieldname("mN-Xn-U-TNLInfoatM");
  mn_xn_u_tnl_infoat_m.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// DRBsToBeSetupList-Setup-MNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 219};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 219};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c
drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 219:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::rlc_dupl_info:
      c = rlc_dupl_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
void drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List", "RLCDuplicationInformation"};
  return convert_enum_idx(names, 2, value, "drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_o>;

SRSASN_CODE drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 219: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_list_setup_m_nterminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeSetupList-Setup-MNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_setup_list_setup_m_nterminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(pdcp_sn_len_present, 1));
  HANDLE_CODE(bref.pack(secondary_mn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(dupl_activation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, mn_ul_pdcp_up_tnl_info, 1, 4, true));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  HANDLE_CODE(drb_qos.pack(bref));
  if (pdcp_sn_len_present) {
    HANDLE_CODE(pdcp_sn_len.pack(bref));
  }
  if (secondary_mn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_mn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_setup_m_nterminated, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_setup_m_nterminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(pdcp_sn_len_present, 1));
  bool secondary_mn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_mn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(dupl_activation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(mn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  HANDLE_CODE(drb_qos.unpack(bref));
  if (pdcp_sn_len_present) {
    HANDLE_CODE(pdcp_sn_len.unpack(bref));
  }
  if (secondary_mn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_mn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_setup_m_nterminated, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_list_setup_m_nterminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  j.start_array("mN-UL-PDCP-UP-TNLInfo");
  for (const auto& e1 : mn_ul_pdcp_up_tnl_info) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("rLC-Mode", rlc_mode.to_string());
  if (ul_cfg_present) {
    j.write_fieldname("uL-Configuration");
    ul_cfg.to_json(j);
  }
  j.write_fieldname("dRB-QoS");
  drb_qos.to_json(j);
  if (pdcp_sn_len_present) {
    j.write_fieldname("pDCP-SNLength");
    pdcp_sn_len.to_json(j);
  }
  if (secondary_mn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("secondary-MN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : secondary_mn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dupl_activation_present) {
    j.write_str("duplicationActivation", dupl_activation.to_string());
  }
  j.start_array("qoSFlowsMappedtoDRB-Setup-MNterminated");
  for (const auto& e1 : qos_flows_mappedto_drb_setup_m_nterminated) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeSetupList-SetupResponse-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {216, 219};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {216, 219};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 216:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c
drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 216:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 219:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 216:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c = add_pdcp_dupl_tnl_list_l{};
      break;
    case types::rlc_dupl_info:
      c = rlc_dupl_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
  }
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const add_pdcp_dupl_tnl_list_l&
drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
void drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("Additional-PDCP-Duplication-TNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-PDCP-Duplication-TNL-List", "RLCDuplicationInformation"};
  return convert_enum_idx(
      names, 2, value, "drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_o>;

SRSASN_CODE drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 216: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 219: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_list_setup_resp_sn_terminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  j.end_obj();
}

// DRBsToBeSetupList-SetupResponse-SNterminated-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_setup_list_setup_resp_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdcp_sn_len_present, 1));
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(secondary_sn_ul_pdcp_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(dupl_activation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, sn_ul_pdcp_up_tnl_info, 1, 4, true));
  HANDLE_CODE(drb_qos.pack(bref));
  if (pdcp_sn_len_present) {
    HANDLE_CODE(pdcp_sn_len.pack(bref));
  }
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  if (secondary_sn_ul_pdcp_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, secondary_sn_ul_pdcp_up_tnl_info, 1, 4, true));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_mappedto_drb_setup_resp_sn_terminated, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_list_setup_resp_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdcp_sn_len_present, 1));
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  bool secondary_sn_ul_pdcp_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(secondary_sn_ul_pdcp_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(dupl_activation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  HANDLE_CODE(drb_qos.unpack(bref));
  if (pdcp_sn_len_present) {
    HANDLE_CODE(pdcp_sn_len.unpack(bref));
  }
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  if (secondary_sn_ul_pdcp_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(secondary_sn_ul_pdcp_up_tnl_info, bref, 1, 4, true));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_mappedto_drb_setup_resp_sn_terminated, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_list_setup_resp_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  j.start_array("sN-UL-PDCP-UP-TNLInfo");
  for (const auto& e1 : sn_ul_pdcp_up_tnl_info) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("dRB-QoS");
  drb_qos.to_json(j);
  if (pdcp_sn_len_present) {
    j.write_fieldname("pDCP-SNLength");
    pdcp_sn_len.to_json(j);
  }
  j.write_str("rLC-Mode", rlc_mode.to_string());
  if (ul_cfg_present) {
    j.write_fieldname("uL-Configuration");
    ul_cfg.to_json(j);
  }
  if (secondary_sn_ul_pdcp_up_tnl_info.size() > 0) {
    j.start_array("secondary-SN-UL-PDCP-UP-TNLInfo");
    for (const auto& e1 : secondary_sn_ul_pdcp_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dupl_activation_present) {
    j.write_str("duplicationActivation", dupl_activation.to_string());
  }
  j.start_array("qoSFlowsMappedtoDRB-SetupResponse-SNterminated");
  for (const auto& e1 : qos_flows_mappedto_drb_setup_resp_sn_terminated) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsToBeForwarded-Item ::= SEQUENCE
SRSASN_CODE qos_flows_to_be_forwarded_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_forwarded_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_to_be_forwarded_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DataForwardingInfoFromTargetE-UTRANnode-Item ::= SEQUENCE
SRSASN_CODE data_forwarding_info_from_target_e_utran_node_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_forwarded_list, 1, 64, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_info_from_target_e_utran_node_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_forwarded_list, bref, 1, 64, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_info_from_target_e_utran_node_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dlForwardingUPTNLInformation");
  dl_forwarding_up_tnl_info.to_json(j);
  j.start_array("qosFlowsToBeForwarded-List");
  for (const auto& e1 : qos_flows_to_be_forwarded_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DataForwardingInfoFromTargetE-UTRANnode ::= SEQUENCE
SRSASN_CODE data_forwarding_info_from_target_e_utran_node_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_info_from_target_e_utran_node_list, 1, 256, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_info_from_target_e_utran_node_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_info_from_target_e_utran_node_list, bref, 1, 256, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_info_from_target_e_utran_node_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dataForwardingInfoFromTargetE-UTRANnode-List");
  for (const auto& e1 : data_forwarding_info_from_target_e_utran_node_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// SharedResourceType-ULDL-Sharing-DL-ResourcesChanged ::= SEQUENCE
SRSASN_CODE shared_res_type_ul_dl_sharing_dl_res_changed_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_res_bitmap.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_res_type_ul_dl_sharing_dl_res_changed_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_res_bitmap.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void shared_res_type_ul_dl_sharing_dl_res_changed_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dl-resourceBitmap", dl_res_bitmap.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SharedResourceType-ULDL-Sharing-UL-ResourcesChanged ::= SEQUENCE
SRSASN_CODE shared_res_type_ul_dl_sharing_ul_res_changed_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_res_bitmap.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_res_type_ul_dl_sharing_ul_res_changed_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_res_bitmap.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void shared_res_type_ul_dl_sharing_ul_res_changed_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ul-resourceBitmap", ul_res_bitmap.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SharedResourceType-ULDL-Sharing-DL-Resources ::= CHOICE
void shared_res_type_ul_dl_sharing_dl_res_c::destroy_()
{
  switch (type_) {
    case types::changed:
      c.destroy<shared_res_type_ul_dl_sharing_dl_res_changed_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void shared_res_type_ul_dl_sharing_dl_res_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      c.init<shared_res_type_ul_dl_sharing_dl_res_changed_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_dl_res_c");
  }
}
shared_res_type_ul_dl_sharing_dl_res_c::shared_res_type_ul_dl_sharing_dl_res_c(
    const shared_res_type_ul_dl_sharing_dl_res_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      c.init(other.c.get<shared_res_type_ul_dl_sharing_dl_res_changed_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_dl_res_c");
  }
}
shared_res_type_ul_dl_sharing_dl_res_c&
shared_res_type_ul_dl_sharing_dl_res_c::operator=(const shared_res_type_ul_dl_sharing_dl_res_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      c.set(other.c.get<shared_res_type_ul_dl_sharing_dl_res_changed_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_dl_res_c");
  }

  return *this;
}
void shared_res_type_ul_dl_sharing_dl_res_c::set_unchanged()
{
  set(types::unchanged);
}
shared_res_type_ul_dl_sharing_dl_res_changed_s& shared_res_type_ul_dl_sharing_dl_res_c::set_changed()
{
  set(types::changed);
  return c.get<shared_res_type_ul_dl_sharing_dl_res_changed_s>();
}
protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>&
shared_res_type_ul_dl_sharing_dl_res_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>();
}
void shared_res_type_ul_dl_sharing_dl_res_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      j.write_fieldname("changed");
      c.get<shared_res_type_ul_dl_sharing_dl_res_changed_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_dl_res_c");
  }
  j.end_obj();
}
SRSASN_CODE shared_res_type_ul_dl_sharing_dl_res_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_dl_res_changed_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_dl_res_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_res_type_ul_dl_sharing_dl_res_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_dl_res_changed_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_dl_res_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_dl_res_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* shared_res_type_ul_dl_sharing_dl_res_c::types_opts::to_string() const
{
  static const char* names[] = {"unchanged", "changed", "choice-extension"};
  return convert_enum_idx(names, 3, value, "shared_res_type_ul_dl_sharing_dl_res_c::types");
}

// SharedResourceType-ULDL-Sharing-UL-Resources ::= CHOICE
void shared_res_type_ul_dl_sharing_ul_res_c::destroy_()
{
  switch (type_) {
    case types::changed:
      c.destroy<shared_res_type_ul_dl_sharing_ul_res_changed_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void shared_res_type_ul_dl_sharing_ul_res_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      c.init<shared_res_type_ul_dl_sharing_ul_res_changed_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_ul_res_c");
  }
}
shared_res_type_ul_dl_sharing_ul_res_c::shared_res_type_ul_dl_sharing_ul_res_c(
    const shared_res_type_ul_dl_sharing_ul_res_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      c.init(other.c.get<shared_res_type_ul_dl_sharing_ul_res_changed_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_ul_res_c");
  }
}
shared_res_type_ul_dl_sharing_ul_res_c&
shared_res_type_ul_dl_sharing_ul_res_c::operator=(const shared_res_type_ul_dl_sharing_ul_res_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      c.set(other.c.get<shared_res_type_ul_dl_sharing_ul_res_changed_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_ul_res_c");
  }

  return *this;
}
void shared_res_type_ul_dl_sharing_ul_res_c::set_unchanged()
{
  set(types::unchanged);
}
shared_res_type_ul_dl_sharing_ul_res_changed_s& shared_res_type_ul_dl_sharing_ul_res_c::set_changed()
{
  set(types::changed);
  return c.get<shared_res_type_ul_dl_sharing_ul_res_changed_s>();
}
protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>&
shared_res_type_ul_dl_sharing_ul_res_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>();
}
void shared_res_type_ul_dl_sharing_ul_res_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      j.write_fieldname("changed");
      c.get<shared_res_type_ul_dl_sharing_ul_res_changed_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_ul_res_c");
  }
  j.end_obj();
}
SRSASN_CODE shared_res_type_ul_dl_sharing_ul_res_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_ul_res_changed_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_ul_res_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_res_type_ul_dl_sharing_ul_res_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::unchanged:
      break;
    case types::changed:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_ul_res_changed_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ul_res_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_ul_res_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* shared_res_type_ul_dl_sharing_ul_res_c::types_opts::to_string() const
{
  static const char* names[] = {"unchanged", "changed", "choice-extension"};
  return convert_enum_idx(names, 3, value, "shared_res_type_ul_dl_sharing_ul_res_c::types");
}

// SharedResourceType-UL-OnlySharing ::= SEQUENCE
SRSASN_CODE shared_res_type_ul_only_sharing_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_res_bitmap.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_res_type_ul_only_sharing_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_res_bitmap.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void shared_res_type_ul_only_sharing_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ul-resourceBitmap", ul_res_bitmap.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SharedResourceType-ULDL-Sharing ::= CHOICE
void shared_res_type_ul_dl_sharing_c::destroy_()
{
  switch (type_) {
    case types::ul_res:
      c.destroy<shared_res_type_ul_dl_sharing_ul_res_c>();
      break;
    case types::dl_res:
      c.destroy<shared_res_type_ul_dl_sharing_dl_res_c>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void shared_res_type_ul_dl_sharing_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ul_res:
      c.init<shared_res_type_ul_dl_sharing_ul_res_c>();
      break;
    case types::dl_res:
      c.init<shared_res_type_ul_dl_sharing_dl_res_c>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_c");
  }
}
shared_res_type_ul_dl_sharing_c::shared_res_type_ul_dl_sharing_c(const shared_res_type_ul_dl_sharing_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ul_res:
      c.init(other.c.get<shared_res_type_ul_dl_sharing_ul_res_c>());
      break;
    case types::dl_res:
      c.init(other.c.get<shared_res_type_ul_dl_sharing_dl_res_c>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_c");
  }
}
shared_res_type_ul_dl_sharing_c&
shared_res_type_ul_dl_sharing_c::operator=(const shared_res_type_ul_dl_sharing_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ul_res:
      c.set(other.c.get<shared_res_type_ul_dl_sharing_ul_res_c>());
      break;
    case types::dl_res:
      c.set(other.c.get<shared_res_type_ul_dl_sharing_dl_res_c>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_c");
  }

  return *this;
}
shared_res_type_ul_dl_sharing_ul_res_c& shared_res_type_ul_dl_sharing_c::set_ul_res()
{
  set(types::ul_res);
  return c.get<shared_res_type_ul_dl_sharing_ul_res_c>();
}
shared_res_type_ul_dl_sharing_dl_res_c& shared_res_type_ul_dl_sharing_c::set_dl_res()
{
  set(types::dl_res);
  return c.get<shared_res_type_ul_dl_sharing_dl_res_c>();
}
protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>&
shared_res_type_ul_dl_sharing_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>();
}
void shared_res_type_ul_dl_sharing_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_res:
      j.write_fieldname("ul-resources");
      c.get<shared_res_type_ul_dl_sharing_ul_res_c>().to_json(j);
      break;
    case types::dl_res:
      j.write_fieldname("dl-resources");
      c.get<shared_res_type_ul_dl_sharing_dl_res_c>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_c");
  }
  j.end_obj();
}
SRSASN_CODE shared_res_type_ul_dl_sharing_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ul_res:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_ul_res_c>().pack(bref));
      break;
    case types::dl_res:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_dl_res_c>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_res_type_ul_dl_sharing_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ul_res:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_ul_res_c>().unpack(bref));
      break;
    case types::dl_res:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_dl_res_c>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ul_dl_sharing_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_ul_dl_sharing_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* shared_res_type_ul_dl_sharing_c::types_opts::to_string() const
{
  static const char* names[] = {"ul-resources", "dl-resources", "choice-extension"};
  return convert_enum_idx(names, 3, value, "shared_res_type_ul_dl_sharing_c::types");
}

// ReservedSubframePattern ::= SEQUENCE
SRSASN_CODE reserved_sf_pattern_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbsfn_ctrl_region_len_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(sf_type.pack(bref));
  HANDLE_CODE(reserved_sf_pattern.pack(bref));
  if (mbsfn_ctrl_region_len_present) {
    HANDLE_CODE(pack_integer(bref, mbsfn_ctrl_region_len, (uint8_t)0u, (uint8_t)3u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reserved_sf_pattern_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbsfn_ctrl_region_len_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(sf_type.unpack(bref));
  HANDLE_CODE(reserved_sf_pattern.unpack(bref));
  if (mbsfn_ctrl_region_len_present) {
    HANDLE_CODE(unpack_integer(mbsfn_ctrl_region_len, bref, (uint8_t)0u, (uint8_t)3u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void reserved_sf_pattern_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("subframeType", sf_type.to_string());
  j.write_str("reservedSubframePattern", reserved_sf_pattern.to_string());
  if (mbsfn_ctrl_region_len_present) {
    j.write_int("mbsfnControlRegionLength", mbsfn_ctrl_region_len);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* reserved_sf_pattern_s::sf_type_opts::to_string() const
{
  static const char* names[] = {"mbsfn", "non-mbsfn"};
  return convert_enum_idx(names, 2, value, "reserved_sf_pattern_s::sf_type_e_");
}

// SharedResourceType ::= CHOICE
void shared_res_type_c::destroy_()
{
  switch (type_) {
    case types::ul_only_sharing:
      c.destroy<shared_res_type_ul_only_sharing_s>();
      break;
    case types::ul_and_dl_sharing:
      c.destroy<shared_res_type_ul_dl_sharing_c>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void shared_res_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ul_only_sharing:
      c.init<shared_res_type_ul_only_sharing_s>();
      break;
    case types::ul_and_dl_sharing:
      c.init<shared_res_type_ul_dl_sharing_c>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_c");
  }
}
shared_res_type_c::shared_res_type_c(const shared_res_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ul_only_sharing:
      c.init(other.c.get<shared_res_type_ul_only_sharing_s>());
      break;
    case types::ul_and_dl_sharing:
      c.init(other.c.get<shared_res_type_ul_dl_sharing_c>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_c");
  }
}
shared_res_type_c& shared_res_type_c::operator=(const shared_res_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ul_only_sharing:
      c.set(other.c.get<shared_res_type_ul_only_sharing_s>());
      break;
    case types::ul_and_dl_sharing:
      c.set(other.c.get<shared_res_type_ul_dl_sharing_c>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_c");
  }

  return *this;
}
shared_res_type_ul_only_sharing_s& shared_res_type_c::set_ul_only_sharing()
{
  set(types::ul_only_sharing);
  return c.get<shared_res_type_ul_only_sharing_s>();
}
shared_res_type_ul_dl_sharing_c& shared_res_type_c::set_ul_and_dl_sharing()
{
  set(types::ul_and_dl_sharing);
  return c.get<shared_res_type_ul_dl_sharing_c>();
}
protocol_ie_single_container_s<shared_res_type_ext_ies_o>& shared_res_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>();
}
void shared_res_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_only_sharing:
      j.write_fieldname("ul-onlySharing");
      c.get<shared_res_type_ul_only_sharing_s>().to_json(j);
      break;
    case types::ul_and_dl_sharing:
      j.write_fieldname("ul-and-dl-Sharing");
      c.get<shared_res_type_ul_dl_sharing_c>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_c");
  }
  j.end_obj();
}
SRSASN_CODE shared_res_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ul_only_sharing:
      HANDLE_CODE(c.get<shared_res_type_ul_only_sharing_s>().pack(bref));
      break;
    case types::ul_and_dl_sharing:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_c>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_res_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ul_only_sharing:
      HANDLE_CODE(c.get<shared_res_type_ul_only_sharing_s>().unpack(bref));
      break;
    case types::ul_and_dl_sharing:
      HANDLE_CODE(c.get<shared_res_type_ul_dl_sharing_c>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<shared_res_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "shared_res_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* shared_res_type_c::types_opts::to_string() const
{
  static const char* names[] = {"ul-onlySharing", "ul-and-dl-Sharing", "choice-extension"};
  return convert_enum_idx(names, 3, value, "shared_res_type_c::types");
}

// DataTrafficResourceIndication ::= SEQUENCE
SRSASN_CODE data_traffic_res_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(reserved_sf_pattern_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, activation_sfn, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(shared_res_type.pack(bref));
  if (reserved_sf_pattern_present) {
    HANDLE_CODE(reserved_sf_pattern.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_traffic_res_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(reserved_sf_pattern_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(activation_sfn, bref, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(shared_res_type.unpack(bref));
  if (reserved_sf_pattern_present) {
    HANDLE_CODE(reserved_sf_pattern.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_traffic_res_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("activationSFN", activation_sfn);
  j.write_fieldname("sharedResourceType");
  shared_res_type.to_json(j);
  if (reserved_sf_pattern_present) {
    j.write_fieldname("reservedSubframePattern");
    reserved_sf_pattern.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ULForwardingProposal ::= ENUMERATED
const char* ul_forwarding_proposal_opts::to_string() const
{
  static const char* names[] = {"ul-forwarding-proposed"};
  return convert_enum_idx(names, 1, value, "ul_forwarding_proposal_e");
}

// DLForwarding ::= ENUMERATED
const char* dl_forwarding_opts::to_string() const
{
  static const char* names[] = {"dl-forwarding-proposed"};
  return convert_enum_idx(names, 1, value, "dl_forwarding_e");
}

// QoSFLowsToBeForwarded-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_f_lows_to_be_forwarded_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {138, 255, 256};
  return map_enum_number(names, 3, idx, "id");
}
bool qos_f_lows_to_be_forwarded_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {138, 255, 256};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_f_lows_to_be_forwarded_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 138:
      return crit_e::ignore;
    case 255:
      return crit_e::ignore;
    case 256:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c qos_f_lows_to_be_forwarded_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 138:
      ret.set(ext_c::types::ul_forwarding_proposal);
      break;
    case 255:
      ret.set(ext_c::types::source_dl_forwarding_ip_address);
      break;
    case 256:
      ret.set(ext_c::types::source_node_dl_forwarding_ip_address);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_f_lows_to_be_forwarded_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 138:
      return presence_e::optional;
    case 255:
      return presence_e::optional;
    case 256:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ul_forwarding_proposal:
      c = ul_forwarding_proposal_e{};
      break;
    case types::source_dl_forwarding_ip_address:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::source_node_dl_forwarding_ip_address:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c");
  }
}
ul_forwarding_proposal_e& qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::ul_forwarding_proposal()
{
  assert_choice_type(types::ul_forwarding_proposal, type_, "Extension");
  return c.get<ul_forwarding_proposal_e>();
}
bounded_bitstring<1, 160, true, true>&
qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::source_dl_forwarding_ip_address()
{
  assert_choice_type(types::source_dl_forwarding_ip_address, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
bounded_bitstring<1, 160, true, true>&
qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::source_node_dl_forwarding_ip_address()
{
  assert_choice_type(types::source_node_dl_forwarding_ip_address, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const ul_forwarding_proposal_e& qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::ul_forwarding_proposal() const
{
  assert_choice_type(types::ul_forwarding_proposal, type_, "Extension");
  return c.get<ul_forwarding_proposal_e>();
}
const bounded_bitstring<1, 160, true, true>&
qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::source_dl_forwarding_ip_address() const
{
  assert_choice_type(types::source_dl_forwarding_ip_address, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const bounded_bitstring<1, 160, true, true>&
qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::source_node_dl_forwarding_ip_address() const
{
  assert_choice_type(types::source_node_dl_forwarding_ip_address, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
void qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_forwarding_proposal:
      j.write_str("ULForwardingProposal", "ul-forwarding-proposed");
      break;
    case types::source_dl_forwarding_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::source_node_dl_forwarding_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_forwarding_proposal:
      HANDLE_CODE(c.get<ul_forwarding_proposal_e>().pack(bref));
      break;
    case types::source_dl_forwarding_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::source_node_dl_forwarding_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_forwarding_proposal:
      HANDLE_CODE(c.get<ul_forwarding_proposal_e>().unpack(bref));
      break;
    case types::source_dl_forwarding_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::source_node_dl_forwarding_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ULForwardingProposal", "BIT STRING", "BIT STRING"};
  return convert_enum_idx(names, 3, value, "qos_f_lows_to_be_forwarded_item_ext_ies_o::ext_c::types");
}

// ULForwarding ::= ENUMERATED
const char* ul_forwarding_opts::to_string() const
{
  static const char* names[] = {"ul-forwarding-proposed"};
  return convert_enum_idx(names, 1, value, "ul_forwarding_e");
}

template struct asn1::protocol_ext_field_s<qos_f_lows_to_be_forwarded_item_ext_ies_o>;

SRSASN_CODE qos_f_lows_to_be_forwarded_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ul_forwarding_proposal_present ? 1 : 0;
  nof_ies += source_dl_forwarding_ip_address_present ? 1 : 0;
  nof_ies += source_node_dl_forwarding_ip_address_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ul_forwarding_proposal_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)138, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_forwarding_proposal.pack(bref));
  }
  if (source_dl_forwarding_ip_address_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)255, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_dl_forwarding_ip_address.pack(bref));
  }
  if (source_node_dl_forwarding_ip_address_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)256, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_node_dl_forwarding_ip_address.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_f_lows_to_be_forwarded_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 138: {
        ul_forwarding_proposal_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_forwarding_proposal.unpack(bref));
        break;
      }
      case 255: {
        source_dl_forwarding_ip_address_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_dl_forwarding_ip_address.unpack(bref));
        break;
      }
      case 256: {
        source_node_dl_forwarding_ip_address_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_node_dl_forwarding_ip_address.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_f_lows_to_be_forwarded_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_forwarding_proposal_present) {
    j.write_int("id", 138);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "ul-forwarding-proposed");
  }
  if (source_dl_forwarding_ip_address_present) {
    j.write_int("id", 255);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", source_dl_forwarding_ip_address.to_string());
  }
  if (source_node_dl_forwarding_ip_address_present) {
    j.write_int("id", 256);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", source_node_dl_forwarding_ip_address.to_string());
  }
  j.end_obj();
}

// QoSFLowsToBeForwarded-Item ::= SEQUENCE
SRSASN_CODE qos_f_lows_to_be_forwarded_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(dl_dataforwarding.pack(bref));
  HANDLE_CODE(ul_dataforwarding.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_f_lows_to_be_forwarded_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(dl_dataforwarding.unpack(bref));
  HANDLE_CODE(ul_dataforwarding.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_f_lows_to_be_forwarded_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_str("dl-dataforwarding", "dl-forwarding-proposed");
  j.write_str("ul-dataforwarding", "ul-forwarding-proposed");
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DataforwardingandOffloadingInfofromSource ::= SEQUENCE
SRSASN_CODE dataforwardingand_offloading_infofrom_source_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(source_drb_to_qos_flow_map.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_forwarded, 1, 64, true));
  if (source_drb_to_qos_flow_map.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, source_drb_to_qos_flow_map, 1, 32, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dataforwardingand_offloading_infofrom_source_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool source_drb_to_qos_flow_map_present;
  HANDLE_CODE(bref.unpack(source_drb_to_qos_flow_map_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_forwarded, bref, 1, 64, true));
  if (source_drb_to_qos_flow_map_present) {
    HANDLE_CODE(unpack_dyn_seq_of(source_drb_to_qos_flow_map, bref, 1, 32, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dataforwardingand_offloading_infofrom_source_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("qosFlowsToBeForwarded");
  for (const auto& e1 : qos_flows_to_be_forwarded) {
    e1.to_json(j);
  }
  j.end_array();
  if (source_drb_to_qos_flow_map.size() > 0) {
    j.start_array("sourceDRBtoQoSFlowMapping");
    for (const auto& e1 : source_drb_to_qos_flow_map) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// E-UTRA-CoordinationAssistanceInfo ::= ENUMERATED
const char* e_utra_coordination_assist_info_opts::to_string() const
{
  static const char* names[] = {"coordination-not-required"};
  return convert_enum_idx(names, 1, value, "e_utra_coordination_assist_info_e");
}

// E-UTRA-ResourceCoordinationInfo ::= SEQUENCE
SRSASN_CODE e_utra_res_coordination_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_coordination_info_present, 1));
  HANDLE_CODE(bref.pack(nr_cell_present, 1));
  HANDLE_CODE(bref.pack(e_utra_coordination_assist_info_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(e_utra_cell.pack(bref));
  HANDLE_CODE(ul_coordination_info.pack(bref));
  if (dl_coordination_info_present) {
    HANDLE_CODE(dl_coordination_info.pack(bref));
  }
  if (nr_cell_present) {
    HANDLE_CODE(nr_cell.pack(bref));
  }
  if (e_utra_coordination_assist_info_present) {
    HANDLE_CODE(e_utra_coordination_assist_info.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE e_utra_res_coordination_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_coordination_info_present, 1));
  HANDLE_CODE(bref.unpack(nr_cell_present, 1));
  HANDLE_CODE(bref.unpack(e_utra_coordination_assist_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(e_utra_cell.unpack(bref));
  HANDLE_CODE(ul_coordination_info.unpack(bref));
  if (dl_coordination_info_present) {
    HANDLE_CODE(dl_coordination_info.unpack(bref));
  }
  if (nr_cell_present) {
    HANDLE_CODE(nr_cell.unpack(bref));
  }
  if (e_utra_coordination_assist_info_present) {
    HANDLE_CODE(e_utra_coordination_assist_info.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void e_utra_res_coordination_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("e-utra-cell");
  e_utra_cell.to_json(j);
  j.write_str("ul-coordination-info", ul_coordination_info.to_string());
  if (dl_coordination_info_present) {
    j.write_str("dl-coordination-info", dl_coordination_info.to_string());
  }
  if (nr_cell_present) {
    j.write_fieldname("nr-cell");
    nr_cell.to_json(j);
  }
  if (e_utra_coordination_assist_info_present) {
    j.write_str("e-utra-coordination-assistance-info", "coordination-not-required");
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// EUTRAPaging-Time-Window ::= ENUMERATED
const char* eutra_paging_time_win_opts::to_string() const
{
  static const char* names[] = {
      "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"};
  return convert_enum_idx(names, 16, value, "eutra_paging_time_win_e");
}
uint8_t eutra_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
  return map_enum_number(numbers, 16, value, "eutra_paging_time_win_e");
}

// EUTRAPaging-eDRX-Cycle ::= ENUMERATED
const char* eutra_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hfhalf", "hf1", "hf2", "hf4", "hf6", "hf8", "hf10", "hf12", "hf14", "hf16", "hf32", "hf64", "hf128", "hf256"};
  return convert_enum_idx(names, 14, value, "eutra_paging_e_drx_cycle_e");
}
float eutra_paging_e_drx_cycle_opts::to_number() const
{
  static const float numbers[] = {0.5, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 32.0, 64.0, 128.0, 256.0};
  return map_enum_number(numbers, 14, value, "eutra_paging_e_drx_cycle_e");
}
const char* eutra_paging_e_drx_cycle_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.5", "1", "2", "4", "6", "8", "10", "12", "14", "16", "32", "64", "128", "256"};
  return convert_enum_idx(number_strs, 14, value, "eutra_paging_e_drx_cycle_e");
}

// EUTRAPagingeDRXInformation ::= SEQUENCE
SRSASN_CODE eutra_paginge_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(eutrapaging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutrapaging_e_drx_cycle.pack(bref));
  if (eutrapaging_time_win_present) {
    HANDLE_CODE(eutrapaging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_paginge_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(eutrapaging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutrapaging_e_drx_cycle.unpack(bref));
  if (eutrapaging_time_win_present) {
    HANDLE_CODE(eutrapaging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_paginge_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eutrapaging-eDRX-Cycle", eutrapaging_e_drx_cycle.to_string());
  if (eutrapaging_time_win_present) {
    j.write_str("eutrapaging-Time-Window", eutrapaging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MeasurementThresholdL1LoggedMDT ::= CHOICE
void meas_thres_l1_logged_mdt_c::destroy_() {}
void meas_thres_l1_logged_mdt_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
meas_thres_l1_logged_mdt_c::meas_thres_l1_logged_mdt_c(const meas_thres_l1_logged_mdt_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::thres_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.init(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
}
meas_thres_l1_logged_mdt_c& meas_thres_l1_logged_mdt_c::operator=(const meas_thres_l1_logged_mdt_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::thres_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.set(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }

  return *this;
}
uint8_t& meas_thres_l1_logged_mdt_c::set_thres_rsrp()
{
  set(types::thres_rsrp);
  return c.get<uint8_t>();
}
uint8_t& meas_thres_l1_logged_mdt_c::set_thres_rsrq()
{
  set(types::thres_rsrq);
  return c.get<uint8_t>();
}
void meas_thres_l1_logged_mdt_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::thres_rsrp:
      j.write_int("threshold-RSRP", c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      j.write_int("threshold-RSRQ", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
  j.end_obj();
}
SRSASN_CODE meas_thres_l1_logged_mdt_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE meas_thres_l1_logged_mdt_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* meas_thres_l1_logged_mdt_c::types_opts::to_string() const
{
  static const char* names[] = {"threshold-RSRP", "threshold-RSRQ"};
  return convert_enum_idx(names, 2, value, "meas_thres_l1_logged_mdt_c::types");
}

// TimeToTrigger ::= ENUMERATED
const char* time_to_trigger_opts::to_string() const
{
  static const char* names[] = {"ms0",
                                "ms40",
                                "ms64",
                                "ms80",
                                "ms100",
                                "ms128",
                                "ms160",
                                "ms256",
                                "ms320",
                                "ms480",
                                "ms512",
                                "ms640",
                                "ms1024",
                                "ms1280",
                                "ms2560",
                                "ms5120"};
  return convert_enum_idx(names, 16, value, "time_to_trigger_e");
}
uint16_t time_to_trigger_opts::to_number() const
{
  static const uint16_t numbers[] = {0, 40, 64, 80, 100, 128, 160, 256, 320, 480, 512, 640, 1024, 1280, 2560, 5120};
  return map_enum_number(numbers, 16, value, "time_to_trigger_e");
}

// EventL1 ::= SEQUENCE
SRSASN_CODE event_l1_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(l1_thres.pack(bref));
  HANDLE_CODE(pack_integer(bref, hysteresis, (uint8_t)0u, (uint8_t)30u, false, true));
  HANDLE_CODE(time_to_trigger.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_l1_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(l1_thres.unpack(bref));
  HANDLE_CODE(unpack_integer(hysteresis, bref, (uint8_t)0u, (uint8_t)30u, false, true));
  HANDLE_CODE(time_to_trigger.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void event_l1_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("l1Threshold");
  l1_thres.to_json(j);
  j.write_int("hysteresis", hysteresis);
  j.write_str("timeToTrigger", time_to_trigger.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EventTypeTrigger ::= CHOICE
void event_type_trigger_c::destroy_()
{
  switch (type_) {
    case types::event_l1:
      c.destroy<event_l1_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void event_type_trigger_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::out_of_coverage:
      break;
    case types::event_l1:
      c.init<event_l1_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_type_trigger_c");
  }
}
event_type_trigger_c::event_type_trigger_c(const event_type_trigger_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::out_of_coverage:
      c.init(other.c.get<out_of_coverage_e_>());
      break;
    case types::event_l1:
      c.init(other.c.get<event_l1_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_type_trigger_c");
  }
}
event_type_trigger_c& event_type_trigger_c::operator=(const event_type_trigger_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::out_of_coverage:
      c.set(other.c.get<out_of_coverage_e_>());
      break;
    case types::event_l1:
      c.set(other.c.get<event_l1_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_type_trigger_c");
  }

  return *this;
}
event_type_trigger_c::out_of_coverage_e_& event_type_trigger_c::set_out_of_coverage()
{
  set(types::out_of_coverage);
  return c.get<out_of_coverage_e_>();
}
event_l1_s& event_type_trigger_c::set_event_l1()
{
  set(types::event_l1);
  return c.get<event_l1_s>();
}
protocol_ie_single_container_s<event_type_trigger_ext_ies_o>& event_type_trigger_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>();
}
void event_type_trigger_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::out_of_coverage:
      j.write_str("outOfCoverage", "true");
      break;
    case types::event_l1:
      j.write_fieldname("eventL1");
      c.get<event_l1_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "event_type_trigger_c");
  }
  j.end_obj();
}
SRSASN_CODE event_type_trigger_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::out_of_coverage:
      HANDLE_CODE(c.get<out_of_coverage_e_>().pack(bref));
      break;
    case types::event_l1:
      HANDLE_CODE(c.get<event_l1_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "event_type_trigger_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE event_type_trigger_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::out_of_coverage:
      HANDLE_CODE(c.get<out_of_coverage_e_>().unpack(bref));
      break;
    case types::event_l1:
      HANDLE_CODE(c.get<event_l1_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<event_type_trigger_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "event_type_trigger_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* event_type_trigger_c::out_of_coverage_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "event_type_trigger_c::out_of_coverage_e_");
}

const char* event_type_trigger_c::types_opts::to_string() const
{
  static const char* names[] = {"outOfCoverage", "eventL1", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "event_type_trigger_c::types");
}
uint8_t event_type_trigger_c::types_opts::to_number() const
{
  if (value == event_l1) {
    return 1;
  }
  invalid_enum_number(value, "event_type_trigger_c::types");
  return 0;
}

// LoggedEventTriggeredConfig ::= SEQUENCE
SRSASN_CODE logged_event_triggered_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(event_type_trigger.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_event_triggered_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(event_type_trigger.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void logged_event_triggered_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eventTypeTrigger");
  event_type_trigger.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EventTriggered ::= SEQUENCE
SRSASN_CODE event_triggered_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(logged_event_triggered_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_triggered_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(logged_event_triggered_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void event_triggered_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("loggedEventTriggeredConfig");
  logged_event_triggered_cfg.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExcessPacketDelayThresholdValue ::= ENUMERATED
const char* excess_packet_delay_thres_value_opts::to_string() const
{
  static const char* names[] = {"ms0dot25",
                                "ms0dot5",
                                "ms1",
                                "ms2",
                                "ms4",
                                "ms5",
                                "ms10",
                                "ms20",
                                "ms30",
                                "ms40",
                                "ms50",
                                "ms60",
                                "ms70",
                                "ms80",
                                "ms90",
                                "ms100",
                                "ms150",
                                "ms300",
                                "ms500"};
  return convert_enum_idx(names, 19, value, "excess_packet_delay_thres_value_e");
}
float excess_packet_delay_thres_value_opts::to_number() const
{
  static const float numbers[] = {
      0.25, 0.5, 1.0, 2.0, 4.0, 5.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 150.0, 300.0, 500.0};
  return map_enum_number(numbers, 19, value, "excess_packet_delay_thres_value_e");
}
const char* excess_packet_delay_thres_value_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25",
                                      "0.5",
                                      "1",
                                      "2",
                                      "4",
                                      "5",
                                      "10",
                                      "20",
                                      "30",
                                      "40",
                                      "50",
                                      "60",
                                      "70",
                                      "80",
                                      "90",
                                      "100",
                                      "150",
                                      "300",
                                      "500"};
  return convert_enum_idx(number_strs, 19, value, "excess_packet_delay_thres_value_e");
}

// ExcessPacketDelayThresholdItem ::= SEQUENCE
SRSASN_CODE excess_packet_delay_thres_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(excess_packet_delay_thres_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE excess_packet_delay_thres_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(excess_packet_delay_thres_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void excess_packet_delay_thres_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQI", five_qi);
  j.write_str("excessPacketDelayThresholdValue", excess_packet_delay_thres_value.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SourceOfUEActivityBehaviourInformation ::= ENUMERATED
const char* source_of_ue_activity_behaviour_info_opts::to_string() const
{
  static const char* names[] = {"subscription-information", "statistics"};
  return convert_enum_idx(names, 2, value, "source_of_ue_activity_behaviour_info_e");
}

// ExpectedUEActivityBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_activity_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.pack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.pack(source_of_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_activity_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_idle_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (source_of_ue_activity_behaviour_info_present) {
    HANDLE_CODE(source_of_ue_activity_behaviour_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_activity_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.unpack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.unpack(source_of_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(unpack_integer(expected_activity_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(unpack_integer(expected_idle_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (source_of_ue_activity_behaviour_info_present) {
    HANDLE_CODE(source_of_ue_activity_behaviour_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_activity_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_activity_period_present) {
    j.write_int("expectedActivityPeriod", expected_activity_period);
  }
  if (expected_idle_period_present) {
    j.write_int("expectedIdlePeriod", expected_idle_period);
  }
  if (source_of_ue_activity_behaviour_info_present) {
    j.write_str("sourceOfUEActivityBehaviourInformation", source_of_ue_activity_behaviour_info.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExpectedUEMovingTrajectoryItem ::= SEQUENCE
SRSASN_CODE expected_ue_moving_trajectory_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(pack_integer(bref, time_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_moving_trajectory_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(unpack_integer(time_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_moving_trajectory_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (time_stayed_in_cell_present) {
    j.write_int("timeStayedInCell", time_stayed_in_cell);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExpectedHOInterval ::= ENUMERATED
const char* expected_ho_interv_opts::to_string() const
{
  static const char* names[] = {"sec15", "sec30", "sec60", "sec90", "sec120", "sec180", "long-time"};
  return convert_enum_idx(names, 7, value, "expected_ho_interv_e");
}
uint8_t expected_ho_interv_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 60, 90, 120, 180};
  return map_enum_number(numbers, 6, value, "expected_ho_interv_e");
}

// ExpectedUEMobility ::= ENUMERATED
const char* expected_ue_mob_opts::to_string() const
{
  static const char* names[] = {"stationary", "mobile"};
  return convert_enum_idx(names, 2, value, "expected_ue_mob_e");
}

// ExpectedUEBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_ue_activity_behaviour_present, 1));
  HANDLE_CODE(bref.pack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_mob_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_moving_trajectory.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_ue_activity_behaviour_present) {
    HANDLE_CODE(expected_ue_activity_behaviour.pack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.pack(bref));
  }
  if (expected_ue_mob_present) {
    HANDLE_CODE(expected_ue_mob.pack(bref));
  }
  if (expected_ue_moving_trajectory.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, expected_ue_moving_trajectory, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_ue_activity_behaviour_present, 1));
  HANDLE_CODE(bref.unpack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.unpack(expected_ue_mob_present, 1));
  bool expected_ue_moving_trajectory_present;
  HANDLE_CODE(bref.unpack(expected_ue_moving_trajectory_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_ue_activity_behaviour_present) {
    HANDLE_CODE(expected_ue_activity_behaviour.unpack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.unpack(bref));
  }
  if (expected_ue_mob_present) {
    HANDLE_CODE(expected_ue_mob.unpack(bref));
  }
  if (expected_ue_moving_trajectory_present) {
    HANDLE_CODE(unpack_dyn_seq_of(expected_ue_moving_trajectory, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_ue_activity_behaviour_present) {
    j.write_fieldname("expectedUEActivityBehaviour");
    expected_ue_activity_behaviour.to_json(j);
  }
  if (expected_ho_interv_present) {
    j.write_str("expectedHOInterval", expected_ho_interv.to_string());
  }
  if (expected_ue_mob_present) {
    j.write_str("expectedUEMobility", expected_ue_mob.to_string());
  }
  if (expected_ue_moving_trajectory.size() > 0) {
    j.start_array("expectedUEMovingTrajectory");
    for (const auto& e1 : expected_ue_moving_trajectory) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GTPTLA-Item ::= SEQUENCE
SRSASN_CODE gtp_tla_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gtp_transport_layer_addresses.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gtp_tla_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gtp_transport_layer_addresses.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gtp_tla_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("gTPTransportLayerAddresses", gtp_transport_layer_addresses.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExtTLA-Item ::= SEQUENCE
SRSASN_CODE ext_tla_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ip_sec_tla_present, 1));
  HANDLE_CODE(bref.pack(gtp_transport_layer_addresses.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ip_sec_tla_present) {
    HANDLE_CODE(ip_sec_tla.pack(bref));
  }
  if (gtp_transport_layer_addresses.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, gtp_transport_layer_addresses, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ext_tla_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ip_sec_tla_present, 1));
  bool gtp_transport_layer_addresses_present;
  HANDLE_CODE(bref.unpack(gtp_transport_layer_addresses_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ip_sec_tla_present) {
    HANDLE_CODE(ip_sec_tla.unpack(bref));
  }
  if (gtp_transport_layer_addresses_present) {
    HANDLE_CODE(unpack_dyn_seq_of(gtp_transport_layer_addresses, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ext_tla_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ip_sec_tla_present) {
    j.write_str("iPsecTLA", ip_sec_tla.to_string());
  }
  if (gtp_transport_layer_addresses.size() > 0) {
    j.start_array("gTPTransportLayerAddresses");
    for (const auto& e1 : gtp_transport_layer_addresses) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExtendedRATRestrictionInformation ::= SEQUENCE
SRSASN_CODE extended_rat_restrict_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(primary_rat_restrict.pack(bref));
  HANDLE_CODE(secondary_rat_restrict.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_rat_restrict_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(primary_rat_restrict.unpack(bref));
  HANDLE_CODE(secondary_rat_restrict.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_rat_restrict_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("primaryRATRestriction", primary_rat_restrict.to_string());
  j.write_str("secondaryRATRestriction", secondary_rat_restrict.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABTNLAddress ::= CHOICE
void iab_tnl_address_c::destroy_()
{
  switch (type_) {
    case types::ip_v4_address:
      c.destroy<fixed_bitstring<32, false, true>>();
      break;
    case types::ip_v6_address:
      c.destroy<fixed_bitstring<128, false, true>>();
      break;
    case types::ip_v6_prefix:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void iab_tnl_address_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ip_v4_address:
      c.init<fixed_bitstring<32, false, true>>();
      break;
    case types::ip_v6_address:
      c.init<fixed_bitstring<128, false, true>>();
      break;
    case types::ip_v6_prefix:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }
}
iab_tnl_address_c::iab_tnl_address_c(const iab_tnl_address_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ip_v4_address:
      c.init(other.c.get<fixed_bitstring<32, false, true>>());
      break;
    case types::ip_v6_address:
      c.init(other.c.get<fixed_bitstring<128, false, true>>());
      break;
    case types::ip_v6_prefix:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }
}
iab_tnl_address_c& iab_tnl_address_c::operator=(const iab_tnl_address_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ip_v4_address:
      c.set(other.c.get<fixed_bitstring<32, false, true>>());
      break;
    case types::ip_v6_address:
      c.set(other.c.get<fixed_bitstring<128, false, true>>());
      break;
    case types::ip_v6_prefix:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }

  return *this;
}
fixed_bitstring<32, false, true>& iab_tnl_address_c::set_ip_v4_address()
{
  set(types::ip_v4_address);
  return c.get<fixed_bitstring<32, false, true>>();
}
fixed_bitstring<128, false, true>& iab_tnl_address_c::set_ip_v6_address()
{
  set(types::ip_v6_address);
  return c.get<fixed_bitstring<128, false, true>>();
}
fixed_bitstring<64, false, true>& iab_tnl_address_c::set_ip_v6_prefix()
{
  set(types::ip_v6_prefix);
  return c.get<fixed_bitstring<64, false, true>>();
}
protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>& iab_tnl_address_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
}
void iab_tnl_address_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ip_v4_address:
      j.write_str("iPv4Address", c.get<fixed_bitstring<32, false, true>>().to_string());
      break;
    case types::ip_v6_address:
      j.write_str("iPv6Address", c.get<fixed_bitstring<128, false, true>>().to_string());
      break;
    case types::ip_v6_prefix:
      j.write_str("iPv6Prefix", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_tnl_address_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ip_v4_address:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true>>().pack(bref)));
      break;
    case types::ip_v6_address:
      HANDLE_CODE((c.get<fixed_bitstring<128, false, true>>().pack(bref)));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_address_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ip_v4_address:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true>>().unpack(bref)));
      break;
    case types::ip_v6_address:
      HANDLE_CODE((c.get<fixed_bitstring<128, false, true>>().unpack(bref)));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* iab_tnl_address_c::types_opts::to_string() const
{
  static const char* names[] = {"iPv4Address", "iPv6Address", "iPv6Prefix", "choice-extension"};
  return convert_enum_idx(names, 4, value, "iab_tnl_address_c::types");
}

// ULF1Terminating-BHInfo ::= SEQUENCE
SRSASN_CODE ul_f1_terminating_bh_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.pack(bref));
  HANDLE_CODE(ingress_bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_f1_terminating_bh_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.unpack(bref));
  HANDLE_CODE(ingress_bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_f1_terminating_bh_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ingressBAPRoutingID");
  ingress_bap_routing_id.to_json(j);
  j.write_str("ingressBHRLCCHID", ingress_bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// F1TerminatingBHInformation-Item ::= SEQUENCE
SRSASN_CODE f1_terminating_bh_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.pack(ul_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, bh_info_idx, (uint16_t)1u, (uint16_t)1024u, false, true));
  HANDLE_CODE(dl_tnl_address.pack(bref));
  if (dl_f1_terminating_bh_info_present) {
    HANDLE_CODE(dl_f1_terminating_bh_info.pack(bref));
  }
  if (ul_f1_terminating_bh_info_present) {
    HANDLE_CODE(ul_f1_terminating_bh_info.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE f1_terminating_bh_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(bh_info_idx, bref, (uint16_t)1u, (uint16_t)1024u, false, true));
  HANDLE_CODE(dl_tnl_address.unpack(bref));
  if (dl_f1_terminating_bh_info_present) {
    HANDLE_CODE(dl_f1_terminating_bh_info.unpack(bref));
  }
  if (ul_f1_terminating_bh_info_present) {
    HANDLE_CODE(ul_f1_terminating_bh_info.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void f1_terminating_bh_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("bHInfoIndex", bh_info_idx);
  j.write_fieldname("dLTNLAddress");
  dl_tnl_address.to_json(j);
  if (dl_f1_terminating_bh_info_present) {
    j.write_fieldname("dlF1TerminatingBHInfo");
    dl_f1_terminating_bh_info.to_json(j);
  }
  if (ul_f1_terminating_bh_info_present) {
    j.write_fieldname("ulF1TerminatingBHInfo");
    ul_f1_terminating_bh_info.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// F1-TerminatingTopologyBHInformation ::= SEQUENCE
SRSASN_CODE f1_terminating_topology_bh_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, f1_terminating_bh_info_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE f1_terminating_topology_bh_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(f1_terminating_bh_info_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void f1_terminating_topology_bh_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("f1TerminatingBHInformation-List");
  for (const auto& e1 : f1_terminating_bh_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UERLFReportContainerLTEExtension ::= SEQUENCE
SRSASN_CODE ue_rlf_report_container_lte_ext_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container_lte.pack(bref));
  HANDLE_CODE(ue_rlf_report_container_lte_extend_band.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_rlf_report_container_lte_ext_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container_lte.unpack(bref));
  HANDLE_CODE(ue_rlf_report_container_lte_extend_band.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_rlf_report_container_lte_ext_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ueRLFReportContainerLTE", ue_rlf_report_container_lte.to_string());
  j.write_str("ueRLFReportContainerLTEExtendBand", ue_rlf_report_container_lte_extend_band.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCConnReestab-Indicator ::= ENUMERATED
const char* rrc_conn_reestab_ind_opts::to_string() const
{
  static const char* names[] = {"reconfigurationFailure", "handoverFailure", "otherFailure"};
  return convert_enum_idx(names, 3, value, "rrc_conn_reestab_ind_e");
}

// UERLFReportContainer-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-IES
uint32_t ue_rlf_report_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {370};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_rlf_report_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 370 == id;
}
crit_e ue_rlf_report_container_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 370) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_rlf_report_container_ext_ies_o::value_c ue_rlf_report_container_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 370) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_rlf_report_container_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 370) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ue_rlf_report_container_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("UERLFReportContainerLTEExtension");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ue_rlf_report_container_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_rlf_report_container_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_rlf_report_container_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UERLFReportContainerLTEExtension"};
  return convert_enum_idx(names, 1, value, "ue_rlf_report_container_ext_ies_o::value_c::types");
}

// NG-RAN-CellPCI ::= CHOICE
void ng_ran_cell_pci_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ng_ran_cell_pci_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      break;
    case types::e_utra:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_pci_c");
  }
}
ng_ran_cell_pci_c::ng_ran_cell_pci_c(const ng_ran_cell_pci_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<uint16_t>());
      break;
    case types::e_utra:
      c.init(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_pci_c");
  }
}
ng_ran_cell_pci_c& ng_ran_cell_pci_c::operator=(const ng_ran_cell_pci_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<uint16_t>());
      break;
    case types::e_utra:
      c.set(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_pci_c");
  }

  return *this;
}
uint16_t& ng_ran_cell_pci_c::set_nr()
{
  set(types::nr);
  return c.get<uint16_t>();
}
uint16_t& ng_ran_cell_pci_c::set_e_utra()
{
  set(types::e_utra);
  return c.get<uint16_t>();
}
protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>& ng_ran_cell_pci_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>();
}
void ng_ran_cell_pci_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_int("nr", c.get<uint16_t>());
      break;
    case types::e_utra:
      j.write_int("e-utra", c.get<uint16_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_pci_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_ran_cell_pci_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)1007u, true, true));
      break;
    case types::e_utra:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)503u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_pci_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_ran_cell_pci_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)1007u, true, true));
      break;
    case types::e_utra:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)503u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_ran_cell_pci_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_cell_pci_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_ran_cell_pci_c::types_opts::to_string() const
{
  static const char* names[] = {"nr", "e-utra", "choice-extension"};
  return convert_enum_idx(names, 3, value, "ng_ran_cell_pci_c::types");
}

// RRCReestab-Initiated-Reporting-wo-UERLFReport-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {259};
  return map_enum_number(names, 1, idx, "id");
}
bool rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 259 == id;
}
crit_e rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 259) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::ext_c
rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 259) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 259) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("RRCConnReestab-Indicator", c.to_string());
  j.end_obj();
}
SRSASN_CODE rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"RRCConnReestab-Indicator"};
  return convert_enum_idx(names, 1, value, "rrc_reestab_initiated_report_wo_ue_rlf_report_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>;

// UERLFReportContainer ::= CHOICE
void ue_rlf_report_container_c::destroy_()
{
  switch (type_) {
    case types::nr_ue_rlf_report_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::lte_ue_rlf_report_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_rlf_report_container_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr_ue_rlf_report_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::lte_ue_rlf_report_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
}
ue_rlf_report_container_c::ue_rlf_report_container_c(const ue_rlf_report_container_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr_ue_rlf_report_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::lte_ue_rlf_report_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
}
ue_rlf_report_container_c& ue_rlf_report_container_c::operator=(const ue_rlf_report_container_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr_ue_rlf_report_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::lte_ue_rlf_report_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_rlf_report_container_c::set_nr_ue_rlf_report_container()
{
  set(types::nr_ue_rlf_report_container);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_rlf_report_container_c::set_lte_ue_rlf_report_container()
{
  set(types::lte_ue_rlf_report_container);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>& ue_rlf_report_container_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
}
void ue_rlf_report_container_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr_ue_rlf_report_container:
      j.write_str("nR-UERLFReportContainer", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::lte_ue_rlf_report_container:
      j.write_str("lTE-UERLFReportContainer", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-Extension");
      c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_rlf_report_container_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr_ue_rlf_report_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::lte_ue_rlf_report_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_rlf_report_container_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr_ue_rlf_report_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::lte_ue_rlf_report_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_rlf_report_container_c::types_opts::to_string() const
{
  static const char* names[] = {"nR-UERLFReportContainer", "lTE-UERLFReportContainer", "choice-Extension"};
  return convert_enum_idx(names, 3, value, "ue_rlf_report_container_c::types");
}

// RRCReestab-Initiated-Reporting-with-UERLFReport ::= SEQUENCE
SRSASN_CODE rrc_reestab_initiated_report_with_ue_rlf_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_reestab_initiated_report_with_ue_rlf_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rrc_reestab_initiated_report_with_ue_rlf_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uERLFReportContainer");
  ue_rlf_report_container.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCReestab-Initiated-Reporting-wo-UERLFReport ::= SEQUENCE
SRSASN_CODE rrc_reestab_initiated_report_wo_ue_rlf_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(fail_cell_pci.pack(bref));
  HANDLE_CODE(reestab_cell_cgi.pack(bref));
  HANDLE_CODE(c_rnti.pack(bref));
  HANDLE_CODE(short_mac_i.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_reestab_initiated_report_wo_ue_rlf_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(fail_cell_pci.unpack(bref));
  HANDLE_CODE(reestab_cell_cgi.unpack(bref));
  HANDLE_CODE(c_rnti.unpack(bref));
  HANDLE_CODE(short_mac_i.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void rrc_reestab_initiated_report_wo_ue_rlf_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("failureCellPCI");
  fail_cell_pci.to_json(j);
  j.write_fieldname("reestabCellCGI");
  reestab_cell_cgi.to_json(j);
  j.write_str("c-RNTI", c_rnti.to_string());
  j.write_str("shortMAC-I", short_mac_i.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// RRCSetup-Initiated-Reporting-with-UERLFReport ::= SEQUENCE
SRSASN_CODE rrc_setup_initiated_report_with_ue_rlf_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_setup_initiated_report_with_ue_rlf_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rrc_setup_initiated_report_with_ue_rlf_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uERLFReportContainer");
  ue_rlf_report_container.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCReestab-Initiated-Reporting ::= CHOICE
void rrc_reestab_initiated_report_c::destroy_()
{
  switch (type_) {
    case types::rrc_reestab_report_wo_ue_rlf_report:
      c.destroy<rrc_reestab_initiated_report_wo_ue_rlf_report_s>();
      break;
    case types::rrc_reestab_report_with_ue_rlf_report:
      c.destroy<rrc_reestab_initiated_report_with_ue_rlf_report_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void rrc_reestab_initiated_report_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rrc_reestab_report_wo_ue_rlf_report:
      c.init<rrc_reestab_initiated_report_wo_ue_rlf_report_s>();
      break;
    case types::rrc_reestab_report_with_ue_rlf_report:
      c.init<rrc_reestab_initiated_report_with_ue_rlf_report_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_reestab_initiated_report_c");
  }
}
rrc_reestab_initiated_report_c::rrc_reestab_initiated_report_c(const rrc_reestab_initiated_report_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rrc_reestab_report_wo_ue_rlf_report:
      c.init(other.c.get<rrc_reestab_initiated_report_wo_ue_rlf_report_s>());
      break;
    case types::rrc_reestab_report_with_ue_rlf_report:
      c.init(other.c.get<rrc_reestab_initiated_report_with_ue_rlf_report_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_reestab_initiated_report_c");
  }
}
rrc_reestab_initiated_report_c& rrc_reestab_initiated_report_c::operator=(const rrc_reestab_initiated_report_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rrc_reestab_report_wo_ue_rlf_report:
      c.set(other.c.get<rrc_reestab_initiated_report_wo_ue_rlf_report_s>());
      break;
    case types::rrc_reestab_report_with_ue_rlf_report:
      c.set(other.c.get<rrc_reestab_initiated_report_with_ue_rlf_report_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_reestab_initiated_report_c");
  }

  return *this;
}
rrc_reestab_initiated_report_wo_ue_rlf_report_s&
rrc_reestab_initiated_report_c::set_rrc_reestab_report_wo_ue_rlf_report()
{
  set(types::rrc_reestab_report_wo_ue_rlf_report);
  return c.get<rrc_reestab_initiated_report_wo_ue_rlf_report_s>();
}
rrc_reestab_initiated_report_with_ue_rlf_report_s&
rrc_reestab_initiated_report_c::set_rrc_reestab_report_with_ue_rlf_report()
{
  set(types::rrc_reestab_report_with_ue_rlf_report);
  return c.get<rrc_reestab_initiated_report_with_ue_rlf_report_s>();
}
protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>& rrc_reestab_initiated_report_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>();
}
void rrc_reestab_initiated_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rrc_reestab_report_wo_ue_rlf_report:
      j.write_fieldname("rRCReestab-reporting-wo-UERLFReport");
      c.get<rrc_reestab_initiated_report_wo_ue_rlf_report_s>().to_json(j);
      break;
    case types::rrc_reestab_report_with_ue_rlf_report:
      j.write_fieldname("rRCReestab-reporting-with-UERLFReport");
      c.get<rrc_reestab_initiated_report_with_ue_rlf_report_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rrc_reestab_initiated_report_c");
  }
  j.end_obj();
}
SRSASN_CODE rrc_reestab_initiated_report_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::rrc_reestab_report_wo_ue_rlf_report:
      HANDLE_CODE(c.get<rrc_reestab_initiated_report_wo_ue_rlf_report_s>().pack(bref));
      break;
    case types::rrc_reestab_report_with_ue_rlf_report:
      HANDLE_CODE(c.get<rrc_reestab_initiated_report_with_ue_rlf_report_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_reestab_initiated_report_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_reestab_initiated_report_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::rrc_reestab_report_wo_ue_rlf_report:
      HANDLE_CODE(c.get<rrc_reestab_initiated_report_wo_ue_rlf_report_s>().unpack(bref));
      break;
    case types::rrc_reestab_report_with_ue_rlf_report:
      HANDLE_CODE(c.get<rrc_reestab_initiated_report_with_ue_rlf_report_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rrc_reestab_initiated_report_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_reestab_initiated_report_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* rrc_reestab_initiated_report_c::types_opts::to_string() const
{
  static const char* names[] = {
      "rRCReestab-reporting-wo-UERLFReport", "rRCReestab-reporting-with-UERLFReport", "choice-extension"};
  return convert_enum_idx(names, 3, value, "rrc_reestab_initiated_report_c::types");
}

// RRCSetup-Initiated-Reporting ::= CHOICE
void rrc_setup_initiated_report_c::destroy_()
{
  switch (type_) {
    case types::rrc_setup_report_with_ue_rlf_report:
      c.destroy<rrc_setup_initiated_report_with_ue_rlf_report_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void rrc_setup_initiated_report_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rrc_setup_report_with_ue_rlf_report:
      c.init<rrc_setup_initiated_report_with_ue_rlf_report_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_setup_initiated_report_c");
  }
}
rrc_setup_initiated_report_c::rrc_setup_initiated_report_c(const rrc_setup_initiated_report_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rrc_setup_report_with_ue_rlf_report:
      c.init(other.c.get<rrc_setup_initiated_report_with_ue_rlf_report_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_setup_initiated_report_c");
  }
}
rrc_setup_initiated_report_c& rrc_setup_initiated_report_c::operator=(const rrc_setup_initiated_report_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rrc_setup_report_with_ue_rlf_report:
      c.set(other.c.get<rrc_setup_initiated_report_with_ue_rlf_report_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_setup_initiated_report_c");
  }

  return *this;
}
rrc_setup_initiated_report_with_ue_rlf_report_s& rrc_setup_initiated_report_c::set_rrc_setup_report_with_ue_rlf_report()
{
  set(types::rrc_setup_report_with_ue_rlf_report);
  return c.get<rrc_setup_initiated_report_with_ue_rlf_report_s>();
}
protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>& rrc_setup_initiated_report_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>();
}
void rrc_setup_initiated_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rrc_setup_report_with_ue_rlf_report:
      j.write_fieldname("rRCSetup-reporting-with-UERLFReport");
      c.get<rrc_setup_initiated_report_with_ue_rlf_report_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rrc_setup_initiated_report_c");
  }
  j.end_obj();
}
SRSASN_CODE rrc_setup_initiated_report_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::rrc_setup_report_with_ue_rlf_report:
      HANDLE_CODE(c.get<rrc_setup_initiated_report_with_ue_rlf_report_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_setup_initiated_report_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_setup_initiated_report_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::rrc_setup_report_with_ue_rlf_report:
      HANDLE_CODE(c.get<rrc_setup_initiated_report_with_ue_rlf_report_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rrc_setup_initiated_report_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_setup_initiated_report_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* rrc_setup_initiated_report_c::types_opts::to_string() const
{
  static const char* names[] = {"rRCSetup-reporting-with-UERLFReport", "choice-extension"};
  return convert_enum_idx(names, 2, value, "rrc_setup_initiated_report_c::types");
}

// RRCReestab-initiated ::= SEQUENCE
SRSASN_CODE rrc_reestab_initiated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrrc_reestab_initiated_report.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_reestab_initiated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrrc_reestab_initiated_report.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rrc_reestab_initiated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("rRRCReestab-initiated-reporting");
  rrrc_reestab_initiated_report.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCSetup-initiated ::= SEQUENCE
SRSASN_CODE rrc_setup_initiated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrrc_setup_initiated_report.pack(bref));
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_setup_initiated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrrc_setup_initiated_report.unpack(bref));
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rrc_setup_initiated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("rRRCSetup-Initiated-Reporting");
  rrrc_setup_initiated_report.to_json(j);
  if (ue_rlf_report_container_present) {
    j.write_fieldname("uERLFReportContainer");
    ue_rlf_report_container.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InitiatingCondition-FailureIndication ::= CHOICE
void init_condition_fail_ind_c::destroy_()
{
  switch (type_) {
    case types::rrc_reestab:
      c.destroy<rrc_reestab_initiated_s>();
      break;
    case types::rrc_setup:
      c.destroy<rrc_setup_initiated_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void init_condition_fail_ind_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rrc_reestab:
      c.init<rrc_reestab_initiated_s>();
      break;
    case types::rrc_setup:
      c.init<rrc_setup_initiated_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_condition_fail_ind_c");
  }
}
init_condition_fail_ind_c::init_condition_fail_ind_c(const init_condition_fail_ind_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rrc_reestab:
      c.init(other.c.get<rrc_reestab_initiated_s>());
      break;
    case types::rrc_setup:
      c.init(other.c.get<rrc_setup_initiated_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_condition_fail_ind_c");
  }
}
init_condition_fail_ind_c& init_condition_fail_ind_c::operator=(const init_condition_fail_ind_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rrc_reestab:
      c.set(other.c.get<rrc_reestab_initiated_s>());
      break;
    case types::rrc_setup:
      c.set(other.c.get<rrc_setup_initiated_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_condition_fail_ind_c");
  }

  return *this;
}
rrc_reestab_initiated_s& init_condition_fail_ind_c::set_rrc_reestab()
{
  set(types::rrc_reestab);
  return c.get<rrc_reestab_initiated_s>();
}
rrc_setup_initiated_s& init_condition_fail_ind_c::set_rrc_setup()
{
  set(types::rrc_setup);
  return c.get<rrc_setup_initiated_s>();
}
protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>& init_condition_fail_ind_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>();
}
void init_condition_fail_ind_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rrc_reestab:
      j.write_fieldname("rRCReestab");
      c.get<rrc_reestab_initiated_s>().to_json(j);
      break;
    case types::rrc_setup:
      j.write_fieldname("rRCSetup");
      c.get<rrc_setup_initiated_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_condition_fail_ind_c");
  }
  j.end_obj();
}
SRSASN_CODE init_condition_fail_ind_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::rrc_reestab:
      HANDLE_CODE(c.get<rrc_reestab_initiated_s>().pack(bref));
      break;
    case types::rrc_setup:
      HANDLE_CODE(c.get<rrc_setup_initiated_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_condition_fail_ind_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_condition_fail_ind_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::rrc_reestab:
      HANDLE_CODE(c.get<rrc_reestab_initiated_s>().unpack(bref));
      break;
    case types::rrc_setup:
      HANDLE_CODE(c.get<rrc_setup_initiated_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<init_condition_fail_ind_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_condition_fail_ind_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_condition_fail_ind_c::types_opts::to_string() const
{
  static const char* names[] = {"rRCReestab", "rRCSetup", "choice-extension"};
  return convert_enum_idx(names, 3, value, "init_condition_fail_ind_c::types");
}

// FiveGProSeDirectCommunication ::= ENUMERATED
const char* five_g_pro_se_direct_communication_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_communication_e");
}

// FiveGProSeDirectDiscovery ::= ENUMERATED
const char* five_g_pro_se_direct_discovery_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_discovery_e");
}

// FiveGProSeLayer2RemoteUE ::= ENUMERATED
const char* five_g_pro_se_layer2_remote_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_remote_ue_e");
}

// FiveGProSeLayer2UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer2_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_ue_to_network_relay_e");
}

// FiveGProSeLayer3UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer3_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer3_ue_to_network_relay_e");
}

// FiveGProSeAuthorized ::= SEQUENCE
SRSASN_CODE five_g_pro_se_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_gpro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.pack(five_gpro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.pack(five_gnr_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_gnr_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_gnr_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (five_gpro_se_direct_discovery_present) {
    HANDLE_CODE(five_gpro_se_direct_discovery.pack(bref));
  }
  if (five_gpro_se_direct_communication_present) {
    HANDLE_CODE(five_gpro_se_direct_communication.pack(bref));
  }
  if (five_gnr_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_gnr_pro_se_layer2_ue_to_network_relay.pack(bref));
  }
  if (five_gnr_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_gnr_pro_se_layer3_ue_to_network_relay.pack(bref));
  }
  if (five_gnr_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_gnr_pro_se_layer2_remote_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_gpro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.unpack(five_gpro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.unpack(five_gnr_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_gnr_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_gnr_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (five_gpro_se_direct_discovery_present) {
    HANDLE_CODE(five_gpro_se_direct_discovery.unpack(bref));
  }
  if (five_gpro_se_direct_communication_present) {
    HANDLE_CODE(five_gpro_se_direct_communication.unpack(bref));
  }
  if (five_gnr_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_gnr_pro_se_layer2_ue_to_network_relay.unpack(bref));
  }
  if (five_gnr_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_gnr_pro_se_layer3_ue_to_network_relay.unpack(bref));
  }
  if (five_gnr_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_gnr_pro_se_layer2_remote_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (five_gpro_se_direct_discovery_present) {
    j.write_str("fiveGproSeDirectDiscovery", five_gpro_se_direct_discovery.to_string());
  }
  if (five_gpro_se_direct_communication_present) {
    j.write_str("fiveGproSeDirectCommunication", five_gpro_se_direct_communication.to_string());
  }
  if (five_gnr_pro_se_layer2_ue_to_network_relay_present) {
    j.write_str("fiveGnrProSeLayer2UEtoNetworkRelay", five_gnr_pro_se_layer2_ue_to_network_relay.to_string());
  }
  if (five_gnr_pro_se_layer3_ue_to_network_relay_present) {
    j.write_str("fiveGnrProSeLayer3UEtoNetworkRelay", five_gnr_pro_se_layer3_ue_to_network_relay.to_string());
  }
  if (five_gnr_pro_se_layer2_remote_ue_present) {
    j.write_str("fiveGnrProSeLayer2RemoteUE", five_gnr_pro_se_layer2_remote_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveGProSePC5FlowBitRates ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_flow_bit_rates_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(
      pack_integer(bref, five_gpro_seguaranteed_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, five_gpro_semax_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_flow_bit_rates_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(five_gpro_seguaranteed_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(five_gpro_semax_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_flow_bit_rates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveGproSeguaranteedFlowBitRate", five_gpro_seguaranteed_flow_bit_rate);
  j.write_int("fiveGproSemaximumFlowBitRate", five_gpro_semax_flow_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Range ::= ENUMERATED
const char* range_opts::to_string() const
{
  static const char* names[] = {"m50", "m80", "m180", "m200", "m350", "m400", "m500", "m700", "m1000"};
  return convert_enum_idx(names, 9, value, "range_e");
}
uint16_t range_opts::to_number() const
{
  static const uint16_t numbers[] = {50, 80, 180, 200, 350, 400, 500, 700, 1000};
  return map_enum_number(numbers, 9, value, "range_e");
}

// FiveGProSePC5QoSFlowItem ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_gpro_sepc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(five_gpro_serange_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_gpro_sep_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (five_gpro_sepc5_flow_bit_rates_present) {
    HANDLE_CODE(five_gpro_sepc5_flow_bit_rates.pack(bref));
  }
  if (five_gpro_serange_present) {
    HANDLE_CODE(five_gpro_serange.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_gpro_sepc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(five_gpro_serange_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_gpro_sep_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (five_gpro_sepc5_flow_bit_rates_present) {
    HANDLE_CODE(five_gpro_sepc5_flow_bit_rates.unpack(bref));
  }
  if (five_gpro_serange_present) {
    HANDLE_CODE(five_gpro_serange.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveGproSepQI", five_gpro_sep_qi);
  if (five_gpro_sepc5_flow_bit_rates_present) {
    j.write_fieldname("fiveGproSepc5FlowBitRates");
    five_gpro_sepc5_flow_bit_rates.to_json(j);
  }
  if (five_gpro_serange_present) {
    j.write_str("fiveGproSerange", five_gpro_serange.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveGProSePC5QoSParameters ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_gpro_sepc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, five_g_pro_sepc5_qos_flow_list, 1, 2064, true));
  if (five_gpro_sepc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(
        pack_integer(bref, five_gpro_sepc5_link_aggr_bit_rates, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_gpro_sepc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(five_g_pro_sepc5_qos_flow_list, bref, 1, 2064, true));
  if (five_gpro_sepc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(
        unpack_integer(five_gpro_sepc5_link_aggr_bit_rates, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("fiveGProSepc5QoSFlowList");
  for (const auto& e1 : five_g_pro_sepc5_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (five_gpro_sepc5_link_aggr_bit_rates_present) {
    j.write_int("fiveGproSepc5LinkAggregateBitRates", five_gpro_sepc5_link_aggr_bit_rates);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Flows-Mapped-To-DRB-Item ::= SEQUENCE
SRSASN_CODE flows_mapped_to_drb_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE flows_mapped_to_drb_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void flows_mapped_to_drb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSFlowIdentifier", qos_flow_id);
  j.write_fieldname("qoSFlowLevelQoSParameters");
  qos_flow_level_qos_params.to_json(j);
  if (qos_flow_map_ind_present) {
    j.write_str("qoSFlowMappingIndication", qos_flow_map_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ForbiddenAreaItem ::= SEQUENCE
SRSASN_CODE forbidden_area_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_tacs, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE forbidden_area_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(forbidden_tacs, bref, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void forbidden_area_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-Identity", plmn_id.to_string());
  j.start_array("forbidden-TACs");
  for (const auto& e1 : forbidden_tacs) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Full-I-RNTI-Profile-List ::= CHOICE
void full_i_rnti_profile_list_c::destroy_()
{
  switch (type_) {
    case types::full_i_rnti_profile_0:
      c.destroy<fixed_bitstring<21, false, true>>();
      break;
    case types::full_i_rnti_profile_1:
      c.destroy<fixed_bitstring<18, false, true>>();
      break;
    case types::full_i_rnti_profile_2:
      c.destroy<fixed_bitstring<15, false, true>>();
      break;
    case types::full_i_rnti_profile_3:
      c.destroy<fixed_bitstring<12, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void full_i_rnti_profile_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::full_i_rnti_profile_0:
      c.init<fixed_bitstring<21, false, true>>();
      break;
    case types::full_i_rnti_profile_1:
      c.init<fixed_bitstring<18, false, true>>();
      break;
    case types::full_i_rnti_profile_2:
      c.init<fixed_bitstring<15, false, true>>();
      break;
    case types::full_i_rnti_profile_3:
      c.init<fixed_bitstring<12, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "full_i_rnti_profile_list_c");
  }
}
full_i_rnti_profile_list_c::full_i_rnti_profile_list_c(const full_i_rnti_profile_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::full_i_rnti_profile_0:
      c.init(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::full_i_rnti_profile_1:
      c.init(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::full_i_rnti_profile_2:
      c.init(other.c.get<fixed_bitstring<15, false, true>>());
      break;
    case types::full_i_rnti_profile_3:
      c.init(other.c.get<fixed_bitstring<12, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "full_i_rnti_profile_list_c");
  }
}
full_i_rnti_profile_list_c& full_i_rnti_profile_list_c::operator=(const full_i_rnti_profile_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::full_i_rnti_profile_0:
      c.set(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::full_i_rnti_profile_1:
      c.set(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::full_i_rnti_profile_2:
      c.set(other.c.get<fixed_bitstring<15, false, true>>());
      break;
    case types::full_i_rnti_profile_3:
      c.set(other.c.get<fixed_bitstring<12, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "full_i_rnti_profile_list_c");
  }

  return *this;
}
fixed_bitstring<21, false, true>& full_i_rnti_profile_list_c::set_full_i_rnti_profile_0()
{
  set(types::full_i_rnti_profile_0);
  return c.get<fixed_bitstring<21, false, true>>();
}
fixed_bitstring<18, false, true>& full_i_rnti_profile_list_c::set_full_i_rnti_profile_1()
{
  set(types::full_i_rnti_profile_1);
  return c.get<fixed_bitstring<18, false, true>>();
}
fixed_bitstring<15, false, true>& full_i_rnti_profile_list_c::set_full_i_rnti_profile_2()
{
  set(types::full_i_rnti_profile_2);
  return c.get<fixed_bitstring<15, false, true>>();
}
fixed_bitstring<12, false, true>& full_i_rnti_profile_list_c::set_full_i_rnti_profile_3()
{
  set(types::full_i_rnti_profile_3);
  return c.get<fixed_bitstring<12, false, true>>();
}
protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>& full_i_rnti_profile_list_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>();
}
void full_i_rnti_profile_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::full_i_rnti_profile_0:
      j.write_str("full-I-RNTI-Profile-0", c.get<fixed_bitstring<21, false, true>>().to_string());
      break;
    case types::full_i_rnti_profile_1:
      j.write_str("full-I-RNTI-Profile-1", c.get<fixed_bitstring<18, false, true>>().to_string());
      break;
    case types::full_i_rnti_profile_2:
      j.write_str("full-I-RNTI-Profile-2", c.get<fixed_bitstring<15, false, true>>().to_string());
      break;
    case types::full_i_rnti_profile_3:
      j.write_str("full-I-RNTI-Profile-3", c.get<fixed_bitstring<12, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "full_i_rnti_profile_list_c");
  }
  j.end_obj();
}
SRSASN_CODE full_i_rnti_profile_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::full_i_rnti_profile_0:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().pack(bref)));
      break;
    case types::full_i_rnti_profile_1:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().pack(bref)));
      break;
    case types::full_i_rnti_profile_2:
      HANDLE_CODE((c.get<fixed_bitstring<15, false, true>>().pack(bref)));
      break;
    case types::full_i_rnti_profile_3:
      HANDLE_CODE((c.get<fixed_bitstring<12, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "full_i_rnti_profile_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE full_i_rnti_profile_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::full_i_rnti_profile_0:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().unpack(bref)));
      break;
    case types::full_i_rnti_profile_1:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().unpack(bref)));
      break;
    case types::full_i_rnti_profile_2:
      HANDLE_CODE((c.get<fixed_bitstring<15, false, true>>().unpack(bref)));
      break;
    case types::full_i_rnti_profile_3:
      HANDLE_CODE((c.get<fixed_bitstring<12, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<full_i_rnti_profile_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "full_i_rnti_profile_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* full_i_rnti_profile_list_c::types_opts::to_string() const
{
  static const char* names[] = {"full-I-RNTI-Profile-0",
                                "full-I-RNTI-Profile-1",
                                "full-I-RNTI-Profile-2",
                                "full-I-RNTI-Profile-3",
                                "choice-extension"};
  return convert_enum_idx(names, 5, value, "full_i_rnti_profile_list_c::types");
}
int8_t full_i_rnti_profile_list_c::types_opts::to_number() const
{
  static const int8_t numbers[] = {0, -1, -2, -3};
  return map_enum_number(numbers, 4, value, "full_i_rnti_profile_list_c::types");
}

// GUAMI ::= SEQUENCE
SRSASN_CODE guami_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(amf_region_id.pack(bref));
  HANDLE_CODE(amf_set_id.pack(bref));
  HANDLE_CODE(amf_pointer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE guami_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(amf_region_id.unpack(bref));
  HANDLE_CODE(amf_set_id.unpack(bref));
  HANDLE_CODE(amf_pointer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void guami_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-ID", plmn_id.to_string());
  j.write_str("amf-region-id", amf_region_id.to_string());
  j.write_str("amf-set-id", amf_set_id.to_string());
  j.write_str("amf-pointer", amf_pointer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverReportType ::= ENUMERATED
const char* ho_report_type_opts::to_string() const
{
  static const char* names[] = {"hoTooEarly", "hoToWrongCell", "intersystempingpong"};
  return convert_enum_idx(names, 3, value, "ho_report_type_e");
}

// ExtendedReportIntervalMDT ::= ENUMERATED
const char* extended_report_interv_mdt_opts::to_string() const
{
  static const char* names[] = {"ms20480", "ms40960"};
  return convert_enum_idx(names, 2, value, "extended_report_interv_mdt_e");
}
uint16_t extended_report_interv_mdt_opts::to_number() const
{
  static const uint16_t numbers[] = {20480, 40960};
  return map_enum_number(numbers, 2, value, "extended_report_interv_mdt_e");
}

// BeamMeasurementIndicationM1 ::= ENUMERATED
const char* beam_meas_ind_m1_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meas_ind_m1_e");
}

// M1PeriodicReporting-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t m1_periodic_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {257};
  return map_enum_number(names, 1, idx, "id");
}
bool m1_periodic_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 257 == id;
}
crit_e m1_periodic_report_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 257) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m1_periodic_report_ext_ies_o::ext_c m1_periodic_report_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 257) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m1_periodic_report_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 257) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m1_periodic_report_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ExtendedReportIntervalMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m1_periodic_report_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_periodic_report_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m1_periodic_report_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExtendedReportIntervalMDT"};
  return convert_enum_idx(names, 1, value, "m1_periodic_report_ext_ies_o::ext_c::types");
}

// M4ReportAmountMDT ::= ENUMERATED
const char* m4_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m4_report_amount_mdt_e");
}
int8_t m4_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m4_report_amount_mdt_e");
}

// M5ReportAmountMDT ::= ENUMERATED
const char* m5_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m5_report_amount_mdt_e");
}
int8_t m5_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m5_report_amount_mdt_e");
}

// M6ReportAmountMDT ::= ENUMERATED
const char* m6_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m6_report_amount_mdt_e");
}
int8_t m6_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m6_report_amount_mdt_e");
}

// M7ReportAmountMDT ::= ENUMERATED
const char* m7_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m7_report_amount_mdt_e");
}
int8_t m7_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m7_report_amount_mdt_e");
}

// MeasurementThresholdA2 ::= CHOICE
void meas_thres_a2_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void meas_thres_a2_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::thres_rsrp:
      break;
    case types::thres_rsrq:
      break;
    case types::thres_sinr:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
  }
}
meas_thres_a2_c::meas_thres_a2_c(const meas_thres_a2_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::thres_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_sinr:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
  }
}
meas_thres_a2_c& meas_thres_a2_c::operator=(const meas_thres_a2_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::thres_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_sinr:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
  }

  return *this;
}
uint8_t& meas_thres_a2_c::set_thres_rsrp()
{
  set(types::thres_rsrp);
  return c.get<uint8_t>();
}
uint8_t& meas_thres_a2_c::set_thres_rsrq()
{
  set(types::thres_rsrq);
  return c.get<uint8_t>();
}
uint8_t& meas_thres_a2_c::set_thres_sinr()
{
  set(types::thres_sinr);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>& meas_thres_a2_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>();
}
void meas_thres_a2_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::thres_rsrp:
      j.write_int("threshold-RSRP", c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      j.write_int("threshold-RSRQ", c.get<uint8_t>());
      break;
    case types::thres_sinr:
      j.write_int("threshold-SINR", c.get<uint8_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
  }
  j.end_obj();
}
SRSASN_CODE meas_thres_a2_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_sinr:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE meas_thres_a2_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_sinr:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<meas_thres_a2_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* meas_thres_a2_c::types_opts::to_string() const
{
  static const char* names[] = {"threshold-RSRP", "threshold-RSRQ", "threshold-SINR", "choice-extension"};
  return convert_enum_idx(names, 4, value, "meas_thres_a2_c::types");
}

// ReportAmountMDT ::= ENUMERATED
const char* report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "report_amount_mdt_e");
}
int8_t report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "report_amount_mdt_e");
}

// ReportIntervalMDT ::= ENUMERATED
const char* report_interv_mdt_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms480",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "min1",
                                "min6",
                                "min12",
                                "min30",
                                "min60"};
  return convert_enum_idx(names, 13, value, "report_interv_mdt_e");
}
uint16_t report_interv_mdt_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 1, 6, 12, 30, 60};
  return map_enum_number(numbers, 13, value, "report_interv_mdt_e");
}

// SensorName ::= SEQUENCE
SRSASN_CODE sensor_name_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(uncompensated_barometric_cfg_present, 1));
  HANDLE_CODE(bref.pack(ue_speed_cfg_present, 1));
  HANDLE_CODE(bref.pack(ue_orientation_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (uncompensated_barometric_cfg_present) {
    HANDLE_CODE(uncompensated_barometric_cfg.pack(bref));
  }
  if (ue_speed_cfg_present) {
    HANDLE_CODE(ue_speed_cfg.pack(bref));
  }
  if (ue_orientation_cfg_present) {
    HANDLE_CODE(ue_orientation_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_name_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(uncompensated_barometric_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ue_speed_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ue_orientation_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (uncompensated_barometric_cfg_present) {
    HANDLE_CODE(uncompensated_barometric_cfg.unpack(bref));
  }
  if (ue_speed_cfg_present) {
    HANDLE_CODE(ue_speed_cfg.unpack(bref));
  }
  if (ue_orientation_cfg_present) {
    HANDLE_CODE(ue_orientation_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sensor_name_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (uncompensated_barometric_cfg_present) {
    j.write_str("uncompensatedBarometricConfig", "true");
  }
  if (ue_speed_cfg_present) {
    j.write_str("ueSpeedConfig", "true");
  }
  if (ue_orientation_cfg_present) {
    j.write_str("ueOrientationConfig", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* sensor_name_s::uncompensated_barometric_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_s::uncompensated_barometric_cfg_e_");
}

const char* sensor_name_s::ue_speed_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_s::ue_speed_cfg_e_");
}

const char* sensor_name_s::ue_orientation_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_s::ue_orientation_cfg_e_");
}

// EarlyMeasurement ::= ENUMERATED
const char* early_meas_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "early_meas_e");
}

// Links-to-log ::= ENUMERATED
const char* links_to_log_opts::to_string() const
{
  static const char* names[] = {"uplink", "downlink", "both-uplink-and-downlink"};
  return convert_enum_idx(names, 3, value, "links_to_log_e");
}

// M1Configuration-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t m1_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {268, 367};
  return map_enum_number(names, 2, idx, "id");
}
bool m1_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {268, 367};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e m1_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 268:
      return crit_e::ignore;
    case 367:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
m1_cfg_ext_ies_o::ext_c m1_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 268:
      ret.set(ext_c::types::beam_meas_ind_m1);
      break;
    case 367:
      ret.set(ext_c::types::beam_meass_report_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m1_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 268:
      return presence_e::optional;
    case 367:
      return presence_e::conditional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void m1_cfg_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::beam_meas_ind_m1:
      c = beam_meas_ind_m1_e{};
      break;
    case types::beam_meass_report_cfg:
      c = beam_meass_report_cfg_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }
}
beam_meas_ind_m1_e& m1_cfg_ext_ies_o::ext_c::beam_meas_ind_m1()
{
  assert_choice_type(types::beam_meas_ind_m1, type_, "Extension");
  return c.get<beam_meas_ind_m1_e>();
}
beam_meass_report_cfg_s& m1_cfg_ext_ies_o::ext_c::beam_meass_report_cfg()
{
  assert_choice_type(types::beam_meass_report_cfg, type_, "Extension");
  return c.get<beam_meass_report_cfg_s>();
}
const beam_meas_ind_m1_e& m1_cfg_ext_ies_o::ext_c::beam_meas_ind_m1() const
{
  assert_choice_type(types::beam_meas_ind_m1, type_, "Extension");
  return c.get<beam_meas_ind_m1_e>();
}
const beam_meass_report_cfg_s& m1_cfg_ext_ies_o::ext_c::beam_meass_report_cfg() const
{
  assert_choice_type(types::beam_meass_report_cfg, type_, "Extension");
  return c.get<beam_meass_report_cfg_s>();
}
void m1_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::beam_meas_ind_m1:
      j.write_str("BeamMeasurementIndicationM1", "true");
      break;
    case types::beam_meass_report_cfg:
      j.write_fieldname("BeamMeasurementsReportConfiguration");
      c.get<beam_meass_report_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE m1_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::beam_meas_ind_m1:
      HANDLE_CODE(c.get<beam_meas_ind_m1_e>().pack(bref));
      break;
    case types::beam_meass_report_cfg:
      HANDLE_CODE(c.get<beam_meass_report_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::beam_meas_ind_m1:
      HANDLE_CODE(c.get<beam_meas_ind_m1_e>().unpack(bref));
      break;
    case types::beam_meass_report_cfg:
      HANDLE_CODE(c.get<beam_meass_report_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m1_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"BeamMeasurementIndicationM1", "BeamMeasurementsReportConfiguration"};
  return convert_enum_idx(names, 2, value, "m1_cfg_ext_ies_o::ext_c::types");
}
uint8_t m1_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "m1_cfg_ext_ies_o::ext_c::types");
}

// M1PeriodicReporting ::= SEQUENCE
SRSASN_CODE m1_periodic_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(report_interv.pack(bref));
  HANDLE_CODE(report_amount.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_periodic_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_interv.unpack(bref));
  HANDLE_CODE(report_amount.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m1_periodic_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reportInterval", report_interv.to_string());
  j.write_str("reportAmount", report_amount.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M1ReportingTrigger ::= ENUMERATED
const char* m1_report_trigger_opts::to_string() const
{
  static const char* names[] = {"periodic", "a2eventtriggered", "a2eventtriggered-periodic"};
  return convert_enum_idx(names, 3, value, "m1_report_trigger_e");
}

// M1ThresholdEventA2 ::= SEQUENCE
SRSASN_CODE m1_thres_event_a2_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(meas_thres.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_thres_event_a2_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(meas_thres.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_thres_event_a2_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("measurementThreshold");
  meas_thres.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M4Configuration-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t m4_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264};
  return map_enum_number(names, 1, idx, "id");
}
bool m4_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 264 == id;
}
crit_e m4_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 264) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m4_cfg_ext_ies_o::ext_c m4_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 264) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m4_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 264) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m4_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M4ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m4_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m4_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m4_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M4ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m4_cfg_ext_ies_o::ext_c::types");
}
uint8_t m4_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {4};
  return map_enum_number(numbers, 1, value, "m4_cfg_ext_ies_o::ext_c::types");
}

// M4period ::= ENUMERATED
const char* m4period_opts::to_string() const
{
  static const char* names[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(names, 5, value, "m4period_e");
}
uint16_t m4period_opts::to_number() const
{
  static const uint16_t numbers[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(numbers, 5, value, "m4period_e");
}

// M5Configuration-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t m5_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {265};
  return map_enum_number(names, 1, idx, "id");
}
bool m5_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 265 == id;
}
crit_e m5_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 265) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m5_cfg_ext_ies_o::ext_c m5_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 265) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m5_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 265) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m5_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M5ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m5_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M5ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m5_cfg_ext_ies_o::ext_c::types");
}
uint8_t m5_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "m5_cfg_ext_ies_o::ext_c::types");
}

// M5period ::= ENUMERATED
const char* m5period_opts::to_string() const
{
  static const char* names[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(names, 5, value, "m5period_e");
}
uint16_t m5period_opts::to_number() const
{
  static const uint16_t numbers[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(numbers, 5, value, "m5period_e");
}

// M6Configuration-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t m6_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {266, 371};
  return map_enum_number(names, 2, idx, "id");
}
bool m6_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {266, 371};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e m6_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 266:
      return crit_e::ignore;
    case 371:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
m6_cfg_ext_ies_o::ext_c m6_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 266:
      ret.set(ext_c::types::m6_report_amount);
      break;
    case 371:
      ret.set(ext_c::types::excess_packet_delay_thres_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m6_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 266:
      return presence_e::optional;
    case 371:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void m6_cfg_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::m6_report_amount:
      c = m6_report_amount_mdt_e{};
      break;
    case types::excess_packet_delay_thres_cfg:
      c = excess_packet_delay_thres_cfg_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }
}
m6_report_amount_mdt_e& m6_cfg_ext_ies_o::ext_c::m6_report_amount()
{
  assert_choice_type(types::m6_report_amount, type_, "Extension");
  return c.get<m6_report_amount_mdt_e>();
}
excess_packet_delay_thres_cfg_l& m6_cfg_ext_ies_o::ext_c::excess_packet_delay_thres_cfg()
{
  assert_choice_type(types::excess_packet_delay_thres_cfg, type_, "Extension");
  return c.get<excess_packet_delay_thres_cfg_l>();
}
const m6_report_amount_mdt_e& m6_cfg_ext_ies_o::ext_c::m6_report_amount() const
{
  assert_choice_type(types::m6_report_amount, type_, "Extension");
  return c.get<m6_report_amount_mdt_e>();
}
const excess_packet_delay_thres_cfg_l& m6_cfg_ext_ies_o::ext_c::excess_packet_delay_thres_cfg() const
{
  assert_choice_type(types::excess_packet_delay_thres_cfg, type_, "Extension");
  return c.get<excess_packet_delay_thres_cfg_l>();
}
void m6_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::m6_report_amount:
      j.write_str("M6ReportAmountMDT", c.get<m6_report_amount_mdt_e>().to_string());
      break;
    case types::excess_packet_delay_thres_cfg:
      j.start_array("ExcessPacketDelayThresholdConfiguration");
      for (const auto& e1 : c.get<excess_packet_delay_thres_cfg_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m6_report_amount:
      HANDLE_CODE(c.get<m6_report_amount_mdt_e>().pack(bref));
      break;
    case types::excess_packet_delay_thres_cfg:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<excess_packet_delay_thres_cfg_l>(), 1, 255, true));
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m6_report_amount:
      HANDLE_CODE(c.get<m6_report_amount_mdt_e>().unpack(bref));
      break;
    case types::excess_packet_delay_thres_cfg:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<excess_packet_delay_thres_cfg_l>(), bref, 1, 255, true));
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m6_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M6ReportAmountMDT", "ExcessPacketDelayThresholdConfiguration"};
  return convert_enum_idx(names, 2, value, "m6_cfg_ext_ies_o::ext_c::types");
}
uint8_t m6_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {6};
  return map_enum_number(numbers, 1, value, "m6_cfg_ext_ies_o::ext_c::types");
}

// M6report-Interval ::= ENUMERATED
const char* m6report_interv_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms480",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms40960",
                                "min1",
                                "min6",
                                "min12",
                                "min30"};
  return convert_enum_idx(names, 14, value, "m6report_interv_e");
}
uint16_t m6report_interv_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 20480, 40960, 1, 6, 12, 30};
  return map_enum_number(numbers, 14, value, "m6report_interv_e");
}

// M7Configuration-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t m7_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {267};
  return map_enum_number(names, 1, idx, "id");
}
bool m7_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 267 == id;
}
crit_e m7_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 267) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m7_cfg_ext_ies_o::ext_c m7_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 267) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m7_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 267) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m7_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M7ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m7_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M7ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m7_cfg_ext_ies_o::ext_c::types");
}
uint8_t m7_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {7};
  return map_enum_number(numbers, 1, value, "m7_cfg_ext_ies_o::ext_c::types");
}

// Periodical ::= SEQUENCE
SRSASN_CODE periodical_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE periodical_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void periodical_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SensorMeasConfig ::= ENUMERATED
const char* sensor_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "sensor_meas_cfg_e");
}

// WLANMeasConfig ::= ENUMERATED
const char* wlan_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_e");
}

// LoggedMDT-NR-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t logged_mdt_nr_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {366};
  return map_enum_number(names, 1, idx, "id");
}
bool logged_mdt_nr_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 366 == id;
}
crit_e logged_mdt_nr_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 366) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
logged_mdt_nr_ext_ies_o::ext_c logged_mdt_nr_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 366) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e logged_mdt_nr_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 366) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void logged_mdt_nr_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("EarlyMeasurement", "true");
  j.end_obj();
}
SRSASN_CODE logged_mdt_nr_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_nr_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* logged_mdt_nr_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"EarlyMeasurement"};
  return convert_enum_idx(names, 1, value, "logged_mdt_nr_ext_ies_o::ext_c::types");
}

// LoggingDuration ::= ENUMERATED
const char* logging_dur_opts::to_string() const
{
  static const char* names[] = {"m10", "m20", "m40", "m60", "m90", "m120"};
  return convert_enum_idx(names, 6, value, "logging_dur_e");
}
uint8_t logging_dur_opts::to_number() const
{
  static const uint8_t numbers[] = {10, 20, 40, 60, 90, 120};
  return map_enum_number(numbers, 6, value, "logging_dur_e");
}

// LoggingInterval ::= ENUMERATED
const char* logging_interv_opts::to_string() const
{
  static const char* names[] = {"ms320",
                                "ms640",
                                "ms1280",
                                "ms2560",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms30720",
                                "ms40960",
                                "ms61440",
                                "infinity"};
  return convert_enum_idx(names, 11, value, "logging_interv_e");
}
int32_t logging_interv_opts::to_number() const
{
  static const int32_t numbers[] = {320, 640, 1280, 2560, 5120, 10240, 20480, 30720, 40960, 61440, -1};
  return map_enum_number(numbers, 11, value, "logging_interv_e");
}

template struct asn1::protocol_ext_field_s<m1_cfg_ext_ies_o>;

SRSASN_CODE m1_cfg_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += beam_meas_ind_m1_present ? 1 : 0;
  nof_ies += beam_meass_report_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (beam_meas_ind_m1_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)268, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(beam_meas_ind_m1.pack(bref));
  }
  if (beam_meass_report_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)367, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(beam_meass_report_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 268: {
        beam_meas_ind_m1_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(beam_meas_ind_m1.unpack(bref));
        break;
      }
      case 367: {
        beam_meass_report_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(beam_meass_report_cfg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void m1_cfg_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (beam_meas_ind_m1_present) {
    j.write_int("id", 268);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (beam_meass_report_cfg_present) {
    j.write_int("id", 367);
    j.write_str("criticality", "ignore");
    beam_meass_report_cfg.to_json(j);
  }
  j.end_obj();
}

// M1Configuration ::= SEQUENCE
SRSASN_CODE m1_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m1thresevent_a2_present, 1));
  HANDLE_CODE(bref.pack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m1report_trigger.pack(bref));
  if (m1thresevent_a2_present) {
    HANDLE_CODE(m1thresevent_a2.pack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m1thresevent_a2_present, 1));
  HANDLE_CODE(bref.unpack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m1report_trigger.unpack(bref));
  if (m1thresevent_a2_present) {
    HANDLE_CODE(m1thresevent_a2.unpack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m1reportingTrigger", m1report_trigger.to_string());
  if (m1thresevent_a2_present) {
    j.write_fieldname("m1thresholdeventA2");
    m1thresevent_a2.to_json(j);
  }
  if (m1periodic_report_present) {
    j.write_fieldname("m1periodicReporting");
    m1periodic_report.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M4Configuration ::= SEQUENCE
SRSASN_CODE m4_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m4period.pack(bref));
  HANDLE_CODE(m4_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m4_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m4period.unpack(bref));
  HANDLE_CODE(m4_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m4_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m4period", m4period.to_string());
  j.write_str("m4-links-to-log", m4_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M5Configuration ::= SEQUENCE
SRSASN_CODE m5_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m5period.pack(bref));
  HANDLE_CODE(m5_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m5period.unpack(bref));
  HANDLE_CODE(m5_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m5_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m5period", m5period.to_string());
  j.write_str("m5-links-to-log", m5_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<m6_cfg_ext_ies_o>;

SRSASN_CODE m6_cfg_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += m6_report_amount_present ? 1 : 0;
  nof_ies += excess_packet_delay_thres_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (m6_report_amount_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)266, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(m6_report_amount.pack(bref));
  }
  if (excess_packet_delay_thres_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)371, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, excess_packet_delay_thres_cfg, 1, 255, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 266: {
        m6_report_amount_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(m6_report_amount.unpack(bref));
        break;
      }
      case 371: {
        excess_packet_delay_thres_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(excess_packet_delay_thres_cfg, bref, 1, 255, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (m6_report_amount_present) {
    j.write_int("id", 266);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", m6_report_amount.to_string());
  }
  if (excess_packet_delay_thres_cfg_present) {
    j.write_int("id", 371);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : excess_packet_delay_thres_cfg) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// M6Configuration ::= SEQUENCE
SRSASN_CODE m6_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.pack(bref));
  HANDLE_CODE(m6_links_to_log.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.unpack(bref));
  HANDLE_CODE(m6_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m6report-Interval", m6report_interv.to_string());
  j.write_str("m6-links-to-log", m6_links_to_log.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M7Configuration ::= SEQUENCE
SRSASN_CODE m7_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, m7period, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(m7period, bref, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m7_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("m7period", m7period);
  j.write_str("m7-links-to-log", m7_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// MBS-Session-ID ::= SEQUENCE
SRSASN_CODE mbs_session_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.pack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.unpack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tMGI", tmgi.to_string());
  if (nid_present) {
    j.write_str("nID", nid.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MaxIPrate ::= ENUMERATED
const char* max_ip_rate_opts::to_string() const
{
  static const char* names[] = {"bitrate64kbs", "max-UErate"};
  return convert_enum_idx(names, 2, value, "max_ip_rate_e");
}
uint8_t max_ip_rate_opts::to_number() const
{
  static const uint8_t numbers[] = {64};
  return map_enum_number(numbers, 1, value, "max_ip_rate_e");
}

// RedundantQoSFlowIndicator ::= ENUMERATED
const char* redundant_qos_flow_ind_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "redundant_qos_flow_ind_e");
}

// ReportType ::= CHOICE
void report_type_c::destroy_()
{
  switch (type_) {
    case types::periodical:
      c.destroy<periodical_s>();
      break;
    case types::event_triggered:
      c.destroy<event_triggered_s>();
      break;
    default:
      break;
  }
}
void report_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::periodical:
      c.init<periodical_s>();
      break;
    case types::event_triggered:
      c.init<event_triggered_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
}
report_type_c::report_type_c(const report_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::periodical:
      c.init(other.c.get<periodical_s>());
      break;
    case types::event_triggered:
      c.init(other.c.get<event_triggered_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
}
report_type_c& report_type_c::operator=(const report_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::periodical:
      c.set(other.c.get<periodical_s>());
      break;
    case types::event_triggered:
      c.set(other.c.get<event_triggered_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }

  return *this;
}
periodical_s& report_type_c::set_periodical()
{
  set(types::periodical);
  return c.get<periodical_s>();
}
event_triggered_s& report_type_c::set_event_triggered()
{
  set(types::event_triggered);
  return c.get<event_triggered_s>();
}
void report_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::periodical:
      j.write_fieldname("periodical");
      c.get<periodical_s>().to_json(j);
      break;
    case types::event_triggered:
      j.write_fieldname("eventTriggered");
      c.get<event_triggered_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
  j.end_obj();
}
SRSASN_CODE report_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::periodical:
      HANDLE_CODE(c.get<periodical_s>().pack(bref));
      break;
    case types::event_triggered:
      HANDLE_CODE(c.get<event_triggered_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE report_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::periodical:
      HANDLE_CODE(c.get<periodical_s>().unpack(bref));
      break;
    case types::event_triggered:
      HANDLE_CODE(c.get<event_triggered_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* report_type_c::types_opts::to_string() const
{
  static const char* names[] = {"periodical", "eventTriggered"};
  return convert_enum_idx(names, 2, value, "report_type_c::types");
}

// SensorMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE sensor_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sensor_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sensor_meas_cfg.pack(bref));
  if (sensor_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sensor_meas_cfg_name_list, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sensor_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  if (sensor_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sensor_meas_cfg_name_list, bref, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sensor_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sensorMeasConfig", "setup");
  if (sensor_meas_cfg_name_list.size() > 0) {
    j.start_array("sensorMeasConfigNameList");
    for (const auto& e1 : sensor_meas_cfg_name_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WLANMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE wlan_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(wlan_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.pack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.pack(bref));
  if (wlan_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, wlan_meas_cfg_name_list, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.pack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wlan_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool wlan_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  if (wlan_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(wlan_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.unpack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wlan_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("wlanMeasConfig", "setup");
  if (wlan_meas_cfg_name_list.size() > 0) {
    j.start_array("wlanMeasConfigNameList");
    for (const auto& e1 : wlan_meas_cfg_name_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (wlan_rssi_present) {
    j.write_str("wlan-rssi", "true");
  }
  if (wlan_rtt_present) {
    j.write_str("wlan-rtt", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* wlan_meas_cfg_s::wlan_rssi_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_s::wlan_rssi_e_");
}

const char* wlan_meas_cfg_s::wlan_rtt_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_s::wlan_rtt_e_");
}

// ImmediateMDT-NR ::= SEQUENCE
SRSASN_CODE immediate_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m1_cfg_present, 1));
  HANDLE_CODE(bref.pack(m4_cfg_present, 1));
  HANDLE_CODE(bref.pack(m5_cfg_present, 1));
  HANDLE_CODE(bref.pack(mdt_location_info_present, 1));
  HANDLE_CODE(bref.pack(m6_cfg_present, 1));
  HANDLE_CODE(bref.pack(m7_cfg_present, 1));
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.pack(bref));
  if (m1_cfg_present) {
    HANDLE_CODE(m1_cfg.pack(bref));
  }
  if (m4_cfg_present) {
    HANDLE_CODE(m4_cfg.pack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.pack(bref));
  }
  if (mdt_location_info_present) {
    HANDLE_CODE(mdt_location_info.pack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.pack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.pack(bref));
  }
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE immediate_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m1_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m4_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m5_cfg_present, 1));
  HANDLE_CODE(bref.unpack(mdt_location_info_present, 1));
  HANDLE_CODE(bref.unpack(m6_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m7_cfg_present, 1));
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.unpack(bref));
  if (m1_cfg_present) {
    HANDLE_CODE(m1_cfg.unpack(bref));
  }
  if (m4_cfg_present) {
    HANDLE_CODE(m4_cfg.unpack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.unpack(bref));
  }
  if (mdt_location_info_present) {
    HANDLE_CODE(mdt_location_info.unpack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.unpack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.unpack(bref));
  }
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void immediate_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("measurementsToActivate", meass_to_activ.to_string());
  if (m1_cfg_present) {
    j.write_fieldname("m1Configuration");
    m1_cfg.to_json(j);
  }
  if (m4_cfg_present) {
    j.write_fieldname("m4Configuration");
    m4_cfg.to_json(j);
  }
  if (m5_cfg_present) {
    j.write_fieldname("m5Configuration");
    m5_cfg.to_json(j);
  }
  if (mdt_location_info_present) {
    j.write_str("mDT-Location-Info", mdt_location_info.to_string());
  }
  if (m6_cfg_present) {
    j.write_fieldname("m6Configuration");
    m6_cfg.to_json(j);
  }
  if (m7_cfg_present) {
    j.write_fieldname("m7Configuration");
    m7_cfg.to_json(j);
  }
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("bluetoothMeasurementConfiguration");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("wLANMeasurementConfiguration");
    wlan_meas_cfg.to_json(j);
  }
  if (sensor_meas_cfg_present) {
    j.write_fieldname("sensorMeasurementConfiguration");
    sensor_meas_cfg.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LoggedMDT-NR ::= SEQUENCE
SRSASN_CODE logged_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(area_scope_of_neigh_cells_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(logging_interv.pack(bref));
  HANDLE_CODE(logging_dur.pack(bref));
  HANDLE_CODE(report_type.pack(bref));
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.pack(bref));
  }
  if (area_scope_of_neigh_cells_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_scope_of_neigh_cells_list, 1, 8, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_present, 1));
  bool area_scope_of_neigh_cells_list_present;
  HANDLE_CODE(bref.unpack(area_scope_of_neigh_cells_list_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(logging_interv.unpack(bref));
  HANDLE_CODE(logging_dur.unpack(bref));
  HANDLE_CODE(report_type.unpack(bref));
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  }
  if (area_scope_of_neigh_cells_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_scope_of_neigh_cells_list, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void logged_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("loggingInterval", logging_interv.to_string());
  j.write_str("loggingDuration", logging_dur.to_string());
  j.write_fieldname("reportType");
  report_type.to_json(j);
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("bluetoothMeasurementConfiguration");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("wLANMeasurementConfiguration");
    wlan_meas_cfg.to_json(j);
  }
  if (sensor_meas_cfg_present) {
    j.write_fieldname("sensorMeasurementConfiguration");
    sensor_meas_cfg.to_json(j);
  }
  if (area_scope_of_neigh_cells_list.size() > 0) {
    j.start_array("areaScopeOfNeighCellsList");
    for (const auto& e1 : area_scope_of_neigh_cells_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// MBS-SessionAssociatedInformation-Item ::= SEQUENCE
SRSASN_CODE mbs_session_associated_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, associated_qos_flow_info_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_associated_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(associated_qos_flow_info_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_associated_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-Session-ID");
  mbs_session_id.to_json(j);
  j.start_array("associated-QoSFlowInfo-List");
  for (const auto& e1 : associated_qos_flow_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MaximumIPdatarate-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t max_ip_datarate_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {114};
  return map_enum_number(names, 1, idx, "id");
}
bool max_ip_datarate_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 114 == id;
}
crit_e max_ip_datarate_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 114) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
max_ip_datarate_ext_ies_o::ext_c max_ip_datarate_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 114) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e max_ip_datarate_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 114) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void max_ip_datarate_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("MaxIPrate", c.to_string());
  j.end_obj();
}
SRSASN_CODE max_ip_datarate_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE max_ip_datarate_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* max_ip_datarate_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"MaxIPrate"};
  return convert_enum_idx(names, 1, value, "max_ip_datarate_ext_ies_o::ext_c::types");
}

// QoSFlowsToBeSetup-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flows_to_be_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {212, 213};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flows_to_be_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {212, 213};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flows_to_be_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 212:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flows_to_be_setup_item_ext_ies_o::ext_c qos_flows_to_be_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 212:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    case 213:
      ret.set(ext_c::types::redundant_qos_flow_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flows_to_be_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 212:
      return presence_e::optional;
    case 213:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flows_to_be_setup_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c = tsc_traffic_characteristics_s{};
      break;
    case types::redundant_qos_flow_ind:
      c = redundant_qos_flow_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_item_ext_ies_o::ext_c");
  }
}
tsc_traffic_characteristics_s& qos_flows_to_be_setup_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
redundant_qos_flow_ind_e& qos_flows_to_be_setup_item_ext_ies_o::ext_c::redundant_qos_flow_ind()
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
const tsc_traffic_characteristics_s& qos_flows_to_be_setup_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const redundant_qos_flow_ind_e& qos_flows_to_be_setup_item_ext_ies_o::ext_c::redundant_qos_flow_ind() const
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
void qos_flows_to_be_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    case types::redundant_qos_flow_ind:
      j.write_str("RedundantQoSFlowIndicator", c.get<redundant_qos_flow_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flows_to_be_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flows_to_be_setup_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics", "RedundantQoSFlowIndicator"};
  return convert_enum_idx(names, 2, value, "qos_flows_to_be_setup_item_ext_ies_o::ext_c::types");
}

// RSN ::= ENUMERATED
const char* r_sn_opts::to_string() const
{
  static const char* names[] = {"v1", "v2"};
  return convert_enum_idx(names, 2, value, "r_sn_e");
}
uint8_t r_sn_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2};
  return map_enum_number(numbers, 2, value, "r_sn_e");
}

// RedundantPDUSessionInformation-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t redundant_pdu_session_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {340};
  return map_enum_number(names, 1, idx, "id");
}
bool redundant_pdu_session_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 340 == id;
}
crit_e redundant_pdu_session_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 340) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
redundant_pdu_session_info_ext_ies_o::ext_c redundant_pdu_session_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 340) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e redundant_pdu_session_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 340) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void redundant_pdu_session_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..255,...)", c);
  j.end_obj();
}
SRSASN_CODE redundant_pdu_session_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint16_t)0u, (uint16_t)255u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE redundant_pdu_session_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  return SRSASN_SUCCESS;
}

const char* redundant_pdu_session_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..255,...)"};
  return convert_enum_idx(names, 1, value, "redundant_pdu_session_info_ext_ies_o::ext_c::types");
}
uint8_t redundant_pdu_session_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "redundant_pdu_session_info_ext_ies_o::ext_c::types");
}

// S-BasedMDT ::= SEQUENCE
SRSASN_CODE s_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ng_ran_trace_id.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ng_ran_trace_id.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void s_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ng-ran-TraceID", ng_ran_trace_id.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// MDT-Activation ::= ENUMERATED
const char* mdt_activation_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT-only", "immediate-MDT-and-Trace", "logged-MDT-only"};
  return convert_enum_idx(names, 3, value, "mdt_activation_e");
}

// MDTAlignmentInfo ::= CHOICE
void mdt_align_info_c::destroy_()
{
  switch (type_) {
    case types::s_based_mdt:
      c.destroy<s_based_mdt_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mdt_align_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s_based_mdt:
      c.init<s_based_mdt_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
}
mdt_align_info_c::mdt_align_info_c(const mdt_align_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s_based_mdt:
      c.init(other.c.get<s_based_mdt_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
}
mdt_align_info_c& mdt_align_info_c::operator=(const mdt_align_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s_based_mdt:
      c.set(other.c.get<s_based_mdt_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }

  return *this;
}
s_based_mdt_s& mdt_align_info_c::set_s_based_mdt()
{
  set(types::s_based_mdt);
  return c.get<s_based_mdt_s>();
}
protocol_ie_single_container_s<mdt_align_info_ext_ies_o>& mdt_align_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
}
void mdt_align_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_based_mdt:
      j.write_fieldname("s-BasedMDT");
      c.get<s_based_mdt_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
  j.end_obj();
}
SRSASN_CODE mdt_align_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::s_based_mdt:
      HANDLE_CODE(c.get<s_based_mdt_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_align_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::s_based_mdt:
      HANDLE_CODE(c.get<s_based_mdt_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mdt_align_info_c::types_opts::to_string() const
{
  static const char* names[] = {"s-BasedMDT", "choice-extension"};
  return convert_enum_idx(names, 2, value, "mdt_align_info_c::types");
}

// MDTMode-NR ::= CHOICE
void mdt_mode_nr_c::destroy_()
{
  switch (type_) {
    case types::immediate_mdt:
      c.destroy<immediate_mdt_nr_s>();
      break;
    case types::logged_mdt:
      c.destroy<logged_mdt_nr_s>();
      break;
    case types::mdt_mode_nr_ext:
      c.destroy<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>();
      break;
    default:
      break;
  }
}
void mdt_mode_nr_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::immediate_mdt:
      c.init<immediate_mdt_nr_s>();
      break;
    case types::logged_mdt:
      c.init<logged_mdt_nr_s>();
      break;
    case types::mdt_mode_nr_ext:
      c.init<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
}
mdt_mode_nr_c::mdt_mode_nr_c(const mdt_mode_nr_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::immediate_mdt:
      c.init(other.c.get<immediate_mdt_nr_s>());
      break;
    case types::logged_mdt:
      c.init(other.c.get<logged_mdt_nr_s>());
      break;
    case types::mdt_mode_nr_ext:
      c.init(other.c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
}
mdt_mode_nr_c& mdt_mode_nr_c::operator=(const mdt_mode_nr_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::immediate_mdt:
      c.set(other.c.get<immediate_mdt_nr_s>());
      break;
    case types::logged_mdt:
      c.set(other.c.get<logged_mdt_nr_s>());
      break;
    case types::mdt_mode_nr_ext:
      c.set(other.c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }

  return *this;
}
immediate_mdt_nr_s& mdt_mode_nr_c::set_immediate_mdt()
{
  set(types::immediate_mdt);
  return c.get<immediate_mdt_nr_s>();
}
logged_mdt_nr_s& mdt_mode_nr_c::set_logged_mdt()
{
  set(types::logged_mdt);
  return c.get<logged_mdt_nr_s>();
}
protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>& mdt_mode_nr_c::set_mdt_mode_nr_ext()
{
  set(types::mdt_mode_nr_ext);
  return c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>();
}
void mdt_mode_nr_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::immediate_mdt:
      j.write_fieldname("immediateMDT");
      c.get<immediate_mdt_nr_s>().to_json(j);
      break;
    case types::logged_mdt:
      j.write_fieldname("loggedMDT");
      c.get<logged_mdt_nr_s>().to_json(j);
      break;
    case types::mdt_mode_nr_ext:
      j.write_fieldname("mDTMode-NR-Extension");
      c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
  j.end_obj();
}
SRSASN_CODE mdt_mode_nr_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::immediate_mdt:
      HANDLE_CODE(c.get<immediate_mdt_nr_s>().pack(bref));
      break;
    case types::logged_mdt:
      HANDLE_CODE(c.get<logged_mdt_nr_s>().pack(bref));
      break;
    case types::mdt_mode_nr_ext: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_mode_nr_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::immediate_mdt:
      HANDLE_CODE(c.get<immediate_mdt_nr_s>().unpack(bref));
      break;
    case types::logged_mdt:
      HANDLE_CODE(c.get<logged_mdt_nr_s>().unpack(bref));
      break;
    case types::mdt_mode_nr_ext: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ie_o>>().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mdt_mode_nr_c::types_opts::to_string() const
{
  static const char* names[] = {"immediateMDT", "loggedMDT", "mDTMode-NR-Extension"};
  return convert_enum_idx(names, 3, value, "mdt_mode_nr_c::types");
}

// MaximumIPdatarate ::= SEQUENCE
SRSASN_CODE max_ip_datarate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(max_ip_rate_ul.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE max_ip_datarate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(max_ip_rate_ul.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void max_ip_datarate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("maxIPrate-UL", max_ip_rate_ul.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// NPNMobilityInformation-PNI-NPN ::= SEQUENCE
SRSASN_CODE npn_mob_info_pni_npn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, allowed_pni_npn_id_list, 1, 16, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_mob_info_pni_npn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(allowed_pni_npn_id_list, bref, 1, 16, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_mob_info_pni_npn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("allowedPNI-NPN-ID-List");
  for (const auto& e1 : allowed_pni_npn_id_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NPNMobilityInformation-SNPN ::= SEQUENCE
SRSASN_CODE npn_mob_info_sn_pn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(serving_n_id.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_mob_info_sn_pn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(serving_n_id.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_mob_info_sn_pn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("serving-NID", serving_n_id.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// QOEMeasStatus ::= ENUMERATED
const char* qoe_meas_status_opts::to_string() const
{
  static const char* names[] = {"ongoing"};
  return convert_enum_idx(names, 1, value, "qoe_meas_status_e");
}

template struct asn1::protocol_ext_field_s<qos_flows_to_be_setup_item_ext_ies_o>;

SRSASN_CODE qos_flows_to_be_setup_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  nof_ies += redundant_qos_flow_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)212, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }
  if (redundant_qos_flow_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)213, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_qos_flow_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 212: {
        tsc_traffic_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.unpack(bref));
        break;
      }
      case 213: {
        redundant_qos_flow_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_qos_flow_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flows_to_be_setup_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_traffic_characteristics_present) {
    j.write_int("id", 212);
    j.write_str("criticality", "ignore");
    tsc_traffic_characteristics.to_json(j);
  }
  if (redundant_qos_flow_ind_present) {
    j.write_int("id", 213);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_qos_flow_ind.to_string());
  }
  j.end_obj();
}

// QoSFlowsToBeSetup-Item ::= SEQUENCE
SRSASN_CODE qos_flows_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(erab_id_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, qfi, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  if (erab_id_present) {
    HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(erab_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(qfi, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  if (erab_id_present) {
    HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qfi", qfi);
  j.write_fieldname("qosFlowLevelQoSParameters");
  qos_flow_level_qos_params.to_json(j);
  if (erab_id_present) {
    j.write_int("e-RAB-ID", erab_id);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// RAT-RestrictionsItem-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t rat_restricts_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {153};
  return map_enum_number(names, 1, idx, "id");
}
bool rat_restricts_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 153 == id;
}
crit_e rat_restricts_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 153) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
rat_restricts_item_ext_ies_o::ext_c rat_restricts_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 153) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rat_restricts_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 153) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void rat_restricts_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExtendedRATRestrictionInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE rat_restricts_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE rat_restricts_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* rat_restricts_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExtendedRATRestrictionInformation"};
  return convert_enum_idx(names, 1, value, "rat_restricts_item_ext_ies_o::ext_c::types");
}

// RedundantPDUSessionInformation ::= SEQUENCE
SRSASN_CODE redundant_pdu_session_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(rsn.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE redundant_pdu_session_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rsn.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void redundant_pdu_session_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rSN", rsn.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// ServiceType ::= ENUMERATED
const char* service_type_opts::to_string() const
{
  static const char* names[] = {"qMC-for-streaming-service", "qMC-for-MTSI-service", "qMC-for-VR-service"};
  return convert_enum_idx(names, 3, value, "service_type_e");
}

// AdditionLocationInformation ::= ENUMERATED
const char* addition_location_info_opts::to_string() const
{
  static const char* names[] = {"includePSCell"};
  return convert_enum_idx(names, 1, value, "addition_location_info_e");
}

// CNTypeRestrictionsForServing ::= ENUMERATED
const char* cn_type_restricts_for_serving_opts::to_string() const
{
  static const char* names[] = {"epc-forbidden"};
  return convert_enum_idx(names, 1, value, "cn_type_restricts_for_serving_e");
}

// MBS-SessionInformation-Item ::= SEQUENCE
SRSASN_CODE mbs_session_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(active_mbs_sessio_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (active_mbs_sessio_info_present) {
    HANDLE_CODE(active_mbs_sessio_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(active_mbs_sessio_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (active_mbs_sessio_info_present) {
    HANDLE_CODE(active_mbs_sessio_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-Session-ID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-Area-Session-ID", mbs_area_session_id);
  }
  if (active_mbs_sessio_info_present) {
    j.write_fieldname("active-MBS-SessioInformation");
    active_mbs_sessio_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDT-Configuration-EUTRA ::= SEQUENCE
SRSASN_CODE mdt_cfg_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(area_scope_of_mdt_eutra_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  if (area_scope_of_mdt_eutra_present) {
    HANDLE_CODE(area_scope_of_mdt_eutra.pack(bref));
  }
  HANDLE_CODE(mdt_mode_eutra.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, sig_based_mdt_plmn_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(area_scope_of_mdt_eutra_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  if (area_scope_of_mdt_eutra_present) {
    HANDLE_CODE(area_scope_of_mdt_eutra.unpack(bref));
  }
  HANDLE_CODE(mdt_mode_eutra.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(sig_based_mdt_plmn_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  if (area_scope_of_mdt_eutra_present) {
    j.write_fieldname("areaScopeOfMDT-EUTRA");
    area_scope_of_mdt_eutra.to_json(j);
  }
  j.write_str("mDTMode-EUTRA", mdt_mode_eutra.to_string());
  j.start_array("signallingBasedMDTPLMNList");
  for (const auto& e1 : sig_based_mdt_plmn_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDT-Configuration-NR ::= SEQUENCE
SRSASN_CODE mdt_cfg_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(area_scope_of_mdt_nr_present, 1));
  HANDLE_CODE(bref.pack(sig_based_mdt_plmn_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  if (area_scope_of_mdt_nr_present) {
    HANDLE_CODE(area_scope_of_mdt_nr.pack(bref));
  }
  HANDLE_CODE(mdt_mode_nr.pack(bref));
  if (sig_based_mdt_plmn_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sig_based_mdt_plmn_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(area_scope_of_mdt_nr_present, 1));
  bool sig_based_mdt_plmn_list_present;
  HANDLE_CODE(bref.unpack(sig_based_mdt_plmn_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  if (area_scope_of_mdt_nr_present) {
    HANDLE_CODE(area_scope_of_mdt_nr.unpack(bref));
  }
  HANDLE_CODE(mdt_mode_nr.unpack(bref));
  if (sig_based_mdt_plmn_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sig_based_mdt_plmn_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  if (area_scope_of_mdt_nr_present) {
    j.write_fieldname("areaScopeOfMDT-NR");
    area_scope_of_mdt_nr.to_json(j);
  }
  j.write_fieldname("mDTMode-NR");
  mdt_mode_nr.to_json(j);
  if (sig_based_mdt_plmn_list.size() > 0) {
    j.start_array("signallingBasedMDTPLMNList");
    for (const auto& e1 : sig_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPNMobilityInformation ::= CHOICE
void npn_mob_info_c::destroy_()
{
  switch (type_) {
    case types::snpn_mob_info:
      c.destroy<npn_mob_info_sn_pn_s>();
      break;
    case types::pni_npn_mob_info:
      c.destroy<npn_mob_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_mob_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::snpn_mob_info:
      c.init<npn_mob_info_sn_pn_s>();
      break;
    case types::pni_npn_mob_info:
      c.init<npn_mob_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
}
npn_mob_info_c::npn_mob_info_c(const npn_mob_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::snpn_mob_info:
      c.init(other.c.get<npn_mob_info_sn_pn_s>());
      break;
    case types::pni_npn_mob_info:
      c.init(other.c.get<npn_mob_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
}
npn_mob_info_c& npn_mob_info_c::operator=(const npn_mob_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::snpn_mob_info:
      c.set(other.c.get<npn_mob_info_sn_pn_s>());
      break;
    case types::pni_npn_mob_info:
      c.set(other.c.get<npn_mob_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }

  return *this;
}
npn_mob_info_sn_pn_s& npn_mob_info_c::set_snpn_mob_info()
{
  set(types::snpn_mob_info);
  return c.get<npn_mob_info_sn_pn_s>();
}
npn_mob_info_pni_npn_s& npn_mob_info_c::set_pni_npn_mob_info()
{
  set(types::pni_npn_mob_info);
  return c.get<npn_mob_info_pni_npn_s>();
}
protocol_ie_single_container_s<npn_mob_info_ext_ies_o>& npn_mob_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
}
void npn_mob_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::snpn_mob_info:
      j.write_fieldname("snpn-mobility-information");
      c.get<npn_mob_info_sn_pn_s>().to_json(j);
      break;
    case types::pni_npn_mob_info:
      j.write_fieldname("pni-npn-mobility-information");
      c.get<npn_mob_info_pni_npn_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_mob_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::snpn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_sn_pn_s>().pack(bref));
      break;
    case types::pni_npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_pni_npn_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_mob_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::snpn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_sn_pn_s>().unpack(bref));
      break;
    case types::pni_npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_pni_npn_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_mob_info_c::types_opts::to_string() const
{
  static const char* names[] = {"snpn-mobility-information", "pni-npn-mobility-information", "choice-extension"};
  return convert_enum_idx(names, 3, value, "npn_mob_info_c::types");
}

// PC5FlowBitRates ::= SEQUENCE
SRSASN_CODE pc5_flow_bit_rates_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_flow_bit_rates_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_flow_bit_rates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("guaranteedFlowBitRate", guaranteed_flow_bit_rate);
  j.write_int("maximumFlowBitRate", max_flow_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE pdu_session_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_session_ambr, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_session_ambr, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_session_ambr, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(ul_session_ambr, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("downlink-session-AMBR", dl_session_ambr);
  j.write_int("uplink-session-AMBR", ul_session_ambr);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourcesToBeSetup-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_to_be_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {108, 127, 207, 210, 211, 217, 275};
  return map_enum_number(names, 7, idx, "id");
}
bool pdu_session_res_to_be_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {108, 127, 207, 210, 211, 217, 275};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_to_be_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 108:
      return crit_e::ignore;
    case 127:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    case 210:
      return crit_e::ignore;
    case 211:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 275:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c
pdu_session_res_to_be_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 108:
      ret.set(ext_c::types::add_ul_ng_u_tnl_at_up_f_list);
      break;
    case 127:
      ret.set(ext_c::types::pdu_session_common_network_instance);
      break;
    case 207:
      ret.set(ext_c::types::redundant_ul_ng_u_tnl_at_up_f);
      break;
    case 210:
      ret.set(ext_c::types::add_redundant_ul_ng_u_tnl_at_up_f_list);
      break;
    case 211:
      ret.set(ext_c::types::redundant_common_network_instance);
      break;
    case 217:
      ret.set(ext_c::types::redundant_pdu_session_info);
      break;
    case 275:
      ret.set(ext_c::types::mbs_session_associated_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_to_be_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 108:
      return presence_e::optional;
    case 127:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    case 210:
      return presence_e::optional;
    case 211:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 275:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_ul_ng_u_tnl_at_up_f_list:
      c = add_ul_ng_u_tnl_at_up_f_list_l{};
      break;
    case types::pdu_session_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      c = up_transport_layer_info_c{};
      break;
    case types::add_redundant_ul_ng_u_tnl_at_up_f_list:
      c = add_ul_ng_u_tnl_at_up_f_list_l{};
      break;
    case types::redundant_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::redundant_pdu_session_info:
      c = redundant_pdu_session_info_s{};
      break;
    case types::mbs_session_associated_info:
      c = mbs_session_associated_info_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_to_be_setup_item_ext_ies_o::ext_c");
  }
}
add_ul_ng_u_tnl_at_up_f_list_l& pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::add_ul_ng_u_tnl_at_up_f_list()
{
  assert_choice_type(types::add_ul_ng_u_tnl_at_up_f_list, type_, "Extension");
  return c.get<add_ul_ng_u_tnl_at_up_f_list_l>();
}
unbounded_octstring<true>& pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::pdu_session_common_network_instance()
{
  assert_choice_type(types::pdu_session_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
up_transport_layer_info_c& pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::redundant_ul_ng_u_tnl_at_up_f()
{
  assert_choice_type(types::redundant_ul_ng_u_tnl_at_up_f, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
add_ul_ng_u_tnl_at_up_f_list_l&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::add_redundant_ul_ng_u_tnl_at_up_f_list()
{
  assert_choice_type(types::add_redundant_ul_ng_u_tnl_at_up_f_list, type_, "Extension");
  return c.get<add_ul_ng_u_tnl_at_up_f_list_l>();
}
unbounded_octstring<true>& pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::redundant_common_network_instance()
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
redundant_pdu_session_info_s& pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::redundant_pdu_session_info()
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
mbs_session_associated_info_l& pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::mbs_session_associated_info()
{
  assert_choice_type(types::mbs_session_associated_info, type_, "Extension");
  return c.get<mbs_session_associated_info_l>();
}
const add_ul_ng_u_tnl_at_up_f_list_l&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::add_ul_ng_u_tnl_at_up_f_list() const
{
  assert_choice_type(types::add_ul_ng_u_tnl_at_up_f_list, type_, "Extension");
  return c.get<add_ul_ng_u_tnl_at_up_f_list_l>();
}
const unbounded_octstring<true>&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::pdu_session_common_network_instance() const
{
  assert_choice_type(types::pdu_session_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const up_transport_layer_info_c&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::redundant_ul_ng_u_tnl_at_up_f() const
{
  assert_choice_type(types::redundant_ul_ng_u_tnl_at_up_f, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const add_ul_ng_u_tnl_at_up_f_list_l&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::add_redundant_ul_ng_u_tnl_at_up_f_list() const
{
  assert_choice_type(types::add_redundant_ul_ng_u_tnl_at_up_f_list, type_, "Extension");
  return c.get<add_ul_ng_u_tnl_at_up_f_list_l>();
}
const unbounded_octstring<true>&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::redundant_common_network_instance() const
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const redundant_pdu_session_info_s&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::redundant_pdu_session_info() const
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const mbs_session_associated_info_l&
pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::mbs_session_associated_info() const
{
  assert_choice_type(types::mbs_session_associated_info, type_, "Extension");
  return c.get<mbs_session_associated_info_l>();
}
void pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_ul_ng_u_tnl_at_up_f_list:
      j.start_array("Additional-UL-NG-U-TNLatUPF-List");
      for (const auto& e1 : c.get<add_ul_ng_u_tnl_at_up_f_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_ul_ng_u_tnl_at_up_f_list:
      j.start_array("Additional-UL-NG-U-TNLatUPF-List");
      for (const auto& e1 : c.get<add_ul_ng_u_tnl_at_up_f_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::redundant_pdu_session_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::mbs_session_associated_info:
      j.start_array("MBS-SessionAssociatedInformation");
      for (const auto& e1 : c.get<mbs_session_associated_info_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_to_be_setup_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ul_ng_u_tnl_at_up_f_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_ul_ng_u_tnl_at_up_f_list_l>(), 1, 3, true));
      break;
    case types::pdu_session_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_ul_ng_u_tnl_at_up_f_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_ul_ng_u_tnl_at_up_f_list_l>(), 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::mbs_session_associated_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_associated_info_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ul_ng_u_tnl_at_up_f_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_ul_ng_u_tnl_at_up_f_list_l>(), bref, 1, 3, true));
      break;
    case types::pdu_session_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_ul_ng_u_tnl_at_up_f_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_ul_ng_u_tnl_at_up_f_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::mbs_session_associated_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_associated_info_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Additional-UL-NG-U-TNLatUPF-List",
                                "OCTET STRING",
                                "UPTransportLayerInformation",
                                "Additional-UL-NG-U-TNLatUPF-List",
                                "OCTET STRING",
                                "RedundantPDUSessionInformation",
                                "MBS-SessionAssociatedInformation"};
  return convert_enum_idx(names, 7, value, "pdu_session_res_to_be_setup_item_ext_ies_o::ext_c::types");
}

// PDUSessionType ::= ENUMERATED
const char* pdu_session_type_opts::to_string() const
{
  static const char* names[] = {"ipv4", "ipv6", "ipv4v6", "ethernet", "unstructured"};
  return convert_enum_idx(names, 5, value, "pdu_session_type_e");
}

// RAT-RestrictionsItem ::= SEQUENCE
SRSASN_CODE rat_restricts_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(rat_restrict_info.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rat_restricts_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(rat_restrict_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void rat_restricts_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-Identity", plmn_id.to_string());
  j.write_str("rat-RestrictionInformation", rat_restrict_info.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SecurityIndication ::= SEQUENCE
SRSASN_CODE security_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_ip_datarate_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_ind.pack(bref));
  HANDLE_CODE(confidentiality_protection_ind.pack(bref));
  if (max_ip_datarate_present) {
    HANDLE_CODE(max_ip_datarate.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_ip_datarate_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_ind.unpack(bref));
  HANDLE_CODE(confidentiality_protection_ind.unpack(bref));
  if (max_ip_datarate_present) {
    HANDLE_CODE(max_ip_datarate.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void security_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("integrityProtectionIndication", integrity_protection_ind.to_string());
  j.write_str("confidentialityProtectionIndication", confidentiality_protection_ind.to_string());
  if (max_ip_datarate_present) {
    j.write_fieldname("maximumIPdatarate");
    max_ip_datarate.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* security_ind_s::integrity_protection_ind_opts::to_string() const
{
  static const char* names[] = {"required", "preferred", "not-needed"};
  return convert_enum_idx(names, 3, value, "security_ind_s::integrity_protection_ind_e_");
}

const char* security_ind_s::confidentiality_protection_ind_opts::to_string() const
{
  static const char* names[] = {"required", "preferred", "not-needed"};
  return convert_enum_idx(names, 3, value, "security_ind_s::confidentiality_protection_ind_e_");
}

// ServiceAreaItem ::= SEQUENCE
SRSASN_CODE service_area_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(allowed_tacs_service_area.size() > 0, 1));
  HANDLE_CODE(bref.pack(not_allowed_tacs_service_area.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (allowed_tacs_service_area.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_tacs_service_area, 1, 16, true));
  }
  if (not_allowed_tacs_service_area.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, not_allowed_tacs_service_area, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE service_area_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool allowed_tacs_service_area_present;
  HANDLE_CODE(bref.unpack(allowed_tacs_service_area_present, 1));
  bool not_allowed_tacs_service_area_present;
  HANDLE_CODE(bref.unpack(not_allowed_tacs_service_area_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (allowed_tacs_service_area_present) {
    HANDLE_CODE(unpack_dyn_seq_of(allowed_tacs_service_area, bref, 1, 16, true));
  }
  if (not_allowed_tacs_service_area_present) {
    HANDLE_CODE(unpack_dyn_seq_of(not_allowed_tacs_service_area, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void service_area_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-Identity", plmn_id.to_string());
  if (allowed_tacs_service_area.size() > 0) {
    j.start_array("allowed-TACs-ServiceArea");
    for (const auto& e1 : allowed_tacs_service_area) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (not_allowed_tacs_service_area.size() > 0) {
    j.start_array("not-allowed-TACs-ServiceArea");
    for (const auto& e1 : not_allowed_tacs_service_area) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEAppLayerMeasConfigInfo ::= SEQUENCE
SRSASN_CODE ue_app_layer_meas_cfg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qoe_meas_cfg_app_layer_id_present, 1));
  HANDLE_CODE(bref.pack(qoe_meas_status_present, 1));
  HANDLE_CODE(bref.pack(container_app_layer_meas_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(mdt_align_info_present, 1));
  HANDLE_CODE(bref.pack(meas_collection_entity_ip_address_present, 1));
  HANDLE_CODE(bref.pack(area_scope_of_qmc_present, 1));
  HANDLE_CODE(bref.pack(s_nssai_list_qo_e.size() > 0, 1));
  HANDLE_CODE(bref.pack(available_rv_qo_e_metrics_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(qoe_ref.pack(bref));
  if (qoe_meas_cfg_app_layer_id_present) {
    HANDLE_CODE(pack_integer(bref, qoe_meas_cfg_app_layer_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  HANDLE_CODE(service_type.pack(bref));
  if (qoe_meas_status_present) {
    HANDLE_CODE(qoe_meas_status.pack(bref));
  }
  if (container_app_layer_meas_cfg.size() > 0) {
    HANDLE_CODE(container_app_layer_meas_cfg.pack(bref));
  }
  if (mdt_align_info_present) {
    HANDLE_CODE(mdt_align_info.pack(bref));
  }
  if (meas_collection_entity_ip_address_present) {
    HANDLE_CODE(meas_collection_entity_ip_address.pack(bref));
  }
  if (area_scope_of_qmc_present) {
    HANDLE_CODE(area_scope_of_qmc.pack(bref));
  }
  if (s_nssai_list_qo_e.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, s_nssai_list_qo_e, 1, 16, true));
  }
  if (available_rv_qo_e_metrics_present) {
    HANDLE_CODE(available_rv_qo_e_metrics.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_cfg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qoe_meas_cfg_app_layer_id_present, 1));
  HANDLE_CODE(bref.unpack(qoe_meas_status_present, 1));
  bool container_app_layer_meas_cfg_present;
  HANDLE_CODE(bref.unpack(container_app_layer_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(mdt_align_info_present, 1));
  HANDLE_CODE(bref.unpack(meas_collection_entity_ip_address_present, 1));
  HANDLE_CODE(bref.unpack(area_scope_of_qmc_present, 1));
  bool s_nssai_list_qo_e_present;
  HANDLE_CODE(bref.unpack(s_nssai_list_qo_e_present, 1));
  HANDLE_CODE(bref.unpack(available_rv_qo_e_metrics_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(qoe_ref.unpack(bref));
  if (qoe_meas_cfg_app_layer_id_present) {
    HANDLE_CODE(unpack_integer(qoe_meas_cfg_app_layer_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  HANDLE_CODE(service_type.unpack(bref));
  if (qoe_meas_status_present) {
    HANDLE_CODE(qoe_meas_status.unpack(bref));
  }
  if (container_app_layer_meas_cfg_present) {
    HANDLE_CODE(container_app_layer_meas_cfg.unpack(bref));
  }
  if (mdt_align_info_present) {
    HANDLE_CODE(mdt_align_info.unpack(bref));
  }
  if (meas_collection_entity_ip_address_present) {
    HANDLE_CODE(meas_collection_entity_ip_address.unpack(bref));
  }
  if (area_scope_of_qmc_present) {
    HANDLE_CODE(area_scope_of_qmc.unpack(bref));
  }
  if (s_nssai_list_qo_e_present) {
    HANDLE_CODE(unpack_dyn_seq_of(s_nssai_list_qo_e, bref, 1, 16, true));
  }
  if (available_rv_qo_e_metrics_present) {
    HANDLE_CODE(available_rv_qo_e_metrics.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_app_layer_meas_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("qOEReference", qoe_ref.to_string());
  if (qoe_meas_cfg_app_layer_id_present) {
    j.write_int("qOEMeasConfigAppLayerID", qoe_meas_cfg_app_layer_id);
  }
  j.write_str("serviceType", service_type.to_string());
  if (qoe_meas_status_present) {
    j.write_str("qOEMeasStatus", "ongoing");
  }
  if (container_app_layer_meas_cfg.size() > 0) {
    j.write_str("containerAppLayerMeasConfig", container_app_layer_meas_cfg.to_string());
  }
  if (mdt_align_info_present) {
    j.write_fieldname("mDTAlignmentInfo");
    mdt_align_info.to_json(j);
  }
  if (meas_collection_entity_ip_address_present) {
    j.write_str("measCollectionEntityIPAddress", meas_collection_entity_ip_address.to_string());
  }
  if (area_scope_of_qmc_present) {
    j.write_fieldname("areaScopeOfQMC");
    area_scope_of_qmc.to_json(j);
  }
  if (s_nssai_list_qo_e.size() > 0) {
    j.start_array("s-NSSAIListQoE");
    for (const auto& e1 : s_nssai_list_qo_e) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (available_rv_qo_e_metrics_present) {
    j.write_fieldname("availableRVQoEMetrics");
    available_rv_qo_e_metrics.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UESliceMaximumBitRate-Item ::= SEQUENCE
SRSASN_CODE ue_slice_max_bit_rate_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pack_integer(bref, dl_ue_slice_mbr, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_ue_slice_mbr, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_slice_max_bit_rate_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(unpack_integer(dl_ue_slice_mbr, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(ul_ue_slice_mbr, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_slice_max_bit_rate_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_int("dl-UE-Slice-MBR", dl_ue_slice_mbr);
  j.write_int("ul-UE-Slice-MBR", ul_ue_slice_mbr);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EventType ::= ENUMERATED
const char* event_type_opts::to_string() const
{
  static const char* names[] = {"report-upon-change-of-serving-cell",
                                "report-UE-moving-presence-into-or-out-of-the-Area-of-Interest",
                                "report-upon-change-of-serving-cell-and-Area-of-Interest"};
  return convert_enum_idx(names, 3, value, "event_type_e");
}

// LTEUESidelinkAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE lte_ue_sidelink_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_sidelink_aggr_max_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lte_ue_sidelink_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_sidelink_aggr_max_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lte_ue_sidelink_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uESidelinkAggregateMaximumBitRate", ue_sidelink_aggr_max_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LocationReportingInformation-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t location_report_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {251};
  return map_enum_number(names, 1, idx, "id");
}
bool location_report_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 251 == id;
}
crit_e location_report_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 251) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
location_report_info_ext_ies_o::ext_c location_report_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 251) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 251) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void location_report_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("AdditionLocationInformation", "includePSCell");
  j.end_obj();
}
SRSASN_CODE location_report_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* location_report_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AdditionLocationInformation"};
  return convert_enum_idx(names, 1, value, "location_report_info_ext_ies_o::ext_c::types");
}

// MDT-Configuration ::= SEQUENCE
SRSASN_CODE mdt_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mdt_cfg_nr_present, 1));
  HANDLE_CODE(bref.pack(mdt_cfg_eutra_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mdt_cfg_nr_present) {
    HANDLE_CODE(mdt_cfg_nr.pack(bref));
  }
  if (mdt_cfg_eutra_present) {
    HANDLE_CODE(mdt_cfg_eutra.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mdt_cfg_nr_present, 1));
  HANDLE_CODE(bref.unpack(mdt_cfg_eutra_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mdt_cfg_nr_present) {
    HANDLE_CODE(mdt_cfg_nr.unpack(bref));
  }
  if (mdt_cfg_eutra_present) {
    HANDLE_CODE(mdt_cfg_eutra.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mdt_cfg_nr_present) {
    j.write_fieldname("mDT-Configuration-NR");
    mdt_cfg_nr.to_json(j);
  }
  if (mdt_cfg_eutra_present) {
    j.write_fieldname("mDT-Configuration-EUTRA");
    mdt_cfg_eutra.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MobilityRestrictionList-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t mob_restrict_list_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {112, 136, 135, 222};
  return map_enum_number(names, 4, idx, "id");
}
bool mob_restrict_list_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {112, 136, 135, 222};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mob_restrict_list_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 112:
      return crit_e::ignore;
    case 136:
      return crit_e::ignore;
    case 135:
      return crit_e::ignore;
    case 222:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
mob_restrict_list_ext_ies_o::ext_c mob_restrict_list_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 112:
      ret.set(ext_c::types::last_e_utran_plmn_id);
      break;
    case 136:
      ret.set(ext_c::types::cn_type_restricts_for_serving);
      break;
    case 135:
      ret.set(ext_c::types::cn_type_restricts_for_equivalent);
      break;
    case 222:
      ret.set(ext_c::types::npn_mob_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e mob_restrict_list_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 112:
      return presence_e::optional;
    case 136:
      return presence_e::optional;
    case 135:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void mob_restrict_list_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::last_e_utran_plmn_id:
      c = fixed_octstring<3, true>{};
      break;
    case types::cn_type_restricts_for_serving:
      c = cn_type_restricts_for_serving_e{};
      break;
    case types::cn_type_restricts_for_equivalent:
      c = cn_type_restricts_for_equivalent_l{};
      break;
    case types::npn_mob_info:
      c = npn_mob_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }
}
fixed_octstring<3, true>& mob_restrict_list_ext_ies_o::ext_c::last_e_utran_plmn_id()
{
  assert_choice_type(types::last_e_utran_plmn_id, type_, "Extension");
  return c.get<fixed_octstring<3, true>>();
}
cn_type_restricts_for_serving_e& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_serving()
{
  assert_choice_type(types::cn_type_restricts_for_serving, type_, "Extension");
  return c.get<cn_type_restricts_for_serving_e>();
}
cn_type_restricts_for_equivalent_l& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_equivalent()
{
  assert_choice_type(types::cn_type_restricts_for_equivalent, type_, "Extension");
  return c.get<cn_type_restricts_for_equivalent_l>();
}
npn_mob_info_c& mob_restrict_list_ext_ies_o::ext_c::npn_mob_info()
{
  assert_choice_type(types::npn_mob_info, type_, "Extension");
  return c.get<npn_mob_info_c>();
}
const fixed_octstring<3, true>& mob_restrict_list_ext_ies_o::ext_c::last_e_utran_plmn_id() const
{
  assert_choice_type(types::last_e_utran_plmn_id, type_, "Extension");
  return c.get<fixed_octstring<3, true>>();
}
const cn_type_restricts_for_serving_e& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_serving() const
{
  assert_choice_type(types::cn_type_restricts_for_serving, type_, "Extension");
  return c.get<cn_type_restricts_for_serving_e>();
}
const cn_type_restricts_for_equivalent_l& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_equivalent() const
{
  assert_choice_type(types::cn_type_restricts_for_equivalent, type_, "Extension");
  return c.get<cn_type_restricts_for_equivalent_l>();
}
const npn_mob_info_c& mob_restrict_list_ext_ies_o::ext_c::npn_mob_info() const
{
  assert_choice_type(types::npn_mob_info, type_, "Extension");
  return c.get<npn_mob_info_c>();
}
void mob_restrict_list_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::last_e_utran_plmn_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<3, true>>().to_string());
      break;
    case types::cn_type_restricts_for_serving:
      j.write_str("CNTypeRestrictionsForServing", "epc-forbidden");
      break;
    case types::cn_type_restricts_for_equivalent:
      j.start_array("CNTypeRestrictionsForEquivalent");
      for (const auto& e1 : c.get<cn_type_restricts_for_equivalent_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::npn_mob_info:
      j.write_fieldname("NPNMobilityInformation");
      c.get<npn_mob_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE mob_restrict_list_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_e_utran_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().pack(bref)));
      break;
    case types::cn_type_restricts_for_serving:
      HANDLE_CODE(c.get<cn_type_restricts_for_serving_e>().pack(bref));
      break;
    case types::cn_type_restricts_for_equivalent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cn_type_restricts_for_equivalent_l>(), 1, 15, true));
      break;
    case types::npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_e_utran_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().unpack(bref)));
      break;
    case types::cn_type_restricts_for_serving:
      HANDLE_CODE(c.get<cn_type_restricts_for_serving_e>().unpack(bref));
      break;
    case types::cn_type_restricts_for_equivalent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cn_type_restricts_for_equivalent_l>(), bref, 1, 15, true));
      break;
    case types::npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mob_restrict_list_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {
      "OCTET STRING", "CNTypeRestrictionsForServing", "CNTypeRestrictionsForEquivalent", "NPNMobilityInformation"};
  return convert_enum_idx(names, 4, value, "mob_restrict_list_ext_ies_o::ext_c::types");
}

// NRUESidelinkAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE nr_ue_sidelink_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_sidelink_aggr_max_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_ue_sidelink_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_sidelink_aggr_max_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_ue_sidelink_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uESidelinkAggregateMaximumBitRate", ue_sidelink_aggr_max_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5QoSFlowItem ::= SEQUENCE
SRSASN_CODE pc5_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(range_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pqi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (pc5_flow_bit_rates_present) {
    HANDLE_CODE(pc5_flow_bit_rates.pack(bref));
  }
  if (range_present) {
    HANDLE_CODE(range.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(range_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pqi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (pc5_flow_bit_rates_present) {
    HANDLE_CODE(pc5_flow_bit_rates.unpack(bref));
  }
  if (range_present) {
    HANDLE_CODE(range.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pQI", pqi);
  if (pc5_flow_bit_rates_present) {
    j.write_fieldname("pc5FlowBitRates");
    pc5_flow_bit_rates.to_json(j);
  }
  if (range_present) {
    j.write_str("range", range.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<pdu_session_res_to_be_setup_item_ext_ies_o>;

SRSASN_CODE pdu_session_res_to_be_setup_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_ul_ng_u_tnl_at_up_f_list_present ? 1 : 0;
  nof_ies += pdu_session_common_network_instance_present ? 1 : 0;
  nof_ies += redundant_ul_ng_u_tnl_at_up_f_present ? 1 : 0;
  nof_ies += add_redundant_ul_ng_u_tnl_at_up_f_list_present ? 1 : 0;
  nof_ies += redundant_common_network_instance_present ? 1 : 0;
  nof_ies += redundant_pdu_session_info_present ? 1 : 0;
  nof_ies += mbs_session_associated_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_ul_ng_u_tnl_at_up_f_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)108, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ul_ng_u_tnl_at_up_f_list, 1, 3, true));
  }
  if (pdu_session_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)127, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdu_session_common_network_instance.pack(bref));
  }
  if (redundant_ul_ng_u_tnl_at_up_f_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ng_u_tnl_at_up_f.pack(bref));
  }
  if (add_redundant_ul_ng_u_tnl_at_up_f_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)210, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_ul_ng_u_tnl_at_up_f_list, 1, 3, true));
  }
  if (redundant_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)211, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_common_network_instance.pack(bref));
  }
  if (redundant_pdu_session_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_pdu_session_info.pack(bref));
  }
  if (mbs_session_associated_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)275, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_associated_info, 1, 32, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_be_setup_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 108: {
        add_ul_ng_u_tnl_at_up_f_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_ul_ng_u_tnl_at_up_f_list, bref, 1, 3, true));
        break;
      }
      case 127: {
        pdu_session_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_common_network_instance.unpack(bref));
        break;
      }
      case 207: {
        redundant_ul_ng_u_tnl_at_up_f_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ng_u_tnl_at_up_f.unpack(bref));
        break;
      }
      case 210: {
        add_redundant_ul_ng_u_tnl_at_up_f_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_ul_ng_u_tnl_at_up_f_list, bref, 1, 3, true));
        break;
      }
      case 211: {
        redundant_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_common_network_instance.unpack(bref));
        break;
      }
      case 217: {
        redundant_pdu_session_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_pdu_session_info.unpack(bref));
        break;
      }
      case 275: {
        mbs_session_associated_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_associated_info, bref, 1, 32, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_be_setup_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_ul_ng_u_tnl_at_up_f_list_present) {
    j.write_int("id", 108);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_ul_ng_u_tnl_at_up_f_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_common_network_instance_present) {
    j.write_int("id", 127);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", pdu_session_common_network_instance.to_string());
  }
  if (redundant_ul_ng_u_tnl_at_up_f_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    redundant_ul_ng_u_tnl_at_up_f.to_json(j);
  }
  if (add_redundant_ul_ng_u_tnl_at_up_f_list_present) {
    j.write_int("id", 210);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_ul_ng_u_tnl_at_up_f_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redundant_common_network_instance_present) {
    j.write_int("id", 211);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_common_network_instance.to_string());
  }
  if (redundant_pdu_session_info_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    redundant_pdu_session_info.to_json(j);
  }
  if (mbs_session_associated_info_present) {
    j.write_int("id", 275);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_session_associated_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PDUSessionResourcesToBeSetup-Item ::= SEQUENCE
SRSASN_CODE pdu_session_res_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_ambr_present, 1));
  HANDLE_CODE(bref.pack(source_dl_ng_u_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(security_ind_present, 1));
  HANDLE_CODE(bref.pack(pdu_session_network_instance_present, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(s_nssai.pack(bref));
  if (pdu_session_ambr_present) {
    HANDLE_CODE(pdu_session_ambr.pack(bref));
  }
  HANDLE_CODE(ul_ng_u_tnl_at_up_f.pack(bref));
  if (source_dl_ng_u_tnl_info_present) {
    HANDLE_CODE(source_dl_ng_u_tnl_info.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.pack(bref));
  }
  HANDLE_CODE(pdu_session_type.pack(bref));
  if (pdu_session_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, pdu_session_network_instance, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_setup_list, 1, 64, true));
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdu_session_ambr_present, 1));
  HANDLE_CODE(bref.unpack(source_dl_ng_u_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(security_ind_present, 1));
  HANDLE_CODE(bref.unpack(pdu_session_network_instance_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(s_nssai.unpack(bref));
  if (pdu_session_ambr_present) {
    HANDLE_CODE(pdu_session_ambr.unpack(bref));
  }
  HANDLE_CODE(ul_ng_u_tnl_at_up_f.unpack(bref));
  if (source_dl_ng_u_tnl_info_present) {
    HANDLE_CODE(source_dl_ng_u_tnl_info.unpack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.unpack(bref));
  }
  HANDLE_CODE(pdu_session_type.unpack(bref));
  if (pdu_session_network_instance_present) {
    HANDLE_CODE(unpack_integer(pdu_session_network_instance, bref, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_setup_list, bref, 1, 64, true));
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pduSessionId", pdu_session_id);
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (pdu_session_ambr_present) {
    j.write_fieldname("pduSessionAMBR");
    pdu_session_ambr.to_json(j);
  }
  j.write_fieldname("uL-NG-U-TNLatUPF");
  ul_ng_u_tnl_at_up_f.to_json(j);
  if (source_dl_ng_u_tnl_info_present) {
    j.write_fieldname("source-DL-NG-U-TNL-Information");
    source_dl_ng_u_tnl_info.to_json(j);
  }
  if (security_ind_present) {
    j.write_fieldname("securityIndication");
    security_ind.to_json(j);
  }
  j.write_str("pduSessionType", pdu_session_type.to_string());
  if (pdu_session_network_instance_present) {
    j.write_int("pduSessionNetworkInstance", pdu_session_network_instance);
  }
  j.start_array("qosFlowsToBeSetup-List");
  for (const auto& e1 : qos_flows_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (dataforwardinginfofrom_source_present) {
    j.write_fieldname("dataforwardinginfofromSource");
    dataforwardinginfofrom_source.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ReportArea ::= ENUMERATED
const char* report_area_opts::to_string() const
{
  static const char* names[] = {"cell"};
  return convert_enum_idx(names, 1, value, "report_area_e");
}

// UEAppLayerMeasInfo-Item ::= SEQUENCE
SRSASN_CODE ue_app_layer_meas_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_app_layer_meas_cfg_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_app_layer_meas_cfg_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_app_layer_meas_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEAppLayerMeasConfigInfo");
  ue_app_layer_meas_cfg_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LastVisitedCell-Item ::= CHOICE
void last_visited_cell_item_c::destroy_()
{
  switch (type_) {
    case types::ng_ran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::e_utran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::utran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::geran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void last_visited_cell_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ng_ran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::e_utran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::utran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::geran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }
}
last_visited_cell_item_c::last_visited_cell_item_c(const last_visited_cell_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ng_ran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::e_utran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::utran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::geran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }
}
last_visited_cell_item_c& last_visited_cell_item_c::operator=(const last_visited_cell_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ng_ran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::e_utran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::utran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::geran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }

  return *this;
}
unbounded_octstring<true>& last_visited_cell_item_c::set_ng_ran_cell()
{
  set(types::ng_ran_cell);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& last_visited_cell_item_c::set_e_utran_cell()
{
  set(types::e_utran_cell);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& last_visited_cell_item_c::set_utran_cell()
{
  set(types::utran_cell);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& last_visited_cell_item_c::set_geran_cell()
{
  set(types::geran_cell);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>& last_visited_cell_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>();
}
void last_visited_cell_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ng_ran_cell:
      j.write_str("nG-RAN-Cell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::e_utran_cell:
      j.write_str("e-UTRAN-Cell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::utran_cell:
      j.write_str("uTRAN-Cell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::geran_cell:
      j.write_str("gERAN-Cell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }
  j.end_obj();
}
SRSASN_CODE last_visited_cell_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ng_ran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::e_utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_cell_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ng_ran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::e_utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<last_visited_cell_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* last_visited_cell_item_c::types_opts::to_string() const
{
  static const char* names[] = {"nG-RAN-Cell", "e-UTRAN-Cell", "uTRAN-Cell", "gERAN-Cell", "choice-extension"};
  return convert_enum_idx(names, 5, value, "last_visited_cell_item_c::types");
}

// LocationReportingInformation ::= SEQUENCE
SRSASN_CODE location_report_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(area_of_interest.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(event_type.pack(bref));
  HANDLE_CODE(report_area.pack(bref));
  if (area_of_interest.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest, 1, 64, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool area_of_interest_present;
  HANDLE_CODE(bref.unpack(area_of_interest_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(event_type.unpack(bref));
  HANDLE_CODE(report_area.unpack(bref));
  if (area_of_interest_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void location_report_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eventType", event_type.to_string());
  j.write_str("reportArea", "cell");
  if (area_of_interest.size() > 0) {
    j.start_array("areaOfInterest");
    for (const auto& e1 : area_of_interest) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<mob_restrict_list_ext_ies_o>;

SRSASN_CODE mob_restrict_list_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += last_e_utran_plmn_id_present ? 1 : 0;
  nof_ies += cn_type_restricts_for_serving_present ? 1 : 0;
  nof_ies += cn_type_restricts_for_equivalent_present ? 1 : 0;
  nof_ies += npn_mob_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (last_e_utran_plmn_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)112, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(last_e_utran_plmn_id.pack(bref));
  }
  if (cn_type_restricts_for_serving_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)136, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_type_restricts_for_serving.pack(bref));
  }
  if (cn_type_restricts_for_equivalent_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)135, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, cn_type_restricts_for_equivalent, 1, 15, true));
  }
  if (npn_mob_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_mob_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 112: {
        last_e_utran_plmn_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(last_e_utran_plmn_id.unpack(bref));
        break;
      }
      case 136: {
        cn_type_restricts_for_serving_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_type_restricts_for_serving.unpack(bref));
        break;
      }
      case 135: {
        cn_type_restricts_for_equivalent_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(cn_type_restricts_for_equivalent, bref, 1, 15, true));
        break;
      }
      case 222: {
        npn_mob_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_mob_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void mob_restrict_list_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (last_e_utran_plmn_id_present) {
    j.write_int("id", 112);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", last_e_utran_plmn_id.to_string());
  }
  if (cn_type_restricts_for_serving_present) {
    j.write_int("id", 136);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "epc-forbidden");
  }
  if (cn_type_restricts_for_equivalent_present) {
    j.write_int("id", 135);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : cn_type_restricts_for_equivalent) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (npn_mob_info_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "reject");
    npn_mob_info.to_json(j);
  }
  j.end_obj();
}

// MobilityRestrictionList ::= SEQUENCE
SRSASN_CODE mob_restrict_list_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(equivalent_plmns.size() > 0, 1));
  HANDLE_CODE(bref.pack(rat_restricts.size() > 0, 1));
  HANDLE_CODE(bref.pack(forbidden_area_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(service_area_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.pack(bref));
  if (equivalent_plmns.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, equivalent_plmns, 1, 15, true));
  }
  if (rat_restricts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, rat_restricts, 1, 16, true));
  }
  if (forbidden_area_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_area_info, 1, 16, true));
  }
  if (service_area_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, service_area_info, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool equivalent_plmns_present;
  HANDLE_CODE(bref.unpack(equivalent_plmns_present, 1));
  bool rat_restricts_present;
  HANDLE_CODE(bref.unpack(rat_restricts_present, 1));
  bool forbidden_area_info_present;
  HANDLE_CODE(bref.unpack(forbidden_area_info_present, 1));
  bool service_area_info_present;
  HANDLE_CODE(bref.unpack(service_area_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.unpack(bref));
  if (equivalent_plmns_present) {
    HANDLE_CODE(unpack_dyn_seq_of(equivalent_plmns, bref, 1, 15, true));
  }
  if (rat_restricts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(rat_restricts, bref, 1, 16, true));
  }
  if (forbidden_area_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(forbidden_area_info, bref, 1, 16, true));
  }
  if (service_area_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(service_area_info, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mob_restrict_list_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("serving-PLMN", serving_plmn.to_string());
  if (equivalent_plmns.size() > 0) {
    j.start_array("equivalent-PLMNs");
    for (const auto& e1 : equivalent_plmns) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (rat_restricts.size() > 0) {
    j.start_array("rat-Restrictions");
    for (const auto& e1 : rat_restricts) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (forbidden_area_info.size() > 0) {
    j.start_array("forbiddenAreaInformation");
    for (const auto& e1 : forbidden_area_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (service_area_info.size() > 0) {
    j.start_array("serviceAreaInformation");
    for (const auto& e1 : service_area_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PedestrianUE ::= ENUMERATED
const char* pedestrian_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "pedestrian_ue_e");
}

// Trace-Depth ::= ENUMERATED
const char* trace_depth_opts::to_string() const
{
  static const char* names[] = {"minimum",
                                "medium",
                                "maximum",
                                "minimumWithoutVendorSpecificExtension",
                                "mediumWithoutVendorSpecificExtension",
                                "maximumWithoutVendorSpecificExtension"};
  return convert_enum_idx(names, 6, value, "trace_depth_e");
}

// TraceActivation-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t trace_activation_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {226, 224};
  return map_enum_number(names, 2, idx, "id");
}
bool trace_activation_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {226, 224};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_activation_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 226:
      return crit_e::ignore;
    case 224:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_activation_ext_ies_o::ext_c trace_activation_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 226:
      ret.set(ext_c::types::trace_collection_entity_uri);
      break;
    case 224:
      ret.set(ext_c::types::mdt_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_activation_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 226:
      return presence_e::optional;
    case 224:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void trace_activation_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::trace_collection_entity_uri:
      c = visible_string<0, MAX_ASN_STRING_LENGTH, false, true>{};
      break;
    case types::mdt_cfg:
      c = mdt_cfg_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg()
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg() const
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
void trace_activation_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    case types::mdt_cfg:
      j.write_fieldname("MDT-Configuration");
      c.get<mdt_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_activation_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"VisibleString", "MDT-Configuration"};
  return convert_enum_idx(names, 2, value, "trace_activation_ext_ies_o::ext_c::types");
}

// UEAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE ue_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_ue_ambr, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_ue_ambr, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(dl_ue_ambr, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(ul_ue_ambr, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dl-UE-AMBR", dl_ue_ambr);
  j.write_int("ul-UE-AMBR", ul_ue_ambr);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UESecurityCapabilities ::= SEQUENCE
SRSASN_CODE ue_security_cap_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(nr_encyption_algorithms.pack(bref));
  HANDLE_CODE(nr_integrity_protection_algorithms.pack(bref));
  HANDLE_CODE(e_utra_encyption_algorithms.pack(bref));
  HANDLE_CODE(e_utra_integrity_protection_algorithms.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_security_cap_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(nr_encyption_algorithms.unpack(bref));
  HANDLE_CODE(nr_integrity_protection_algorithms.unpack(bref));
  HANDLE_CODE(e_utra_encyption_algorithms.unpack(bref));
  HANDLE_CODE(e_utra_integrity_protection_algorithms.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_security_cap_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nr-EncyptionAlgorithms", nr_encyption_algorithms.to_string());
  j.write_str("nr-IntegrityProtectionAlgorithms", nr_integrity_protection_algorithms.to_string());
  j.write_str("e-utra-EncyptionAlgorithms", e_utra_encyption_algorithms.to_string());
  j.write_str("e-utra-IntegrityProtectionAlgorithms", e_utra_integrity_protection_algorithms.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// VehicleUE ::= ENUMERATED
const char* vehicle_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "vehicle_ue_e");
}

// IABNodeIndication ::= ENUMERATED
const char* iab_node_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "iab_node_ind_e");
}

// LTEV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE ltev2x_services_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ltev2x_services_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ltev2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE nr_v2x_services_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_v2x_services_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_v2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NoPDUSessionIndication ::= ENUMERATED
const char* no_pdu_session_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "no_pdu_session_ind_e");
}

// PC5QoSParameters ::= SEQUENCE
SRSASN_CODE pc5_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, pc5_qos_flow_list, 1, 2064, true));
  if (pc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(pack_integer(bref, pc5_link_aggr_bit_rates, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(pc5_qos_flow_list, bref, 1, 2064, true));
  if (pc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(unpack_integer(pc5_link_aggr_bit_rates, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("pc5QoSFlowList");
  for (const auto& e1 : pc5_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pc5_link_aggr_bit_rates_present) {
    j.write_int("pc5LinkAggregateBitRates", pc5_link_aggr_bit_rates);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QMCConfigInfo ::= SEQUENCE
SRSASN_CODE q_mcc_onfig_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ue_app_layer_meas_info_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE q_mcc_onfig_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ue_app_layer_meas_info_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void q_mcc_onfig_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("uEAppLayerMeasInfoList");
  for (const auto& e1 : ue_app_layer_meas_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TimeSynchronizationAssistanceInformation ::= SEQUENCE
SRSASN_CODE time_sync_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(uu_time_sync_error_budget_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(time_distribution_ind.pack(bref));
  if (uu_time_sync_error_budget_present) {
    HANDLE_CODE(pack_integer(bref, uu_time_sync_error_budget, (uint32_t)0u, (uint32_t)1000000u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE time_sync_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(uu_time_sync_error_budget_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(time_distribution_ind.unpack(bref));
  if (uu_time_sync_error_budget_present) {
    HANDLE_CODE(unpack_integer(uu_time_sync_error_budget, bref, (uint32_t)0u, (uint32_t)1000000u, true, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void time_sync_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("timeDistributionIndication", time_distribution_ind.to_string());
  if (uu_time_sync_error_budget_present) {
    j.write_int("uuTimeSynchronizationErrorBudget", uu_time_sync_error_budget);
  }
  if (ie_ext_present) {
    j.write_fieldname("ie-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* time_sync_assist_info_s::time_distribution_ind_opts::to_string() const
{
  static const char* names[] = {"enabled", "disabled"};
  return convert_enum_idx(names, 2, value, "time_sync_assist_info_s::time_distribution_ind_e_");
}

template struct asn1::protocol_ext_field_s<trace_activation_ext_ies_o>;

SRSASN_CODE trace_activation_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  nof_ies += mdt_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)226, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }
  if (mdt_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)224, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mdt_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 226: {
        trace_collection_entity_uri_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.unpack(bref));
        break;
      }
      case 224: {
        mdt_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mdt_cfg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void trace_activation_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (trace_collection_entity_uri_present) {
    j.write_int("id", 226);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", trace_collection_entity_uri.to_string());
  }
  if (mdt_cfg_present) {
    j.write_int("id", 224);
    j.write_str("criticality", "ignore");
    mdt_cfg.to_json(j);
  }
  j.end_obj();
}

// TraceActivation ::= SEQUENCE
SRSASN_CODE trace_activation_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ng_ran_trace_id.pack(bref));
  HANDLE_CODE(interfaces_to_trace.pack(bref));
  HANDLE_CODE(trace_depth.pack(bref));
  HANDLE_CODE(trace_coll_address.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ng_ran_trace_id.unpack(bref));
  HANDLE_CODE(interfaces_to_trace.unpack(bref));
  HANDLE_CODE(trace_depth.unpack(bref));
  HANDLE_CODE(trace_coll_address.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trace_activation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ng-ran-TraceID", ng_ran_trace_id.to_string());
  j.write_str("interfaces-to-trace", interfaces_to_trace.to_string());
  j.write_str("trace-depth", trace_depth.to_string());
  j.write_str("trace-coll-address", trace_coll_address.to_string());
  if (ie_ext_present) {
    j.write_fieldname("ie-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UEHistoryInformationFromTheUE ::= CHOICE
void ue_history_info_from_the_ue_c::destroy_()
{
  switch (type_) {
    case types::nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_history_info_from_the_ue_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
}
ue_history_info_from_the_ue_c::ue_history_info_from_the_ue_c(const ue_history_info_from_the_ue_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
}
ue_history_info_from_the_ue_c& ue_history_info_from_the_ue_c::operator=(const ue_history_info_from_the_ue_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_history_info_from_the_ue_c::set_nr()
{
  set(types::nr);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>& ue_history_info_from_the_ue_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
}
void ue_history_info_from_the_ue_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_str("nR", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_history_info_from_the_ue_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_history_info_from_the_ue_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_history_info_from_the_ue_c::types_opts::to_string() const
{
  static const char* names[] = {"nR", "choice-extension"};
  return convert_enum_idx(names, 2, value, "ue_history_info_from_the_ue_c::types");
}

// QoSFlowsAdmitted-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flows_admitted_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flows_admitted_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e qos_flows_admitted_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flows_admitted_item_ext_ies_o::ext_c qos_flows_admitted_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flows_admitted_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flows_admitted_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flows_admitted_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_admitted_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flows_admitted_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flows_admitted_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flows_admitted_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "qos_flows_admitted_item_ext_ies_o::ext_c::types");
}

// SecondarydataForwardingInfoFromTarget-Item ::= SEQUENCE
SRSASN_CODE secondarydata_forwarding_info_from_target_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(secondarydata_forwarding_info_from_target.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondarydata_forwarding_info_from_target_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(secondarydata_forwarding_info_from_target.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void secondarydata_forwarding_info_from_target_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("secondarydataForwardingInfoFromTarget");
  secondarydata_forwarding_info_from_target.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsAdmitted-Item ::= SEQUENCE
SRSASN_CODE qos_flows_admitted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qfi, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_admitted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(qfi, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_admitted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qfi", qfi);
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// QoSFlowwithCause-Item ::= SEQUENCE
SRSASN_CODE qos_flowwith_cause_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, qfi, (uint8_t)0u, (uint8_t)63u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flowwith_cause_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(qfi, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flowwith_cause_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qfi", qfi);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// MBS-DataForwardingResponseInfofromTarget-Item ::= SEQUENCE
SRSASN_CODE mbs_data_forwarding_resp_infofrom_target_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl.pack(bref));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_data_forwarding_resp_infofrom_target_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl.unpack(bref));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_data_forwarding_resp_infofrom_target_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("dlForwardingUPTNL");
  dl_forwarding_up_tnl.to_json(j);
  if (mrb_progress_info_present) {
    j.write_fieldname("mRB-ProgressInformation");
    mrb_progress_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceAdmittedInfo-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_admitted_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {109};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_admitted_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 109 == id;
}
crit_e pdu_session_res_admitted_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 109) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_admitted_info_ext_ies_o::ext_c pdu_session_res_admitted_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 109) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_admitted_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 109) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_admitted_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("SecondarydataForwardingInfoFromTarget-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE pdu_session_res_admitted_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 3, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_admitted_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 3, true));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_admitted_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondarydataForwardingInfoFromTarget-List"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_admitted_info_ext_ies_o::ext_c::types");
}

// PDUSessionResourceAdmittedInfo ::= SEQUENCE
SRSASN_CODE pdu_session_res_admitted_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_ng_u_tnl_info_unchanged_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_not_admitted_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(data_forwarding_info_from_target_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (dl_ng_u_tnl_info_unchanged_present) {
    HANDLE_CODE(dl_ng_u_tnl_info_unchanged.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_admitted_list, 1, 64, true));
  if (qos_flows_not_admitted_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_not_admitted_list, 1, 64, true));
  }
  if (data_forwarding_info_from_target_present) {
    HANDLE_CODE(data_forwarding_info_from_target.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_admitted_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_ng_u_tnl_info_unchanged_present, 1));
  bool qos_flows_not_admitted_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_not_admitted_list_present, 1));
  HANDLE_CODE(bref.unpack(data_forwarding_info_from_target_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dl_ng_u_tnl_info_unchanged_present) {
    HANDLE_CODE(dl_ng_u_tnl_info_unchanged.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_admitted_list, bref, 1, 64, true));
  if (qos_flows_not_admitted_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_not_admitted_list, bref, 1, 64, true));
  }
  if (data_forwarding_info_from_target_present) {
    HANDLE_CODE(data_forwarding_info_from_target.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_admitted_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_ng_u_tnl_info_unchanged_present) {
    j.write_str("dL-NG-U-TNL-Information-Unchanged", "true");
  }
  j.start_array("qosFlowsAdmitted-List");
  for (const auto& e1 : qos_flows_admitted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (qos_flows_not_admitted_list.size() > 0) {
    j.start_array("qosFlowsNotAdmitted-List");
    for (const auto& e1 : qos_flows_not_admitted_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_info_from_target_present) {
    j.write_fieldname("dataForwardingInfoFromTarget");
    data_forwarding_info_from_target.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* pdu_session_res_admitted_info_s::dl_ng_u_tnl_info_unchanged_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_admitted_info_s::dl_ng_u_tnl_info_unchanged_e_");
}

// MBS-SessionInformationResponse-Item ::= SEQUENCE
SRSASN_CODE mbs_session_info_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_data_forwarding_resp_infofrom_target.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_data_forwarding_resp_infofrom_target.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_data_forwarding_resp_infofrom_target, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_info_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mbs_data_forwarding_resp_infofrom_target_present;
  HANDLE_CODE(bref.unpack(mbs_data_forwarding_resp_infofrom_target_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_data_forwarding_resp_infofrom_target_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_data_forwarding_resp_infofrom_target, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_info_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-Session-ID");
  mbs_session_id.to_json(j);
  if (mbs_data_forwarding_resp_infofrom_target.size() > 0) {
    j.start_array("mBS-DataForwardingResponseInfofromTarget");
    for (const auto& e1 : mbs_data_forwarding_resp_infofrom_target) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourcesAdmitted-Item ::= SEQUENCE
SRSASN_CODE pdu_session_res_admitted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_admitted_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_admitted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_admitted_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_admitted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pduSessionId", pdu_session_id);
  j.write_fieldname("pduSessionResourceAdmittedInfo");
  pdu_session_res_admitted_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourcesNotAdmitted-Item ::= SEQUENCE
SRSASN_CODE pdu_session_res_not_admitted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_not_admitted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_not_admitted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pduSessionId", pdu_session_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UEContextKeptIndicator ::= ENUMERATED
const char* ue_context_kept_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "ue_context_kept_ind_e");
}

// I-RNTI ::= CHOICE
void i_rnti_c::destroy_()
{
  switch (type_) {
    case types::i_rnti_full:
      c.destroy<fixed_bitstring<40, false, true>>();
      break;
    case types::i_rnti_short:
      c.destroy<fixed_bitstring<24, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<i_rnti_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void i_rnti_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::i_rnti_full:
      c.init<fixed_bitstring<40, false, true>>();
      break;
    case types::i_rnti_short:
      c.init<fixed_bitstring<24, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<i_rnti_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "i_rnti_c");
  }
}
i_rnti_c::i_rnti_c(const i_rnti_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::i_rnti_full:
      c.init(other.c.get<fixed_bitstring<40, false, true>>());
      break;
    case types::i_rnti_short:
      c.init(other.c.get<fixed_bitstring<24, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<i_rnti_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "i_rnti_c");
  }
}
i_rnti_c& i_rnti_c::operator=(const i_rnti_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::i_rnti_full:
      c.set(other.c.get<fixed_bitstring<40, false, true>>());
      break;
    case types::i_rnti_short:
      c.set(other.c.get<fixed_bitstring<24, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<i_rnti_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "i_rnti_c");
  }

  return *this;
}
fixed_bitstring<40, false, true>& i_rnti_c::set_i_rnti_full()
{
  set(types::i_rnti_full);
  return c.get<fixed_bitstring<40, false, true>>();
}
fixed_bitstring<24, false, true>& i_rnti_c::set_i_rnti_short()
{
  set(types::i_rnti_short);
  return c.get<fixed_bitstring<24, false, true>>();
}
protocol_ie_single_container_s<i_rnti_ext_ies_o>& i_rnti_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<i_rnti_ext_ies_o>>();
}
void i_rnti_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::i_rnti_full:
      j.write_str("i-RNTI-full", c.get<fixed_bitstring<40, false, true>>().to_string());
      break;
    case types::i_rnti_short:
      j.write_str("i-RNTI-short", c.get<fixed_bitstring<24, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<i_rnti_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "i_rnti_c");
  }
  j.end_obj();
}
SRSASN_CODE i_rnti_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::i_rnti_full:
      HANDLE_CODE((c.get<fixed_bitstring<40, false, true>>().pack(bref)));
      break;
    case types::i_rnti_short:
      HANDLE_CODE((c.get<fixed_bitstring<24, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<i_rnti_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "i_rnti_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE i_rnti_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::i_rnti_full:
      HANDLE_CODE((c.get<fixed_bitstring<40, false, true>>().unpack(bref)));
      break;
    case types::i_rnti_short:
      HANDLE_CODE((c.get<fixed_bitstring<24, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<i_rnti_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "i_rnti_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* i_rnti_c::types_opts::to_string() const
{
  static const char* names[] = {"i-RNTI-full", "i-RNTI-short", "choice-extension"};
  return convert_enum_idx(names, 3, value, "i_rnti_c::types");
}

// IABTNLAddressToRemove-Item ::= SEQUENCE
SRSASN_CODE iab_tnl_address_to_rem_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(iab_tnl_address.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_address_to_rem_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(iab_tnl_address.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_address_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABTNLAddress");
  iab_tnl_address.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// IABTNLAddressesRequested ::= SEQUENCE
SRSASN_CODE iab_tnl_addresses_requested_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_all_traffic_present, 1));
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_f1_c_present, 1));
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_f1_u_present, 1));
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_no_nf1_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (tnl_addresses_or_prefixes_requested_all_traffic_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_all_traffic, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_c_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_f1_c, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_u_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_f1_u, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_no_nf1_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_no_nf1, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_addresses_requested_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_all_traffic_present, 1));
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_f1_c_present, 1));
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_f1_u_present, 1));
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_no_nf1_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (tnl_addresses_or_prefixes_requested_all_traffic_present) {
    HANDLE_CODE(unpack_integer(
        tnl_addresses_or_prefixes_requested_all_traffic, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_c_present) {
    HANDLE_CODE(
        unpack_integer(tnl_addresses_or_prefixes_requested_f1_c, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_u_present) {
    HANDLE_CODE(
        unpack_integer(tnl_addresses_or_prefixes_requested_f1_u, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_no_nf1_present) {
    HANDLE_CODE(
        unpack_integer(tnl_addresses_or_prefixes_requested_no_nf1, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_addresses_requested_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (tnl_addresses_or_prefixes_requested_all_traffic_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedAllTraffic", tnl_addresses_or_prefixes_requested_all_traffic);
  }
  if (tnl_addresses_or_prefixes_requested_f1_c_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedF1-C", tnl_addresses_or_prefixes_requested_f1_c);
  }
  if (tnl_addresses_or_prefixes_requested_f1_u_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedF1-U", tnl_addresses_or_prefixes_requested_f1_u);
  }
  if (tnl_addresses_or_prefixes_requested_no_nf1_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedNoNF1", tnl_addresses_or_prefixes_requested_no_nf1);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABIPv6RequestType ::= CHOICE
void iab_ip_v6_request_type_c::destroy_()
{
  switch (type_) {
    case types::ip_v6_address:
      c.destroy<iab_tnl_addresses_requested_s>();
      break;
    case types::ip_v6_prefix:
      c.destroy<iab_tnl_addresses_requested_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void iab_ip_v6_request_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ip_v6_address:
      c.init<iab_tnl_addresses_requested_s>();
      break;
    case types::ip_v6_prefix:
      c.init<iab_tnl_addresses_requested_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }
}
iab_ip_v6_request_type_c::iab_ip_v6_request_type_c(const iab_ip_v6_request_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ip_v6_address:
      c.init(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::ip_v6_prefix:
      c.init(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }
}
iab_ip_v6_request_type_c& iab_ip_v6_request_type_c::operator=(const iab_ip_v6_request_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ip_v6_address:
      c.set(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::ip_v6_prefix:
      c.set(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }

  return *this;
}
iab_tnl_addresses_requested_s& iab_ip_v6_request_type_c::set_ip_v6_address()
{
  set(types::ip_v6_address);
  return c.get<iab_tnl_addresses_requested_s>();
}
iab_tnl_addresses_requested_s& iab_ip_v6_request_type_c::set_ip_v6_prefix()
{
  set(types::ip_v6_prefix);
  return c.get<iab_tnl_addresses_requested_s>();
}
protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>& iab_ip_v6_request_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
}
void iab_ip_v6_request_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ip_v6_address:
      j.write_fieldname("iPv6Address");
      c.get<iab_tnl_addresses_requested_s>().to_json(j);
      break;
    case types::ip_v6_prefix:
      j.write_fieldname("iPv6Prefix");
      c.get<iab_tnl_addresses_requested_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_ip_v6_request_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ip_v6_address:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().pack(bref));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_ip_v6_request_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ip_v6_address:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().unpack(bref));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* iab_ip_v6_request_type_c::types_opts::to_string() const
{
  static const char* names[] = {"iPv6Address", "iPv6Prefix", "choice-extension"};
  return convert_enum_idx(names, 3, value, "iab_ip_v6_request_type_c::types");
}

// IAB-TNL-Address-Request ::= SEQUENCE
SRSASN_CODE iab_tnl_address_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(iab_ip_v4_addresses_requested.pack(bref));
  HANDLE_CODE(iab_ip_v6_request_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, iab_tnl_address_to_rem_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_address_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(iab_ip_v4_addresses_requested.unpack(bref));
  HANDLE_CODE(iab_ip_v6_request_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(iab_tnl_address_to_rem_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_address_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABIPv4AddressesRequested");
  iab_ip_v4_addresses_requested.to_json(j);
  j.write_fieldname("iABIPv6RequestType");
  iab_ip_v6_request_type.to_json(j);
  j.start_array("iABTNLAddressToRemove-List");
  for (const auto& e1 : iab_tnl_address_to_rem_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABTNLAddressUsage ::= ENUMERATED
const char* iab_tnl_address_usage_opts::to_string() const
{
  static const char* names[] = {"f1-c", "f1-u", "non-f1", "all"};
  return convert_enum_idx(names, 4, value, "iab_tnl_address_usage_e");
}

// IABAllocatedTNLAddress-Item ::= SEQUENCE
SRSASN_CODE iab_allocated_tnl_address_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(iab_tnl_address_usage_present, 1));
  HANDLE_CODE(bref.pack(associated_donor_du_address_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.pack(bref));
  if (iab_tnl_address_usage_present) {
    HANDLE_CODE(iab_tnl_address_usage.pack(bref));
  }
  if (associated_donor_du_address_present) {
    HANDLE_CODE(associated_donor_du_address.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_allocated_tnl_address_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(iab_tnl_address_usage_present, 1));
  HANDLE_CODE(bref.unpack(associated_donor_du_address_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.unpack(bref));
  if (iab_tnl_address_usage_present) {
    HANDLE_CODE(iab_tnl_address_usage.unpack(bref));
  }
  if (associated_donor_du_address_present) {
    HANDLE_CODE(associated_donor_du_address.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_allocated_tnl_address_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABTNLAddress");
  iab_tnl_address.to_json(j);
  if (iab_tnl_address_usage_present) {
    j.write_str("iABTNLAddressUsage", iab_tnl_address_usage.to_string());
  }
  if (associated_donor_du_address_present) {
    j.write_str("associatedDonorDUAddress", associated_donor_du_address.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-TNL-Address-Response ::= SEQUENCE
SRSASN_CODE iab_tnl_address_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, iab_allocated_tnl_address_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_address_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(iab_allocated_tnl_address_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_address_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("iABAllocatedTNLAddress-List");
  for (const auto& e1 : iab_allocated_tnl_address_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABTNLAddress-Item ::= SEQUENCE
SRSASN_CODE iab_tnl_address_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_address_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_address_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABTNLAddress");
  iab_tnl_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NonUPTrafficType ::= ENUMERATED
const char* non_up_traffic_type_opts::to_string() const
{
  static const char* names[] = {"ueassociatedf1ap", "nonueassociatedf1ap", "nonf1"};
  return convert_enum_idx(names, 3, value, "non_up_traffic_type_e");
}

// NonUPTraffic ::= CHOICE
void non_up_traffic_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void non_up_traffic_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::non_up_traffic_type:
      break;
    case types::ctrl_plane_traffic_type:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_up_traffic_c");
  }
}
non_up_traffic_c::non_up_traffic_c(const non_up_traffic_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::non_up_traffic_type:
      c.init(other.c.get<non_up_traffic_type_e>());
      break;
    case types::ctrl_plane_traffic_type:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_up_traffic_c");
  }
}
non_up_traffic_c& non_up_traffic_c::operator=(const non_up_traffic_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::non_up_traffic_type:
      c.set(other.c.get<non_up_traffic_type_e>());
      break;
    case types::ctrl_plane_traffic_type:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_up_traffic_c");
  }

  return *this;
}
non_up_traffic_type_e& non_up_traffic_c::set_non_up_traffic_type()
{
  set(types::non_up_traffic_type);
  return c.get<non_up_traffic_type_e>();
}
uint8_t& non_up_traffic_c::set_ctrl_plane_traffic_type()
{
  set(types::ctrl_plane_traffic_type);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<non_up_traffic_ext_ies_o>& non_up_traffic_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>();
}
void non_up_traffic_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::non_up_traffic_type:
      j.write_str("nonUPTrafficType", c.get<non_up_traffic_type_e>().to_string());
      break;
    case types::ctrl_plane_traffic_type:
      j.write_int("controlPlaneTrafficType", c.get<uint8_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "non_up_traffic_c");
  }
  j.end_obj();
}
SRSASN_CODE non_up_traffic_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::non_up_traffic_type:
      HANDLE_CODE(c.get<non_up_traffic_type_e>().pack(bref));
      break;
    case types::ctrl_plane_traffic_type:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)3u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "non_up_traffic_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE non_up_traffic_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::non_up_traffic_type:
      HANDLE_CODE(c.get<non_up_traffic_type_e>().unpack(bref));
      break;
    case types::ctrl_plane_traffic_type:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)3u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<non_up_traffic_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "non_up_traffic_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* non_up_traffic_c::types_opts::to_string() const
{
  static const char* names[] = {"nonUPTrafficType", "controlPlaneTrafficType", "choice-extension"};
  return convert_enum_idx(names, 3, value, "non_up_traffic_c::types");
}

// TrafficToBeRelease-Item ::= SEQUENCE
SRSASN_CODE traffic_to_be_release_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bh_info_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, traffic_idx, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (bh_info_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, bh_info_list, 1, 1024, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE traffic_to_be_release_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool bh_info_list_present;
  HANDLE_CODE(bref.unpack(bh_info_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(traffic_idx, bref, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (bh_info_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(bh_info_list, bref, 1, 1024, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void traffic_to_be_release_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("trafficIndex", traffic_idx);
  if (bh_info_list.size() > 0) {
    j.start_array("bHInfoList");
    for (const auto& e1 : bh_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// AllTrafficIndication ::= ENUMERATED
const char* all_traffic_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "all_traffic_ind_e");
}

// TrafficProfile ::= CHOICE
void traffic_profile_c::destroy_()
{
  switch (type_) {
    case types::up_traffic:
      c.destroy<qos_flow_level_qos_params_s>();
      break;
    case types::non_up_traffic:
      c.destroy<non_up_traffic_c>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void traffic_profile_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::up_traffic:
      c.init<qos_flow_level_qos_params_s>();
      break;
    case types::non_up_traffic:
      c.init<non_up_traffic_c>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_profile_c");
  }
}
traffic_profile_c::traffic_profile_c(const traffic_profile_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::up_traffic:
      c.init(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::non_up_traffic:
      c.init(other.c.get<non_up_traffic_c>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_profile_c");
  }
}
traffic_profile_c& traffic_profile_c::operator=(const traffic_profile_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::up_traffic:
      c.set(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::non_up_traffic:
      c.set(other.c.get<non_up_traffic_c>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_profile_c");
  }

  return *this;
}
qos_flow_level_qos_params_s& traffic_profile_c::set_up_traffic()
{
  set(types::up_traffic);
  return c.get<qos_flow_level_qos_params_s>();
}
non_up_traffic_c& traffic_profile_c::set_non_up_traffic()
{
  set(types::non_up_traffic);
  return c.get<non_up_traffic_c>();
}
protocol_ie_single_container_s<traffic_profile_ext_ies_o>& traffic_profile_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>();
}
void traffic_profile_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::up_traffic:
      j.write_fieldname("uPTraffic");
      c.get<qos_flow_level_qos_params_s>().to_json(j);
      break;
    case types::non_up_traffic:
      j.write_fieldname("nonUPTraffic");
      c.get<non_up_traffic_c>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "traffic_profile_c");
  }
  j.end_obj();
}
SRSASN_CODE traffic_profile_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::up_traffic:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().pack(bref));
      break;
    case types::non_up_traffic:
      HANDLE_CODE(c.get<non_up_traffic_c>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "traffic_profile_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE traffic_profile_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::up_traffic:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().unpack(bref));
      break;
    case types::non_up_traffic:
      HANDLE_CODE(c.get<non_up_traffic_c>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<traffic_profile_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "traffic_profile_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* traffic_profile_c::types_opts::to_string() const
{
  static const char* names[] = {"uPTraffic", "nonUPTraffic", "choice-extension"};
  return convert_enum_idx(names, 3, value, "traffic_profile_c::types");
}

// TrafficReleaseType ::= CHOICE
void traffic_release_type_c::destroy_()
{
  switch (type_) {
    case types::partial_release:
      c.destroy<traffic_to_be_release_list_l>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void traffic_release_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::full_release:
      break;
    case types::partial_release:
      c.init<traffic_to_be_release_list_l>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_release_type_c");
  }
}
traffic_release_type_c::traffic_release_type_c(const traffic_release_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::full_release:
      c.init(other.c.get<all_traffic_ind_e>());
      break;
    case types::partial_release:
      c.init(other.c.get<traffic_to_be_release_list_l>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_release_type_c");
  }
}
traffic_release_type_c& traffic_release_type_c::operator=(const traffic_release_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::full_release:
      c.set(other.c.get<all_traffic_ind_e>());
      break;
    case types::partial_release:
      c.set(other.c.get<traffic_to_be_release_list_l>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_release_type_c");
  }

  return *this;
}
all_traffic_ind_e& traffic_release_type_c::set_full_release()
{
  set(types::full_release);
  return c.get<all_traffic_ind_e>();
}
traffic_to_be_release_list_l& traffic_release_type_c::set_partial_release()
{
  set(types::partial_release);
  return c.get<traffic_to_be_release_list_l>();
}
protocol_ie_single_container_s<traffic_release_type_ext_ies_o>& traffic_release_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>();
}
void traffic_release_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::full_release:
      j.write_str("fullRelease", "true");
      break;
    case types::partial_release:
      j.start_array("partialRelease");
      for (const auto& e1 : c.get<traffic_to_be_release_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "traffic_release_type_c");
  }
  j.end_obj();
}
SRSASN_CODE traffic_release_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::full_release:
      HANDLE_CODE(c.get<all_traffic_ind_e>().pack(bref));
      break;
    case types::partial_release:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<traffic_to_be_release_list_l>(), 1, 1024, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "traffic_release_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE traffic_release_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::full_release:
      HANDLE_CODE(c.get<all_traffic_ind_e>().unpack(bref));
      break;
    case types::partial_release:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<traffic_to_be_release_list_l>(), bref, 1, 1024, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<traffic_release_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "traffic_release_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* traffic_release_type_c::types_opts::to_string() const
{
  static const char* names[] = {"fullRelease", "partialRelease", "choice-extension"};
  return convert_enum_idx(names, 3, value, "traffic_release_type_c::types");
}

// TrafficToBeReleaseInformation ::= SEQUENCE
SRSASN_CODE traffic_to_be_release_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(release_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE traffic_to_be_release_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(release_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void traffic_to_be_release_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("releaseType");
  release_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("ie-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ULNonF1Terminating-BHInfo ::= SEQUENCE
SRSASN_CODE ul_non_f1_terminating_bh_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(egress_bap_routing_id.pack(bref));
  HANDLE_CODE(egress_bh_rlc_ch_id.pack(bref));
  HANDLE_CODE(nexthop_bap_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_f1_terminating_bh_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(egress_bap_routing_id.unpack(bref));
  HANDLE_CODE(egress_bh_rlc_ch_id.unpack(bref));
  HANDLE_CODE(nexthop_bap_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_non_f1_terminating_bh_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("egressBAPRoutingID");
  egress_bap_routing_id.to_json(j);
  j.write_str("egressBHRLCCHID", egress_bh_rlc_ch_id.to_string());
  j.write_str("nexthopBAPAddress", nexthop_bap_address.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NonF1TerminatingBHInformation-Item ::= SEQUENCE
SRSASN_CODE non_f1_terminating_bh_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_non_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.pack(ul_non_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, bh_info_idx, (uint16_t)1u, (uint16_t)1024u, false, true));
  if (dl_non_f1_terminating_bh_info_present) {
    HANDLE_CODE(dl_non_f1_terminating_bh_info.pack(bref));
  }
  if (ul_non_f1_terminating_bh_info_present) {
    HANDLE_CODE(ul_non_f1_terminating_bh_info.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_f1_terminating_bh_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_non_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_non_f1_terminating_bh_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(bh_info_idx, bref, (uint16_t)1u, (uint16_t)1024u, false, true));
  if (dl_non_f1_terminating_bh_info_present) {
    HANDLE_CODE(dl_non_f1_terminating_bh_info.unpack(bref));
  }
  if (ul_non_f1_terminating_bh_info_present) {
    HANDLE_CODE(ul_non_f1_terminating_bh_info.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_f1_terminating_bh_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("bHInfoIndex", bh_info_idx);
  if (dl_non_f1_terminating_bh_info_present) {
    j.write_fieldname("dlNon-F1TerminatingBHInfo");
    dl_non_f1_terminating_bh_info.to_json(j);
  }
  if (ul_non_f1_terminating_bh_info_present) {
    j.write_fieldname("ulNon-F1TerminatingBHInfo");
    ul_non_f1_terminating_bh_info.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// Non-F1-TerminatingTopologyBHInformation ::= SEQUENCE
SRSASN_CODE non_f1_terminating_topology_bh_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bap_ctrl_pdu_rlc_ch_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, non_f1_terminating_bh_info_list, 1, 1024, true));
  if (bap_ctrl_pdu_rlc_ch_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, bap_ctrl_pdu_rlc_ch_list, 1, 2, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_f1_terminating_topology_bh_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool bap_ctrl_pdu_rlc_ch_list_present;
  HANDLE_CODE(bref.unpack(bap_ctrl_pdu_rlc_ch_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(non_f1_terminating_bh_info_list, bref, 1, 1024, true));
  if (bap_ctrl_pdu_rlc_ch_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(bap_ctrl_pdu_rlc_ch_list, bref, 1, 2, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_f1_terminating_topology_bh_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("nonF1TerminatingBHInformation-List");
  for (const auto& e1 : non_f1_terminating_bh_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (bap_ctrl_pdu_rlc_ch_list.size() > 0) {
    j.start_array("bAPControlPDURLCCH-List");
    for (const auto& e1 : bap_ctrl_pdu_rlc_ch_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsToBeSetup-List-Modified-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {212, 213};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {212, 213};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 212:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c
qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 212:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    case 213:
      ret.set(ext_c::types::redundant_qos_flow_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 212:
      return presence_e::optional;
    case 213:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c = tsc_traffic_characteristics_s{};
      break;
    case types::redundant_qos_flow_ind:
      c = redundant_qos_flow_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c");
  }
}
tsc_traffic_characteristics_s&
qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
redundant_qos_flow_ind_e&
qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::redundant_qos_flow_ind()
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
const tsc_traffic_characteristics_s&
qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const redundant_qos_flow_ind_e&
qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::redundant_qos_flow_ind() const
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
void qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    case types::redundant_qos_flow_ind:
      j.write_str("RedundantQoSFlowIndicator", c.get<redundant_qos_flow_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics", "RedundantQoSFlowIndicator"};
  return convert_enum_idx(
      names, 2, value, "qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o::ext_c::types");
}

// QoSFlowsToBeSetup-List-Setup-SNterminated-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {212, 213};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {212, 213};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 212:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c
qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 212:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    case 213:
      ret.set(ext_c::types::redundant_qos_flow_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 212:
      return presence_e::optional;
    case 213:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c = tsc_traffic_characteristics_s{};
      break;
    case types::redundant_qos_flow_ind:
      c = redundant_qos_flow_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c");
  }
}
tsc_traffic_characteristics_s&
qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
redundant_qos_flow_ind_e& qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::redundant_qos_flow_ind()
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
const tsc_traffic_characteristics_s&
qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const redundant_qos_flow_ind_e&
qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::redundant_qos_flow_ind() const
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
void qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    case types::redundant_qos_flow_ind:
      j.write_str("RedundantQoSFlowIndicator", c.get<redundant_qos_flow_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics", "RedundantQoSFlowIndicator"};
  return convert_enum_idx(
      names, 2, value, "qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o::ext_c::types");
}

// VolumeTimedReport-Item ::= SEQUENCE
SRSASN_CODE volume_timed_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(start_time_stamp.pack(bref));
  HANDLE_CODE(end_time_stamp.pack(bref));
  HANDLE_CODE(pack_integer(bref, usage_count_ul, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(pack_integer(bref, usage_count_dl, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE volume_timed_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(start_time_stamp.unpack(bref));
  HANDLE_CODE(end_time_stamp.unpack(bref));
  HANDLE_CODE(unpack_integer(usage_count_ul, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(unpack_integer(usage_count_dl, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void volume_timed_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("startTimeStamp", start_time_stamp.to_string());
  j.write_str("endTimeStamp", end_time_stamp.to_string());
  j.write_int("usageCountUL", usage_count_ul);
  j.write_int("usageCountDL", usage_count_dl);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DefaultDRB-Allowed ::= ENUMERATED
const char* default_drb_allowed_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "default_drb_allowed_e");
}

// NonGBRResources-Offered ::= ENUMERATED
const char* non_gbr_res_offered_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "non_gbr_res_offered_e");
}

template struct asn1::protocol_ext_field_s<qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_o>;

SRSASN_CODE qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  nof_ies += redundant_qos_flow_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)212, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }
  if (redundant_qos_flow_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)213, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_qos_flow_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 212: {
        tsc_traffic_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.unpack(bref));
        break;
      }
      case 213: {
        redundant_qos_flow_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_qos_flow_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flows_to_be_setup_list_modified_sn_terminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_traffic_characteristics_present) {
    j.write_int("id", 212);
    j.write_str("criticality", "ignore");
    tsc_traffic_characteristics.to_json(j);
  }
  if (redundant_qos_flow_ind_present) {
    j.write_int("id", 213);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_qos_flow_ind.to_string());
  }
  j.end_obj();
}

// QoSFlowsToBeSetup-List-Modified-SNterminated-Item ::= SEQUENCE
SRSASN_CODE qos_flows_to_be_setup_list_modified_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_level_qos_params_present, 1));
  HANDLE_CODE(bref.pack(offered_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qfi, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_level_qos_params_present) {
    HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  }
  if (offered_gbr_qos_flow_info_present) {
    HANDLE_CODE(offered_gbr_qos_flow_info.pack(bref));
  }
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_list_modified_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_flow_level_qos_params_present, 1));
  HANDLE_CODE(bref.unpack(offered_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qfi, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_level_qos_params_present) {
    HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  }
  if (offered_gbr_qos_flow_info_present) {
    HANDLE_CODE(offered_gbr_qos_flow_info.unpack(bref));
  }
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_to_be_setup_list_modified_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qfi", qfi);
  if (qos_flow_level_qos_params_present) {
    j.write_fieldname("qosFlowLevelQoSParameters");
    qos_flow_level_qos_params.to_json(j);
  }
  if (offered_gbr_qos_flow_info_present) {
    j.write_fieldname("offeredGBRQoSFlowInfo");
    offered_gbr_qos_flow_info.to_json(j);
  }
  if (qos_flow_map_ind_present) {
    j.write_str("qosFlowMappingIndication", qos_flow_map_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_o>;

SRSASN_CODE qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  nof_ies += redundant_qos_flow_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)212, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }
  if (redundant_qos_flow_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)213, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_qos_flow_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 212: {
        tsc_traffic_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.unpack(bref));
        break;
      }
      case 213: {
        redundant_qos_flow_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_qos_flow_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flows_to_be_setup_list_setup_sn_terminated_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_traffic_characteristics_present) {
    j.write_int("id", 212);
    j.write_str("criticality", "ignore");
    tsc_traffic_characteristics.to_json(j);
  }
  if (redundant_qos_flow_ind_present) {
    j.write_int("id", 213);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_qos_flow_ind.to_string());
  }
  j.end_obj();
}

// QoSFlowsToBeSetup-List-Setup-SNterminated-Item ::= SEQUENCE
SRSASN_CODE qos_flows_to_be_setup_list_setup_sn_terminated_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(offered_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qfi, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  if (offered_gbr_qos_flow_info_present) {
    HANDLE_CODE(offered_gbr_qos_flow_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_to_be_setup_list_setup_sn_terminated_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(offered_gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qfi, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  if (offered_gbr_qos_flow_info_present) {
    HANDLE_CODE(offered_gbr_qos_flow_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_to_be_setup_list_setup_sn_terminated_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qfi", qfi);
  j.write_fieldname("qosFlowLevelQoSParameters");
  qos_flow_level_qos_params.to_json(j);
  if (offered_gbr_qos_flow_info_present) {
    j.write_fieldname("offeredGBRQoSFlowInfo");
    offered_gbr_qos_flow_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecurityResult ::= SEQUENCE
SRSASN_CODE security_result_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_result.pack(bref));
  HANDLE_CODE(confidentiality_protection_result.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_result_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_result.unpack(bref));
  HANDLE_CODE(confidentiality_protection_result.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void security_result_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("integrityProtectionResult", integrity_protection_result.to_string());
  j.write_str("confidentialityProtectionResult", confidentiality_protection_result.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* security_result_s::integrity_protection_result_opts::to_string() const
{
  static const char* names[] = {"performed", "not-performed"};
  return convert_enum_idx(names, 2, value, "security_result_s::integrity_protection_result_e_");
}

const char* security_result_s::confidentiality_protection_result_opts::to_string() const
{
  static const char* names[] = {"performed", "not-performed"};
  return convert_enum_idx(names, 2, value, "security_result_s::confidentiality_protection_result_e_");
}

// SplitSessionIndicator ::= ENUMERATED
const char* split_session_ind_opts::to_string() const
{
  static const char* names[] = {"split"};
  return convert_enum_idx(names, 1, value, "split_session_ind_e");
}

// PDUSession-List-withDataForwardingRequest-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_list_with_data_forwarding_request_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {7};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_list_with_data_forwarding_request_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 7 == id;
}
crit_e pdu_session_list_with_data_forwarding_request_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 7) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_list_with_data_forwarding_request_item_ext_ies_o::ext_c
pdu_session_list_with_data_forwarding_request_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 7) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_list_with_data_forwarding_request_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 7) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_list_with_data_forwarding_request_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("Cause");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_list_with_data_forwarding_request_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_list_with_data_forwarding_request_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_list_with_data_forwarding_request_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause"};
  return convert_enum_idx(
      names, 1, value, "pdu_session_list_with_data_forwarding_request_item_ext_ies_o::ext_c::types");
}

// PDUSessionResourceModificationInfo-SNterminated-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_mod_info_sn_terminated_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {127, 132, 146, 207, 211, 258};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_mod_info_sn_terminated_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {127, 132, 146, 207, 211, 258};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_mod_info_sn_terminated_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 127:
      return crit_e::ignore;
    case 132:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    case 211:
      return crit_e::ignore;
    case 258:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c
pdu_session_res_mod_info_sn_terminated_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 127:
      ret.set(ext_c::types::pdu_session_common_network_instance);
      break;
    case 132:
      ret.set(ext_c::types::default_drb_allowed);
      break;
    case 146:
      ret.set(ext_c::types::non_gbr_res_offered);
      break;
    case 207:
      ret.set(ext_c::types::redundant_ul_ng_u_tnl_at_up_f);
      break;
    case 211:
      ret.set(ext_c::types::redundant_common_network_instance);
      break;
    case 258:
      ret.set(ext_c::types::security_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_mod_info_sn_terminated_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 127:
      return presence_e::optional;
    case 132:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    case 211:
      return presence_e::optional;
    case 258:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::pdu_session_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::default_drb_allowed:
      c = default_drb_allowed_e{};
      break;
    case types::non_gbr_res_offered:
      c = non_gbr_res_offered_e{};
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      c = up_transport_layer_info_c{};
      break;
    case types::redundant_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::security_ind:
      c = security_ind_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c");
  }
}
unbounded_octstring<true>&
pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::pdu_session_common_network_instance()
{
  assert_choice_type(types::pdu_session_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
default_drb_allowed_e& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::default_drb_allowed()
{
  assert_choice_type(types::default_drb_allowed, type_, "Extension");
  return c.get<default_drb_allowed_e>();
}
non_gbr_res_offered_e& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::non_gbr_res_offered()
{
  assert_choice_type(types::non_gbr_res_offered, type_, "Extension");
  return c.get<non_gbr_res_offered_e>();
}
up_transport_layer_info_c& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::redundant_ul_ng_u_tnl_at_up_f()
{
  assert_choice_type(types::redundant_ul_ng_u_tnl_at_up_f, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
unbounded_octstring<true>& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::redundant_common_network_instance()
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
security_ind_s& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::security_ind()
{
  assert_choice_type(types::security_ind, type_, "Extension");
  return c.get<security_ind_s>();
}
const unbounded_octstring<true>&
pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::pdu_session_common_network_instance() const
{
  assert_choice_type(types::pdu_session_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const default_drb_allowed_e& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::default_drb_allowed() const
{
  assert_choice_type(types::default_drb_allowed, type_, "Extension");
  return c.get<default_drb_allowed_e>();
}
const non_gbr_res_offered_e& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::non_gbr_res_offered() const
{
  assert_choice_type(types::non_gbr_res_offered, type_, "Extension");
  return c.get<non_gbr_res_offered_e>();
}
const up_transport_layer_info_c&
pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::redundant_ul_ng_u_tnl_at_up_f() const
{
  assert_choice_type(types::redundant_ul_ng_u_tnl_at_up_f, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const unbounded_octstring<true>&
pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::redundant_common_network_instance() const
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const security_ind_s& pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::security_ind() const
{
  assert_choice_type(types::security_ind, type_, "Extension");
  return c.get<security_ind_s>();
}
void pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdu_session_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::default_drb_allowed:
      j.write_str("DefaultDRB-Allowed", c.get<default_drb_allowed_e>().to_string());
      break;
    case types::non_gbr_res_offered:
      j.write_str("NonGBRResources-Offered", "true");
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::security_ind:
      j.write_fieldname("SecurityIndication");
      c.get<security_ind_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::default_drb_allowed:
      HANDLE_CODE(c.get<default_drb_allowed_e>().pack(bref));
      break;
    case types::non_gbr_res_offered:
      HANDLE_CODE(c.get<non_gbr_res_offered_e>().pack(bref));
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::default_drb_allowed:
      HANDLE_CODE(c.get<default_drb_allowed_e>().unpack(bref));
      break;
    case types::non_gbr_res_offered:
      HANDLE_CODE(c.get<non_gbr_res_offered_e>().unpack(bref));
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING",
                                "DefaultDRB-Allowed",
                                "NonGBRResources-Offered",
                                "UPTransportLayerInformation",
                                "OCTET STRING",
                                "SecurityIndication"};
  return convert_enum_idx(names, 6, value, "pdu_session_res_mod_info_sn_terminated_ext_ies_o::ext_c::types");
}

// PDUSessionResourceModificationResponseInfo-SNterminated-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {133, 214, 115};
  return map_enum_number(names, 3, idx, "id");
}
bool pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {133, 214, 115};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 133:
      return crit_e::reject;
    case 214:
      return crit_e::ignore;
    case 115:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c
pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 133:
      ret.set(ext_c::types::drb_ids_takenintouse);
      break;
    case 214:
      ret.set(ext_c::types::redundant_dl_ng_u_tnl_at_ng_ran);
      break;
    case 115:
      ret.set(ext_c::types::security_result);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 133:
      return presence_e::optional;
    case 214:
      return presence_e::optional;
    case 115:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::drb_ids_takenintouse:
      c = drb_list_l{};
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      c = up_transport_layer_info_c{};
      break;
    case types::security_result:
      c = security_result_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c");
  }
}
drb_list_l& pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::drb_ids_takenintouse()
{
  assert_choice_type(types::drb_ids_takenintouse, type_, "Extension");
  return c.get<drb_list_l>();
}
up_transport_layer_info_c&
pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::redundant_dl_ng_u_tnl_at_ng_ran()
{
  assert_choice_type(types::redundant_dl_ng_u_tnl_at_ng_ran, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
security_result_s& pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::security_result()
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
const drb_list_l& pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::drb_ids_takenintouse() const
{
  assert_choice_type(types::drb_ids_takenintouse, type_, "Extension");
  return c.get<drb_list_l>();
}
const up_transport_layer_info_c&
pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::redundant_dl_ng_u_tnl_at_ng_ran() const
{
  assert_choice_type(types::redundant_dl_ng_u_tnl_at_ng_ran, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const security_result_s& pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::security_result() const
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
void pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::drb_ids_takenintouse:
      j.start_array("DRB-List");
      for (const auto& e1 : c.get<drb_list_l>()) {
        j.write_int(e1);
      }
      j.end_array();
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::security_result:
      j.write_fieldname("SecurityResult");
      c.get<security_result_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::drb_ids_takenintouse:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<drb_list_l>(), 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::drb_ids_takenintouse:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<drb_list_l>(), bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DRB-List", "UPTransportLayerInformation", "SecurityResult"};
  return convert_enum_idx(names, 3, value, "pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSetupInfo-SNterminated-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_info_sn_terminated_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {115, 127, 132, 134, 146, 207, 211, 217};
  return map_enum_number(names, 8, idx, "id");
}
bool pdu_session_res_setup_info_sn_terminated_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {115, 127, 132, 134, 146, 207, 211, 217};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_info_sn_terminated_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 115:
      return crit_e::reject;
    case 127:
      return crit_e::ignore;
    case 132:
      return crit_e::ignore;
    case 134:
      return crit_e::reject;
    case 146:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    case 211:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c
pdu_session_res_setup_info_sn_terminated_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 115:
      ret.set(ext_c::types::security_result);
      break;
    case 127:
      ret.set(ext_c::types::pdu_session_common_network_instance);
      break;
    case 132:
      ret.set(ext_c::types::default_drb_allowed);
      break;
    case 134:
      ret.set(ext_c::types::split_session_ind);
      break;
    case 146:
      ret.set(ext_c::types::non_gbr_res_offered);
      break;
    case 207:
      ret.set(ext_c::types::redundant_ul_ng_u_tnl_at_up_f);
      break;
    case 211:
      ret.set(ext_c::types::redundant_common_network_instance);
      break;
    case 217:
      ret.set(ext_c::types::redundant_pdu_session_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_info_sn_terminated_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 115:
      return presence_e::optional;
    case 127:
      return presence_e::optional;
    case 132:
      return presence_e::optional;
    case 134:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    case 211:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::security_result:
      c = security_result_s{};
      break;
    case types::pdu_session_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::default_drb_allowed:
      c = default_drb_allowed_e{};
      break;
    case types::split_session_ind:
      c = split_session_ind_e{};
      break;
    case types::non_gbr_res_offered:
      c = non_gbr_res_offered_e{};
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      c = up_transport_layer_info_c{};
      break;
    case types::redundant_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::redundant_pdu_session_info:
      c = redundant_pdu_session_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c");
  }
}
security_result_s& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::security_result()
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
unbounded_octstring<true>&
pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::pdu_session_common_network_instance()
{
  assert_choice_type(types::pdu_session_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
default_drb_allowed_e& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::default_drb_allowed()
{
  assert_choice_type(types::default_drb_allowed, type_, "Extension");
  return c.get<default_drb_allowed_e>();
}
split_session_ind_e& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::split_session_ind()
{
  assert_choice_type(types::split_session_ind, type_, "Extension");
  return c.get<split_session_ind_e>();
}
non_gbr_res_offered_e& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::non_gbr_res_offered()
{
  assert_choice_type(types::non_gbr_res_offered, type_, "Extension");
  return c.get<non_gbr_res_offered_e>();
}
up_transport_layer_info_c& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::redundant_ul_ng_u_tnl_at_up_f()
{
  assert_choice_type(types::redundant_ul_ng_u_tnl_at_up_f, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
unbounded_octstring<true>&
pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::redundant_common_network_instance()
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
redundant_pdu_session_info_s& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::redundant_pdu_session_info()
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const security_result_s& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::security_result() const
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
const unbounded_octstring<true>&
pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::pdu_session_common_network_instance() const
{
  assert_choice_type(types::pdu_session_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const default_drb_allowed_e& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::default_drb_allowed() const
{
  assert_choice_type(types::default_drb_allowed, type_, "Extension");
  return c.get<default_drb_allowed_e>();
}
const split_session_ind_e& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::split_session_ind() const
{
  assert_choice_type(types::split_session_ind, type_, "Extension");
  return c.get<split_session_ind_e>();
}
const non_gbr_res_offered_e& pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::non_gbr_res_offered() const
{
  assert_choice_type(types::non_gbr_res_offered, type_, "Extension");
  return c.get<non_gbr_res_offered_e>();
}
const up_transport_layer_info_c&
pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::redundant_ul_ng_u_tnl_at_up_f() const
{
  assert_choice_type(types::redundant_ul_ng_u_tnl_at_up_f, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const unbounded_octstring<true>&
pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::redundant_common_network_instance() const
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const redundant_pdu_session_info_s&
pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::redundant_pdu_session_info() const
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
void pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::security_result:
      j.write_fieldname("SecurityResult");
      c.get<security_result_s>().to_json(j);
      break;
    case types::pdu_session_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::default_drb_allowed:
      j.write_str("DefaultDRB-Allowed", c.get<default_drb_allowed_e>().to_string());
      break;
    case types::split_session_ind:
      j.write_str("SplitSessionIndicator", "split");
      break;
    case types::non_gbr_res_offered:
      j.write_str("NonGBRResources-Offered", "true");
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::redundant_pdu_session_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().pack(bref));
      break;
    case types::pdu_session_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::default_drb_allowed:
      HANDLE_CODE(c.get<default_drb_allowed_e>().pack(bref));
      break;
    case types::split_session_ind:
      HANDLE_CODE(c.get<split_session_ind_e>().pack(bref));
      break;
    case types::non_gbr_res_offered:
      HANDLE_CODE(c.get<non_gbr_res_offered_e>().pack(bref));
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().unpack(bref));
      break;
    case types::pdu_session_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::default_drb_allowed:
      HANDLE_CODE(c.get<default_drb_allowed_e>().unpack(bref));
      break;
    case types::split_session_ind:
      HANDLE_CODE(c.get<split_session_ind_e>().unpack(bref));
      break;
    case types::non_gbr_res_offered:
      HANDLE_CODE(c.get<non_gbr_res_offered_e>().unpack(bref));
      break;
    case types::redundant_ul_ng_u_tnl_at_up_f:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecurityResult",
                                "OCTET STRING",
                                "DefaultDRB-Allowed",
                                "SplitSessionIndicator",
                                "NonGBRResources-Offered",
                                "UPTransportLayerInformation",
                                "OCTET STRING",
                                "RedundantPDUSessionInformation"};
  return convert_enum_idx(names, 8, value, "pdu_session_res_setup_info_sn_terminated_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSetupResponseInfo-MNterminated-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {124};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 124 == id;
}
crit_e pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 124) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::ext_c
pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 124) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 124) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("DRB-List-withCause");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 32, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 32, true));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DRB-List-withCause"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_setup_resp_info_m_nterminated_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSetupResponseInfo-SNterminated-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {133, 214, 218};
  return map_enum_number(names, 3, idx, "id");
}
bool pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {133, 214, 218};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 133:
      return crit_e::reject;
    case 214:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c
pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 133:
      ret.set(ext_c::types::drb_ids_takenintouse);
      break;
    case 214:
      ret.set(ext_c::types::redundant_dl_ng_u_tnl_at_ng_ran);
      break;
    case 218:
      ret.set(ext_c::types::used_r_sn_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 133:
      return presence_e::optional;
    case 214:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::drb_ids_takenintouse:
      c = drb_list_l{};
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      c = up_transport_layer_info_c{};
      break;
    case types::used_r_sn_info:
      c = redundant_pdu_session_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c");
  }
}
drb_list_l& pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::drb_ids_takenintouse()
{
  assert_choice_type(types::drb_ids_takenintouse, type_, "Extension");
  return c.get<drb_list_l>();
}
up_transport_layer_info_c&
pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::redundant_dl_ng_u_tnl_at_ng_ran()
{
  assert_choice_type(types::redundant_dl_ng_u_tnl_at_ng_ran, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
redundant_pdu_session_info_s& pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::used_r_sn_info()
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const drb_list_l& pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::drb_ids_takenintouse() const
{
  assert_choice_type(types::drb_ids_takenintouse, type_, "Extension");
  return c.get<drb_list_l>();
}
const up_transport_layer_info_c&
pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::redundant_dl_ng_u_tnl_at_ng_ran() const
{
  assert_choice_type(types::redundant_dl_ng_u_tnl_at_ng_ran, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const redundant_pdu_session_info_s&
pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::used_r_sn_info() const
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
void pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::drb_ids_takenintouse:
      j.start_array("DRB-List");
      for (const auto& e1 : c.get<drb_list_l>()) {
        j.write_int(e1);
      }
      j.end_array();
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::used_r_sn_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::drb_ids_takenintouse:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<drb_list_l>(), 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::drb_ids_takenintouse:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<drb_list_l>(), bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
      break;
    case types::redundant_dl_ng_u_tnl_at_ng_ran:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DRB-List", "UPTransportLayerInformation", "RedundantPDUSessionInformation"};
  return convert_enum_idx(names, 3, value, "pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o::ext_c::types");
}

// QoSFlowNotificationControlIndicationInfo-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t qos_flow_notif_ctrl_ind_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_notif_ctrl_ind_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e qos_flow_notif_ctrl_ind_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c qos_flow_notif_ctrl_ind_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_notif_ctrl_ind_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "qos_flow_notif_ctrl_ind_info_ext_ies_o::ext_c::types");
}

// QoSFlowsUsageReport-Item ::= SEQUENCE
SRSASN_CODE qos_flows_usage_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(rat_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_timed_report_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_usage_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(rat_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_timed_report_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_usage_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_str("rATType", rat_type.to_string());
  j.start_array("qoSFlowsTimedReportList");
  for (const auto& e1 : qos_flows_timed_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* qos_flows_usage_report_item_s::rat_type_opts::to_string() const
{
  static const char* names[] = {"nr", "eutra", "nr-unlicensed", "e-utra-unlicensed"};
  return convert_enum_idx(names, 4, value, "qos_flows_usage_report_item_s::rat_type_e_");
}

// MobilityParametersInformation ::= SEQUENCE
SRSASN_CODE mob_params_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, ho_trigger_change, (int8_t)-20, (int8_t)20, false, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_params_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(ho_trigger_change, bref, (int8_t)-20, (int8_t)20, false, true));

  return SRSASN_SUCCESS;
}
void mob_params_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("handoverTriggerChange", ho_trigger_change);
  j.end_obj();
}

// NR-CoordinationAssistanceInfo ::= ENUMERATED
const char* nr_coordination_assist_info_opts::to_string() const
{
  static const char* names[] = {"coordination-not-required"};
  return convert_enum_idx(names, 1, value, "nr_coordination_assist_info_e");
}

// PDUSession-List-withCause-Item ::= SEQUENCE
SRSASN_CODE pdu_session_list_with_cause_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_list_with_cause_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_list_with_cause_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pduSessionId", pdu_session_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// PDUSession-List-withDataForwardingFromTarget-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {133};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 133 == id;
}
crit_e pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 133) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::ext_c
pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 133) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 133) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("DRB-List");
  for (const auto& e1 : c) {
    j.write_int(e1);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  return SRSASN_SUCCESS;
}

const char* pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DRB-List"};
  return convert_enum_idx(
      names, 1, value, "pdu_session_list_with_data_forwarding_from_target_item_ext_ies_o::ext_c::types");
}

// PDUSession-List-withDataForwardingRequest-Item ::= SEQUENCE
SRSASN_CODE pdu_session_list_with_data_forwarding_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dataforwarding_infofrom_source_present, 1));
  HANDLE_CODE(bref.pack(drb_to_be_released_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (dataforwarding_infofrom_source_present) {
    HANDLE_CODE(dataforwarding_infofrom_source.pack(bref));
  }
  if (drb_to_be_released_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drb_to_be_released_list, 1, 32, true));
  }
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_list_with_data_forwarding_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dataforwarding_infofrom_source_present, 1));
  bool drb_to_be_released_list_present;
  HANDLE_CODE(bref.unpack(drb_to_be_released_list_present, 1));
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (dataforwarding_infofrom_source_present) {
    HANDLE_CODE(dataforwarding_infofrom_source.unpack(bref));
  }
  if (drb_to_be_released_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drb_to_be_released_list, bref, 1, 32, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_list_with_data_forwarding_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pduSessionId", pdu_session_id);
  if (dataforwarding_infofrom_source_present) {
    j.write_fieldname("dataforwardingInfofromSource");
    dataforwarding_infofrom_source.to_json(j);
  }
  if (drb_to_be_released_list.size() > 0) {
    j.start_array("dRBtoBeReleasedList");
    for (const auto& e1 : drb_to_be_released_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// PDUSessionResourceModConfirmInfo-SNterminated-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {133};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 133 == id;
}
crit_e pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 133) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::ext_c
pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 133) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 133) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("DRB-List");
  for (const auto& e1 : c) {
    j.write_int(e1);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DRB-List"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_mod_confirm_info_sn_terminated_ext_ies_o::ext_c::types");
}

// PDUSessionResourceModificationInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drbs_to_be_setup.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_modified.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_released.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pdu_session_type.pack(bref));
  if (drbs_to_be_setup.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_setup, 1, 32, true));
  }
  if (drbs_to_be_modified.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_modified, 1, 32, true));
  }
  if (drbs_to_be_released.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_released, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool drbs_to_be_setup_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_setup_present, 1));
  bool drbs_to_be_modified_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_modified_present, 1));
  bool drbs_to_be_released_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_released_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pdu_session_type.unpack(bref));
  if (drbs_to_be_setup_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_setup, bref, 1, 32, true));
  }
  if (drbs_to_be_modified_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_modified, bref, 1, 32, true));
  }
  if (drbs_to_be_released_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_released, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pduSessionType", pdu_session_type.to_string());
  if (drbs_to_be_setup.size() > 0) {
    j.start_array("dRBsToBeSetup");
    for (const auto& e1 : drbs_to_be_setup) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_modified.size() > 0) {
    j.start_array("dRBsToBeModified");
    for (const auto& e1 : drbs_to_be_modified) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_released.size() > 0) {
    j.start_array("dRBsToBeReleased");
    for (const auto& e1 : drbs_to_be_released) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<pdu_session_res_mod_info_sn_terminated_ext_ies_o>;

SRSASN_CODE pdu_session_res_mod_info_sn_terminated_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += pdu_session_common_network_instance_present ? 1 : 0;
  nof_ies += default_drb_allowed_present ? 1 : 0;
  nof_ies += non_gbr_res_offered_present ? 1 : 0;
  nof_ies += redundant_ul_ng_u_tnl_at_up_f_present ? 1 : 0;
  nof_ies += redundant_common_network_instance_present ? 1 : 0;
  nof_ies += security_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (pdu_session_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)127, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdu_session_common_network_instance.pack(bref));
  }
  if (default_drb_allowed_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)132, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(default_drb_allowed.pack(bref));
  }
  if (non_gbr_res_offered_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(non_gbr_res_offered.pack(bref));
  }
  if (redundant_ul_ng_u_tnl_at_up_f_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ng_u_tnl_at_up_f.pack(bref));
  }
  if (redundant_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)211, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_common_network_instance.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)258, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_info_sn_terminated_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 127: {
        pdu_session_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_common_network_instance.unpack(bref));
        break;
      }
      case 132: {
        default_drb_allowed_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_drb_allowed.unpack(bref));
        break;
      }
      case 146: {
        non_gbr_res_offered_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(non_gbr_res_offered.unpack(bref));
        break;
      }
      case 207: {
        redundant_ul_ng_u_tnl_at_up_f_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ng_u_tnl_at_up_f.unpack(bref));
        break;
      }
      case 211: {
        redundant_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_common_network_instance.unpack(bref));
        break;
      }
      case 258: {
        security_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_info_sn_terminated_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_common_network_instance_present) {
    j.write_int("id", 127);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", pdu_session_common_network_instance.to_string());
  }
  if (default_drb_allowed_present) {
    j.write_int("id", 132);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", default_drb_allowed.to_string());
  }
  if (non_gbr_res_offered_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (redundant_ul_ng_u_tnl_at_up_f_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    redundant_ul_ng_u_tnl_at_up_f.to_json(j);
  }
  if (redundant_common_network_instance_present) {
    j.write_int("id", 211);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_common_network_instance.to_string());
  }
  if (security_ind_present) {
    j.write_int("id", 258);
    j.write_str("criticality", "ignore");
    security_ind.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModificationInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_ng_u_tnl_at_up_f_present, 1));
  HANDLE_CODE(bref.pack(pdu_session_network_instance_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_to_be_setup_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_to_be_modified_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flows_to_be_released_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_modified_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_released.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ul_ng_u_tnl_at_up_f_present) {
    HANDLE_CODE(ul_ng_u_tnl_at_up_f.pack(bref));
  }
  if (pdu_session_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, pdu_session_network_instance, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (qos_flows_to_be_setup_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_setup_list, 1, 64, true));
  }
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.pack(bref));
  }
  if (qos_flows_to_be_modified_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_modified_list, 1, 64, true));
  }
  if (qos_flows_to_be_released_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_released_list, 1, 64, true));
  }
  if (drbs_to_be_modified_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_modified_list, 1, 32, true));
  }
  if (drbs_to_be_released.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_released, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_ng_u_tnl_at_up_f_present, 1));
  HANDLE_CODE(bref.unpack(pdu_session_network_instance_present, 1));
  bool qos_flows_to_be_setup_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_to_be_setup_list_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfofrom_source_present, 1));
  bool qos_flows_to_be_modified_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_to_be_modified_list_present, 1));
  bool qos_flows_to_be_released_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_to_be_released_list_present, 1));
  bool drbs_to_be_modified_list_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_modified_list_present, 1));
  bool drbs_to_be_released_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_released_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ul_ng_u_tnl_at_up_f_present) {
    HANDLE_CODE(ul_ng_u_tnl_at_up_f.unpack(bref));
  }
  if (pdu_session_network_instance_present) {
    HANDLE_CODE(unpack_integer(pdu_session_network_instance, bref, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (qos_flows_to_be_setup_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_setup_list, bref, 1, 64, true));
  }
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.unpack(bref));
  }
  if (qos_flows_to_be_modified_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_modified_list, bref, 1, 64, true));
  }
  if (qos_flows_to_be_released_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_released_list, bref, 1, 64, true));
  }
  if (drbs_to_be_modified_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_modified_list, bref, 1, 32, true));
  }
  if (drbs_to_be_released_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_released, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_ng_u_tnl_at_up_f_present) {
    j.write_fieldname("uL-NG-U-TNLatUPF");
    ul_ng_u_tnl_at_up_f.to_json(j);
  }
  if (pdu_session_network_instance_present) {
    j.write_int("pduSessionNetworkInstance", pdu_session_network_instance);
  }
  if (qos_flows_to_be_setup_list.size() > 0) {
    j.start_array("qosFlowsToBeSetup-List");
    for (const auto& e1 : qos_flows_to_be_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dataforwardinginfofrom_source_present) {
    j.write_fieldname("dataforwardinginfofromSource");
    dataforwardinginfofrom_source.to_json(j);
  }
  if (qos_flows_to_be_modified_list.size() > 0) {
    j.start_array("qosFlowsToBeModified-List");
    for (const auto& e1 : qos_flows_to_be_modified_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flows_to_be_released_list.size() > 0) {
    j.start_array("qoSFlowsToBeReleased-List");
    for (const auto& e1 : qos_flows_to_be_released_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_modified_list.size() > 0) {
    j.start_array("drbsToBeModifiedList");
    for (const auto& e1 : drbs_to_be_modified_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_released.size() > 0) {
    j.start_array("dRBsToBeReleased");
    for (const auto& e1 : drbs_to_be_released) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModificationResponseInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_resp_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drbs_released_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_not_admitted_setup_modify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_admitted_list, 1, 32, true));
  if (drbs_released_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_released_list, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  }
  if (drbs_not_admitted_setup_modify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_not_admitted_setup_modify_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_resp_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool drbs_released_list_present;
  HANDLE_CODE(bref.unpack(drbs_released_list_present, 1));
  bool drbs_not_admitted_setup_modify_list_present;
  HANDLE_CODE(bref.unpack(drbs_not_admitted_setup_modify_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(drbs_admitted_list, bref, 1, 32, true));
  if (drbs_released_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_released_list, bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  }
  if (drbs_not_admitted_setup_modify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_not_admitted_setup_modify_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_resp_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dRBsAdmittedList");
  for (const auto& e1 : drbs_admitted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (drbs_released_list.size() > 0) {
    j.start_array("dRBsReleasedList");
    for (const auto& e1 : drbs_released_list) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (drbs_not_admitted_setup_modify_list.size() > 0) {
    j.start_array("dRBsNotAdmittedSetupModifyList");
    for (const auto& e1 : drbs_not_admitted_setup_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<pdu_session_res_mod_resp_info_sn_terminated_ext_ies_o>;

SRSASN_CODE pdu_session_res_mod_resp_info_sn_terminated_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += drb_ids_takenintouse_present ? 1 : 0;
  nof_ies += redundant_dl_ng_u_tnl_at_ng_ran_present ? 1 : 0;
  nof_ies += security_result_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (drb_ids_takenintouse_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)133, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, drb_ids_takenintouse, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  }
  if (redundant_dl_ng_u_tnl_at_ng_ran_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)214, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_ng_u_tnl_at_ng_ran.pack(bref));
  }
  if (security_result_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)115, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_result.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_resp_info_sn_terminated_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 133: {
        drb_ids_takenintouse_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(drb_ids_takenintouse, bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
        break;
      }
      case 214: {
        redundant_dl_ng_u_tnl_at_ng_ran_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ng_u_tnl_at_ng_ran.unpack(bref));
        break;
      }
      case 115: {
        security_result_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_result.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_resp_info_sn_terminated_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (drb_ids_takenintouse_present) {
    j.write_int("id", 133);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : drb_ids_takenintouse) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (redundant_dl_ng_u_tnl_at_ng_ran_present) {
    j.write_int("id", 214);
    j.write_str("criticality", "ignore");
    redundant_dl_ng_u_tnl_at_ng_ran.to_json(j);
  }
  if (security_result_present) {
    j.write_int("id", 115);
    j.write_str("criticality", "ignore");
    security_result.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModificationResponseInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_resp_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_ng_u_tnl_at_ng_ran_present, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_setup.size() > 0, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfo_target_present, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_modified.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_released.size() > 0, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_not_admitted_tb_added.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flows_released.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dl_ng_u_tnl_at_ng_ran_present) {
    HANDLE_CODE(dl_ng_u_tnl_at_ng_ran.pack(bref));
  }
  if (drbs_to_be_setup.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_setup, 1, 32, true));
  }
  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.pack(bref));
  }
  if (drbs_to_be_modified.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_modified, 1, 32, true));
  }
  if (drbs_to_be_released.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_released, 1, 32, true));
  }
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.pack(bref));
  }
  if (qos_flows_not_admitted_tb_added.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_not_admitted_tb_added, 1, 64, true));
  }
  if (qos_flows_released.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_released, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_resp_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_ng_u_tnl_at_ng_ran_present, 1));
  bool drbs_to_be_setup_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_setup_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfo_target_present, 1));
  bool drbs_to_be_modified_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_modified_present, 1));
  bool drbs_to_be_released_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_released_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfofrom_source_present, 1));
  bool qos_flows_not_admitted_tb_added_present;
  HANDLE_CODE(bref.unpack(qos_flows_not_admitted_tb_added_present, 1));
  bool qos_flows_released_present;
  HANDLE_CODE(bref.unpack(qos_flows_released_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dl_ng_u_tnl_at_ng_ran_present) {
    HANDLE_CODE(dl_ng_u_tnl_at_ng_ran.unpack(bref));
  }
  if (drbs_to_be_setup_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_setup, bref, 1, 32, true));
  }
  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.unpack(bref));
  }
  if (drbs_to_be_modified_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_modified, bref, 1, 32, true));
  }
  if (drbs_to_be_released_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_released, bref, 1, 32, true));
  }
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.unpack(bref));
  }
  if (qos_flows_not_admitted_tb_added_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_not_admitted_tb_added, bref, 1, 64, true));
  }
  if (qos_flows_released_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_released, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_resp_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_ng_u_tnl_at_ng_ran_present) {
    j.write_fieldname("dL-NG-U-TNLatNG-RAN");
    dl_ng_u_tnl_at_ng_ran.to_json(j);
  }
  if (drbs_to_be_setup.size() > 0) {
    j.start_array("dRBsToBeSetup");
    for (const auto& e1 : drbs_to_be_setup) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dataforwardinginfo_target_present) {
    j.write_fieldname("dataforwardinginfoTarget");
    dataforwardinginfo_target.to_json(j);
  }
  if (drbs_to_be_modified.size() > 0) {
    j.start_array("dRBsToBeModified");
    for (const auto& e1 : drbs_to_be_modified) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_released.size() > 0) {
    j.start_array("dRBsToBeReleased");
    for (const auto& e1 : drbs_to_be_released) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dataforwardinginfofrom_source_present) {
    j.write_fieldname("dataforwardinginfofromSource");
    dataforwardinginfofrom_source.to_json(j);
  }
  if (qos_flows_not_admitted_tb_added.size() > 0) {
    j.start_array("qosFlowsNotAdmittedTBAdded");
    for (const auto& e1 : qos_flows_not_admitted_tb_added) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flows_released.size() > 0) {
    j.start_array("qosFlowsReleased");
    for (const auto& e1 : qos_flows_released) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pdu_session_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_setup, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pdu_session_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_setup, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pduSessionType", pdu_session_type.to_string());
  j.start_array("dRBsToBeSetup");
  for (const auto& e1 : drbs_to_be_setup) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<pdu_session_res_setup_info_sn_terminated_ext_ies_o>;

SRSASN_CODE pdu_session_res_setup_info_sn_terminated_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += security_result_present ? 1 : 0;
  nof_ies += pdu_session_common_network_instance_present ? 1 : 0;
  nof_ies += default_drb_allowed_present ? 1 : 0;
  nof_ies += split_session_ind_present ? 1 : 0;
  nof_ies += non_gbr_res_offered_present ? 1 : 0;
  nof_ies += redundant_ul_ng_u_tnl_at_up_f_present ? 1 : 0;
  nof_ies += redundant_common_network_instance_present ? 1 : 0;
  nof_ies += redundant_pdu_session_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (security_result_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)115, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_result.pack(bref));
  }
  if (pdu_session_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)127, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdu_session_common_network_instance.pack(bref));
  }
  if (default_drb_allowed_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)132, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(default_drb_allowed.pack(bref));
  }
  if (split_session_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)134, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(split_session_ind.pack(bref));
  }
  if (non_gbr_res_offered_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(non_gbr_res_offered.pack(bref));
  }
  if (redundant_ul_ng_u_tnl_at_up_f_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ng_u_tnl_at_up_f.pack(bref));
  }
  if (redundant_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)211, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_common_network_instance.pack(bref));
  }
  if (redundant_pdu_session_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_pdu_session_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_info_sn_terminated_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 115: {
        security_result_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_result.unpack(bref));
        break;
      }
      case 127: {
        pdu_session_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_common_network_instance.unpack(bref));
        break;
      }
      case 132: {
        default_drb_allowed_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_drb_allowed.unpack(bref));
        break;
      }
      case 134: {
        split_session_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(split_session_ind.unpack(bref));
        break;
      }
      case 146: {
        non_gbr_res_offered_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(non_gbr_res_offered.unpack(bref));
        break;
      }
      case 207: {
        redundant_ul_ng_u_tnl_at_up_f_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ng_u_tnl_at_up_f.unpack(bref));
        break;
      }
      case 211: {
        redundant_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_common_network_instance.unpack(bref));
        break;
      }
      case 217: {
        redundant_pdu_session_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_pdu_session_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_info_sn_terminated_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (security_result_present) {
    j.write_int("id", 115);
    j.write_str("criticality", "reject");
    security_result.to_json(j);
  }
  if (pdu_session_common_network_instance_present) {
    j.write_int("id", 127);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", pdu_session_common_network_instance.to_string());
  }
  if (default_drb_allowed_present) {
    j.write_int("id", 132);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", default_drb_allowed.to_string());
  }
  if (split_session_ind_present) {
    j.write_int("id", 134);
    j.write_str("criticality", "reject");
    j.write_str("Extension", "split");
  }
  if (non_gbr_res_offered_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (redundant_ul_ng_u_tnl_at_up_f_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    redundant_ul_ng_u_tnl_at_up_f.to_json(j);
  }
  if (redundant_common_network_instance_present) {
    j.write_int("id", 211);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_common_network_instance.to_string());
  }
  if (redundant_pdu_session_info_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    redundant_pdu_session_info.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_network_instance_present, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.pack(security_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_ng_u_tnl_at_up_f.pack(bref));
  HANDLE_CODE(pdu_session_type.pack(bref));
  if (pdu_session_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, pdu_session_network_instance, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_setup_list, 1, 64, true));
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdu_session_network_instance_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.unpack(security_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_ng_u_tnl_at_up_f.unpack(bref));
  HANDLE_CODE(pdu_session_type.unpack(bref));
  if (pdu_session_network_instance_present) {
    HANDLE_CODE(unpack_integer(pdu_session_network_instance, bref, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_setup_list, bref, 1, 64, true));
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.unpack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-NG-U-TNLatUPF");
  ul_ng_u_tnl_at_up_f.to_json(j);
  j.write_str("pduSessionType", pdu_session_type.to_string());
  if (pdu_session_network_instance_present) {
    j.write_int("pduSessionNetworkInstance", pdu_session_network_instance);
  }
  j.start_array("qosFlowsToBeSetup-List");
  for (const auto& e1 : qos_flows_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (dataforwardinginfofrom_source_present) {
    j.write_fieldname("dataforwardinginfofromSource");
    dataforwardinginfofrom_source.to_json(j);
  }
  if (security_ind_present) {
    j.write_fieldname("securityIndication");
    security_ind.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupResponseInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_resp_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_admitted_list, 1, 32, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(drbs_admitted_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dRBsAdmittedList");
  for (const auto& e1 : drbs_admitted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<pdu_session_res_setup_resp_info_sn_terminated_ext_ies_o>;

SRSASN_CODE pdu_session_res_setup_resp_info_sn_terminated_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += drb_ids_takenintouse_present ? 1 : 0;
  nof_ies += redundant_dl_ng_u_tnl_at_ng_ran_present ? 1 : 0;
  nof_ies += used_r_sn_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (drb_ids_takenintouse_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)133, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, drb_ids_takenintouse, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  }
  if (redundant_dl_ng_u_tnl_at_ng_ran_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)214, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_ng_u_tnl_at_ng_ran.pack(bref));
  }
  if (used_r_sn_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(used_r_sn_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_info_sn_terminated_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 133: {
        drb_ids_takenintouse_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(drb_ids_takenintouse, bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
        break;
      }
      case 214: {
        redundant_dl_ng_u_tnl_at_ng_ran_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ng_u_tnl_at_ng_ran.unpack(bref));
        break;
      }
      case 218: {
        used_r_sn_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(used_r_sn_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_info_sn_terminated_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (drb_ids_takenintouse_present) {
    j.write_int("id", 133);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : drb_ids_takenintouse) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (redundant_dl_ng_u_tnl_at_ng_ran_present) {
    j.write_int("id", 214);
    j.write_str("criticality", "ignore");
    redundant_dl_ng_u_tnl_at_ng_ran.to_json(j);
  }
  if (used_r_sn_info_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    used_r_sn_info.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupResponseInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_resp_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drbs_to_be_setup.size() > 0, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfo_target_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_not_admitted_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(security_result_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_ng_u_tnl_at_ng_ran.pack(bref));
  if (drbs_to_be_setup.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_setup, 1, 32, true));
  }
  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.pack(bref));
  }
  if (qos_flows_not_admitted_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_not_admitted_list, 1, 64, true));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool drbs_to_be_setup_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_setup_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfo_target_present, 1));
  bool qos_flows_not_admitted_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_not_admitted_list_present, 1));
  HANDLE_CODE(bref.unpack(security_result_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_ng_u_tnl_at_ng_ran.unpack(bref));
  if (drbs_to_be_setup_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_setup, bref, 1, 32, true));
  }
  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.unpack(bref));
  }
  if (qos_flows_not_admitted_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_not_admitted_list, bref, 1, 64, true));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-NG-U-TNLatNG-RAN");
  dl_ng_u_tnl_at_ng_ran.to_json(j);
  if (drbs_to_be_setup.size() > 0) {
    j.start_array("dRBsToBeSetup");
    for (const auto& e1 : drbs_to_be_setup) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dataforwardinginfo_target_present) {
    j.write_fieldname("dataforwardinginfoTarget");
    dataforwardinginfo_target.to_json(j);
  }
  if (qos_flows_not_admitted_list.size() > 0) {
    j.start_array("qosFlowsNotAdmittedList");
    for (const auto& e1 : qos_flows_not_admitted_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (security_result_present) {
    j.write_fieldname("securityResult");
    security_result.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionUsageReport ::= SEQUENCE
SRSASN_CODE pdu_session_usage_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rat_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_timed_report_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_usage_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rat_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(pdu_session_timed_report_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_usage_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rATType", rat_type.to_string());
  j.start_array("pDUSessionTimedReportList");
  for (const auto& e1 : pdu_session_timed_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* pdu_session_usage_report_s::rat_type_opts::to_string() const
{
  static const char* names[] = {"nr", "eutra", "nr-unlicensed", "e-utra-unlicensed"};
  return convert_enum_idx(names, 4, value, "pdu_session_usage_report_s::rat_type_e_");
}

// PartialListIndicator ::= ENUMERATED
const char* partial_list_ind_opts::to_string() const
{
  static const char* names[] = {"partial"};
  return convert_enum_idx(names, 1, value, "partial_list_ind_e");
}

// QoSFlowNotify-Item ::= SEQUENCE
SRSASN_CODE qos_flow_notify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(notif_info.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_notify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(notif_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_notify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_str("notificationInformation", notif_info.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* qos_flow_notify_item_s::notif_info_opts::to_string() const
{
  static const char* names[] = {"fulfilled", "not-fulfilled"};
  return convert_enum_idx(names, 2, value, "qos_flow_notify_item_s::notif_info_e_");
}

// RANAreaID ::= SEQUENCE
SRSASN_CODE ran_area_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tac.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_area_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tac.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ran_area_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tAC", tac.to_string());
  if (ranac_present) {
    j.write_int("rANAC", ranac);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ResetRequestPartialReleaseItem ::= SEQUENCE
SRSASN_CODE reset_request_partial_release_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ng_ran_node1_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.pack(ng_ran_node2_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ng_ran_node1_ue_xn_ap_id_present) {
    HANDLE_CODE(pack_integer(bref, ng_ran_node1_ue_xn_ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ng_ran_node2_ue_xn_ap_id_present) {
    HANDLE_CODE(pack_integer(bref, ng_ran_node2_ue_xn_ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_request_partial_release_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ng_ran_node1_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.unpack(ng_ran_node2_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ng_ran_node1_ue_xn_ap_id_present) {
    HANDLE_CODE(unpack_integer(ng_ran_node1_ue_xn_ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ng_ran_node2_ue_xn_ap_id_present) {
    HANDLE_CODE(unpack_integer(ng_ran_node2_ue_xn_ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void reset_request_partial_release_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ng_ran_node1_ue_xn_ap_id_present) {
    j.write_int("ng-ran-node1UEXnAPID", ng_ran_node1_ue_xn_ap_id);
  }
  if (ng_ran_node2_ue_xn_ap_id_present) {
    j.write_int("ng-ran-node2UEXnAPID", ng_ran_node2_ue_xn_ap_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ResetResponsePartialReleaseItem ::= SEQUENCE
SRSASN_CODE reset_resp_partial_release_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ng_ran_node1_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.pack(ng_ran_node2_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ng_ran_node1_ue_xn_ap_id_present) {
    HANDLE_CODE(pack_integer(bref, ng_ran_node1_ue_xn_ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ng_ran_node2_ue_xn_ap_id_present) {
    HANDLE_CODE(pack_integer(bref, ng_ran_node2_ue_xn_ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_resp_partial_release_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ng_ran_node1_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.unpack(ng_ran_node2_ue_xn_ap_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ng_ran_node1_ue_xn_ap_id_present) {
    HANDLE_CODE(unpack_integer(ng_ran_node1_ue_xn_ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ng_ran_node2_ue_xn_ap_id_present) {
    HANDLE_CODE(unpack_integer(ng_ran_node2_ue_xn_ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void reset_resp_partial_release_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ng_ran_node1_ue_xn_ap_id_present) {
    j.write_int("ng-ran-node1UEXnAPID", ng_ran_node1_ue_xn_ap_id);
  }
  if (ng_ran_node2_ue_xn_ap_id_present) {
    j.write_int("ng-ran-node2UEXnAPID", ng_ran_node2_ue_xn_ap_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Short-I-RNTI-Profile-List ::= CHOICE
void short_i_rnti_profile_list_c::destroy_()
{
  switch (type_) {
    case types::short_i_rnti_profile_0:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::short_i_rnti_profile_1:
      c.destroy<fixed_bitstring<6, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void short_i_rnti_profile_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::short_i_rnti_profile_0:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::short_i_rnti_profile_1:
      c.init<fixed_bitstring<6, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "short_i_rnti_profile_list_c");
  }
}
short_i_rnti_profile_list_c::short_i_rnti_profile_list_c(const short_i_rnti_profile_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::short_i_rnti_profile_0:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::short_i_rnti_profile_1:
      c.init(other.c.get<fixed_bitstring<6, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "short_i_rnti_profile_list_c");
  }
}
short_i_rnti_profile_list_c& short_i_rnti_profile_list_c::operator=(const short_i_rnti_profile_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::short_i_rnti_profile_0:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::short_i_rnti_profile_1:
      c.set(other.c.get<fixed_bitstring<6, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "short_i_rnti_profile_list_c");
  }

  return *this;
}
fixed_bitstring<8, false, true>& short_i_rnti_profile_list_c::set_short_i_rnti_profile_0()
{
  set(types::short_i_rnti_profile_0);
  return c.get<fixed_bitstring<8, false, true>>();
}
fixed_bitstring<6, false, true>& short_i_rnti_profile_list_c::set_short_i_rnti_profile_1()
{
  set(types::short_i_rnti_profile_1);
  return c.get<fixed_bitstring<6, false, true>>();
}
protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>& short_i_rnti_profile_list_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>();
}
void short_i_rnti_profile_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::short_i_rnti_profile_0:
      j.write_str("short-I-RNTI-Profile-0", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::short_i_rnti_profile_1:
      j.write_str("short-I-RNTI-Profile-1", c.get<fixed_bitstring<6, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "short_i_rnti_profile_list_c");
  }
  j.end_obj();
}
SRSASN_CODE short_i_rnti_profile_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::short_i_rnti_profile_0:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::short_i_rnti_profile_1:
      HANDLE_CODE((c.get<fixed_bitstring<6, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "short_i_rnti_profile_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE short_i_rnti_profile_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::short_i_rnti_profile_0:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::short_i_rnti_profile_1:
      HANDLE_CODE((c.get<fixed_bitstring<6, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<short_i_rnti_profile_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "short_i_rnti_profile_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* short_i_rnti_profile_list_c::types_opts::to_string() const
{
  static const char* names[] = {"short-I-RNTI-Profile-0", "short-I-RNTI-Profile-1", "choice-extension"};
  return convert_enum_idx(names, 3, value, "short_i_rnti_profile_list_c::types");
}
int8_t short_i_rnti_profile_list_c::types_opts::to_number() const
{
  static const int8_t numbers[] = {0, -1};
  return map_enum_number(numbers, 2, value, "short_i_rnti_profile_list_c::types");
}

// LastVisitedPSCellList-Item ::= SEQUENCE
SRSASN_CODE last_visited_pscell_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(last_visited_pscell_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_pscell_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(last_visited_pscell_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void last_visited_pscell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("lastVisitedPSCellInformation", last_visited_pscell_info.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Local-NG-RAN-Node-Identifier ::= CHOICE
void local_ng_ran_node_id_c::destroy_()
{
  switch (type_) {
    case types::full_i_rnti_profile_list:
      c.destroy<full_i_rnti_profile_list_c>();
      break;
    case types::short_i_rnti_profile_list:
      c.destroy<short_i_rnti_profile_list_c>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void local_ng_ran_node_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::full_i_rnti_profile_list:
      c.init<full_i_rnti_profile_list_c>();
      break;
    case types::short_i_rnti_profile_list:
      c.init<short_i_rnti_profile_list_c>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "local_ng_ran_node_id_c");
  }
}
local_ng_ran_node_id_c::local_ng_ran_node_id_c(const local_ng_ran_node_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::full_i_rnti_profile_list:
      c.init(other.c.get<full_i_rnti_profile_list_c>());
      break;
    case types::short_i_rnti_profile_list:
      c.init(other.c.get<short_i_rnti_profile_list_c>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "local_ng_ran_node_id_c");
  }
}
local_ng_ran_node_id_c& local_ng_ran_node_id_c::operator=(const local_ng_ran_node_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::full_i_rnti_profile_list:
      c.set(other.c.get<full_i_rnti_profile_list_c>());
      break;
    case types::short_i_rnti_profile_list:
      c.set(other.c.get<short_i_rnti_profile_list_c>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "local_ng_ran_node_id_c");
  }

  return *this;
}
full_i_rnti_profile_list_c& local_ng_ran_node_id_c::set_full_i_rnti_profile_list()
{
  set(types::full_i_rnti_profile_list);
  return c.get<full_i_rnti_profile_list_c>();
}
short_i_rnti_profile_list_c& local_ng_ran_node_id_c::set_short_i_rnti_profile_list()
{
  set(types::short_i_rnti_profile_list);
  return c.get<short_i_rnti_profile_list_c>();
}
protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>& local_ng_ran_node_id_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>();
}
void local_ng_ran_node_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::full_i_rnti_profile_list:
      j.write_fieldname("full-I-RNTI-Profile-List");
      c.get<full_i_rnti_profile_list_c>().to_json(j);
      break;
    case types::short_i_rnti_profile_list:
      j.write_fieldname("short-I-RNTI-Profile-List");
      c.get<short_i_rnti_profile_list_c>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "local_ng_ran_node_id_c");
  }
  j.end_obj();
}
SRSASN_CODE local_ng_ran_node_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::full_i_rnti_profile_list:
      HANDLE_CODE(c.get<full_i_rnti_profile_list_c>().pack(bref));
      break;
    case types::short_i_rnti_profile_list:
      HANDLE_CODE(c.get<short_i_rnti_profile_list_c>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "local_ng_ran_node_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE local_ng_ran_node_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::full_i_rnti_profile_list:
      HANDLE_CODE(c.get<full_i_rnti_profile_list_c>().unpack(bref));
      break;
    case types::short_i_rnti_profile_list:
      HANDLE_CODE(c.get<short_i_rnti_profile_list_c>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<local_ng_ran_node_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "local_ng_ran_node_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* local_ng_ran_node_id_c::types_opts::to_string() const
{
  static const char* names[] = {"full-I-RNTI-Profile-List", "short-I-RNTI-Profile-List", "choice-extension"};
  return convert_enum_idx(names, 3, value, "local_ng_ran_node_id_c::types");
}

// MobilityParametersModificationRange ::= SEQUENCE
SRSASN_CODE mob_params_mod_range_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, ho_trigger_change_lower_limit, (int8_t)-20, (int8_t)20, false, true));
  HANDLE_CODE(pack_integer(bref, ho_trigger_change_upper_limit, (int8_t)-20, (int8_t)20, false, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_params_mod_range_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(ho_trigger_change_lower_limit, bref, (int8_t)-20, (int8_t)20, false, true));
  HANDLE_CODE(unpack_integer(ho_trigger_change_upper_limit, bref, (int8_t)-20, (int8_t)20, false, true));

  return SRSASN_SUCCESS;
}
void mob_params_mod_range_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("handoverTriggerChangeLowerLimit", ho_trigger_change_lower_limit);
  j.write_int("handoverTriggerChangeUpperLimit", ho_trigger_change_upper_limit);
  j.end_obj();
}

// NR-ResourceCoordinationInfo ::= SEQUENCE
SRSASN_CODE nr_res_coordination_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_coordination_info_present, 1));
  HANDLE_CODE(bref.pack(e_utra_cell_present, 1));
  HANDLE_CODE(bref.pack(nr_coordination_assist_info_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(nr_cell.pack(bref));
  HANDLE_CODE(ul_coordination_info.pack(bref));
  if (dl_coordination_info_present) {
    HANDLE_CODE(dl_coordination_info.pack(bref));
  }
  if (e_utra_cell_present) {
    HANDLE_CODE(e_utra_cell.pack(bref));
  }
  if (nr_coordination_assist_info_present) {
    HANDLE_CODE(nr_coordination_assist_info.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_res_coordination_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_coordination_info_present, 1));
  HANDLE_CODE(bref.unpack(e_utra_cell_present, 1));
  HANDLE_CODE(bref.unpack(nr_coordination_assist_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(nr_cell.unpack(bref));
  HANDLE_CODE(ul_coordination_info.unpack(bref));
  if (dl_coordination_info_present) {
    HANDLE_CODE(dl_coordination_info.unpack(bref));
  }
  if (e_utra_cell_present) {
    HANDLE_CODE(e_utra_cell.unpack(bref));
  }
  if (nr_coordination_assist_info_present) {
    HANDLE_CODE(nr_coordination_assist_info.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_res_coordination_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nr-cell");
  nr_cell.to_json(j);
  j.write_str("ul-coordination-info", ul_coordination_info.to_string());
  if (dl_coordination_info_present) {
    j.write_str("dl-coordination-info", dl_coordination_info.to_string());
  }
  if (e_utra_cell_present) {
    j.write_fieldname("e-utra-cell");
    e_utra_cell.to_json(j);
  }
  if (nr_coordination_assist_info_present) {
    j.write_str("nr-coordination-assistance-info", "coordination-not-required");
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// PDUSession-List-withDataForwardingFromTarget-Item ::= SEQUENCE
SRSASN_CODE pdu_session_list_with_data_forwarding_from_target_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(dataforwardinginfo_target.pack(bref));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_list_with_data_forwarding_from_target_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(dataforwardinginfo_target.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_list_with_data_forwarding_from_target_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pduSessionId", pdu_session_id);
  j.write_fieldname("dataforwardinginfoTarget");
  dataforwardinginfo_target.to_json(j);
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// PDUSessionResourceBearerSetupCompleteInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_bearer_setup_complete_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_setup_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_bearer_setup_complete_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_setup_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_bearer_setup_complete_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dRBsToBeSetupList");
  for (const auto& e1 : drbs_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceChangeConfirmInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_change_confirm_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_change_confirm_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_change_confirm_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceChangeRequiredInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_change_required_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_change_required_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_change_required_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceChangeRequiredInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_change_required_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_change_required_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_change_required_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dataforwardinginfofrom_source_present) {
    j.write_fieldname("dataforwardinginfofromSource");
    dataforwardinginfofrom_source.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModConfirmInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_confirm_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_confirm_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_confirm_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModConfirmInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_confirm_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_ng_u_tnl_at_up_f_present, 1));
  HANDLE_CODE(bref.pack(drbs_not_admitted_setup_modify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfo_target_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ul_ng_u_tnl_at_up_f_present) {
    HANDLE_CODE(ul_ng_u_tnl_at_up_f.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_admitted_list, 1, 32, true));
  if (drbs_not_admitted_setup_modify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_not_admitted_setup_modify_list, 1, 32, true));
  }
  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_confirm_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_ng_u_tnl_at_up_f_present, 1));
  bool drbs_not_admitted_setup_modify_list_present;
  HANDLE_CODE(bref.unpack(drbs_not_admitted_setup_modify_list_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfo_target_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ul_ng_u_tnl_at_up_f_present) {
    HANDLE_CODE(ul_ng_u_tnl_at_up_f.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(drbs_admitted_list, bref, 1, 32, true));
  if (drbs_not_admitted_setup_modify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_not_admitted_setup_modify_list, bref, 1, 32, true));
  }
  if (dataforwardinginfo_target_present) {
    HANDLE_CODE(dataforwardinginfo_target.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_confirm_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_ng_u_tnl_at_up_f_present) {
    j.write_fieldname("uL-NG-U-TNLatUPF");
    ul_ng_u_tnl_at_up_f.to_json(j);
  }
  j.start_array("dRBsAdmittedList");
  for (const auto& e1 : drbs_admitted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (drbs_not_admitted_setup_modify_list.size() > 0) {
    j.start_array("dRBsNotAdmittedSetupModifyList");
    for (const auto& e1 : drbs_not_admitted_setup_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dataforwardinginfo_target_present) {
    j.write_fieldname("dataforwardinginfoTarget");
    dataforwardinginfo_target.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceModRqdInfo-MNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_rqd_info_m_nterminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drbs_to_be_modified.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_released.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (drbs_to_be_modified.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_modified, 1, 32, true));
  }
  if (drbs_to_be_released.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_released, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_rqd_info_m_nterminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool drbs_to_be_modified_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_modified_present, 1));
  bool drbs_to_be_released_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_released_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (drbs_to_be_modified_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_modified, bref, 1, 32, true));
  }
  if (drbs_to_be_released_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_released, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_rqd_info_m_nterminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (drbs_to_be_modified.size() > 0) {
    j.start_array("dRBsToBeModified");
    for (const auto& e1 : drbs_to_be_modified) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_released.size() > 0) {
    j.start_array("dRBsToBeReleased");
    for (const auto& e1 : drbs_to_be_released) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModRqdInfo-SNterminated ::= SEQUENCE
SRSASN_CODE pdu_session_res_mod_rqd_info_sn_terminated_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_ng_u_tnl_at_ng_ran_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_to_be_released_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(dataforwardinginfofrom_source_present, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_setup_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_modified_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(drbs_to_be_released.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dl_ng_u_tnl_at_ng_ran_present) {
    HANDLE_CODE(dl_ng_u_tnl_at_ng_ran.pack(bref));
  }
  if (qos_flows_to_be_released_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_to_be_released_list, 1, 64, true));
  }
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.pack(bref));
  }
  if (drbs_to_be_setup_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_setup_list, 1, 32, true));
  }
  if (drbs_to_be_modified_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_modified_list, 1, 32, true));
  }
  if (drbs_to_be_released.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_released, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_mod_rqd_info_sn_terminated_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_ng_u_tnl_at_ng_ran_present, 1));
  bool qos_flows_to_be_released_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_to_be_released_list_present, 1));
  HANDLE_CODE(bref.unpack(dataforwardinginfofrom_source_present, 1));
  bool drbs_to_be_setup_list_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_setup_list_present, 1));
  bool drbs_to_be_modified_list_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_modified_list_present, 1));
  bool drbs_to_be_released_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_released_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dl_ng_u_tnl_at_ng_ran_present) {
    HANDLE_CODE(dl_ng_u_tnl_at_ng_ran.unpack(bref));
  }
  if (qos_flows_to_be_released_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_to_be_released_list, bref, 1, 64, true));
  }
  if (dataforwardinginfofrom_source_present) {
    HANDLE_CODE(dataforwardinginfofrom_source.unpack(bref));
  }
  if (drbs_to_be_setup_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_setup_list, bref, 1, 32, true));
  }
  if (drbs_to_be_modified_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_modified_list, bref, 1, 32, true));
  }
  if (drbs_to_be_released_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_released, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_mod_rqd_info_sn_terminated_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_ng_u_tnl_at_ng_ran_present) {
    j.write_fieldname("dL-NG-U-TNLatNG-RAN");
    dl_ng_u_tnl_at_ng_ran.to_json(j);
  }
  if (qos_flows_to_be_released_list.size() > 0) {
    j.start_array("qoSFlowsToBeReleased-List");
    for (const auto& e1 : qos_flows_to_be_released_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dataforwardinginfofrom_source_present) {
    j.write_fieldname("dataforwardinginfofromSource");
    dataforwardinginfofrom_source.to_json(j);
  }
  if (drbs_to_be_setup_list.size() > 0) {
    j.start_array("drbsToBeSetupList");
    for (const auto& e1 : drbs_to_be_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_modified_list.size() > 0) {
    j.start_array("drbsToBeModifiedList");
    for (const auto& e1 : drbs_to_be_modified_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drbs_to_be_released.size() > 0) {
    j.start_array("dRBsToBeReleased");
    for (const auto& e1 : drbs_to_be_released) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PositioningInformation ::= SEQUENCE
SRSASN_CODE positioning_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(requested_srs_tx_characteristics.pack(bref));
  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(pack_integer(bref, nrppa_transaction_id, (uint16_t)0u, (uint16_t)32767u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE positioning_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(requested_srs_tx_characteristics.unpack(bref));
  HANDLE_CODE(routing_id.unpack(bref));
  HANDLE_CODE(unpack_integer(nrppa_transaction_id, bref, (uint16_t)0u, (uint16_t)32767u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void positioning_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("requestedSRSTransmissionCharacteristics", requested_srs_tx_characteristics.to_string());
  j.write_str("routingID", routing_id.to_string());
  j.write_int("nRPPaTransactionID", nrppa_transaction_id);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// SDT-DRBsToBeSetupList-Item ::= SEQUENCE
SRSASN_CODE sdt_drbs_to_be_setup_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(ul_tnl_info.pack(bref));
  HANDLE_CODE(drb_rlc_bearer_cfg.pack(bref));
  HANDLE_CODE(drb_qos.pack(bref));
  HANDLE_CODE(rlc_mode.pack(bref));
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pdcp_sn_len.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, flows_mapped_to_drb_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_drbs_to_be_setup_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(ul_tnl_info.unpack(bref));
  HANDLE_CODE(drb_rlc_bearer_cfg.unpack(bref));
  HANDLE_CODE(drb_qos.unpack(bref));
  HANDLE_CODE(rlc_mode.unpack(bref));
  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(pdcp_sn_len.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(flows_mapped_to_drb_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_drbs_to_be_setup_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  j.write_fieldname("uL-TNLInfo");
  ul_tnl_info.to_json(j);
  j.write_str("dRB-RLC-Bearer-Configuration", drb_rlc_bearer_cfg.to_string());
  j.write_fieldname("dRB-QoS");
  drb_qos.to_json(j);
  j.write_str("rLC-Mode", rlc_mode.to_string());
  j.write_fieldname("s-nssai");
  s_nssai.to_json(j);
  j.write_fieldname("pDCP-SNLength");
  pdcp_sn_len.to_json(j);
  j.start_array("flows-Mapped-To-DRB-List");
  for (const auto& e1 : flows_mapped_to_drb_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SDT-SRBsToBeSetupList-Item ::= SEQUENCE
SRSASN_CODE sdt_srbs_to_be_setup_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)4u, true, true));
  HANDLE_CODE(srb_rlc_bearer_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_srbs_to_be_setup_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)4u, true, true));
  HANDLE_CODE(srb_rlc_bearer_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_srbs_to_be_setup_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("srb-ID", srb_id);
  j.write_str("sRB-RLC-Bearer-Configuration", srb_rlc_bearer_cfg.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBOffsetInformation ::= SEQUENCE
SRSASN_CODE ssb_offset_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(ssb_trigger_offset.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_offset_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(ssb_trigger_offset.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_offset_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_fieldname("sSBTriggeringOffset");
  ssb_trigger_offset.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecondaryRATUsageInformation ::= SEQUENCE
SRSASN_CODE secondary_rat_usage_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_usage_report_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_usage_report_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (pdu_session_usage_report_present) {
    HANDLE_CODE(pdu_session_usage_report.pack(bref));
  }
  if (qos_flows_usage_report_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_usage_report_list, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_usage_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdu_session_usage_report_present, 1));
  bool qos_flows_usage_report_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_usage_report_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (pdu_session_usage_report_present) {
    HANDLE_CODE(pdu_session_usage_report.unpack(bref));
  }
  if (qos_flows_usage_report_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_usage_report_list, bref, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void secondary_rat_usage_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_usage_report_present) {
    j.write_fieldname("pDUSessionUsageReport");
    pdu_session_usage_report.to_json(j);
  }
  if (qos_flows_usage_report_list.size() > 0) {
    j.start_array("qosFlowsUsageReportList");
    for (const auto& e1 : qos_flows_usage_report_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// TNLAssociationUsage ::= ENUMERATED
const char* tnl_assoc_usage_opts::to_string() const
{
  static const char* names[] = {"ue", "non-ue", "both"};
  return convert_enum_idx(names, 3, value, "tnl_assoc_usage_e");
}

// UEIdentityIndexList-MBSGroupPagingValue ::= CHOICE
void ue_id_idx_list_mbs_group_paging_value_c::destroy_()
{
  switch (type_) {
    case types::ue_id_idx_value_mbs_group_paging:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_id_idx_list_mbs_group_paging_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_id_idx_value_mbs_group_paging:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_list_mbs_group_paging_value_c");
  }
}
ue_id_idx_list_mbs_group_paging_value_c::ue_id_idx_list_mbs_group_paging_value_c(
    const ue_id_idx_list_mbs_group_paging_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_id_idx_value_mbs_group_paging:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_list_mbs_group_paging_value_c");
  }
}
ue_id_idx_list_mbs_group_paging_value_c&
ue_id_idx_list_mbs_group_paging_value_c::operator=(const ue_id_idx_list_mbs_group_paging_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_id_idx_value_mbs_group_paging:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_list_mbs_group_paging_value_c");
  }

  return *this;
}
fixed_bitstring<10, false, true>& ue_id_idx_list_mbs_group_paging_value_c::set_ue_id_idx_value_mbs_group_paging()
{
  set(types::ue_id_idx_value_mbs_group_paging);
  return c.get<fixed_bitstring<10, false, true>>();
}
protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>&
ue_id_idx_list_mbs_group_paging_value_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>();
}
void ue_id_idx_list_mbs_group_paging_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_id_idx_value_mbs_group_paging:
      j.write_str("uEIdentityIndexValueMBSGroupPaging", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_list_mbs_group_paging_value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_id_idx_list_mbs_group_paging_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ue_id_idx_value_mbs_group_paging:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_list_mbs_group_paging_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_id_idx_list_mbs_group_paging_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ue_id_idx_value_mbs_group_paging:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_mbs_group_paging_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_list_mbs_group_paging_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_id_idx_list_mbs_group_paging_value_c::types_opts::to_string() const
{
  static const char* names[] = {"uEIdentityIndexValueMBSGroupPaging", "choice-extension"};
  return convert_enum_idx(names, 2, value, "ue_id_idx_list_mbs_group_paging_value_c::types");
}

// UESpecificDRX ::= ENUMERATED
const char* ue_specific_drx_opts::to_string() const
{
  static const char* names[] = {"v32", "v64", "v128", "v256"};
  return convert_enum_idx(names, 4, value, "ue_specific_drx_e");
}
uint16_t ue_specific_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {32, 64, 128, 256};
  return map_enum_number(numbers, 4, value, "ue_specific_drx_e");
}

// XnUAddressInfoperPDUSession-Item-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t xn_u_address_infoper_pdu_session_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {109, 133, 252};
  return map_enum_number(names, 3, idx, "id");
}
bool xn_u_address_infoper_pdu_session_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {109, 133, 252};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e xn_u_address_infoper_pdu_session_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 109:
      return crit_e::ignore;
    case 133:
      return crit_e::reject;
    case 252:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c
xn_u_address_infoper_pdu_session_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 109:
      ret.set(ext_c::types::secondarydata_forwarding_info_from_target_list);
      break;
    case 133:
      ret.set(ext_c::types::drb_ids_takenintouse);
      break;
    case 252:
      ret.set(ext_c::types::data_forwarding_info_from_target_e_utran_node);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e xn_u_address_infoper_pdu_session_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 109:
      return presence_e::optional;
    case 133:
      return presence_e::optional;
    case 252:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::secondarydata_forwarding_info_from_target_list:
      c = secondarydata_forwarding_info_from_target_list_l{};
      break;
    case types::drb_ids_takenintouse:
      c = drb_list_l{};
      break;
    case types::data_forwarding_info_from_target_e_utran_node:
      c = data_forwarding_info_from_target_e_utran_node_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c");
  }
}
secondarydata_forwarding_info_from_target_list_l&
xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::secondarydata_forwarding_info_from_target_list()
{
  assert_choice_type(types::secondarydata_forwarding_info_from_target_list, type_, "Extension");
  return c.get<secondarydata_forwarding_info_from_target_list_l>();
}
drb_list_l& xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::drb_ids_takenintouse()
{
  assert_choice_type(types::drb_ids_takenintouse, type_, "Extension");
  return c.get<drb_list_l>();
}
data_forwarding_info_from_target_e_utran_node_s&
xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::data_forwarding_info_from_target_e_utran_node()
{
  assert_choice_type(types::data_forwarding_info_from_target_e_utran_node, type_, "Extension");
  return c.get<data_forwarding_info_from_target_e_utran_node_s>();
}
const secondarydata_forwarding_info_from_target_list_l&
xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::secondarydata_forwarding_info_from_target_list() const
{
  assert_choice_type(types::secondarydata_forwarding_info_from_target_list, type_, "Extension");
  return c.get<secondarydata_forwarding_info_from_target_list_l>();
}
const drb_list_l& xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::drb_ids_takenintouse() const
{
  assert_choice_type(types::drb_ids_takenintouse, type_, "Extension");
  return c.get<drb_list_l>();
}
const data_forwarding_info_from_target_e_utran_node_s&
xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::data_forwarding_info_from_target_e_utran_node() const
{
  assert_choice_type(types::data_forwarding_info_from_target_e_utran_node, type_, "Extension");
  return c.get<data_forwarding_info_from_target_e_utran_node_s>();
}
void xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::secondarydata_forwarding_info_from_target_list:
      j.start_array("SecondarydataForwardingInfoFromTarget-List");
      for (const auto& e1 : c.get<secondarydata_forwarding_info_from_target_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::drb_ids_takenintouse:
      j.start_array("DRB-List");
      for (const auto& e1 : c.get<drb_list_l>()) {
        j.write_int(e1);
      }
      j.end_array();
      break;
    case types::data_forwarding_info_from_target_e_utran_node:
      j.write_fieldname("DataForwardingInfoFromTargetE-UTRANnode");
      c.get<data_forwarding_info_from_target_e_utran_node_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondarydata_forwarding_info_from_target_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondarydata_forwarding_info_from_target_list_l>(), 1, 3, true));
      break;
    case types::drb_ids_takenintouse:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<drb_list_l>(), 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
      break;
    case types::data_forwarding_info_from_target_e_utran_node:
      HANDLE_CODE(c.get<data_forwarding_info_from_target_e_utran_node_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondarydata_forwarding_info_from_target_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondarydata_forwarding_info_from_target_list_l>(), bref, 1, 3, true));
      break;
    case types::drb_ids_takenintouse:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<drb_list_l>(), bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
      break;
    case types::data_forwarding_info_from_target_e_utran_node:
      HANDLE_CODE(c.get<data_forwarding_info_from_target_e_utran_node_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {
      "SecondarydataForwardingInfoFromTarget-List", "DRB-List", "DataForwardingInfoFromTargetE-UTRANnode"};
  return convert_enum_idx(names, 3, value, "xn_u_address_infoper_pdu_session_item_ext_ies_o::ext_c::types");
}

// LowerLayerPresenceStatusChange ::= ENUMERATED
const char* lower_layer_presence_status_change_opts::to_string() const
{
  static const char* names[] = {
      "release-lower-layers", "re-establish-lower-layers", "suspend-lower-layers", "resume-lower-layers"};
  return convert_enum_idx(names, 4, value, "lower_layer_presence_status_change_e");
}

// NG-RAN-Node-ResourceCoordinationInfo ::= CHOICE
void ng_ran_node_res_coordination_info_c::destroy_()
{
  switch (type_) {
    case types::eutra_res_coordination_info:
      c.destroy<e_utra_res_coordination_info_s>();
      break;
    case types::nr_res_coordination_info:
      c.destroy<nr_res_coordination_info_s>();
      break;
    default:
      break;
  }
}
void ng_ran_node_res_coordination_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_res_coordination_info:
      c.init<e_utra_res_coordination_info_s>();
      break;
    case types::nr_res_coordination_info:
      c.init<nr_res_coordination_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_node_res_coordination_info_c");
  }
}
ng_ran_node_res_coordination_info_c::ng_ran_node_res_coordination_info_c(
    const ng_ran_node_res_coordination_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_res_coordination_info:
      c.init(other.c.get<e_utra_res_coordination_info_s>());
      break;
    case types::nr_res_coordination_info:
      c.init(other.c.get<nr_res_coordination_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_node_res_coordination_info_c");
  }
}
ng_ran_node_res_coordination_info_c&
ng_ran_node_res_coordination_info_c::operator=(const ng_ran_node_res_coordination_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_res_coordination_info:
      c.set(other.c.get<e_utra_res_coordination_info_s>());
      break;
    case types::nr_res_coordination_info:
      c.set(other.c.get<nr_res_coordination_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_node_res_coordination_info_c");
  }

  return *this;
}
e_utra_res_coordination_info_s& ng_ran_node_res_coordination_info_c::set_eutra_res_coordination_info()
{
  set(types::eutra_res_coordination_info);
  return c.get<e_utra_res_coordination_info_s>();
}
nr_res_coordination_info_s& ng_ran_node_res_coordination_info_c::set_nr_res_coordination_info()
{
  set(types::nr_res_coordination_info);
  return c.get<nr_res_coordination_info_s>();
}
void ng_ran_node_res_coordination_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_res_coordination_info:
      j.write_fieldname("eutra-resource-coordination-info");
      c.get<e_utra_res_coordination_info_s>().to_json(j);
      break;
    case types::nr_res_coordination_info:
      j.write_fieldname("nr-resource-coordination-info");
      c.get<nr_res_coordination_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_node_res_coordination_info_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_ran_node_res_coordination_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_res_coordination_info:
      HANDLE_CODE(c.get<e_utra_res_coordination_info_s>().pack(bref));
      break;
    case types::nr_res_coordination_info:
      HANDLE_CODE(c.get<nr_res_coordination_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_node_res_coordination_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_ran_node_res_coordination_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_res_coordination_info:
      HANDLE_CODE(c.get<e_utra_res_coordination_info_s>().unpack(bref));
      break;
    case types::nr_res_coordination_info:
      HANDLE_CODE(c.get<nr_res_coordination_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_ran_node_res_coordination_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_ran_node_res_coordination_info_c::types_opts::to_string() const
{
  static const char* names[] = {"eutra-resource-coordination-info", "nr-resource-coordination-info"};
  return convert_enum_idx(names, 2, value, "ng_ran_node_res_coordination_info_c::types");
}

// NRPaging-Time-Window ::= ENUMERATED
const char* nr_paging_time_win_opts::to_string() const
{
  static const char* names[] = {"s1",  "s2",  "s3",  "s4",  "s5",  "s6",  "s7",  "s8",  "s9",  "s10", "s11",
                                "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21", "s22",
                                "s23", "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31", "s32"};
  return convert_enum_idx(names, 32, value, "nr_paging_time_win_e");
}
uint8_t nr_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,
                                    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32};
  return map_enum_number(numbers, 32, value, "nr_paging_time_win_e");
}

// NRPaging-eDRX-Cycle ::= ENUMERATED
const char* nr_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hfquarter", "hfhalf", "hf1", "hf2", "hf4", "hf8", "hf16", "hf32", "hf64", "hf128", "hf256", "hf512", "hf1024"};
  return convert_enum_idx(names, 13, value, "nr_paging_e_drx_cycle_e");
}
float nr_paging_e_drx_cycle_opts::to_number() const
{
  static const float numbers[] = {0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0};
  return map_enum_number(numbers, 13, value, "nr_paging_e_drx_cycle_e");
}
const char* nr_paging_e_drx_cycle_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25", "0.5", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024"};
  return convert_enum_idx(number_strs, 13, value, "nr_paging_e_drx_cycle_e");
}

// NRPaging-eDRX-Cycle-Inactive ::= ENUMERATED
const char* nr_paging_e_drx_cycle_inactive_opts::to_string() const
{
  static const char* names[] = {"hfquarter", "hfhalf", "hf1"};
  return convert_enum_idx(names, 3, value, "nr_paging_e_drx_cycle_inactive_e");
}
float nr_paging_e_drx_cycle_inactive_opts::to_number() const
{
  static const float numbers[] = {0.25, 0.5, 1.0};
  return map_enum_number(numbers, 3, value, "nr_paging_e_drx_cycle_inactive_e");
}
const char* nr_paging_e_drx_cycle_inactive_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25", "0.5", "1"};
  return convert_enum_idx(number_strs, 3, value, "nr_paging_e_drx_cycle_inactive_e");
}

// Neighbour-NG-RAN-Node-Item ::= SEQUENCE
SRSASN_CODE neighbour_ng_ran_node_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_ran_node_id.pack(bref));
  HANDLE_CODE(local_ng_ran_node_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_ng_ran_node_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_ran_node_id.unpack(bref));
  HANDLE_CODE(local_ng_ran_node_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_ng_ran_node_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalNG-RANNodeID");
  global_ng_ran_node_id.to_json(j);
  j.write_fieldname("local-NG-RAN-Node-Identifier");
  local_ng_ran_node_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("ie-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSecondaryRATUsageItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_secondary_rat_usage_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_secondary_rat_usage_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(secondary_rat_usage_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_secondary_rat_usage_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_fieldname("secondaryRATUsageInformation");
  secondary_rat_usage_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RANPagingAreaChoice ::= CHOICE
void ran_paging_area_choice_c::destroy_()
{
  switch (type_) {
    case types::cell_list:
      c.destroy<ng_ran_cell_id_listin_ran_paging_area_l>();
      break;
    case types::ran_area_id_list:
      c.destroy<ran_area_id_list_l>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ran_paging_area_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_list:
      c.init<ng_ran_cell_id_listin_ran_paging_area_l>();
      break;
    case types::ran_area_id_list:
      c.init<ran_area_id_list_l>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_paging_area_choice_c");
  }
}
ran_paging_area_choice_c::ran_paging_area_choice_c(const ran_paging_area_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_list:
      c.init(other.c.get<ng_ran_cell_id_listin_ran_paging_area_l>());
      break;
    case types::ran_area_id_list:
      c.init(other.c.get<ran_area_id_list_l>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_paging_area_choice_c");
  }
}
ran_paging_area_choice_c& ran_paging_area_choice_c::operator=(const ran_paging_area_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_list:
      c.set(other.c.get<ng_ran_cell_id_listin_ran_paging_area_l>());
      break;
    case types::ran_area_id_list:
      c.set(other.c.get<ran_area_id_list_l>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_paging_area_choice_c");
  }

  return *this;
}
ng_ran_cell_id_listin_ran_paging_area_l& ran_paging_area_choice_c::set_cell_list()
{
  set(types::cell_list);
  return c.get<ng_ran_cell_id_listin_ran_paging_area_l>();
}
ran_area_id_list_l& ran_paging_area_choice_c::set_ran_area_id_list()
{
  set(types::ran_area_id_list);
  return c.get<ran_area_id_list_l>();
}
protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>& ran_paging_area_choice_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>();
}
void ran_paging_area_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_list:
      j.start_array("cell-List");
      for (const auto& e1 : c.get<ng_ran_cell_id_listin_ran_paging_area_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ran_area_id_list:
      j.start_array("rANAreaID-List");
      for (const auto& e1 : c.get<ran_area_id_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_paging_area_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_paging_area_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ng_ran_cell_id_listin_ran_paging_area_l>(), 1, 32, true));
      break;
    case types::ran_area_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ran_area_id_list_l>(), 1, 16, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_paging_area_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_paging_area_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ng_ran_cell_id_listin_ran_paging_area_l>(), bref, 1, 32, true));
      break;
    case types::ran_area_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ran_area_id_list_l>(), bref, 1, 16, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ran_paging_area_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_paging_area_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ran_paging_area_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"cell-List", "rANAreaID-List", "choice-extension"};
  return convert_enum_idx(names, 3, value, "ran_paging_area_choice_c::types");
}

// ResetRequestTypeInfo-Full ::= SEQUENCE
SRSASN_CODE reset_request_type_info_full_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_request_type_info_full_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void reset_request_type_info_full_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ResetRequestTypeInfo-Partial ::= SEQUENCE
SRSASN_CODE reset_request_type_info_partial_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ue_contexts_to_be_released_list, 1, 8192, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_request_type_info_partial_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ue_contexts_to_be_released_list, bref, 1, 8192, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void reset_request_type_info_partial_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("ue-contexts-ToBeReleasedList");
  for (const auto& e1 : ue_contexts_to_be_released_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ResetResponseTypeInfo-Full ::= SEQUENCE
SRSASN_CODE reset_resp_type_info_full_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_resp_type_info_full_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void reset_resp_type_info_full_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ResetResponseTypeInfo-Partial ::= SEQUENCE
SRSASN_CODE reset_resp_type_info_partial_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ue_contexts_admitted_to_be_released_list, 1, 8192, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_resp_type_info_partial_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ue_contexts_admitted_to_be_released_list, bref, 1, 8192, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void reset_resp_type_info_partial_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("ue-contexts-AdmittedToBeReleasedList");
  for (const auto& e1 : ue_contexts_admitted_to_be_released_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// SDTAssistantInfo ::= ENUMERATED
const char* sdt_assistant_info_opts::to_string() const
{
  static const char* names[] = {"single-packet", "multiple-packets"};
  return convert_enum_idx(names, 2, value, "sdt_assistant_info_e");
}

// SDTDataForwardingDRBList-Item ::= SEQUENCE
SRSASN_CODE sdt_data_forwarding_drb_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_tnl_info_present) {
    HANDLE_CODE(dl_tnl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_data_forwarding_drb_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_tnl_info_present) {
    HANDLE_CODE(dl_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_data_forwarding_drb_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("drb-ID", drb_id);
  if (dl_tnl_info_present) {
    j.write_fieldname("dL-TNLInfo");
    dl_tnl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SDTIndicator ::= ENUMERATED
const char* sdt_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sdt_ind_e");
}

// SSBOffsetModificationRange ::= SEQUENCE
SRSASN_CODE ssb_offset_mod_range_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(ss_bobility_params_mod_range.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_offset_mod_range_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(ss_bobility_params_mod_range.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_offset_mod_range_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_fieldname("sSBobilityParametersModificationRange");
  ss_bobility_params_mod_range.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBOffsets-Item ::= SEQUENCE
SRSASN_CODE ssb_offsets_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ng_ra_nnode1_ssb_offsets_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ng_ra_nnode1_ssb_offsets_present) {
    HANDLE_CODE(ng_ra_nnode1_ssb_offsets.pack(bref));
  }
  HANDLE_CODE(ng_ra_nnode2_proposed_ssb_offsets.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_offsets_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ng_ra_nnode1_ssb_offsets_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ng_ra_nnode1_ssb_offsets_present) {
    HANDLE_CODE(ng_ra_nnode1_ssb_offsets.unpack(bref));
  }
  HANDLE_CODE(ng_ra_nnode2_proposed_ssb_offsets.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_offsets_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ng_ra_nnode1_ssb_offsets_present) {
    j.write_fieldname("nG-RANnode1SSBOffsets");
    ng_ra_nnode1_ssb_offsets.to_json(j);
  }
  j.write_fieldname("nG-RANnode2ProposedSSBOffsets");
  ng_ra_nnode2_proposed_ssb_offsets.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAISupport-Item ::= SEQUENCE
SRSASN_CODE tai_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tac.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmns, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tac.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmns, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tac", tac.to_string());
  j.start_array("broadcastPLMNs");
  for (const auto& e1 : broadcast_plmns) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLA-Failed-To-Setup-Item ::= SEQUENCE
SRSASN_CODE tnl_a_failed_to_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_a_failed_to_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_a_failed_to_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLA-Setup-Item ::= SEQUENCE
SRSASN_CODE tnl_a_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_a_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_a_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLA-To-Add-Item ::= SEQUENCE
SRSASN_CODE tnl_a_to_add_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  HANDLE_CODE(tnl_assoc_usage.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_a_to_add_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_a_to_add_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLA-To-Remove-Item ::= SEQUENCE
SRSASN_CODE tnl_a_to_rem_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_a_to_rem_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_a_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLA-To-Update-Item ::= SEQUENCE
SRSASN_CODE tnl_a_to_upd_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_a_to_upd_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_a_to_upd_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (tnl_assoc_usage_present) {
    j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEContextIDforRRCReestablishment ::= SEQUENCE
SRSASN_CODE ue_context_id_for_rrc_reest_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(c_rnti.pack(bref));
  HANDLE_CODE(fail_cell_pci.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_id_for_rrc_reest_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(c_rnti.unpack(bref));
  HANDLE_CODE(fail_cell_pci.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_id_for_rrc_reest_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("c-rnti", c_rnti.to_string());
  j.write_fieldname("failureCellPCI");
  fail_cell_pci.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UEContextIDforRRCResume ::= SEQUENCE
SRSASN_CODE ue_context_id_for_rrc_resume_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(i_rnti.pack(bref));
  HANDLE_CODE(allocated_c_rnti.pack(bref));
  HANDLE_CODE(access_pci.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_id_for_rrc_resume_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(i_rnti.unpack(bref));
  HANDLE_CODE(allocated_c_rnti.unpack(bref));
  HANDLE_CODE(access_pci.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_id_for_rrc_resume_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("i-rnti");
  i_rnti.to_json(j);
  j.write_str("allocated-c-rnti", allocated_c_rnti.to_string());
  j.write_fieldname("accessPCI");
  access_pci.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UEContextInfoRetrUECtxtResp-ExtIEs ::= OBJECT SET OF XNAP-PROTOCOL-EXTENSION
uint32_t ue_context_info_retr_ue_ctxt_resp_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {155, 172, 171, 227, 273, 298, 346, 358, 360};
  return map_enum_number(names, 9, idx, "id");
}
bool ue_context_info_retr_ue_ctxt_resp_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {155, 172, 171, 227, 273, 298, 346, 358, 360};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_info_retr_ue_ctxt_resp_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 155:
      return crit_e::ignore;
    case 172:
      return crit_e::ignore;
    case 171:
      return crit_e::ignore;
    case 227:
      return crit_e::reject;
    case 273:
      return crit_e::ignore;
    case 298:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 358:
      return crit_e::ignore;
    case 360:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 155:
      ret.set(ext_c::types::five_gc_mob_restrict_list_container);
      break;
    case 172:
      ret.set(ext_c::types::nr_ue_sidelink_aggr_max_bit_rate);
      break;
    case 171:
      ret.set(ext_c::types::lte_ue_sidelink_aggr_max_bit_rate);
      break;
    case 227:
      ret.set(ext_c::types::ue_radio_cap_id);
      break;
    case 273:
      ret.set(ext_c::types::mbs_session_info_list);
      break;
    case 298:
      ret.set(ext_c::types::no_pdu_session_ind);
      break;
    case 346:
      ret.set(ext_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 358:
      ret.set(ext_c::types::ue_slice_max_bit_rate_list);
      break;
    case 360:
      ret.set(ext_c::types::positioning_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_info_retr_ue_ctxt_resp_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 155:
      return presence_e::optional;
    case 172:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    case 227:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    case 298:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 358:
      return presence_e::optional;
    case 360:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::five_gc_mob_restrict_list_container:
      c = unbounded_octstring<true>{};
      break;
    case types::nr_ue_sidelink_aggr_max_bit_rate:
      c = nr_ue_sidelink_aggr_max_bit_rate_s{};
      break;
    case types::lte_ue_sidelink_aggr_max_bit_rate:
      c = lte_ue_sidelink_aggr_max_bit_rate_s{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::mbs_session_info_list:
      c = mbs_session_info_list_l{};
      break;
    case types::no_pdu_session_ind:
      c = no_pdu_session_ind_e{};
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c = nr_ue_sidelink_aggr_max_bit_rate_s{};
      break;
    case types::ue_slice_max_bit_rate_list:
      c = ue_slice_max_bit_rate_list_l{};
      break;
    case types::positioning_info:
      c = positioning_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c");
  }
}
unbounded_octstring<true>& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::five_gc_mob_restrict_list_container()
{
  assert_choice_type(types::five_gc_mob_restrict_list_container, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
nr_ue_sidelink_aggr_max_bit_rate_s&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::nr_ue_sidelink_aggr_max_bit_rate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bit_rate, type_, "Extension");
  return c.get<nr_ue_sidelink_aggr_max_bit_rate_s>();
}
lte_ue_sidelink_aggr_max_bit_rate_s&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::lte_ue_sidelink_aggr_max_bit_rate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bit_rate, type_, "Extension");
  return c.get<lte_ue_sidelink_aggr_max_bit_rate_s>();
}
unbounded_octstring<true>& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
mbs_session_info_list_l& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::mbs_session_info_list()
{
  assert_choice_type(types::mbs_session_info_list, type_, "Extension");
  return c.get<mbs_session_info_list_l>();
}
no_pdu_session_ind_e& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::no_pdu_session_ind()
{
  assert_choice_type(types::no_pdu_session_ind, type_, "Extension");
  return c.get<no_pdu_session_ind_e>();
}
nr_ue_sidelink_aggr_max_bit_rate_s&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Extension");
  return c.get<nr_ue_sidelink_aggr_max_bit_rate_s>();
}
ue_slice_max_bit_rate_list_l& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Extension");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
positioning_info_s& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::positioning_info()
{
  assert_choice_type(types::positioning_info, type_, "Extension");
  return c.get<positioning_info_s>();
}
const unbounded_octstring<true>&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::five_gc_mob_restrict_list_container() const
{
  assert_choice_type(types::five_gc_mob_restrict_list_container, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const nr_ue_sidelink_aggr_max_bit_rate_s&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::nr_ue_sidelink_aggr_max_bit_rate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bit_rate, type_, "Extension");
  return c.get<nr_ue_sidelink_aggr_max_bit_rate_s>();
}
const lte_ue_sidelink_aggr_max_bit_rate_s&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::lte_ue_sidelink_aggr_max_bit_rate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bit_rate, type_, "Extension");
  return c.get<lte_ue_sidelink_aggr_max_bit_rate_s>();
}
const unbounded_octstring<true>& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_info_list_l& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::mbs_session_info_list() const
{
  assert_choice_type(types::mbs_session_info_list, type_, "Extension");
  return c.get<mbs_session_info_list_l>();
}
const no_pdu_session_ind_e& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::no_pdu_session_ind() const
{
  assert_choice_type(types::no_pdu_session_ind, type_, "Extension");
  return c.get<no_pdu_session_ind_e>();
}
const nr_ue_sidelink_aggr_max_bit_rate_s&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Extension");
  return c.get<nr_ue_sidelink_aggr_max_bit_rate_s>();
}
const ue_slice_max_bit_rate_list_l&
ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Extension");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const positioning_info_s& ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::positioning_info() const
{
  assert_choice_type(types::positioning_info, type_, "Extension");
  return c.get<positioning_info_s>();
}
void ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_gc_mob_restrict_list_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nr_ue_sidelink_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitRate");
      c.get<nr_ue_sidelink_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bit_rate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitRate");
      c.get<lte_ue_sidelink_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mbs_session_info_list:
      j.start_array("MBS-SessionInformation-List");
      for (const auto& e1 : c.get<mbs_session_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::no_pdu_session_ind:
      j.write_str("NoPDUSessionIndication", "true");
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitRate");
      c.get<nr_ue_sidelink_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::positioning_info:
      j.write_fieldname("PositioningInformation");
      c.get<positioning_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_gc_mob_restrict_list_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bit_rate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mbs_session_info_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_info_list_l>(), 1, 256, true));
      break;
    case types::no_pdu_session_ind:
      HANDLE_CODE(c.get<no_pdu_session_ind_e>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::positioning_info:
      HANDLE_CODE(c.get<positioning_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_gc_mob_restrict_list_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bit_rate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mbs_session_info_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_info_list_l>(), bref, 1, 256, true));
      break;
    case types::no_pdu_session_ind:
      HANDLE_CODE(c.get<no_pdu_session_ind_e>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::positioning_info:
      HANDLE_CODE(c.get<positioning_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING",
                                "NRUESidelinkAggregateMaximumBitRate",
                                "LTEUESidelinkAggregateMaximumBitRate",
                                "OCTET STRING",
                                "MBS-SessionInformation-List",
                                "NoPDUSessionIndication",
                                "NRUESidelinkAggregateMaximumBitRate",
                                "UESliceMaximumBitRateList",
                                "PositioningInformation"};
  return convert_enum_idx(names, 9, value, "ue_context_info_retr_ue_ctxt_resp_ext_ies_o::ext_c::types");
}

// UEIdentityIndexList-MBSGroupPaging-Item ::= SEQUENCE
SRSASN_CODE ue_id_idx_list_mbs_group_paging_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(paging_drx_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ue_id_idx_list_mbs_group_paging_value.pack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_id_idx_list_mbs_group_paging_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(paging_drx_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ue_id_idx_list_mbs_group_paging_value.unpack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_id_idx_list_mbs_group_paging_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ueIdentityIndexList-MBSGroupPagingValue");
  ue_id_idx_list_mbs_group_paging_value.to_json(j);
  if (paging_drx_present) {
    j.write_str("pagingDRX", paging_drx.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<xn_u_address_infoper_pdu_session_item_ext_ies_o>;

SRSASN_CODE xn_u_address_infoper_pdu_session_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += secondarydata_forwarding_info_from_target_list_present ? 1 : 0;
  nof_ies += drb_ids_takenintouse_present ? 1 : 0;
  nof_ies += data_forwarding_info_from_target_e_utran_node_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (secondarydata_forwarding_info_from_target_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)109, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, secondarydata_forwarding_info_from_target_list, 1, 3, true));
  }
  if (drb_ids_takenintouse_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)133, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, drb_ids_takenintouse, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
  }
  if (data_forwarding_info_from_target_e_utran_node_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)252, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(data_forwarding_info_from_target_e_utran_node.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_u_address_infoper_pdu_session_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 109: {
        secondarydata_forwarding_info_from_target_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(secondarydata_forwarding_info_from_target_list, bref, 1, 3, true));
        break;
      }
      case 133: {
        drb_ids_takenintouse_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(drb_ids_takenintouse, bref, 1, 32, integer_packer<uint8_t>(1, 32, true, true)));
        break;
      }
      case 252: {
        data_forwarding_info_from_target_e_utran_node_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_forwarding_info_from_target_e_utran_node.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void xn_u_address_infoper_pdu_session_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (secondarydata_forwarding_info_from_target_list_present) {
    j.write_int("id", 109);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : secondarydata_forwarding_info_from_target_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (drb_ids_takenintouse_present) {
    j.write_int("id", 133);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : drb_ids_takenintouse) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (data_forwarding_info_from_target_e_utran_node_present) {
    j.write_int("id", 252);
    j.write_str("criticality", "ignore");
    data_forwarding_info_from_target_e_utran_node.to_json(j);
  }
  j.end_obj();
}

// XnUAddressInfoperPDUSession-Item ::= SEQUENCE
SRSASN_CODE xn_u_address_infoper_pdu_session_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(data_forwarding_info_from_target_ngra_nnode_present, 1));
  HANDLE_CODE(bref.pack(pdu_session_res_setup_complete_info_sn_term_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (data_forwarding_info_from_target_ngra_nnode_present) {
    HANDLE_CODE(data_forwarding_info_from_target_ngra_nnode.pack(bref));
  }
  if (pdu_session_res_setup_complete_info_sn_term_present) {
    HANDLE_CODE(pdu_session_res_setup_complete_info_sn_term.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_u_address_infoper_pdu_session_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(data_forwarding_info_from_target_ngra_nnode_present, 1));
  HANDLE_CODE(bref.unpack(pdu_session_res_setup_complete_info_sn_term_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (data_forwarding_info_from_target_ngra_nnode_present) {
    HANDLE_CODE(data_forwarding_info_from_target_ngra_nnode.unpack(bref));
  }
  if (pdu_session_res_setup_complete_info_sn_term_present) {
    HANDLE_CODE(pdu_session_res_setup_complete_info_sn_term.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void xn_u_address_infoper_pdu_session_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pduSession-ID", pdu_session_id);
  if (data_forwarding_info_from_target_ngra_nnode_present) {
    j.write_fieldname("dataForwardingInfoFromTargetNGRANnode");
    data_forwarding_info_from_target_ngra_nnode.to_json(j);
  }
  if (pdu_session_res_setup_complete_info_sn_term_present) {
    j.write_fieldname("pduSessionResourceSetupCompleteInfo-SNterm");
    pdu_session_res_setup_complete_info_sn_term.to_json(j);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// CHO-MRDC-EarlyDataForwarding ::= ENUMERATED
const char* cho_mrdc_early_data_forwarding_opts::to_string() const
{
  static const char* names[] = {"stop"};
  return convert_enum_idx(names, 1, value, "cho_mrdc_early_data_forwarding_e");
}

// CHO-MRDC-Indicator ::= ENUMERATED
const char* cho_mrdc_ind_opts::to_string() const
{
  static const char* names[] = {"true", "coordination-only"};
  return convert_enum_idx(names, 2, value, "cho_mrdc_ind_e");
}

// CPC-DataForwarding-Indicator ::= ENUMERATED
const char* cp_c_data_forwarding_ind_opts::to_string() const
{
  static const char* names[] = {"triggered", "early-data-transmission-stop", "coordination-only"};
  return convert_enum_idx(names, 3, value, "cp_c_data_forwarding_ind_e");
}

// DesiredActNotificationLevel ::= ENUMERATED
const char* desired_act_notif_level_opts::to_string() const
{
  static const char* names[] = {"none", "qos-flow", "pdu-session", "ue-level"};
  return convert_enum_idx(names, 4, value, "desired_act_notif_level_e");
}
uint8_t desired_act_notif_level_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "desired_act_notif_level_e");
}

// DirectForwardingPathAvailability ::= ENUMERATED
const char* direct_forwarding_path_availability_opts::to_string() const
{
  static const char* names[] = {"direct-path-available"};
  return convert_enum_idx(names, 1, value, "direct_forwarding_path_availability_e");
}

// F1-terminatingIAB-donorIndicator ::= ENUMERATED
const char* f1_terminating_iab_donor_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "f1_terminating_iab_donor_ind_e");
}

// LocationInformationSNReporting ::= ENUMERATED
const char* location_info_snr_eporting_opts::to_string() const
{
  static const char* names[] = {"pSCell"};
  return convert_enum_idx(names, 1, value, "location_info_snr_eporting_e");
}

// MR-DC-ResourceCoordinationInfo ::= SEQUENCE
SRSASN_CODE mr_dc_res_coordination_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ng_ran_node_res_coordination_info.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mr_dc_res_coordination_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ng_ran_node_res_coordination_info.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mr_dc_res_coordination_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ng-RAN-Node-ResourceCoordinationInfo");
  ng_ran_node_res_coordination_info.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// MessageOversizeNotification ::= SEQUENCE
SRSASN_CODE msg_oversize_notif_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, max_cell_list_size, (uint16_t)1u, (uint16_t)16384u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE msg_oversize_notif_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(max_cell_list_size, bref, (uint16_t)1u, (uint16_t)16384u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void msg_oversize_notif_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("maximumCellListSize", max_cell_list_size);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NE-DC-TDM-Pattern ::= SEQUENCE
SRSASN_CODE ne_dc_tdm_pattern_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(sf_assign.pack(bref));
  HANDLE_CODE(pack_integer(bref, harq_offset, (uint8_t)0u, (uint8_t)9u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ne_dc_tdm_pattern_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(sf_assign.unpack(bref));
  HANDLE_CODE(unpack_integer(harq_offset, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ne_dc_tdm_pattern_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("subframeAssignment", sf_assign.to_string());
  j.write_int("harqOffset", harq_offset);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* ne_dc_tdm_pattern_s::sf_assign_opts::to_string() const
{
  static const char* names[] = {"sa0", "sa1", "sa2", "sa3", "sa4", "sa5", "sa6"};
  return convert_enum_idx(names, 7, value, "ne_dc_tdm_pattern_s::sf_assign_e_");
}
uint8_t ne_dc_tdm_pattern_s::sf_assign_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5, 6};
  return map_enum_number(numbers, 7, value, "ne_dc_tdm_pattern_s::sf_assign_e_");
}

// NRPagingeDRXInformation ::= SEQUENCE
SRSASN_CODE nr_paginge_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nr_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle.pack(bref));
  if (nr_paging_time_win_present) {
    HANDLE_CODE(nr_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_paginge_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nr_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle.unpack(bref));
  if (nr_paging_time_win_present) {
    HANDLE_CODE(nr_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_paginge_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRPaging-eDRX-Cycle", nr_paging_e_drx_cycle.to_string());
  if (nr_paging_time_win_present) {
    j.write_str("nRPaging-Time-Window", nr_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRPagingeDRXInformationforRRCINACTIVE ::= SEQUENCE
SRSASN_CODE nr_paginge_drx_infofor_rrc_inactive_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle_inactive.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_paginge_drx_infofor_rrc_inactive_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle_inactive.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_paginge_drx_infofor_rrc_inactive_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRPaging-eDRX-Cycle-Inactive", nr_paging_e_drx_cycle_inactive.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDCPChangeIndication ::= CHOICE
void pdcp_change_ind_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pdcp_change_ind_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::from_s_ng_ran_node:
      break;
    case types::from_m_ng_ran_node:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdcp_change_ind_c");
  }
}
pdcp_change_ind_c::pdcp_change_ind_c(const pdcp_change_ind_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::from_s_ng_ran_node:
      c.init(other.c.get<from_s_ng_ran_node_e_>());
      break;
    case types::from_m_ng_ran_node:
      c.init(other.c.get<from_m_ng_ran_node_e_>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdcp_change_ind_c");
  }
}
pdcp_change_ind_c& pdcp_change_ind_c::operator=(const pdcp_change_ind_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::from_s_ng_ran_node:
      c.set(other.c.get<from_s_ng_ran_node_e_>());
      break;
    case types::from_m_ng_ran_node:
      c.set(other.c.get<from_m_ng_ran_node_e_>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdcp_change_ind_c");
  }

  return *this;
}
pdcp_change_ind_c::from_s_ng_ran_node_e_& pdcp_change_ind_c::set_from_s_ng_ran_node()
{
  set(types::from_s_ng_ran_node);
  return c.get<from_s_ng_ran_node_e_>();
}
pdcp_change_ind_c::from_m_ng_ran_node_e_& pdcp_change_ind_c::set_from_m_ng_ran_node()
{
  set(types::from_m_ng_ran_node);
  return c.get<from_m_ng_ran_node_e_>();
}
protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>& pdcp_change_ind_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>();
}
void pdcp_change_ind_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::from_s_ng_ran_node:
      j.write_str("from-S-NG-RAN-node", c.get<from_s_ng_ran_node_e_>().to_string());
      break;
    case types::from_m_ng_ran_node:
      j.write_str("from-M-NG-RAN-node", "pdcp-data-recovery-required");
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdcp_change_ind_c");
  }
  j.end_obj();
}
SRSASN_CODE pdcp_change_ind_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::from_s_ng_ran_node:
      HANDLE_CODE(c.get<from_s_ng_ran_node_e_>().pack(bref));
      break;
    case types::from_m_ng_ran_node:
      HANDLE_CODE(c.get<from_m_ng_ran_node_e_>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdcp_change_ind_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdcp_change_ind_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::from_s_ng_ran_node:
      HANDLE_CODE(c.get<from_s_ng_ran_node_e_>().unpack(bref));
      break;
    case types::from_m_ng_ran_node:
      HANDLE_CODE(c.get<from_m_ng_ran_node_e_>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pdcp_change_ind_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdcp_change_ind_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdcp_change_ind_c::from_s_ng_ran_node_opts::to_string() const
{
  static const char* names[] = {"s-ng-ran-node-key-update-required", "pdcp-data-recovery-required"};
  return convert_enum_idx(names, 2, value, "pdcp_change_ind_c::from_s_ng_ran_node_e_");
}

const char* pdcp_change_ind_c::from_m_ng_ran_node_opts::to_string() const
{
  static const char* names[] = {"pdcp-data-recovery-required"};
  return convert_enum_idx(names, 1, value, "pdcp_change_ind_c::from_m_ng_ran_node_e_");
}

const char* pdcp_change_ind_c::types_opts::to_string() const
{
  static const char* names[] = {"from-S-NG-RAN-node", "from-M-NG-RAN-node", "choice-extension"};
  return convert_enum_idx(names, 3, value, "pdcp_change_ind_c::types");
}

// PEIPSassistanceInformation ::= SEQUENCE
SRSASN_CODE pe_ip_sassist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, cnsubgroup_id, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pe_ip_sassist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(cnsubgroup_id, bref, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pe_ip_sassist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("cNsubgroupID", cnsubgroup_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PSCellChangeHistory ::= ENUMERATED
const char* pscell_change_history_opts::to_string() const
{
  static const char* names[] = {"reporting-full-history"};
  return convert_enum_idx(names, 1, value, "pscell_change_history_e");
}

// PSCellHistoryInformationRetrieve ::= ENUMERATED
const char* pscell_history_info_retrieve_opts::to_string() const
{
  static const char* names[] = {"query"};
  return convert_enum_idx(names, 1, value, "pscell_history_info_retrieve_e");
}

// PagingCause ::= ENUMERATED
const char* paging_cause_opts::to_string() const
{
  static const char* names[] = {"voice"};
  return convert_enum_idx(names, 1, value, "paging_cause_e");
}

// PagingDRX ::= ENUMERATED
const char* paging_drx_opts::to_string() const
{
  static const char* names[] = {"v32", "v64", "v128", "v256", "v512", "v1024"};
  return convert_enum_idx(names, 6, value, "paging_drx_e");
}
uint16_t paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {32, 64, 128, 256, 512, 1024};
  return map_enum_number(numbers, 6, value, "paging_drx_e");
}

// PagingPriority ::= ENUMERATED
const char* paging_prio_opts::to_string() const
{
  static const char* names[] = {
      "priolevel1", "priolevel2", "priolevel3", "priolevel4", "priolevel5", "priolevel6", "priolevel7", "priolevel8"};
  return convert_enum_idx(names, 8, value, "paging_prio_e");
}
uint8_t paging_prio_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8};
  return map_enum_number(numbers, 8, value, "paging_prio_e");
}

// RANPagingArea ::= SEQUENCE
SRSASN_CODE ran_paging_area_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(ran_paging_area_choice.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_paging_area_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(ran_paging_area_choice.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ran_paging_area_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.write_fieldname("rANPagingAreaChoice");
  ran_paging_area_choice.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCConfigIndication ::= ENUMERATED
const char* rrc_cfg_ind_opts::to_string() const
{
  static const char* names[] = {"full-config", "delta-config"};
  return convert_enum_idx(names, 2, value, "rrc_cfg_ind_e");
}

// RRCResumeCause ::= ENUMERATED
const char* rrc_resume_cause_opts::to_string() const
{
  static const char* names[] = {"rna-Update"};
  return convert_enum_idx(names, 1, value, "rrc_resume_cause_e");
}

// RegistrationRequest ::= ENUMERATED
const char* regist_request_opts::to_string() const
{
  static const char* names[] = {"start", "stop", "add"};
  return convert_enum_idx(names, 3, value, "regist_request_e");
}

// ReportingPeriodicity ::= ENUMERATED
const char* report_periodicity_opts::to_string() const
{
  static const char* names[] = {
      "half-thousand-ms", "one-thousand-ms", "two-thousand-ms", "five-thousand-ms", "ten-thousand-ms"};
  return convert_enum_idx(names, 5, value, "report_periodicity_e");
}
float report_periodicity_opts::to_number() const
{
  static const float numbers[] = {0.5, 1.0, 2.0, 5.0};
  return map_enum_number(numbers, 4, value, "report_periodicity_e");
}
const char* report_periodicity_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.5", "1", "2", "5"};
  return convert_enum_idx(number_strs, 5, value, "report_periodicity_e");
}

// ResetRequestTypeInfo ::= CHOICE
void reset_request_type_info_c::destroy_()
{
  switch (type_) {
    case types::full_reset:
      c.destroy<reset_request_type_info_full_s>();
      break;
    case types::partial_reset:
      c.destroy<reset_request_type_info_partial_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void reset_request_type_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::full_reset:
      c.init<reset_request_type_info_full_s>();
      break;
    case types::partial_reset:
      c.init<reset_request_type_info_partial_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_request_type_info_c");
  }
}
reset_request_type_info_c::reset_request_type_info_c(const reset_request_type_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::full_reset:
      c.init(other.c.get<reset_request_type_info_full_s>());
      break;
    case types::partial_reset:
      c.init(other.c.get<reset_request_type_info_partial_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_request_type_info_c");
  }
}
reset_request_type_info_c& reset_request_type_info_c::operator=(const reset_request_type_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::full_reset:
      c.set(other.c.get<reset_request_type_info_full_s>());
      break;
    case types::partial_reset:
      c.set(other.c.get<reset_request_type_info_partial_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_request_type_info_c");
  }

  return *this;
}
reset_request_type_info_full_s& reset_request_type_info_c::set_full_reset()
{
  set(types::full_reset);
  return c.get<reset_request_type_info_full_s>();
}
reset_request_type_info_partial_s& reset_request_type_info_c::set_partial_reset()
{
  set(types::partial_reset);
  return c.get<reset_request_type_info_partial_s>();
}
protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>& reset_request_type_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>();
}
void reset_request_type_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::full_reset:
      j.write_fieldname("fullReset");
      c.get<reset_request_type_info_full_s>().to_json(j);
      break;
    case types::partial_reset:
      j.write_fieldname("partialReset");
      c.get<reset_request_type_info_partial_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reset_request_type_info_c");
  }
  j.end_obj();
}
SRSASN_CODE reset_request_type_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::full_reset:
      HANDLE_CODE(c.get<reset_request_type_info_full_s>().pack(bref));
      break;
    case types::partial_reset:
      HANDLE_CODE(c.get<reset_request_type_info_partial_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_request_type_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_request_type_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::full_reset:
      HANDLE_CODE(c.get<reset_request_type_info_full_s>().unpack(bref));
      break;
    case types::partial_reset:
      HANDLE_CODE(c.get<reset_request_type_info_partial_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_request_type_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_request_type_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reset_request_type_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fullReset", "partialReset", "choice-extension"};
  return convert_enum_idx(names, 3, value, "reset_request_type_info_c::types");
}

// ResetResponseTypeInfo ::= CHOICE
void reset_resp_type_info_c::destroy_()
{
  switch (type_) {
    case types::full_reset:
      c.destroy<reset_resp_type_info_full_s>();
      break;
    case types::partial_reset:
      c.destroy<reset_resp_type_info_partial_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void reset_resp_type_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::full_reset:
      c.init<reset_resp_type_info_full_s>();
      break;
    case types::partial_reset:
      c.init<reset_resp_type_info_partial_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_resp_type_info_c");
  }
}
reset_resp_type_info_c::reset_resp_type_info_c(const reset_resp_type_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::full_reset:
      c.init(other.c.get<reset_resp_type_info_full_s>());
      break;
    case types::partial_reset:
      c.init(other.c.get<reset_resp_type_info_partial_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_resp_type_info_c");
  }
}
reset_resp_type_info_c& reset_resp_type_info_c::operator=(const reset_resp_type_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::full_reset:
      c.set(other.c.get<reset_resp_type_info_full_s>());
      break;
    case types::partial_reset:
      c.set(other.c.get<reset_resp_type_info_partial_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_resp_type_info_c");
  }

  return *this;
}
reset_resp_type_info_full_s& reset_resp_type_info_c::set_full_reset()
{
  set(types::full_reset);
  return c.get<reset_resp_type_info_full_s>();
}
reset_resp_type_info_partial_s& reset_resp_type_info_c::set_partial_reset()
{
  set(types::partial_reset);
  return c.get<reset_resp_type_info_partial_s>();
}
protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>& reset_resp_type_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>();
}
void reset_resp_type_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::full_reset:
      j.write_fieldname("fullReset");
      c.get<reset_resp_type_info_full_s>().to_json(j);
      break;
    case types::partial_reset:
      j.write_fieldname("partialReset");
      c.get<reset_resp_type_info_partial_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reset_resp_type_info_c");
  }
  j.end_obj();
}
SRSASN_CODE reset_resp_type_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::full_reset:
      HANDLE_CODE(c.get<reset_resp_type_info_full_s>().pack(bref));
      break;
    case types::partial_reset:
      HANDLE_CODE(c.get<reset_resp_type_info_partial_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_resp_type_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_resp_type_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::full_reset:
      HANDLE_CODE(c.get<reset_resp_type_info_full_s>().unpack(bref));
      break;
    case types::partial_reset:
      HANDLE_CODE(c.get<reset_resp_type_info_partial_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_resp_type_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_resp_type_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reset_resp_type_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fullReset", "partialReset", "choice-extension"};
  return convert_enum_idx(names, 3, value, "reset_resp_type_info_c::types");
}

// S-NG-RANnode-Addition-Trigger-Ind ::= ENUMERATED
const char* s_ng_ra_nnode_addition_trigger_ind_opts::to_string() const
{
  static const char* names[] = {"sn-change", "inter-MN-HO", "intra-MN-HO"};
  return convert_enum_idx(names, 3, value, "s_ng_ra_nnode_addition_trigger_ind_e");
}

// SCGActivationRequest ::= ENUMERATED
const char* scg_activation_request_opts::to_string() const
{
  static const char* names[] = {"activate-scg", "deactivate-scg"};
  return convert_enum_idx(names, 2, value, "scg_activation_request_e");
}

// SCGActivationStatus ::= ENUMERATED
const char* scg_activation_status_opts::to_string() const
{
  static const char* names[] = {"scg-activated", "scg-deactivated"};
  return convert_enum_idx(names, 2, value, "scg_activation_status_e");
}

// SCGConfigurationQuery ::= ENUMERATED
const char* scg_cfg_query_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "scg_cfg_query_e");
}

// SCGIndicator ::= ENUMERATED
const char* scg_ind_opts::to_string() const
{
  static const char* names[] = {"released"};
  return convert_enum_idx(names, 1, value, "scg_ind_e");
}

// SCGUEHistoryInformation ::= SEQUENCE
SRSASN_CODE scg_ue_history_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(last_visited_pscell_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (last_visited_pscell_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, last_visited_pscell_list, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE scg_ue_history_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool last_visited_pscell_list_present;
  HANDLE_CODE(bref.unpack(last_visited_pscell_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (last_visited_pscell_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(last_visited_pscell_list, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void scg_ue_history_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (last_visited_pscell_list.size() > 0) {
    j.start_array("lastVisitedPSCellList");
    for (const auto& e1 : last_visited_pscell_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SCGreconfigNotification ::= ENUMERATED
const char* sc_grecfg_notif_opts::to_string() const
{
  static const char* names[] = {"executed", "executed-deleted", "deleted"};
  return convert_enum_idx(names, 3, value, "sc_grecfg_notif_e");
}

// SDT-Termination-Request ::= ENUMERATED
const char* sdt_termination_request_opts::to_string() const
{
  static const char* names[] = {"radio-link-problem", "normal"};
  return convert_enum_idx(names, 2, value, "sdt_termination_request_e");
}

// SDTPartialUEContextInfo ::= SEQUENCE
SRSASN_CODE sdt_partial_ue_context_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drbs_to_be_setup.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (drbs_to_be_setup.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_be_setup, 1, 32, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, srbs_to_be_setup, 1, 5, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_partial_ue_context_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool drbs_to_be_setup_present;
  HANDLE_CODE(bref.unpack(drbs_to_be_setup_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (drbs_to_be_setup_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_be_setup, bref, 1, 32, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(srbs_to_be_setup, bref, 1, 5, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_partial_ue_context_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (drbs_to_be_setup.size() > 0) {
    j.start_array("dRBsToBeSetup");
    for (const auto& e1 : drbs_to_be_setup) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.start_array("sRBsToBeSetup");
  for (const auto& e1 : srbs_to_be_setup) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SDTSupportRequest ::= SEQUENCE
SRSASN_CODE sdt_support_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sdt_assistant_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sdtind.pack(bref));
  if (sdt_assistant_info_present) {
    HANDLE_CODE(sdt_assistant_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_support_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(sdt_assistant_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sdtind.unpack(bref));
  if (sdt_assistant_info_present) {
    HANDLE_CODE(sdt_assistant_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_support_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sdtindicator", "true");
  if (sdt_assistant_info_present) {
    j.write_str("sdtAssistantInfo", sdt_assistant_info.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SNTriggered ::= ENUMERATED
const char* sn_triggered_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sn_triggered_e");
}

// SplitSRBsTypes ::= ENUMERATED
const char* split_srbs_types_opts::to_string() const
{
  static const char* names[] = {"srb1", "srb2", "srb1and2"};
  return convert_enum_idx(names, 3, value, "split_srbs_types_e");
}

// TNLConfigurationInfo ::= SEQUENCE
SRSASN_CODE tnl_cfg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(extended_up_transport_layer_addresses_to_add.size() > 0, 1));
  HANDLE_CODE(bref.pack(extended_up_transport_layer_addresses_to_rem.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (extended_up_transport_layer_addresses_to_add.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_up_transport_layer_addresses_to_add, 1, 16, true));
  }
  if (extended_up_transport_layer_addresses_to_rem.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_up_transport_layer_addresses_to_rem, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_cfg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool extended_up_transport_layer_addresses_to_add_present;
  HANDLE_CODE(bref.unpack(extended_up_transport_layer_addresses_to_add_present, 1));
  bool extended_up_transport_layer_addresses_to_rem_present;
  HANDLE_CODE(bref.unpack(extended_up_transport_layer_addresses_to_rem_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (extended_up_transport_layer_addresses_to_add_present) {
    HANDLE_CODE(unpack_dyn_seq_of(extended_up_transport_layer_addresses_to_add, bref, 1, 16, true));
  }
  if (extended_up_transport_layer_addresses_to_rem_present) {
    HANDLE_CODE(unpack_dyn_seq_of(extended_up_transport_layer_addresses_to_rem, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_up_transport_layer_addresses_to_add.size() > 0) {
    j.start_array("extendedUPTransportLayerAddressesToAdd");
    for (const auto& e1 : extended_up_transport_layer_addresses_to_add) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (extended_up_transport_layer_addresses_to_rem.size() > 0) {
    j.start_array("extendedUPTransportLayerAddressesToRemove");
    for (const auto& e1 : extended_up_transport_layer_addresses_to_rem) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TimeToWait ::= ENUMERATED
const char* time_to_wait_opts::to_string() const
{
  static const char* names[] = {"v1s", "v2s", "v5s", "v10s", "v20s", "v60s"};
  return convert_enum_idx(names, 6, value, "time_to_wait_e");
}
uint8_t time_to_wait_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 5, 10, 20, 60};
  return map_enum_number(numbers, 6, value, "time_to_wait_e");
}

// UEContextID ::= CHOICE
void ue_context_id_c::destroy_()
{
  switch (type_) {
    case types::rrc_resume:
      c.destroy<ue_context_id_for_rrc_resume_s>();
      break;
    case types::rrrc_reest:
      c.destroy<ue_context_id_for_rrc_reest_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_context_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rrc_resume:
      c.init<ue_context_id_for_rrc_resume_s>();
      break;
    case types::rrrc_reest:
      c.init<ue_context_id_for_rrc_reest_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_id_c");
  }
}
ue_context_id_c::ue_context_id_c(const ue_context_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rrc_resume:
      c.init(other.c.get<ue_context_id_for_rrc_resume_s>());
      break;
    case types::rrrc_reest:
      c.init(other.c.get<ue_context_id_for_rrc_reest_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_id_c");
  }
}
ue_context_id_c& ue_context_id_c::operator=(const ue_context_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rrc_resume:
      c.set(other.c.get<ue_context_id_for_rrc_resume_s>());
      break;
    case types::rrrc_reest:
      c.set(other.c.get<ue_context_id_for_rrc_reest_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_id_c");
  }

  return *this;
}
ue_context_id_for_rrc_resume_s& ue_context_id_c::set_rrc_resume()
{
  set(types::rrc_resume);
  return c.get<ue_context_id_for_rrc_resume_s>();
}
ue_context_id_for_rrc_reest_s& ue_context_id_c::set_rrrc_reest()
{
  set(types::rrrc_reest);
  return c.get<ue_context_id_for_rrc_reest_s>();
}
protocol_ie_single_container_s<ue_context_id_ext_ies_o>& ue_context_id_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>();
}
void ue_context_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rrc_resume:
      j.write_fieldname("rRCResume");
      c.get<ue_context_id_for_rrc_resume_s>().to_json(j);
      break;
    case types::rrrc_reest:
      j.write_fieldname("rRRCReestablishment");
      c.get<ue_context_id_for_rrc_reest_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::rrc_resume:
      HANDLE_CODE(c.get<ue_context_id_for_rrc_resume_s>().pack(bref));
      break;
    case types::rrrc_reest:
      HANDLE_CODE(c.get<ue_context_id_for_rrc_reest_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::rrc_resume:
      HANDLE_CODE(c.get<ue_context_id_for_rrc_resume_s>().unpack(bref));
      break;
    case types::rrrc_reest:
      HANDLE_CODE(c.get<ue_context_id_for_rrc_reest_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_context_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_id_c::types_opts::to_string() const
{
  static const char* names[] = {"rRCResume", "rRRCReestablishment", "choice-extension"};
  return convert_enum_idx(names, 3, value, "ue_context_id_c::types");
}

template struct asn1::protocol_ext_field_s<ue_context_info_retr_ue_ctxt_resp_ext_ies_o>;

SRSASN_CODE ue_context_info_retr_ue_ctxt_resp_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += five_gc_mob_restrict_list_container_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += mbs_session_info_list_present ? 1 : 0;
  nof_ies += no_pdu_session_ind_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += positioning_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (five_gc_mob_restrict_list_container_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)155, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_gc_mob_restrict_list_container.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)172, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bit_rate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)171, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bit_rate.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)227, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (mbs_session_info_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)273, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_info_list, 1, 256, true));
  }
  if (no_pdu_session_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(no_pdu_session_ind.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)358, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }
  if (positioning_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)360, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(positioning_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_info_retr_ue_ctxt_resp_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 155: {
        five_gc_mob_restrict_list_container_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_gc_mob_restrict_list_container.unpack(bref));
        break;
      }
      case 172: {
        nr_ue_sidelink_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 171: {
        lte_ue_sidelink_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 227: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 273: {
        mbs_session_info_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_info_list, bref, 1, 256, true));
        break;
      }
      case 298: {
        no_pdu_session_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(no_pdu_session_ind.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 358: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      case 360: {
        positioning_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(positioning_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ue_context_info_retr_ue_ctxt_resp_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (five_gc_mob_restrict_list_container_present) {
    j.write_int("id", 155);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", five_gc_mob_restrict_list_container.to_string());
  }
  if (nr_ue_sidelink_aggr_max_bit_rate_present) {
    j.write_int("id", 172);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bit_rate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bit_rate_present) {
    j.write_int("id", 171);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bit_rate.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 227);
    j.write_str("criticality", "reject");
    j.write_str("Extension", ue_radio_cap_id.to_string());
  }
  if (mbs_session_info_list_present) {
    j.write_int("id", 273);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_session_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (no_pdu_session_ind_present) {
    j.write_int("id", 298);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 358);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (positioning_info_present) {
    j.write_int("id", 360);
    j.write_str("criticality", "ignore");
    positioning_info.to_json(j);
  }
  j.end_obj();
}

// UEContextInfoRetrUECtxtResp ::= SEQUENCE
SRSASN_CODE ue_context_info_retr_ue_ctxt_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mob_restrict_list_present, 1));
  HANDLE_CODE(bref.pack(idx_to_rat_freq_sel_prio_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, ng_c_ue_sig_ref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  HANDLE_CODE(sig_tnl_at_source.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(security_info.pack(bref));
  HANDLE_CODE(ue_ambr.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_to_be_setup_list, 1, 256, true));
  HANDLE_CODE(rrc_context.pack(bref));
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (idx_to_rat_freq_sel_prio_present) {
    HANDLE_CODE(pack_integer(bref, idx_to_rat_freq_sel_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_info_retr_ue_ctxt_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mob_restrict_list_present, 1));
  HANDLE_CODE(bref.unpack(idx_to_rat_freq_sel_prio_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(ng_c_ue_sig_ref, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  HANDLE_CODE(sig_tnl_at_source.unpack(bref));
  HANDLE_CODE(ue_security_cap.unpack(bref));
  HANDLE_CODE(security_info.unpack(bref));
  HANDLE_CODE(ue_ambr.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_to_be_setup_list, bref, 1, 256, true));
  HANDLE_CODE(rrc_context.unpack(bref));
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.unpack(bref));
  }
  if (idx_to_rat_freq_sel_prio_present) {
    HANDLE_CODE(unpack_integer(idx_to_rat_freq_sel_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_info_retr_ue_ctxt_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("ng-c-UE-signalling-ref", ng_c_ue_sig_ref);
  j.write_fieldname("signalling-TNL-at-source");
  sig_tnl_at_source.to_json(j);
  j.write_fieldname("ueSecurityCapabilities");
  ue_security_cap.to_json(j);
  j.write_fieldname("securityInformation");
  security_info.to_json(j);
  j.write_fieldname("ue-AMBR");
  ue_ambr.to_json(j);
  j.start_array("pduSessionResourcesToBeSetup-List");
  for (const auto& e1 : pdu_session_res_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("rrc-Context", rrc_context.to_string());
  if (mob_restrict_list_present) {
    j.write_fieldname("mobilityRestrictionList");
    mob_restrict_list.to_json(j);
  }
  if (idx_to_rat_freq_sel_prio_present) {
    j.write_int("indexToRatFrequencySelectionPriority", idx_to_rat_freq_sel_prio);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UEIdentityIndexValue ::= CHOICE
void ue_id_idx_value_c::destroy_()
{
  switch (type_) {
    case types::idx_len10:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_id_idx_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::idx_len10:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c::ue_id_idx_value_c(const ue_id_idx_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::idx_len10:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c& ue_id_idx_value_c::operator=(const ue_id_idx_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::idx_len10:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }

  return *this;
}
fixed_bitstring<10, false, true>& ue_id_idx_value_c::set_idx_len10()
{
  set(types::idx_len10);
  return c.get<fixed_bitstring<10, false, true>>();
}
protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>& ue_id_idx_value_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
}
void ue_id_idx_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::idx_len10:
      j.write_str("indexLength10", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_id_idx_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_id_idx_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_id_idx_value_c::types_opts::to_string() const
{
  static const char* names[] = {"indexLength10", "choice-extension"};
  return convert_enum_idx(names, 2, value, "ue_id_idx_value_c::types");
}
uint8_t ue_id_idx_value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {10};
  return map_enum_number(numbers, 1, value, "ue_id_idx_value_c::types");
}

// UERANPagingIdentity ::= CHOICE
void ue_ran_paging_id_c::destroy_()
{
  switch (type_) {
    case types::i_rnti_full:
      c.destroy<fixed_bitstring<40, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_ran_paging_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::i_rnti_full:
      c.init<fixed_bitstring<40, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ran_paging_id_c");
  }
}
ue_ran_paging_id_c::ue_ran_paging_id_c(const ue_ran_paging_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::i_rnti_full:
      c.init(other.c.get<fixed_bitstring<40, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ran_paging_id_c");
  }
}
ue_ran_paging_id_c& ue_ran_paging_id_c::operator=(const ue_ran_paging_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::i_rnti_full:
      c.set(other.c.get<fixed_bitstring<40, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ran_paging_id_c");
  }

  return *this;
}
fixed_bitstring<40, false, true>& ue_ran_paging_id_c::set_i_rnti_full()
{
  set(types::i_rnti_full);
  return c.get<fixed_bitstring<40, false, true>>();
}
protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>& ue_ran_paging_id_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>();
}
void ue_ran_paging_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::i_rnti_full:
      j.write_str("i-RNTI-full", c.get<fixed_bitstring<40, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_ran_paging_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_ran_paging_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::i_rnti_full:
      HANDLE_CODE((c.get<fixed_bitstring<40, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_ran_paging_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_ran_paging_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::i_rnti_full:
      HANDLE_CODE((c.get<fixed_bitstring<40, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_ran_paging_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_ran_paging_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_ran_paging_id_c::types_opts::to_string() const
{
  static const char* names[] = {"i-RNTI-full", "choice-extension"};
  return convert_enum_idx(names, 2, value, "ue_ran_paging_id_c::types");
}

// UERadioCapabilityForPaging ::= SEQUENCE
SRSASN_CODE ue_radio_cap_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_radio_cap_for_paging_of_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(ue_radio_cap_for_paging_of_eutra.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ue_radio_cap_for_paging_of_nr.size() > 0) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_nr.pack(bref));
  }
  if (ue_radio_cap_for_paging_of_eutra.size() > 0) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_eutra.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ue_radio_cap_for_paging_of_nr_present;
  HANDLE_CODE(bref.unpack(ue_radio_cap_for_paging_of_nr_present, 1));
  bool ue_radio_cap_for_paging_of_eutra_present;
  HANDLE_CODE(bref.unpack(ue_radio_cap_for_paging_of_eutra_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ue_radio_cap_for_paging_of_nr_present) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_nr.unpack(bref));
  }
  if (ue_radio_cap_for_paging_of_eutra_present) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_eutra.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_radio_cap_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_radio_cap_for_paging_of_nr.size() > 0) {
    j.write_str("uERadioCapabilityForPagingOfNR", ue_radio_cap_for_paging_of_nr.to_string());
  }
  if (ue_radio_cap_for_paging_of_eutra.size() > 0) {
    j.write_str("uERadioCapabilityForPagingOfEUTRA", ue_radio_cap_for_paging_of_eutra.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}
