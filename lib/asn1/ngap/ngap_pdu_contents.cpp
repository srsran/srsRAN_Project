/*
 *
 * Copyright 2021-2024 Software Radio Systems Limited
 *
 * This file is part of srsRAN.
 *
 * srsRAN is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsRAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srsran/asn1/ngap/ngap_pdu_contents.h"
using namespace asn1;
using namespace asn1::ngap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// AMFCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  return map_enum_number(names, 4, idx, "id");
}
bool amf_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cp_relocation_ind_ies_o::value_c amf_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::s_nssai:
      c = s_nssai_s{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
void amf_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cp_relocation_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "S-NSSAI", "AllowedNSSAI"};
  return convert_enum_idx(names, 4, value, "amf_cp_relocation_ind_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<amf_cp_relocation_ind_ies_o>;

SRSASN_CODE amf_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (s_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 148: {
        s_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (s_nssai_present) {
    j.write_int("id", 148);
    j.write_str("criticality", "ignore");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// AMFConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool amf_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 6:
      return crit_e::ignore;
    case 7:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ies_o::value_c amf_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 6:
      ret.set(value_c::types::amf_tnl_assoc_to_add_list);
      break;
    case 7:
      ret.set(value_c::types::amf_tnl_assoc_to_rem_list);
      break;
    case 8:
      ret.set(value_c::types::amf_tnl_assoc_to_upd_list);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::optional;
    case 96:
      return presence_e::optional;
    case 86:
      return presence_e::optional;
    case 80:
      return presence_e::optional;
    case 6:
      return presence_e::optional;
    case 7:
      return presence_e::optional;
    case 8:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c = printable_string<1, 150, true, true>{};
      break;
    case types::served_guami_list:
      c = served_guami_list_l{};
      break;
    case types::relative_amf_capacity:
      c = uint16_t{};
      break;
    case types::plmn_support_list:
      c = plmn_support_list_l{};
      break;
    case types::amf_tnl_assoc_to_add_list:
      c = amf_tnl_assoc_to_add_list_l{};
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c = amf_tnl_assoc_to_rem_list_l{};
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c = amf_tnl_assoc_to_upd_list_l{};
      break;
    case types::extended_amf_name:
      c = extended_amf_name_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
}
printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
const amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
const amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
const extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void amf_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_add_list:
      j.start_array("AMF-TNLAssociationToAddList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_add_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      j.start_array("AMF-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      j.start_array("AMF-TNLAssociationToUpdateList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_upd_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_add_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_upd_list_l>(), 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_add_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_upd_list_l>(), bref, 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cfg_upd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PrintableString",
                                "ServedGUAMIList",
                                "INTEGER (0..255)",
                                "PLMNSupportList",
                                "AMF-TNLAssociationToAddList",
                                "AMF-TNLAssociationToRemoveList",
                                "AMF-TNLAssociationToUpdateList",
                                "Extended-AMFName"};
  return convert_enum_idx(names, 8, value, "amf_cfg_upd_ies_o::value_c::types");
}
uint8_t amf_cfg_upd_ies_o::value_c::types_opts::to_number() const
{
  if (value == relative_amf_capacity) {
    return 0;
  }
  invalid_enum_number(value, "amf_cfg_upd_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<amf_cfg_upd_ies_o>;

SRSASN_CODE amf_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_name_present ? 1 : 0;
  nof_ies += served_guami_list_present ? 1 : 0;
  nof_ies += relative_amf_capacity_present ? 1 : 0;
  nof_ies += plmn_support_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_add_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_upd_list_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)1, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_name.pack(bref));
  }
  if (served_guami_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)96, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, served_guami_list, 1, 256, true));
  }
  if (relative_amf_capacity_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)86, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, relative_amf_capacity, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (plmn_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)80, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, plmn_support_list, 1, 12, true));
  }
  if (amf_tnl_assoc_to_add_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)6, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_to_add_list, 1, 32, true));
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)7, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_to_rem_list, 1, 32, true));
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)8, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_to_upd_list, 1, 32, true));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)274, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 1: {
        amf_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.unpack(bref));
        break;
      }
      case 96: {
        served_guami_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(served_guami_list, bref, 1, 256, true));
        break;
      }
      case 86: {
        relative_amf_capacity_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(relative_amf_capacity, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 80: {
        plmn_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(plmn_support_list, bref, 1, 12, true));
        break;
      }
      case 6: {
        amf_tnl_assoc_to_add_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_to_add_list, bref, 1, 32, true));
        break;
      }
      case 7: {
        amf_tnl_assoc_to_rem_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_to_rem_list, bref, 1, 32, true));
        break;
      }
      case 8: {
        amf_tnl_assoc_to_upd_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_to_upd_list, bref, 1, 32, true));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_name_present) {
    j.write_int("id", 1);
    j.write_str("criticality", "reject");
    j.write_str("Value", amf_name.to_string());
  }
  if (served_guami_list_present) {
    j.write_int("id", 96);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : served_guami_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (relative_amf_capacity_present) {
    j.write_int("id", 86);
    j.write_str("criticality", "ignore");
    j.write_int("Value", relative_amf_capacity);
  }
  if (plmn_support_list_present) {
    j.write_int("id", 80);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : plmn_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_to_add_list_present) {
    j.write_int("id", 6);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_to_add_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    j.write_int("id", 7);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_to_rem_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    j.write_int("id", 8);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_to_upd_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (extended_amf_name_present) {
    j.write_int("id", 274);
    j.write_str("criticality", "ignore");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {5, 4, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {5, 4, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 5:
      return crit_e::ignore;
    case 4:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ack_ies_o::value_c amf_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 5:
      ret.set(value_c::types::amf_tnl_assoc_setup_list);
      break;
    case 4:
      ret.set(value_c::types::amf_tnl_assoc_failed_to_setup_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 5:
      return presence_e::optional;
    case 4:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ack_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c = amf_tnl_assoc_setup_list_l{};
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c = tnl_assoc_list_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
}
amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
const tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
const crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      j.start_array("AMF-TNLAssociationSetupList");
      for (const auto& e1 : c.get<amf_tnl_assoc_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      j.start_array("TNLAssociationList");
      for (const auto& e1 : c.get<tnl_assoc_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_setup_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tnl_assoc_list_l>(), 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_setup_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tnl_assoc_list_l>(), bref, 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cfg_upd_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"AMF-TNLAssociationSetupList", "TNLAssociationList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "amf_cfg_upd_ack_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<amf_cfg_upd_ack_ies_o>;

SRSASN_CODE amf_cfg_upd_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_tnl_assoc_setup_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_failed_to_setup_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_tnl_assoc_setup_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)5, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_setup_list, 1, 32, true));
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)4, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_failed_to_setup_list, 1, 32, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 5: {
        amf_tnl_assoc_setup_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_setup_list, bref, 1, 32, true));
        break;
      }
      case 4: {
        amf_tnl_assoc_failed_to_setup_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_failed_to_setup_list, bref, 1, 32, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_tnl_assoc_setup_list_present) {
    j.write_int("id", 5);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    j.write_int("id", 4);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_failed_to_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_fail_ies_o::value_c amf_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cause:
      c = cause_c{};
      break;
    case types::time_to_wait:
      c = time_to_wait_e{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
}
cause_c& amf_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& amf_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cfg_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "amf_cfg_upd_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<amf_cfg_upd_fail_ies_o>;

SRSASN_CODE amf_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (time_to_wait_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)107, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_int("id", 107);
    j.write_str("criticality", "ignore");
    j.write_str("Value", time_to_wait.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// AMFStatusIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_status_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {120};
  return map_enum_number(names, 1, idx, "id");
}
bool amf_status_ind_ies_o::is_id_valid(const uint32_t& id)
{
  return 120 == id;
}
crit_e amf_status_ind_ies_o::get_crit(const uint32_t& id)
{
  if (id == 120) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
amf_status_ind_ies_o::value_c amf_status_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 120) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_status_ind_ies_o::get_presence(const uint32_t& id)
{
  if (id == 120) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void amf_status_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("UnavailableGUAMIList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE amf_status_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 256, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_status_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 256, true));
  return SRSASN_SUCCESS;
}

const char* amf_status_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UnavailableGUAMIList"};
  return convert_enum_idx(names, 1, value, "amf_status_ind_ies_o::value_c::types");
}

// BroadcastSessionModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 348:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_fail_ies_o::value_c broadcast_session_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 348:
      ret.set(value_c::types::mbs_session_mod_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 348:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_session_mod_fail_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer()
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer() const
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_mod_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "broadcast_session_mod_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_mod_fail_ies_o>;

SRSASN_CODE broadcast_session_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_mod_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_mod_fail_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)348, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_mod_fail_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 348: {
        mbs_session_mod_fail_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_fail_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_fail_transfer_present) {
    j.write_int("id", 348);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_mod_fail_transfer.to_string());
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 349};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 349};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 349:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_request_ies_o::value_c broadcast_session_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 349:
      ret.set(value_c::types::mbs_session_mod_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 349:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_service_area:
      c = mbs_service_area_c{};
      break;
    case types::mbs_session_mod_request_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer()
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer() const
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_mod_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_mod_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "MBS-ServiceArea", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "broadcast_session_mod_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_mod_request_ies_o>;

SRSASN_CODE broadcast_session_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_service_area_present ? 1 : 0;
  nof_ies += mbs_session_mod_request_transfer_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (mbs_session_mod_request_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)349, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_mod_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.unpack(bref));
        break;
      }
      case 349: {
        mbs_session_mod_request_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_int("id", 298);
    j.write_str("criticality", "reject");
    mbs_service_area.to_json(j);
  }
  if (mbs_session_mod_request_transfer_present) {
    j.write_int("id", 349);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_mod_request_transfer.to_string());
  }
  j.end_obj();
}

// BroadcastSessionModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 350, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 350, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 350:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_resp_ies_o::value_c broadcast_session_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 350:
      ret.set(value_c::types::mbs_session_mod_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 350:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_session_mod_resp_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer()
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer() const
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_mod_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "broadcast_session_mod_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_mod_resp_ies_o>;

SRSASN_CODE broadcast_session_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_mod_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_mod_resp_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)350, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_mod_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 350: {
        mbs_session_mod_resp_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_resp_transfer_present) {
    j.write_int("id", 350);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_mod_resp_transfer.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_request_ies_o::value_c broadcast_session_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "Cause"};
  return convert_enum_idx(names, 2, value, "broadcast_session_release_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_release_request_ies_o>;

SRSASN_CODE broadcast_session_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_required_ies_o::value_c
broadcast_session_release_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_required_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_release_required_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "Cause"};
  return convert_enum_idx(names, 2, value, "broadcast_session_release_required_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_release_required_ies_o>;

SRSASN_CODE broadcast_session_release_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 358, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 358, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 358:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_resp_ies_o::value_c broadcast_session_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 358:
      ret.set(value_c::types::mbs_session_release_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 358:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_session_release_resp_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer()
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer() const
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_release_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_release_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "broadcast_session_release_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_release_resp_ies_o>;

SRSASN_CODE broadcast_session_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_release_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_release_resp_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)358, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_release_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 358: {
        mbs_session_release_resp_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_release_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_release_resp_transfer_present) {
    j.write_int("id", 358);
    j.write_str("criticality", "ignore");
    j.write_str("Value", mbs_session_release_resp_transfer.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 314:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_fail_ies_o::value_c broadcast_session_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 314:
      ret.set(value_c::types::mbs_session_setup_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 314:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_session_setup_fail_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer()
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer() const
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "broadcast_session_setup_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_setup_fail_ies_o>;

SRSASN_CODE broadcast_session_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_setup_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_setup_fail_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)314, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_setup_fail_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 314: {
        mbs_session_setup_fail_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_fail_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_fail_transfer_present) {
    j.write_int("id", 314);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_setup_fail_transfer.to_string());
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 148:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 315:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_request_ies_o::value_c broadcast_session_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 315:
      ret.set(value_c::types::mbs_session_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 148:
      return presence_e::mandatory;
    case 298:
      return presence_e::mandatory;
    case 315:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::s_nssai:
      c = s_nssai_s{};
      break;
    case types::mbs_service_area:
      c = mbs_service_area_c{};
      break;
    case types::mbs_session_setup_request_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer()
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>&
broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer() const
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "S-NSSAI", "MBS-ServiceArea", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "broadcast_session_setup_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_setup_request_ies_o>;

SRSASN_CODE broadcast_session_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)315, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_setup_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 148: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 298: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.unpack(bref));
        break;
      }
      case 315: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 148);
  j.write_str("criticality", "reject");
  s_nssai.to_json(j);
  j.write_int("id", 298);
  j.write_str("criticality", "reject");
  mbs_service_area.to_json(j);
  j.write_int("id", 315);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_session_setup_request_transfer.to_string());
  j.end_obj();
}

// BroadcastSessionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 316, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 316, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 316:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_resp_ies_o::value_c broadcast_session_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 316:
      ret.set(value_c::types::mbs_session_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 316:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_session_setup_resp_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
}
mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer()
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "broadcast_session_setup_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_setup_resp_ies_o>;

SRSASN_CODE broadcast_session_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_setup_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_setup_resp_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)316, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_setup_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 316: {
        mbs_session_setup_resp_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_resp_transfer_present) {
    j.write_int("id", 316);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_setup_resp_transfer.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// CellTrafficTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t cell_traffic_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  return map_enum_number(names, 7, idx, "id");
}
bool cell_traffic_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e cell_traffic_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 43:
      return crit_e::ignore;
    case 109:
      return crit_e::ignore;
    case 256:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
cell_traffic_trace_ies_o::value_c cell_traffic_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 43:
      ret.set(value_c::types::ngran_cgi);
      break;
    case 109:
      ret.set(value_c::types::trace_collection_entity_ip_address);
      break;
    case 256:
      ret.set(value_c::types::privacy_ind);
      break;
    case 257:
      ret.set(value_c::types::trace_collection_entity_uri);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cell_traffic_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 43:
      return presence_e::mandatory;
    case 109:
      return presence_e::mandatory;
    case 256:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void cell_traffic_trace_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ngran_trace_id:
      c = fixed_octstring<8, true>{};
      break;
    case types::ngran_cgi:
      c = ngran_cgi_c{};
      break;
    case types::trace_collection_entity_ip_address:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::privacy_ind:
      c = privacy_ind_e{};
      break;
    case types::trace_collection_entity_uri:
      c = visible_string<0, MAX_ASN_STRING_LENGTH, false, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi()
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
bounded_bitstring<1, 160, true, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address()
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind()
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi() const
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
const bounded_bitstring<1, 160, true, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address() const
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind() const
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
void cell_traffic_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::ngran_cgi:
      j.write_fieldname("NGRAN-CGI");
      c.get<ngran_cgi_c>().to_json(j);
      break;
    case types::trace_collection_entity_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::privacy_ind:
      j.write_str("PrivacyIndicator", c.get<privacy_ind_e>().to_string());
      break;
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().pack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().pack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().unpack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().unpack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_traffic_trace_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "NGRAN-CGI",
                                "BIT STRING",
                                "PrivacyIndicator",
                                "VisibleString"};
  return convert_enum_idx(names, 7, value, "cell_traffic_trace_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<cell_traffic_trace_ies_o>;

SRSASN_CODE cell_traffic_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += privacy_ind_present ? 1 : 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)44, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_trace_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)43, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_cgi.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)109, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  }
  if (privacy_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)256, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(privacy_ind.pack(bref));
  }
  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)257, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.unpack(bref));
        break;
      }
      case 43: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_cgi.unpack(bref));
        break;
      }
      case 109: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_ip_address.unpack(bref));
        break;
      }
      case 256: {
        privacy_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(privacy_ind.unpack(bref));
        break;
      }
      case 257: {
        trace_collection_entity_uri_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void cell_traffic_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 44);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ngran_trace_id.to_string());
  j.write_int("id", 43);
  j.write_str("criticality", "ignore");
  ngran_cgi.to_json(j);
  j.write_int("id", 109);
  j.write_str("criticality", "ignore");
  j.write_str("Value", trace_collection_entity_ip_address.to_string());
  if (privacy_ind_present) {
    j.write_int("id", 256);
    j.write_str("criticality", "ignore");
    j.write_str("Value", privacy_ind.to_string());
  }
  if (trace_collection_entity_uri_present) {
    j.write_int("id", 257);
    j.write_str("criticality", "ignore");
    j.write_str("Value", trace_collection_entity_uri.to_string());
  }
  j.end_obj();
}

// ConnectionEstablishmentIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t conn_establishment_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  return map_enum_number(names, 13, idx, "id");
}
bool conn_establishment_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e conn_establishment_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 212:
      return crit_e::ignore;
    case 210:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
conn_establishment_ind_ies_o::value_c conn_establishment_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 212:
      ret.set(value_c::types::dl_cp_security_info);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e conn_establishment_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 212:
      return presence_e::optional;
    case 210:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void conn_establishment_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ue_radio_cap:
      c = unbounded_octstring<true>{};
      break;
    case types::end_ind:
      c = end_ind_e{};
      break;
    case types::s_nssai:
      c = s_nssai_s{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::ue_diff_info:
      c = ue_diff_info_s{};
      break;
    case types::dl_cp_security_info:
      c = dl_cp_security_info_s{};
      break;
    case types::nb_iot_ue_prio:
      c = uint16_t{};
      break;
    case types::enhanced_coverage_restrict:
      c = enhanced_coverage_restrict_e{};
      break;
    case types::ce_mode_brestricted:
      c = ce_mode_brestricted_e{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::masked_imeisv:
      c = fixed_bitstring<64, false, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info()
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info() const
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
const uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void conn_establishment_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::dl_cp_security_info:
      j.write_fieldname("DL-CP-SecurityInformation");
      c.get<dl_cp_security_info_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* conn_establishment_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "EndIndication",
                                "S-NSSAI",
                                "AllowedNSSAI",
                                "UE-DifferentiationInfo",
                                "DL-CP-SecurityInformation",
                                "INTEGER (0..255,...)",
                                "Enhanced-CoverageRestriction",
                                "CEmodeBrestricted",
                                "OCTET STRING",
                                "BIT STRING"};
  return convert_enum_idx(names, 13, value, "conn_establishment_ind_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<conn_establishment_ind_ies_o>;

SRSASN_CODE conn_establishment_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += dl_cp_security_info_present ? 1 : 0;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)226, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (dl_cp_security_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)212, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_cp_security_info.pack(bref));
  }
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)210, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, nb_iot_ue_prio, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 212: {
        dl_cp_security_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_cp_security_info.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(nb_iot_ue_prio, bref, (uint16_t)0u, (uint16_t)255u, true, true));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void conn_establishment_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (end_ind_present) {
    j.write_int("id", 226);
    j.write_str("criticality", "ignore");
    j.write_str("Value", end_ind.to_string());
  }
  if (s_nssai_present) {
    j.write_int("id", 148);
    j.write_str("criticality", "ignore");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (dl_cp_security_info_present) {
    j.write_int("id", 212);
    j.write_str("criticality", "ignore");
    dl_cp_security_info.to_json(j);
  }
  if (nb_iot_ue_prio_present) {
    j.write_int("id", 210);
    j.write_str("criticality", "ignore");
    j.write_int("Value", nb_iot_ue_prio);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.end_obj();
}

// DeactivateTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t deactiv_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44};
  return map_enum_number(names, 3, idx, "id");
}
bool deactiv_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e deactiv_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
deactiv_trace_ies_o::value_c deactiv_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e deactiv_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void deactiv_trace_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ngran_trace_id:
      c = fixed_octstring<8, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
void deactiv_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE deactiv_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* deactiv_trace_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "deactiv_trace_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<deactiv_trace_ies_o>;

SRSASN_CODE deactiv_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)44, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_trace_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void deactiv_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 44);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ngran_trace_id.to_string());
  j.end_obj();
}

// DistributionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 300:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_request_ies_o::value_c distribution_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 300:
      ret.set(value_c::types::mbs_distribution_release_request_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 300:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::mbs_distribution_release_request_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
}
mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer()
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void distribution_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING", "Cause"};
  return convert_enum_idx(names, 4, value, "distribution_release_request_ies_o::value_c::types");
}
uint8_t distribution_release_request_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_release_request_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_release_request_ies_o>;

SRSASN_CODE distribution_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)300, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_release_request_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 300: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_release_request_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 300);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_distribution_release_request_transfer.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// DistributionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_resp_ies_o::value_c distribution_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
}
mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_release_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "distribution_release_resp_ies_o::value_c::types");
}
uint8_t distribution_release_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_release_resp_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_release_resp_ies_o>;

SRSASN_CODE distribution_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool distribution_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 303:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_fail_ies_o::value_c distribution_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 303:
      ret.set(value_c::types::mbs_distribution_setup_unsuccessful_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 303:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
}
mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "distribution_setup_fail_ies_o::value_c::types");
}
uint8_t distribution_setup_fail_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_setup_fail_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_setup_fail_ies_o>;

SRSASN_CODE distribution_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)303, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 303: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 303);
  j.write_str("criticality", "ignore");
  j.write_str("Value", mbs_distribution_setup_unsuccessful_transfer.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 301};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 301};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 301:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_request_ies_o::value_c distribution_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 301:
      ret.set(value_c::types::mbs_distribution_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 301:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::mbs_distribution_setup_request_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
}
mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void distribution_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "distribution_setup_request_ies_o::value_c::types");
}
uint8_t distribution_setup_request_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_setup_request_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_setup_request_ies_o>;

SRSASN_CODE distribution_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)301, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_setup_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 301: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 301);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_distribution_setup_request_transfer.to_string());
  j.end_obj();
}

// DistributionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 302:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_resp_ies_o::value_c distribution_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 302:
      ret.set(value_c::types::mbs_distribution_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 302:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
}
mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "distribution_setup_resp_ies_o::value_c::types");
}
uint8_t distribution_setup_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_setup_resp_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_setup_resp_ies_o>;

SRSASN_CODE distribution_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)302, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_setup_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 302: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 302);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_distribution_setup_resp_transfer.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DownlinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  return map_enum_number(names, 20, idx, "id");
}
bool dl_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 228:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 334:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_nas_transport_ies_o::value_c dl_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 228:
      ret.set(value_c::types::ue_cap_info_request);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 228:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_nas_transport_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::old_amf:
      c = printable_string<1, 150, true, true>{};
      break;
    case types::ran_paging_prio:
      c = uint16_t{};
      break;
    case types::nas_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::mob_restrict_list:
      c = mob_restrict_list_s{};
      break;
    case types::idx_to_rfsp:
      c = uint16_t{};
      break;
    case types::ue_aggr_max_bit_rate:
      c = ue_aggr_max_bit_rate_s{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::srvcc_operation_possible:
      c = srvcc_operation_possible_e{};
      break;
    case types::enhanced_coverage_restrict:
      c = enhanced_coverage_restrict_e{};
      break;
    case types::extended_connected_time:
      c = uint16_t{};
      break;
    case types::ue_diff_info:
      c = ue_diff_info_s{};
      break;
    case types::ce_mode_brestricted:
      c = ce_mode_brestricted_e{};
      break;
    case types::ue_radio_cap:
      c = unbounded_octstring<true>{};
      break;
    case types::ue_cap_info_request:
      c = ue_cap_info_request_e{};
      break;
    case types::end_ind:
      c = end_ind_e{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::target_nssai_info:
      c = target_nssai_info_s{};
      break;
    case types::masked_imeisv:
      c = fixed_bitstring<64, false, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request()
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
end_ind_e& dl_nas_transport_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request() const
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
const end_ind_e& dl_nas_transport_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void dl_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_cap_info_request:
      j.write_str("UECapabilityInfoRequest", "requested");
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_nas_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PrintableString",
                                "INTEGER (1..256)",
                                "OCTET STRING",
                                "MobilityRestrictionList",
                                "INTEGER (1..256,...)",
                                "UEAggregateMaximumBitRate",
                                "AllowedNSSAI",
                                "SRVCCOperationPossible",
                                "Enhanced-CoverageRestriction",
                                "INTEGER (0..255)",
                                "UE-DifferentiationInfo",
                                "CEmodeBrestricted",
                                "OCTET STRING",
                                "UECapabilityInfoRequest",
                                "EndIndication",
                                "OCTET STRING",
                                "TargetNSSAIInformation",
                                "BIT STRING"};
  return convert_enum_idx(names, 20, value, "dl_nas_transport_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_nas_transport_ies_o>;

SRSASN_CODE dl_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_cap_info_request_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (old_amf_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)48, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)36, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)31, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_cap_info_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)228, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_cap_info_request.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)226, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)334, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 48: {
        old_amf_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 228: {
        ue_cap_info_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_cap_info_request.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (old_amf_present) {
    j.write_int("id", 48);
    j.write_str("criticality", "reject");
    j.write_str("Value", old_amf.to_string());
  }
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  j.write_int("id", 38);
  j.write_str("criticality", "reject");
  j.write_str("Value", nas_pdu.to_string());
  if (mob_restrict_list_present) {
    j.write_int("id", 36);
    j.write_str("criticality", "ignore");
    mob_restrict_list.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_int("id", 31);
    j.write_str("criticality", "ignore");
    j.write_int("Value", idx_to_rfsp);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "ignore");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (ue_cap_info_request_present) {
    j.write_int("id", 228);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "requested");
  }
  if (end_ind_present) {
    j.write_int("id", 226);
    j.write_str("criticality", "ignore");
    j.write_str("Value", end_ind.to_string());
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (target_nssai_info_present) {
    j.write_int("id", 334);
    j.write_str("criticality", "ignore");
    target_nssai_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.end_obj();
}

// DownlinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool dl_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c
dl_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c = unbounded_octstring<true>{};
      break;
    case types::nrppa_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_non_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "dl_non_ue_associated_nrppa_transport_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_non_ue_associated_nrppa_transport_ies_o>;

SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

// DownlinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {98, 157, 250};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {98, 157, 250};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 98:
      return crit_e::ignore;
    case 157:
      return crit_e::ignore;
    case 250:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_cfg_transfer_ies_o::value_c dl_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 98:
      ret.set(value_c::types::son_cfg_transfer_dl);
      break;
    case 157:
      ret.set(value_c::types::endc_son_cfg_transfer_dl);
      break;
    case 250:
      ret.set(value_c::types::intersys_son_cfg_transfer_dl);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 98:
      return presence_e::optional;
    case 157:
      return presence_e::optional;
    case 250:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c = son_cfg_transfer_s{};
      break;
    case types::endc_son_cfg_transfer_dl:
      c = unbounded_octstring<true>{};
      break;
    case types::intersys_son_cfg_transfer_dl:
      c = intersys_son_cfg_transfer_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
}
son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl()
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl()
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl()
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl() const
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl() const
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void dl_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_dl:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_dl:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_dl:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ran_cfg_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SONConfigurationTransfer", "OCTET STRING", "IntersystemSONConfigurationTransfer"};
  return convert_enum_idx(names, 3, value, "dl_ran_cfg_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ran_cfg_transfer_ies_o>;

SRSASN_CODE dl_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_dl_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)98, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(son_cfg_transfer_dl.pack(bref));
  }
  if (endc_son_cfg_transfer_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)157, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(endc_son_cfg_transfer_dl.pack(bref));
  }
  if (intersys_son_cfg_transfer_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)250, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(intersys_son_cfg_transfer_dl.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 98: {
        son_cfg_transfer_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_dl.unpack(bref));
        break;
      }
      case 157: {
        endc_son_cfg_transfer_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_dl.unpack(bref));
        break;
      }
      case 250: {
        intersys_son_cfg_transfer_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_dl.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dl_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_dl_present) {
    j.write_int("id", 98);
    j.write_str("criticality", "ignore");
    son_cfg_transfer_dl.to_json(j);
  }
  if (endc_son_cfg_transfer_dl_present) {
    j.write_int("id", 157);
    j.write_str("criticality", "ignore");
    j.write_str("Value", endc_son_cfg_transfer_dl.to_string());
  }
  if (intersys_son_cfg_transfer_dl_present) {
    j.write_int("id", 250);
    j.write_str("criticality", "ignore");
    intersys_son_cfg_transfer_dl.to_json(j);
  }
  j.end_obj();
}

// DownlinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_early_status_transfer_ies_o::value_c dl_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::early_status_transfer_transparent_container:
      c = early_status_transfer_transparent_container_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void dl_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ran_early_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "EarlyStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "dl_ran_early_status_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ran_early_status_transfer_ies_o>;

SRSASN_CODE dl_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)268, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 268);
  j.write_str("criticality", "reject");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// DownlinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_status_transfer_ies_o::value_c dl_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_status_transfer_transparent_container:
      c = ran_status_transfer_transparent_container_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void dl_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ran_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "RANStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "dl_ran_status_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ran_status_transfer_ies_o>;

SRSASN_CODE dl_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)84, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 84);
  j.write_str("criticality", "reject");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// DownlinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool dl_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e dl_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
dl_rim_info_transfer_ies_o::value_c dl_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void dl_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* dl_rim_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"RIMInformationTransfer"};
  return convert_enum_idx(names, 1, value, "dl_rim_info_transfer_ies_o::value_c::types");
}

// DownlinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool dl_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ue_associated_nrppa_transport_ies_o::value_c dl_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::routing_id:
      c = unbounded_octstring<true>{};
      break;
    case types::nrppa_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "dl_ue_associated_nrppa_transport_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ue_associated_nrppa_transport_ies_o>;

SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

// ErrorIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t error_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  return map_enum_number(names, 5, idx, "id");
}
bool error_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e error_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 26:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
error_ind_ies_o::value_c error_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e error_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::optional;
    case 85:
      return presence_e::optional;
    case 15:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 26:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void error_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::five_g_s_tmsi:
      c = five_g_s_tmsi_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& error_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& error_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
void error_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE error_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* error_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics", "FiveG-S-TMSI"};
  return convert_enum_idx(names, 5, value, "error_ind_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<error_ind_ies_o>;

SRSASN_CODE error_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += ran_ue_ngap_id_present ? 1 : 0;
  nof_ies += cause_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (cause_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        amf_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        ran_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        cause_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void error_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_ue_ngap_id_present) {
    j.write_int("id", 10);
    j.write_str("criticality", "ignore");
    j.write_int("Value", amf_ue_ngap_id);
  }
  if (ran_ue_ngap_id_present) {
    j.write_int("id", 85);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_ue_ngap_id);
  }
  if (cause_present) {
    j.write_int("id", 15);
    j.write_str("criticality", "ignore");
    cause.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (five_g_s_tmsi_present) {
    j.write_int("id", 26);
    j.write_str("criticality", "ignore");
    five_g_s_tmsi.to_json(j);
  }
  j.end_obj();
}

// HandoverCancelIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ies_o::value_c ho_cancel_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_cancel_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_cancel_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ho_cancel_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cancel_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause"};
  return convert_enum_idx(names, 3, value, "ho_cancel_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_cancel_ies_o>;

SRSASN_CODE ho_cancel_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// HandoverCancelAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ack_ies_o::value_c ho_cancel_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ack_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cancel_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cancel_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ho_cancel_ack_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_cancel_ack_ies_o>;

SRSASN_CODE ho_cancel_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 39:
      return crit_e::reject;
    case 59:
      return crit_e::ignore;
    case 78:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cmd_ies_o::value_c ho_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 39:
      ret.set(value_c::types::nas_security_params_from_ngran);
      break;
    case 59:
      ret.set(value_c::types::pdu_session_res_ho_list);
      break;
    case 78:
      ret.set(value_c::types::pdu_session_res_to_release_list_ho_cmd);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 39:
      return presence_e::conditional;
    case 59:
      return presence_e::optional;
    case 78:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cmd_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::handov_type:
      c = handov_type_e{};
      break;
    case types::nas_security_params_from_ngran:
      c = unbounded_octstring<true>{};
      break;
    case types::pdu_session_res_ho_list:
      c = pdu_session_res_ho_list_l{};
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c = pdu_session_res_to_release_list_ho_cmd_l{};
      break;
    case types::target_to_source_transparent_container:
      c = unbounded_octstring<true>{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_cmd_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran()
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list()
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_cmd_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran() const
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list() const
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
const pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::nas_security_params_from_ngran:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_ho_list:
      j.start_array("PDUSessionResourceHandoverList");
      for (const auto& e1 : c.get<pdu_session_res_ho_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      j.start_array("PDUSessionResourceToReleaseListHOCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_ho_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_ho_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_ho_cmd_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_ho_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_ho_cmd_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "HandoverType",
                                "OCTET STRING",
                                "PDUSessionResourceHandoverList",
                                "PDUSessionResourceToReleaseListHOCmd",
                                "OCTET STRING",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 8, value, "ho_cmd_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_cmd_ies_o>;

SRSASN_CODE ho_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += nas_security_params_from_ngran_present ? 1 : 0;
  nof_ies += pdu_session_res_ho_list_present ? 1 : 0;
  nof_ies += pdu_session_res_to_release_list_ho_cmd_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)29, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(handov_type.pack(bref));
  }
  if (nas_security_params_from_ngran_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)39, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_security_params_from_ngran.pack(bref));
  }
  if (pdu_session_res_ho_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)59, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_ho_list, 1, 256, true));
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)78, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_to_release_list_ho_cmd, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)106, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.unpack(bref));
        break;
      }
      case 39: {
        nas_security_params_from_ngran_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_security_params_from_ngran.unpack(bref));
        break;
      }
      case 59: {
        pdu_session_res_ho_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_ho_list, bref, 1, 256, true));
        break;
      }
      case 78: {
        pdu_session_res_to_release_list_ho_cmd_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_to_release_list_ho_cmd, bref, 1, 256, true));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 29);
  j.write_str("criticality", "reject");
  j.write_str("Value", handov_type.to_string());
  if (nas_security_params_from_ngran_present) {
    j.write_int("id", 39);
    j.write_str("criticality", "reject");
    j.write_str("Value", nas_security_params_from_ngran.to_string());
  }
  if (pdu_session_res_ho_list_present) {
    j.write_int("id", 59);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_ho_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    j.write_int("id", 78);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_to_release_list_ho_cmd) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 106);
  j.write_str("criticality", "reject");
  j.write_str("Value", target_to_source_transparent_container.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_fail_ies_o::value_c ho_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::targetto_source_fail_transparent_container:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "Cause", "CriticalityDiagnostics", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "ho_fail_ies_o::value_c::types");
}
uint8_t ho_fail_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "ho_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_fail_ies_o>;

SRSASN_CODE ho_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)262, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_int("id", 262);
    j.write_str("criticality", "ignore");
    j.write_str("Value", targetto_source_fail_transparent_container.to_string());
  }
  j.end_obj();
}

// HandoverNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_notify_ies_o::value_c ho_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 269:
      ret.set(value_c::types::notify_source_ngran_node);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 269:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_notify_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::notify_source_ngran_node:
      c = notify_source_ngran_node_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ho_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node()
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
const uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ho_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node() const
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
void ho_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::notify_source_ngran_node:
      j.write_str("NotifySourceNGRANNode", "notifySource");
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_notify_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "UserLocationInformation", "NotifySourceNGRANNode"};
  return convert_enum_idx(names, 4, value, "ho_notify_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_notify_ies_o>;

SRSASN_CODE ho_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += notify_source_ngran_node_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (notify_source_ngran_node_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)269, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(notify_source_ngran_node.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 269: {
        notify_source_ngran_node_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(notify_source_ngran_node.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  if (notify_source_ngran_node_present) {
    j.write_int("id", 269);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "notifySource");
  }
  j.end_obj();
}

// HandoverPreparationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_prep_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  return map_enum_number(names, 5, idx, "id");
}
bool ho_prep_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_prep_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_prep_fail_ies_o::value_c ho_prep_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_prep_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_prep_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::targetto_source_fail_transparent_container:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_prep_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_prep_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_prep_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_prep_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics", "OCTET STRING"};
  return convert_enum_idx(names, 5, value, "ho_prep_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_prep_fail_ies_o>;

SRSASN_CODE ho_prep_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)262, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_prep_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_int("id", 262);
    j.write_str("criticality", "ignore");
    j.write_str("Value", targetto_source_fail_transparent_container.to_string());
  }
  j.end_obj();
}

// HandoverRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  return map_enum_number(names, 39, idx, "id");
}
bool ho_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 37:
      return crit_e::reject;
    case 73:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 101:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::reject;
    case 205:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 206:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ies_o::value_c ho_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 37:
      ret.set(value_c::types::nasc);
      break;
    case 73:
      ret.set(value_c::types::pdu_session_res_setup_list_ho_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 110:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 119:
      return presence_e::mandatory;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 37:
      return presence_e::optional;
    case 73:
      return presence_e::mandatory;
    case 0:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 101:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::handov_type:
      c = handov_type_e{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::ue_aggr_max_bit_rate:
      c = ue_aggr_max_bit_rate_s{};
      break;
    case types::core_network_assist_info_for_inactive:
      c = core_network_assist_info_for_inactive_s{};
      break;
    case types::ue_security_cap:
      c = ue_security_cap_s{};
      break;
    case types::security_context:
      c = security_context_s{};
      break;
    case types::new_security_context_ind:
      c = new_security_context_ind_e{};
      break;
    case types::nasc:
      c = unbounded_octstring<true>{};
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c = pdu_session_res_setup_list_ho_req_l{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::trace_activation:
      c = trace_activation_s{};
      break;
    case types::masked_imeisv:
      c = fixed_bitstring<64, false, true>{};
      break;
    case types::source_to_target_transparent_container:
      c = unbounded_octstring<true>{};
      break;
    case types::mob_restrict_list:
      c = mob_restrict_list_s{};
      break;
    case types::location_report_request_type:
      c = location_report_request_type_s{};
      break;
    case types::rrc_inactive_transition_report_request:
      c = rrc_inactive_transition_report_request_e{};
      break;
    case types::guami:
      c = guami_s{};
      break;
    case types::redirection_voice_fallback:
      c = redirection_voice_fallback_e{};
      break;
    case types::cn_assisted_ran_tuning:
      c = cn_assisted_ran_tuning_s{};
      break;
    case types::srvcc_operation_possible:
      c = srvcc_operation_possible_e{};
      break;
    case types::iab_authorized:
      c = iab_authorized_e{};
      break;
    case types::enhanced_coverage_restrict:
      c = enhanced_coverage_restrict_e{};
      break;
    case types::ue_diff_info:
      c = ue_diff_info_s{};
      break;
    case types::nr_v2x_services_authorized:
      c = nr_v2x_services_authorized_s{};
      break;
    case types::ltev2x_services_authorized:
      c = ltev2x_services_authorized_s{};
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c = lte_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::pc5_qos_params:
      c = pc5_qos_params_s{};
      break;
    case types::ce_mode_brestricted:
      c = ce_mode_brestricted_e{};
      break;
    case types::ue_up_c_iot_support:
      c = ue_up_c_iot_support_e{};
      break;
    case types::management_based_mdt_plmn_list:
      c = mdt_plmn_list_l{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::extended_connected_time:
      c = uint16_t{};
      break;
    case types::time_sync_assist_info:
      c = time_sync_assist_info_s{};
      break;
    case types::ue_slice_max_bit_rate_list:
      c = ue_slice_max_bit_rate_list_l{};
      break;
    case types::five_g_pro_se_authorized:
      c = five_g_pro_se_authorized_s{};
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c = five_g_pro_se_pc5_qos_params_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_request_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& ho_request_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::nasc()
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
trace_activation_s& ho_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
rrc_inactive_transition_report_request_e& ho_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ho_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ho_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& ho_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_request_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& ho_request_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::nasc() const
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
const allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const trace_activation_s& ho_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const rrc_inactive_transition_report_request_e&
ho_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ho_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ho_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& ho_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ho_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::nasc:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      j.start_array("PDUSessionResourceSetupListHOReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_ho_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_ho_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_ho_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "HandoverType",
                                "Cause",
                                "UEAggregateMaximumBitRate",
                                "CoreNetworkAssistanceInformationForInactive",
                                "UESecurityCapabilities",
                                "SecurityContext",
                                "NewSecurityContextInd",
                                "OCTET STRING",
                                "PDUSessionResourceSetupListHOReq",
                                "AllowedNSSAI",
                                "TraceActivation",
                                "BIT STRING",
                                "OCTET STRING",
                                "MobilityRestrictionList",
                                "LocationReportingRequestType",
                                "RRCInactiveTransitionReportRequest",
                                "GUAMI",
                                "RedirectionVoiceFallback",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "IAB-Authorized",
                                "Enhanced-CoverageRestriction",
                                "UE-DifferentiationInfo",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "CEmodeBrestricted",
                                "UE-UP-CIoT-Support",
                                "MDTPLMNList",
                                "OCTET STRING",
                                "INTEGER (0..255)",
                                "TimeSyncAssistanceInfo",
                                "UESliceMaximumBitRateList",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters"};
  return convert_enum_idx(names, 39, value, "ho_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_request_ies_o>;

SRSASN_CODE ho_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 10;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += nasc_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)29, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(handov_type.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (new_security_context_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)41, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  if (nasc_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)37, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nasc.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)73, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_ho_req, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (trace_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)108, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)101, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)36, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)28, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(guami.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)199, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)254, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_list, 1, 16, true));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 10;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 110: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.unpack(bref));
        break;
      }
      case 37: {
        nasc_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nasc.unpack(bref));
        break;
      }
      case 73: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_ho_req, bref, 1, 256, true));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 108: {
        trace_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_list, bref, 1, 16, true));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 29);
  j.write_str("criticality", "reject");
  j.write_str("Value", handov_type.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.write_int("id", 110);
  j.write_str("criticality", "reject");
  ue_aggr_max_bit_rate.to_json(j);
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_int("id", 119);
  j.write_str("criticality", "reject");
  ue_security_cap.to_json(j);
  j.write_int("id", 93);
  j.write_str("criticality", "reject");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_int("id", 41);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  if (nasc_present) {
    j.write_int("id", 37);
    j.write_str("criticality", "reject");
    j.write_str("Value", nasc.to_string());
  }
  j.write_int("id", 73);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_setup_list_ho_req) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 0);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : allowed_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  if (trace_activation_present) {
    j.write_int("id", 108);
    j.write_str("criticality", "ignore");
    trace_activation.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.write_int("id", 101);
  j.write_str("criticality", "reject");
  j.write_str("Value", source_to_target_transparent_container.to_string());
  if (mob_restrict_list_present) {
    j.write_int("id", 36);
    j.write_str("criticality", "ignore");
    mob_restrict_list.to_json(j);
  }
  if (location_report_request_type_present) {
    j.write_int("id", 33);
    j.write_str("criticality", "ignore");
    location_report_request_type.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  j.write_int("id", 28);
  j.write_str("criticality", "reject");
  guami.to_json(j);
  if (redirection_voice_fallback_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redirection_voice_fallback.to_string());
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (iab_authorized_present) {
    j.write_int("id", 199);
    j.write_str("criticality", "reject");
    j.write_str("Value", iab_authorized.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_up_c_iot_support_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "supported");
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_int("id", 254);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 53:
      return crit_e::ignore;
    case 56:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ack_ies_o::value_c ho_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 53:
      ret.set(value_c::types::pdu_session_res_admitted_list);
      break;
    case 56:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ho_ack);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 53:
      return presence_e::mandatory;
    case 56:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ack_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_admitted_list:
      c = pdu_session_res_admitted_list_l{};
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c = pdu_session_res_failed_to_setup_list_ho_ack_l{};
      break;
    case types::target_to_source_transparent_container:
      c = unbounded_octstring<true>{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::npn_access_info:
      c = npn_access_info_c{};
      break;
    case types::red_cap_ind:
      c = red_cap_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list()
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list() const
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
const pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
const unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void ho_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      j.start_array("PDUSessionResourceAdmittedList");
      for (const auto& e1 : c.get<pdu_session_res_admitted_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      j.start_array("PDUSessionResourceFailedToSetupListHOAck");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_admitted_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_admitted_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceAdmittedList",
                                "PDUSessionResourceFailedToSetupListHOAck",
                                "OCTET STRING",
                                "CriticalityDiagnostics",
                                "NPN-AccessInformation",
                                "RedCapIndication"};
  return convert_enum_idx(names, 8, value, "ho_request_ack_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_request_ack_ies_o>;

SRSASN_CODE ho_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += pdu_session_res_failed_to_setup_list_ho_ack_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)53, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_admitted_list, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)56, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_ho_ack, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)106, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)259, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)333, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 53: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_admitted_list, bref, 1, 256, true));
        break;
      }
      case 56: {
        pdu_session_res_failed_to_setup_list_ho_ack_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_ho_ack, bref, 1, 256, true));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 53);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_admitted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    j.write_int("id", 56);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_ho_ack) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 106);
  j.write_str("criticality", "reject");
  j.write_str("Value", target_to_source_transparent_container.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (npn_access_info_present) {
    j.write_int("id", 259);
    j.write_str("criticality", "reject");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_int("id", 333);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "redcap");
  }
  j.end_obj();
}

// HandoverRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 105:
      return crit_e::reject;
    case 22:
      return crit_e::ignore;
    case 61:
      return crit_e::reject;
    case 101:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_required_ies_o::value_c ho_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 105:
      ret.set(value_c::types::target_id);
      break;
    case 22:
      ret.set(value_c::types::direct_forwarding_path_availability);
      break;
    case 61:
      ret.set(value_c::types::pdu_session_res_list_ho_rqd);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 105:
      return presence_e::mandatory;
    case 22:
      return presence_e::optional;
    case 61:
      return presence_e::mandatory;
    case 101:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_required_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::handov_type:
      c = handov_type_e{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::target_id:
      c = target_id_c{};
      break;
    case types::direct_forwarding_path_availability:
      c = direct_forwarding_path_availability_e{};
      break;
    case types::pdu_session_res_list_ho_rqd:
      c = pdu_session_res_list_ho_rqd_l{};
      break;
    case types::source_to_target_transparent_container:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_required_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
target_id_c& ho_required_ies_o::value_c::target_id()
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd()
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_required_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const target_id_c& ho_required_ies_o::value_c::target_id() const
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
const direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability() const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
const pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd() const
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::target_id:
      j.write_fieldname("TargetID");
      c.get<target_id_c>().to_json(j);
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::pdu_session_res_list_ho_rqd:
      j.start_array("PDUSessionResourceListHORqd");
      for (const auto& e1 : c.get<pdu_session_res_list_ho_rqd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().pack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_ho_rqd_l>(), 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().unpack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_ho_rqd_l>(), bref, 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_required_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "HandoverType",
                                "Cause",
                                "TargetID",
                                "DirectForwardingPathAvailability",
                                "PDUSessionResourceListHORqd",
                                "OCTET STRING"};
  return convert_enum_idx(names, 8, value, "ho_required_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_required_ies_o>;

SRSASN_CODE ho_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 7;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)29, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(handov_type.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)105, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_id.pack(bref));
  }
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)22, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)61, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_list_ho_rqd, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)101, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 7;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 105: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_id.unpack(bref));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.unpack(bref));
        break;
      }
      case 61: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_list_ho_rqd, bref, 1, 256, true));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 29);
  j.write_str("criticality", "reject");
  j.write_str("Value", handov_type.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.write_int("id", 105);
  j.write_str("criticality", "reject");
  target_id.to_json(j);
  if (direct_forwarding_path_availability_present) {
    j.write_int("id", 22);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "direct-path-available");
  }
  j.write_int("id", 61);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_list_ho_rqd) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 101);
  j.write_str("criticality", "reject");
  j.write_str("Value", source_to_target_transparent_container.to_string());
  j.end_obj();
}

// HandoverSuccessIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_success_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ho_success_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_success_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_success_ies_o::value_c ho_success_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_success_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_success_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
}
uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ho_success_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_success_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_success_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)"};
  return convert_enum_idx(names, 2, value, "ho_success_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_success_ies_o>;

SRSASN_CODE ho_success_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_success_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.end_obj();
}

// InitialContextSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 132:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_fail_ies_o::value_c init_context_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 132:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_fail);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 132:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c = pdu_session_res_failed_to_setup_list_cxt_fail_l{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
cause_c& init_context_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
const cause_c& init_context_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      j.start_array("PDUSessionResourceFailedToSetupListCxtFail");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceFailedToSetupListCxtFail",
                                "Cause",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "init_context_setup_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_context_setup_fail_ies_o>;

SRSASN_CODE init_context_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_fail_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)132, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_cxt_fail, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 132: {
        pdu_session_res_failed_to_setup_list_cxt_fail_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_cxt_fail, bref, 1, 256, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    j.write_int("id", 132);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_cxt_fail) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  return map_enum_number(names, 44, idx, "id");
}
bool init_context_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 71:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 119:
      return crit_e::reject;
    case 94:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 36:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 238:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 334:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_request_ies_o::value_c init_context_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 71:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 110:
      return presence_e::conditional;
    case 18:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 71:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 94:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 36:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::old_amf:
      c = printable_string<1, 150, true, true>{};
      break;
    case types::ue_aggr_max_bit_rate:
      c = ue_aggr_max_bit_rate_s{};
      break;
    case types::core_network_assist_info_for_inactive:
      c = core_network_assist_info_for_inactive_s{};
      break;
    case types::guami:
      c = guami_s{};
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c = pdu_session_res_setup_list_cxt_req_l{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::ue_security_cap:
      c = ue_security_cap_s{};
      break;
    case types::security_key:
      c = fixed_bitstring<256, false, true>{};
      break;
    case types::trace_activation:
      c = trace_activation_s{};
      break;
    case types::mob_restrict_list:
      c = mob_restrict_list_s{};
      break;
    case types::ue_radio_cap:
      c = unbounded_octstring<true>{};
      break;
    case types::idx_to_rfsp:
      c = uint16_t{};
      break;
    case types::masked_imeisv:
      c = fixed_bitstring<64, false, true>{};
      break;
    case types::nas_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::emergency_fallback_ind:
      c = emergency_fallback_ind_s{};
      break;
    case types::rrc_inactive_transition_report_request:
      c = rrc_inactive_transition_report_request_e{};
      break;
    case types::ue_radio_cap_for_paging:
      c = ue_radio_cap_for_paging_s{};
      break;
    case types::redirection_voice_fallback:
      c = redirection_voice_fallback_e{};
      break;
    case types::location_report_request_type:
      c = location_report_request_type_s{};
      break;
    case types::cn_assisted_ran_tuning:
      c = cn_assisted_ran_tuning_s{};
      break;
    case types::srvcc_operation_possible:
      c = srvcc_operation_possible_e{};
      break;
    case types::iab_authorized:
      c = iab_authorized_e{};
      break;
    case types::enhanced_coverage_restrict:
      c = enhanced_coverage_restrict_e{};
      break;
    case types::extended_connected_time:
      c = uint16_t{};
      break;
    case types::ue_diff_info:
      c = ue_diff_info_s{};
      break;
    case types::nr_v2x_services_authorized:
      c = nr_v2x_services_authorized_s{};
      break;
    case types::ltev2x_services_authorized:
      c = ltev2x_services_authorized_s{};
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c = lte_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::pc5_qos_params:
      c = pc5_qos_params_s{};
      break;
    case types::ce_mode_brestricted:
      c = ce_mode_brestricted_e{};
      break;
    case types::ue_up_c_iot_support:
      c = ue_up_c_iot_support_e{};
      break;
    case types::rg_level_wireline_access_characteristics:
      c = unbounded_octstring<true>{};
      break;
    case types::management_based_mdt_plmn_list:
      c = mdt_plmn_list_l{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::time_sync_assist_info:
      c = time_sync_assist_info_s{};
      break;
    case types::q_mcc_onfig_info:
      c = q_mcc_onfig_info_s{};
      break;
    case types::target_nssai_info:
      c = target_nssai_info_s{};
      break;
    case types::ue_slice_max_bit_rate_list:
      c = ue_slice_max_bit_rate_list_l{};
      break;
    case types::five_g_pro_se_authorized:
      c = five_g_pro_se_authorized_s{};
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c = five_g_pro_se_pc5_qos_params_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
guami_s& init_context_setup_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
pdu_session_res_setup_list_cxt_req_l& init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const guami_s& init_context_setup_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const pdu_session_res_setup_list_cxt_req_l&
init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
const allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>&
init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void init_context_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      j.start_array("PDUSessionResourceSetupListCxtReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PrintableString",
                                "UEAggregateMaximumBitRate",
                                "CoreNetworkAssistanceInformationForInactive",
                                "GUAMI",
                                "PDUSessionResourceSetupListCxtReq",
                                "AllowedNSSAI",
                                "UESecurityCapabilities",
                                "BIT STRING",
                                "TraceActivation",
                                "MobilityRestrictionList",
                                "OCTET STRING",
                                "INTEGER (1..256,...)",
                                "BIT STRING",
                                "OCTET STRING",
                                "EmergencyFallbackIndicator",
                                "RRCInactiveTransitionReportRequest",
                                "UERadioCapabilityForPaging",
                                "RedirectionVoiceFallback",
                                "LocationReportingRequestType",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "IAB-Authorized",
                                "Enhanced-CoverageRestriction",
                                "INTEGER (0..255)",
                                "UE-DifferentiationInfo",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "CEmodeBrestricted",
                                "UE-UP-CIoT-Support",
                                "OCTET STRING",
                                "MDTPLMNList",
                                "OCTET STRING",
                                "TimeSyncAssistanceInfo",
                                "QMCConfigInfo",
                                "TargetNSSAIInformation",
                                "UESliceMaximumBitRateList",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters"};
  return convert_enum_idx(names, 44, value, "init_context_setup_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_context_setup_request_ies_o>;

SRSASN_CODE init_context_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 6;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += pdu_session_res_setup_list_cxt_req_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (old_amf_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)48, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)28, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(guami.pack(bref));
  }
  if (pdu_session_res_setup_list_cxt_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)71, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_cxt_req, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)94, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_key.pack(bref));
  }
  if (trace_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)108, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)36, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)31, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)24, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)199, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)238, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)254, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_list, 1, 16, true));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)328, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)334, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 6;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 48: {
        old_amf_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.unpack(bref));
        break;
      }
      case 71: {
        pdu_session_res_setup_list_cxt_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_cxt_req, bref, 1, 256, true));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 94: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.unpack(bref));
        break;
      }
      case 108: {
        trace_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_list, bref, 1, 16, true));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (old_amf_present) {
    j.write_int("id", 48);
    j.write_str("criticality", "reject");
    j.write_str("Value", old_amf.to_string());
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "reject");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_int("id", 28);
  j.write_str("criticality", "reject");
  guami.to_json(j);
  if (pdu_session_res_setup_list_cxt_req_present) {
    j.write_int("id", 71);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_setup_list_cxt_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 0);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : allowed_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 119);
  j.write_str("criticality", "reject");
  ue_security_cap.to_json(j);
  j.write_int("id", 94);
  j.write_str("criticality", "reject");
  j.write_str("Value", security_key.to_string());
  if (trace_activation_present) {
    j.write_int("id", 108);
    j.write_str("criticality", "ignore");
    trace_activation.to_json(j);
  }
  if (mob_restrict_list_present) {
    j.write_int("id", 36);
    j.write_str("criticality", "ignore");
    mob_restrict_list.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (idx_to_rfsp_present) {
    j.write_int("id", 31);
    j.write_str("criticality", "ignore");
    j.write_int("Value", idx_to_rfsp);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  if (nas_pdu_present) {
    j.write_int("id", 38);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nas_pdu.to_string());
  }
  if (emergency_fallback_ind_present) {
    j.write_int("id", 24);
    j.write_str("criticality", "reject");
    emergency_fallback_ind.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "ignore");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redirection_voice_fallback.to_string());
  }
  if (location_report_request_type_present) {
    j.write_int("id", 33);
    j.write_str("criticality", "ignore");
    location_report_request_type.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (iab_authorized_present) {
    j.write_int("id", 199);
    j.write_str("criticality", "ignore");
    j.write_str("Value", iab_authorized.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_up_c_iot_support_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "supported");
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_int("id", 238);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rg_level_wireline_access_characteristics.to_string());
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_int("id", 254);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_int("id", 328);
    j.write_str("criticality", "ignore");
    q_mcc_onfig_info.to_json(j);
  }
  if (target_nssai_info_present) {
    j.write_int("id", 334);
    j.write_str("criticality", "ignore");
    target_nssai_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 72:
      return crit_e::ignore;
    case 55:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_resp_ies_o::value_c init_context_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 72:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_res);
      break;
    case 55:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 72:
      return presence_e::optional;
    case 55:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c = pdu_session_res_setup_list_cxt_res_l{};
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c = pdu_session_res_failed_to_setup_list_cxt_res_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_cxt_res_l& init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
const pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
const crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      j.start_array("PDUSessionResourceSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      j.start_array("PDUSessionResourceFailedToSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceSetupListCxtRes",
                                "PDUSessionResourceFailedToSetupListCxtRes",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "init_context_setup_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_context_setup_resp_ies_o>;

SRSASN_CODE init_context_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_setup_list_cxt_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)72, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_cxt_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)55, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_cxt_res, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 72: {
        pdu_session_res_setup_list_cxt_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_cxt_res, bref, 1, 256, true));
        break;
      }
      case 55: {
        pdu_session_res_failed_to_setup_list_cxt_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_cxt_res, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_setup_list_cxt_res_present) {
    j.write_int("id", 72);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_setup_list_cxt_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    j.write_int("id", 55);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_cxt_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialUEMessage-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_ue_msg_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  return map_enum_number(names, 17, idx, "id");
}
bool init_ue_msg_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_ue_msg_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::reject;
    case 90:
      return crit_e::ignore;
    case 26:
      return crit_e::reject;
    case 3:
      return crit_e::ignore;
    case 112:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    case 174:
      return crit_e::ignore;
    case 201:
      return crit_e::reject;
    case 224:
      return crit_e::reject;
    case 225:
      return crit_e::ignore;
    case 227:
      return crit_e::ignore;
    case 245:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_ue_msg_ies_o::value_c init_ue_msg_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 90:
      ret.set(value_c::types::rrc_establishment_cause);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 112:
      ret.set(value_c::types::ue_context_request);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    case 174:
      ret.set(value_c::types::sel_plmn_id);
      break;
    case 201:
      ret.set(value_c::types::iab_node_ind);
      break;
    case 224:
      ret.set(value_c::types::ce_mode_b_support_ind);
      break;
    case 225:
      ret.set(value_c::types::ltem_ind);
      break;
    case 227:
      ret.set(value_c::types::edt_session);
      break;
    case 245:
      ret.set(value_c::types::authenticated_ind);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_ue_msg_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 90:
      return presence_e::mandatory;
    case 26:
      return presence_e::optional;
    case 3:
      return presence_e::optional;
    case 112:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    case 174:
      return presence_e::optional;
    case 201:
      return presence_e::optional;
    case 224:
      return presence_e::optional;
    case 225:
      return presence_e::optional;
    case 227:
      return presence_e::optional;
    case 245:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_ue_msg_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::nas_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::rrc_establishment_cause:
      c = rrc_establishment_cause_e{};
      break;
    case types::five_g_s_tmsi:
      c = five_g_s_tmsi_s{};
      break;
    case types::amf_set_id:
      c = fixed_bitstring<10, false, true>{};
      break;
    case types::ue_context_request:
      c = ue_context_request_e{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::source_to_target_amf_info_reroute:
      c = source_to_target_amf_info_reroute_s{};
      break;
    case types::sel_plmn_id:
      c = fixed_octstring<3, true>{};
      break;
    case types::iab_node_ind:
      c = iab_node_ind_e{};
      break;
    case types::ce_mode_b_support_ind:
      c = ce_mode_b_support_ind_e{};
      break;
    case types::ltem_ind:
      c = ltem_ind_e{};
      break;
    case types::edt_session:
      c = edt_session_e{};
      break;
    case types::authenticated_ind:
      c = authenticated_ind_e{};
      break;
    case types::npn_access_info:
      c = npn_access_info_c{};
      break;
    case types::red_cap_ind:
      c = red_cap_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause()
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request()
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id()
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind()
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind()
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind()
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
edt_session_e& init_ue_msg_ies_o::value_c::edt_session()
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind()
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause() const
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request() const
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
const allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id() const
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
const iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind() const
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
const ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind() const
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
const ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind() const
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
const edt_session_e& init_ue_msg_ies_o::value_c::edt_session() const
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
const authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind() const
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
const npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void init_ue_msg_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::rrc_establishment_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::ue_context_request:
      j.write_str("UEContextRequest", "requested");
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    case types::sel_plmn_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<3, true>>().to_string());
      break;
    case types::iab_node_ind:
      j.write_str("IABNodeIndication", "true");
      break;
    case types::ce_mode_b_support_ind:
      j.write_str("CEmodeBSupport-Indicator", "supported");
      break;
    case types::ltem_ind:
      j.write_str("LTEM-Indication", "lte-m");
      break;
    case types::edt_session:
      j.write_str("EDT-Session", "true");
      break;
    case types::authenticated_ind:
      j.write_str("AuthenticatedIndication", "true");
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_ue_msg_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().pack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().pack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().pack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().pack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().pack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().unpack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().unpack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().unpack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().unpack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().unpack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_ue_msg_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "UserLocationInformation",
                                "RRCEstablishmentCause",
                                "FiveG-S-TMSI",
                                "BIT STRING",
                                "UEContextRequest",
                                "AllowedNSSAI",
                                "SourceToTarget-AMFInformationReroute",
                                "OCTET STRING",
                                "IABNodeIndication",
                                "CEmodeBSupport-Indicator",
                                "LTEM-Indication",
                                "EDT-Session",
                                "AuthenticatedIndication",
                                "NPN-AccessInformation",
                                "RedCapIndication"};
  return convert_enum_idx(names, 17, value, "init_ue_msg_ies_o::value_c::types");
}
uint8_t init_ue_msg_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "init_ue_msg_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_ue_msg_ies_o>;

SRSASN_CODE init_ue_msg_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  nof_ies += amf_set_id_present ? 1 : 0;
  nof_ies += ue_context_request_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  nof_ies += sel_plmn_id_present ? 1 : 0;
  nof_ies += iab_node_ind_present ? 1 : 0;
  nof_ies += ce_mode_b_support_ind_present ? 1 : 0;
  nof_ies += ltem_ind_present ? 1 : 0;
  nof_ies += edt_session_present ? 1 : 0;
  nof_ies += authenticated_ind_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)90, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_establishment_cause.pack(bref));
  }
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  if (amf_set_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)3, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_set_id.pack(bref));
  }
  if (ue_context_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)112, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_context_request.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)171, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }
  if (sel_plmn_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)174, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sel_plmn_id.pack(bref));
  }
  if (iab_node_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)201, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_node_ind.pack(bref));
  }
  if (ce_mode_b_support_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)224, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_b_support_ind.pack(bref));
  }
  if (ltem_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)225, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltem_ind.pack(bref));
  }
  if (edt_session_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)227, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(edt_session.pack(bref));
  }
  if (authenticated_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)245, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(authenticated_ind.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)259, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)333, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 90: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_establishment_cause.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      case 3: {
        amf_set_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.unpack(bref));
        break;
      }
      case 112: {
        ue_context_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_context_request.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.unpack(bref));
        break;
      }
      case 174: {
        sel_plmn_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sel_plmn_id.unpack(bref));
        break;
      }
      case 201: {
        iab_node_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_node_ind.unpack(bref));
        break;
      }
      case 224: {
        ce_mode_b_support_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_b_support_ind.unpack(bref));
        break;
      }
      case 225: {
        ltem_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltem_ind.unpack(bref));
        break;
      }
      case 227: {
        edt_session_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(edt_session.unpack(bref));
        break;
      }
      case 245: {
        authenticated_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(authenticated_ind.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_ue_msg_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 38);
  j.write_str("criticality", "reject");
  j.write_str("Value", nas_pdu.to_string());
  j.write_int("id", 121);
  j.write_str("criticality", "reject");
  user_location_info.to_json(j);
  j.write_int("id", 90);
  j.write_str("criticality", "ignore");
  j.write_str("Value", rrc_establishment_cause.to_string());
  if (five_g_s_tmsi_present) {
    j.write_int("id", 26);
    j.write_str("criticality", "reject");
    five_g_s_tmsi.to_json(j);
  }
  if (amf_set_id_present) {
    j.write_int("id", 3);
    j.write_str("criticality", "ignore");
    j.write_str("Value", amf_set_id.to_string());
  }
  if (ue_context_request_present) {
    j.write_int("id", 112);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "requested");
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_int("id", 171);
    j.write_str("criticality", "ignore");
    source_to_target_amf_info_reroute.to_json(j);
  }
  if (sel_plmn_id_present) {
    j.write_int("id", 174);
    j.write_str("criticality", "ignore");
    j.write_str("Value", sel_plmn_id.to_string());
  }
  if (iab_node_ind_present) {
    j.write_int("id", 201);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  if (ce_mode_b_support_ind_present) {
    j.write_int("id", 224);
    j.write_str("criticality", "reject");
    j.write_str("Value", "supported");
  }
  if (ltem_ind_present) {
    j.write_int("id", 225);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "lte-m");
  }
  if (edt_session_present) {
    j.write_int("id", 227);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "true");
  }
  if (authenticated_ind_present) {
    j.write_int("id", 245);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "true");
  }
  if (npn_access_info_present) {
    j.write_int("id", 259);
    j.write_str("criticality", "reject");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_int("id", 333);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "redcap");
  }
  j.end_obj();
}

// LocationReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  return map_enum_number(names, 5, idx, "id");
}
bool location_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 116:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ies_o::value_c location_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 116:
      ret.set(value_c::types::ue_presence_in_area_of_interest_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 116:
      return presence_e::optional;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::ue_presence_in_area_of_interest_list:
      c = ue_presence_in_area_of_interest_list_l{};
      break;
    case types::location_report_request_type:
      c = location_report_request_type_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& location_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_presence_in_area_of_interest_list_l& location_report_ies_o::value_c::ue_presence_in_area_of_interest_list()
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& location_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_presence_in_area_of_interest_list_l&
location_report_ies_o::value_c::ue_presence_in_area_of_interest_list() const
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
const location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_presence_in_area_of_interest_list:
      j.start_array("UEPresenceInAreaOfInterestList");
      for (const auto& e1 : c.get<ue_presence_in_area_of_interest_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_presence_in_area_of_interest_list_l>(), 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_presence_in_area_of_interest_list_l>(), bref, 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "UserLocationInformation",
                                "UEPresenceInAreaOfInterestList",
                                "LocationReportingRequestType"};
  return convert_enum_idx(names, 5, value, "location_report_ies_o::value_c::types");
}

// LocationReportingControlIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ctrl_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 33};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_ctrl_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ctrl_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ctrl_ies_o::value_c location_report_ctrl_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ctrl_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ctrl_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::location_report_request_type:
      c = location_report_request_type_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ctrl_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_ctrl_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "LocationReportingRequestType"};
  return convert_enum_idx(names, 3, value, "location_report_ctrl_ies_o::value_c::types");
}

// LocationReportingFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_fail_ind_ies_o::value_c location_report_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_fail_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& location_report_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& location_report_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void location_report_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause"};
  return convert_enum_idx(names, 3, value, "location_report_fail_ind_ies_o::value_c::types");
}

// MulticastGroupPagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_group_paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 307};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_group_paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 307};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_group_paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::ignore;
    case 298:
      return crit_e::ignore;
    case 307:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_group_paging_ies_o::value_c multicast_group_paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 307:
      ret.set(value_c::types::multicast_group_paging_area_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_group_paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 307:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_group_paging_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_service_area:
      c = mbs_service_area_c{};
      break;
    case types::multicast_group_paging_area_list:
      c = multicast_group_paging_area_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
multicast_group_paging_area_list_l& multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list()
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
const mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const multicast_group_paging_area_list_l&
multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list() const
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
void multicast_group_paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::multicast_group_paging_area_list:
      j.start_array("MulticastGroupPagingAreaList");
      for (const auto& e1 : c.get<multicast_group_paging_area_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<multicast_group_paging_area_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<multicast_group_paging_area_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_group_paging_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "MBS-ServiceArea", "MulticastGroupPagingAreaList"};
  return convert_enum_idx(names, 3, value, "multicast_group_paging_ies_o::value_c::types");
}

// MulticastSessionActivationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_activation_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_fail_ies_o::value_c multicast_session_activation_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& multicast_session_activation_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& multicast_session_activation_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_activation_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "multicast_session_activation_fail_ies_o::value_c::types");
}

// MulticastSessionActivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 304};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 304};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 304:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_request_ies_o::value_c
multicast_session_activation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 304:
      ret.set(value_c::types::multicast_session_activation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 304:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::multicast_session_activation_request_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer()
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer() const
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_activation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_activation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_activation_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "multicast_session_activation_request_ies_o::value_c::types");
}

// MulticastSessionActivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_resp_ies_o::value_c multicast_session_activation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_activation_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 2, value, "multicast_session_activation_resp_ies_o::value_c::types");
}

// MulticastSessionDeactivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 305};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 305};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 305:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_request_ies_o::value_c
multicast_session_deactivation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 305:
      ret.set(value_c::types::multicast_session_deactivation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 305:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::multicast_session_deactivation_request_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer()
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer() const
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_deactivation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_deactivation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_deactivation_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "multicast_session_deactivation_request_ies_o::value_c::types");
}

// MulticastSessionDeactivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_resp_ies_o::value_c
multicast_session_deactivation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_deactivation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_deactivation_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 2, value, "multicast_session_deactivation_resp_ies_o::value_c::types");
}

// MulticastSessionUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool multicast_session_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_fail_ies_o::value_c multicast_session_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& multicast_session_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& multicast_session_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "multicast_session_upd_fail_ies_o::value_c::types");
}
uint8_t multicast_session_upd_fail_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "multicast_session_upd_fail_ies_o::value_c::types");
  return 0;
}

// MulticastSessionUpdateRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 306};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 306};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 306:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_request_ies_o::value_c multicast_session_upd_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 306:
      ret.set(value_c::types::multicast_session_upd_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 306:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::multicast_session_upd_request_transfer:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer()
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer() const
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_upd_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "multicast_session_upd_request_ies_o::value_c::types");
}
uint8_t multicast_session_upd_request_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "multicast_session_upd_request_ies_o::value_c::types");
  return 0;
}

// MulticastSessionUpdateResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_resp_ies_o::value_c multicast_session_upd_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_area_session_id:
      c = uint32_t{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "multicast_session_upd_resp_ies_o::value_c::types");
}
uint8_t multicast_session_upd_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "multicast_session_upd_resp_ies_o::value_c::types");
  return 0;
}

// NASNonDeliveryIndication-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t nas_non_delivery_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool nas_non_delivery_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nas_non_delivery_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
nas_non_delivery_ind_ies_o::value_c nas_non_delivery_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nas_non_delivery_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void nas_non_delivery_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::nas_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& nas_non_delivery_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& nas_non_delivery_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void nas_non_delivery_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nas_non_delivery_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "Cause"};
  return convert_enum_idx(names, 4, value, "nas_non_delivery_ind_ies_o::value_c::types");
}

// NGResetAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {111, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {111, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ack_ies_o::value_c ng_reset_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::ue_associated_lc_ng_conn_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ack_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c = ue_associated_lc_ng_conn_list_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
}
ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list()
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list() const
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
const crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_reset_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      j.start_array("UE-associatedLogicalNG-connectionList");
      for (const auto& e1 : c.get<ue_associated_lc_ng_conn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_ng_conn_list_l>(), 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_ng_conn_list_l>(), bref, 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_reset_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UE-associatedLogicalNG-connectionList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 2, value, "ng_reset_ack_ies_o::value_c::types");
}

// NGResetIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 88};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 88};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 88:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ies_o::value_c ng_reset_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 88:
      ret.set(value_c::types::reset_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 88:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cause:
      c = cause_c{};
      break;
    case types::reset_type:
      c = reset_type_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
}
cause_c& ng_reset_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
reset_type_c& ng_reset_ies_o::value_c::reset_type()
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
const cause_c& ng_reset_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const reset_type_c& ng_reset_ies_o::value_c::reset_type() const
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
void ng_reset_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::reset_type:
      j.write_fieldname("ResetType");
      c.get<reset_type_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_reset_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "ResetType"};
  return convert_enum_idx(names, 2, value, "ng_reset_ies_o::value_c::types");
}

// NGSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ng_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_fail_ies_o::value_c ng_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cause:
      c = cause_c{};
      break;
    case types::time_to_wait:
      c = time_to_wait_e{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
}
cause_c& ng_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ng_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ng_setup_fail_ies_o::value_c::types");
}

// NGSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ng_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 27:
      return crit_e::reject;
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_request_ies_o::value_c ng_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 27:
      return presence_e::mandatory;
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::mandatory;
    case 21:
      return presence_e::mandatory;
    case 147:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::ran_node_name:
      c = printable_string<1, 150, true, true>{};
      break;
    case types::supported_ta_list:
      c = supported_ta_list_l{};
      break;
    case types::default_paging_drx:
      c = paging_drx_e{};
      break;
    case types::ue_retention_info:
      c = ue_retention_info_e{};
      break;
    case types::nb_iot_default_paging_drx:
      c = nb_iot_default_paging_drx_e{};
      break;
    case types::extended_ran_node_name:
      c = extended_ran_node_name_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
}
global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ng_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"GlobalRANNodeID",
                                "PrintableString",
                                "SupportedTAList",
                                "PagingDRX",
                                "UERetentionInformation",
                                "NB-IoT-DefaultPagingDRX",
                                "Extended-RANNodeName"};
  return convert_enum_idx(names, 7, value, "ng_setup_request_ies_o::value_c::types");
}

// NGSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool ng_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 200:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_resp_ies_o::value_c ng_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 200:
      ret.set(value_c::types::iab_supported);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::mandatory;
    case 96:
      return presence_e::mandatory;
    case 86:
      return presence_e::mandatory;
    case 80:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 147:
      return presence_e::optional;
    case 200:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c = printable_string<1, 150, true, true>{};
      break;
    case types::served_guami_list:
      c = served_guami_list_l{};
      break;
    case types::relative_amf_capacity:
      c = uint16_t{};
      break;
    case types::plmn_support_list:
      c = plmn_support_list_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::ue_retention_info:
      c = ue_retention_info_e{};
      break;
    case types::iab_supported:
      c = iab_supported_e{};
      break;
    case types::extended_amf_name:
      c = extended_amf_name_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
}
printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported()
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported() const
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
const extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void ng_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::iab_supported:
      j.write_str("IAB-Supported", "true");
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().pack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().unpack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PrintableString",
                                "ServedGUAMIList",
                                "INTEGER (0..255)",
                                "PLMNSupportList",
                                "CriticalityDiagnostics",
                                "UERetentionInformation",
                                "IAB-Supported",
                                "Extended-AMFName"};
  return convert_enum_idx(names, 8, value, "ng_setup_resp_ies_o::value_c::types");
}
uint8_t ng_setup_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == relative_amf_capacity) {
    return 0;
  }
  invalid_enum_number(value, "ng_setup_resp_ies_o::value_c::types");
  return 0;
}

// OverloadStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t overload_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {2, 9, 49};
  return map_enum_number(names, 3, idx, "id");
}
bool overload_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {2, 9, 49};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e overload_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::reject;
    case 9:
      return crit_e::ignore;
    case 49:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
overload_start_ies_o::value_c overload_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::amf_overload_resp);
      break;
    case 9:
      ret.set(value_c::types::amf_traffic_load_reduction_ind);
      break;
    case 49:
      ret.set(value_c::types::overload_start_nssai_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e overload_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::optional;
    case 9:
      return presence_e::optional;
    case 49:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void overload_start_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_overload_resp:
      c = overload_resp_c{};
      break;
    case types::amf_traffic_load_reduction_ind:
      c = uint8_t{};
      break;
    case types::overload_start_nssai_list:
      c = overload_start_nssai_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp()
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind()
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list()
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
const overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp() const
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
const uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind() const
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
const overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list() const
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
void overload_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_overload_resp:
      j.write_fieldname("OverloadResponse");
      c.get<overload_resp_c>().to_json(j);
      break;
    case types::amf_traffic_load_reduction_ind:
      j.write_int("INTEGER (1..99)", c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      j.start_array("OverloadStartNSSAIList");
      for (const auto& e1 : c.get<overload_start_nssai_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE overload_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().pack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<overload_start_nssai_list_l>(), 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().unpack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<overload_start_nssai_list_l>(), bref, 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* overload_start_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OverloadResponse", "INTEGER (1..99)", "OverloadStartNSSAIList"};
  return convert_enum_idx(names, 3, value, "overload_start_ies_o::value_c::types");
}
uint8_t overload_start_ies_o::value_c::types_opts::to_number() const
{
  if (value == amf_traffic_load_reduction_ind) {
    return 1;
  }
  invalid_enum_number(value, "overload_start_ies_o::value_c::types");
  return 0;
}

// PDUSessionResourceModifyConfirmIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_confirm_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_modify_confirm_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_confirm_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 62:
      return crit_e::ignore;
    case 131:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_confirm_ies_o::value_c pdu_session_res_modify_confirm_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 62:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_cfm);
      break;
    case 131:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_cfm);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_confirm_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 62:
      return presence_e::optional;
    case 131:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_confirm_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c = pdu_session_res_modify_list_mod_cfm_l{};
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c = pdu_session_res_failed_to_modify_list_mod_cfm_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
const pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
const crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_confirm_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceFailedToModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_confirm_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceModifyListModCfm",
                                "PDUSessionResourceFailedToModifyListModCfm",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_modify_confirm_ies_o::value_c::types");
}

// PDUSessionResourceModifyIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 63:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_ind_ies_o::value_c pdu_session_res_modify_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 63:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_ind);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 63:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c = pdu_session_res_modify_list_mod_ind_l{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_ind_l& pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_ind_l&
pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
const user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_modify_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      j.start_array("PDUSessionResourceModifyListModInd");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_ind_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_ind_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_ind_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceModifyListModInd",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 4, value, "pdu_session_res_modify_ind_ies_o::value_c::types");
}

// PDUSessionResourceModifyRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 64:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_request_ies_o::value_c pdu_session_res_modify_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 64:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 64:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_paging_prio:
      c = uint16_t{};
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c = pdu_session_res_modify_list_mod_req_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
void pdu_session_res_modify_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      j.start_array("PDUSessionResourceModifyListModReq");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "PDUSessionResourceModifyListModReq"};
  return convert_enum_idx(names, 4, value, "pdu_session_res_modify_request_ies_o::value_c::types");
}

// PDUSessionResourceModifyResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_modify_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 65:
      return crit_e::ignore;
    case 54:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_resp_ies_o::value_c pdu_session_res_modify_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 65:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_res);
      break;
    case 54:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 65:
      return presence_e::optional;
    case 54:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c = pdu_session_res_modify_list_mod_res_l{};
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c = pdu_session_res_failed_to_modify_list_mod_res_l{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_res_l& pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
const pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
const user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      j.start_array("PDUSessionResourceModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      j.start_array("PDUSessionResourceFailedToModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceModifyListModRes",
                                "PDUSessionResourceFailedToModifyListModRes",
                                "UserLocationInformation",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 6, value, "pdu_session_res_modify_resp_ies_o::value_c::types");
}

// PDUSessionResourceNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 67:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_notify_ies_o::value_c pdu_session_res_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 66:
      ret.set(value_c::types::pdu_session_res_notify_list);
      break;
    case 67:
      ret.set(value_c::types::pdu_session_res_released_list_not);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 67:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_notify_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_notify_list:
      c = pdu_session_res_notify_list_l{};
      break;
    case types::pdu_session_res_released_list_not:
      c = pdu_session_res_released_list_not_l{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list()
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
pdu_session_res_released_list_not_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not()
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list() const
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
const pdu_session_res_released_list_not_l&
pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not() const
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
const user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      j.start_array("PDUSessionResourceNotifyList");
      for (const auto& e1 : c.get<pdu_session_res_notify_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_not:
      j.start_array("PDUSessionResourceReleasedListNot");
      for (const auto& e1 : c.get<pdu_session_res_released_list_not_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_notify_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_not_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_notify_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_not_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_notify_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceNotifyList",
                                "PDUSessionResourceReleasedListNot",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_notify_ies_o::value_c::types");
}

// PDUSessionResourceReleaseCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 79:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_cmd_ies_o::value_c pdu_session_res_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 79:
      ret.set(value_c::types::pdu_session_res_to_release_list_rel_cmd);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 79:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_cmd_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_paging_prio:
      c = uint16_t{};
      break;
    case types::nas_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c = pdu_session_res_to_release_list_rel_cmd_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
void pdu_session_res_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      j.start_array("PDUSessionResourceToReleaseListRelCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_rel_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_rel_cmd_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_rel_cmd_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_release_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "OCTET STRING",
                                "PDUSessionResourceToReleaseListRelCmd"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_release_cmd_ies_o::value_c::types");
}

// PDUSessionResourceReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 70:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_resp_ies_o::value_c pdu_session_res_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 70:
      ret.set(value_c::types::pdu_session_res_released_list_rel_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 70:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_released_list_rel_res:
      c = pdu_session_res_released_list_rel_res_l{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res()
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res() const
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
const user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      j.start_array("PDUSessionResourceReleasedListRelRes");
      for (const auto& e1 : c.get<pdu_session_res_released_list_rel_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_rel_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_rel_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_release_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceReleasedListRelRes",
                                "UserLocationInformation",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_release_resp_ies_o::value_c::types");
}

// PDUSessionResourceSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  return map_enum_number(names, 7, idx, "id");
}
bool pdu_session_res_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 74:
      return crit_e::reject;
    case 110:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_request_ies_o::value_c pdu_session_res_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 74:
      ret.set(value_c::types::pdu_session_res_setup_list_su_req);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 74:
      return presence_e::mandatory;
    case 110:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_paging_prio:
      c = uint16_t{};
      break;
    case types::nas_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::pdu_session_res_setup_list_su_req:
      c = pdu_session_res_setup_list_su_req_l{};
      break;
    case types::ue_aggr_max_bit_rate:
      c = ue_aggr_max_bit_rate_s{};
      break;
    case types::ue_slice_max_bit_rate_list:
      c = ue_slice_max_bit_rate_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_su_req_l& pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_su_req_l&
pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
const ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
void pdu_session_res_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_su_req:
      j.start_array("PDUSessionResourceSetupListSUReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_req_l>(), 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_req_l>(), bref, 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "OCTET STRING",
                                "PDUSessionResourceSetupListSUReq",
                                "UEAggregateMaximumBitRate",
                                "UESliceMaximumBitRateList"};
  return convert_enum_idx(names, 7, value, "pdu_session_res_setup_request_ies_o::value_c::types");
}

// PDUSessionResourceSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 75:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_resp_ies_o::value_c pdu_session_res_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 75:
      ret.set(value_c::types::pdu_session_res_setup_list_su_res);
      break;
    case 58:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_su_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 75:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_setup_list_su_res:
      c = pdu_session_res_setup_list_su_res_l{};
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c = pdu_session_res_failed_to_setup_list_su_res_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_su_res_l& pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
const pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
const crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      j.start_array("PDUSessionResourceSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      j.start_array("PDUSessionResourceFailedToSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceSetupListSURes",
                                "PDUSessionResourceFailedToSetupListSURes",
                                "CriticalityDiagnostics",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 6, value, "pdu_session_res_setup_resp_ies_o::value_c::types");
}

// PWSCancelRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 14:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_request_ies_o::value_c pws_cancel_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 14:
      ret.set(value_c::types::cancel_all_warning_msgs);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 14:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::serial_num:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::warning_area_list:
      c = warning_area_list_c{};
      break;
    case types::cancel_all_warning_msgs:
      c = cancel_all_warning_msgs_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs()
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs() const
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
void pws_cancel_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::cancel_all_warning_msgs:
      j.write_str("CancelAllWarningMessages", "true");
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_cancel_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING", "WarningAreaList", "CancelAllWarningMessages"};
  return convert_enum_idx(names, 4, value, "pws_cancel_request_ies_o::value_c::types");
}

// PWSCancelResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 12:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_resp_ies_o::value_c pws_cancel_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 12:
      ret.set(value_c::types::broadcast_cancelled_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 12:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::serial_num:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::broadcast_cancelled_area_list:
      c = broadcast_cancelled_area_list_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list()
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list() const
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
const crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pws_cancel_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_cancelled_area_list:
      j.write_fieldname("BroadcastCancelledAreaList");
      c.get<broadcast_cancelled_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_cancel_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING", "BroadcastCancelledAreaList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "pws_cancel_resp_ies_o::value_c::types");
}

// PWSFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {81, 27};
  return map_enum_number(names, 2, idx, "id");
}
bool pws_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {81, 27};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 81:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_fail_ind_ies_o::value_c pws_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 81:
      ret.set(value_c::types::pws_failed_cell_id_list);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 81:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_fail_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c = pws_failed_cell_id_list_c{};
      break;
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list()
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list() const
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
const global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
void pws_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pws_failed_cell_id_list:
      j.write_fieldname("PWSFailedCellIDList");
      c.get<pws_failed_cell_id_list_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PWSFailedCellIDList", "GlobalRANNodeID"};
  return convert_enum_idx(names, 2, value, "pws_fail_ind_ies_o::value_c::types");
}

// PWSRestartIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_restart_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_restart_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_restart_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 16:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    case 104:
      return crit_e::reject;
    case 23:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_restart_ind_ies_o::value_c pws_restart_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 16:
      ret.set(value_c::types::cell_id_list_for_restart);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 104:
      ret.set(value_c::types::tai_list_for_restart);
      break;
    case 23:
      ret.set(value_c::types::emergency_area_id_list_for_restart);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_restart_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 16:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    case 104:
      return presence_e::mandatory;
    case 23:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_restart_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cell_id_list_for_restart:
      c = cell_id_list_for_restart_c{};
      break;
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::tai_list_for_restart:
      c = tai_list_for_restart_l{};
      break;
    case types::emergency_area_id_list_for_restart:
      c = emergency_area_id_list_for_restart_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart()
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart()
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart()
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
const cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart() const
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
const global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart() const
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
const emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart() const
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
void pws_restart_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_list_for_restart:
      j.write_fieldname("CellIDListForRestart");
      c.get<cell_id_list_for_restart_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::tai_list_for_restart:
      j.start_array("TAIListForRestart");
      for (const auto& e1 : c.get<tai_list_for_restart_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list_for_restart:
      j.start_array("EmergencyAreaIDListForRestart");
      for (const auto& e1 : c.get<emergency_area_id_list_for_restart_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_restart_l>(), 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_for_restart_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_restart_l>(), bref, 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_for_restart_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_restart_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "CellIDListForRestart", "GlobalRANNodeID", "TAIListForRestart", "EmergencyAreaIDListForRestart"};
  return convert_enum_idx(names, 4, value, "pws_restart_ind_ies_o::value_c::types");
}

// PagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  return map_enum_number(names, 16, idx, "id");
}
bool paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 115:
      return crit_e::ignore;
    case 50:
      return crit_e::ignore;
    case 103:
      return crit_e::ignore;
    case 52:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 51:
      return crit_e::ignore;
    case 11:
      return crit_e::ignore;
    case 203:
      return crit_e::ignore;
    case 202:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 208:
      return crit_e::ignore;
    case 223:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 332:
      return crit_e::ignore;
    case 342:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
paging_ies_o::value_c paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 115:
      ret.set(value_c::types::ue_paging_id);
      break;
    case 50:
      ret.set(value_c::types::paging_drx);
      break;
    case 103:
      ret.set(value_c::types::tai_list_for_paging);
      break;
    case 52:
      ret.set(value_c::types::paging_prio);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 51:
      ret.set(value_c::types::paging_origin);
      break;
    case 11:
      ret.set(value_c::types::assist_data_for_paging);
      break;
    case 203:
      ret.set(value_c::types::nb_iot_paging_e_drx_info);
      break;
    case 202:
      ret.set(value_c::types::nb_iot_paging_drx);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 208:
      ret.set(value_c::types::wus_assist_info);
      break;
    case 223:
      ret.set(value_c::types::eutra_paginge_drx_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 332:
      ret.set(value_c::types::nr_paginge_drx_info);
      break;
    case 342:
      ret.set(value_c::types::paging_cause);
      break;
    case 344:
      ret.set(value_c::types::pe_ip_sassist_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 115:
      return presence_e::mandatory;
    case 50:
      return presence_e::optional;
    case 103:
      return presence_e::mandatory;
    case 52:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 51:
      return presence_e::optional;
    case 11:
      return presence_e::optional;
    case 203:
      return presence_e::optional;
    case 202:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 208:
      return presence_e::optional;
    case 223:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 332:
      return presence_e::optional;
    case 342:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void paging_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ue_paging_id:
      c = ue_paging_id_c{};
      break;
    case types::paging_drx:
      c = paging_drx_e{};
      break;
    case types::tai_list_for_paging:
      c = tai_list_for_paging_l{};
      break;
    case types::paging_prio:
      c = paging_prio_e{};
      break;
    case types::ue_radio_cap_for_paging:
      c = ue_radio_cap_for_paging_s{};
      break;
    case types::paging_origin:
      c = paging_origin_e{};
      break;
    case types::assist_data_for_paging:
      c = assist_data_for_paging_s{};
      break;
    case types::nb_iot_paging_e_drx_info:
      c = nb_iot_paging_e_drx_info_s{};
      break;
    case types::nb_iot_paging_drx:
      c = nb_iot_paging_drx_e{};
      break;
    case types::enhanced_coverage_restrict:
      c = enhanced_coverage_restrict_e{};
      break;
    case types::wus_assist_info:
      c = wus_assist_info_s{};
      break;
    case types::eutra_paginge_drx_info:
      c = eutra_paginge_drx_info_s{};
      break;
    case types::ce_mode_brestricted:
      c = ce_mode_brestricted_e{};
      break;
    case types::nr_paginge_drx_info:
      c = nr_paginge_drx_info_s{};
      break;
    case types::paging_cause:
      c = paging_cause_e{};
      break;
    case types::pe_ip_sassist_info:
      c = pe_ip_sassist_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
ue_paging_id_c& paging_ies_o::value_c::ue_paging_id()
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
paging_drx_e& paging_ies_o::value_c::paging_drx()
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging()
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
paging_prio_e& paging_ies_o::value_c::paging_prio()
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
paging_origin_e& paging_ies_o::value_c::paging_origin()
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging()
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info()
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx()
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
wus_assist_info_s& paging_ies_o::value_c::wus_assist_info()
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info()
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info()
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
paging_cause_e& paging_ies_o::value_c::paging_cause()
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info()
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
const ue_paging_id_c& paging_ies_o::value_c::ue_paging_id() const
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
const paging_drx_e& paging_ies_o::value_c::paging_drx() const
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging() const
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
const paging_prio_e& paging_ies_o::value_c::paging_prio() const
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
const ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const paging_origin_e& paging_ies_o::value_c::paging_origin() const
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
const assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging() const
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
const nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info() const
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
const nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx() const
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
const enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const wus_assist_info_s& paging_ies_o::value_c::wus_assist_info() const
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
const eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info() const
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
const ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info() const
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
const paging_cause_e& paging_ies_o::value_c::paging_cause() const
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
const pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info() const
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
void paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_paging_id:
      j.write_fieldname("UEPagingIdentity");
      c.get<ue_paging_id_c>().to_json(j);
      break;
    case types::paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::tai_list_for_paging:
      j.start_array("TAIListForPaging");
      for (const auto& e1 : c.get<tai_list_for_paging_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::paging_prio:
      j.write_str("PagingPriority", c.get<paging_prio_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::paging_origin:
      j.write_str("PagingOrigin", "non-3gpp");
      break;
    case types::assist_data_for_paging:
      j.write_fieldname("AssistanceDataForPaging");
      c.get<assist_data_for_paging_s>().to_json(j);
      break;
    case types::nb_iot_paging_e_drx_info:
      j.write_fieldname("NB-IoT-Paging-eDRXInfo");
      c.get<nb_iot_paging_e_drx_info_s>().to_json(j);
      break;
    case types::nb_iot_paging_drx:
      j.write_str("NB-IoT-PagingDRX", c.get<nb_iot_paging_drx_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::wus_assist_info:
      j.write_fieldname("WUS-Assistance-Information");
      c.get<wus_assist_info_s>().to_json(j);
      break;
    case types::eutra_paginge_drx_info:
      j.write_fieldname("EUTRA-PagingeDRXInformation");
      c.get<eutra_paginge_drx_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::nr_paginge_drx_info:
      j.write_fieldname("NR-PagingeDRXInformation");
      c.get<nr_paginge_drx_info_s>().to_json(j);
      break;
    case types::paging_cause:
      j.write_str("PagingCause", "voice");
      break;
    case types::pe_ip_sassist_info:
      j.write_fieldname("PEIPSassistanceInformation");
      c.get<pe_ip_sassist_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().pack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_paging_l>(), 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().pack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().pack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().pack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().pack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().pack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().pack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().unpack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_paging_l>(), bref, 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().unpack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().unpack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().unpack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().unpack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().unpack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().unpack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* paging_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UEPagingIdentity",
                                "PagingDRX",
                                "TAIListForPaging",
                                "PagingPriority",
                                "UERadioCapabilityForPaging",
                                "PagingOrigin",
                                "AssistanceDataForPaging",
                                "NB-IoT-Paging-eDRXInfo",
                                "NB-IoT-PagingDRX",
                                "Enhanced-CoverageRestriction",
                                "WUS-Assistance-Information",
                                "EUTRA-PagingeDRXInformation",
                                "CEmodeBrestricted",
                                "NR-PagingeDRXInformation",
                                "PagingCause",
                                "PEIPSassistanceInformation"};
  return convert_enum_idx(names, 16, value, "paging_ies_o::value_c::types");
}

// PathSwitchRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  return map_enum_number(names, 31, idx, "id");
}
bool path_switch_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 77:
      return crit_e::ignore;
    case 68:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 254:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ack_ies_o::value_c path_switch_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 77:
      ret.set(value_c::types::pdu_session_res_switched_list);
      break;
    case 68:
      ret.set(value_c::types::pdu_session_res_released_list_ps_ack);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 119:
      return presence_e::optional;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 77:
      return presence_e::mandatory;
    case 68:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ack_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ue_security_cap:
      c = ue_security_cap_s{};
      break;
    case types::security_context:
      c = security_context_s{};
      break;
    case types::new_security_context_ind:
      c = new_security_context_ind_e{};
      break;
    case types::pdu_session_res_switched_list:
      c = pdu_session_res_switched_list_l{};
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c = pdu_session_res_released_list_ps_ack_l{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::core_network_assist_info_for_inactive:
      c = core_network_assist_info_for_inactive_s{};
      break;
    case types::rrc_inactive_transition_report_request:
      c = rrc_inactive_transition_report_request_e{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::redirection_voice_fallback:
      c = redirection_voice_fallback_e{};
      break;
    case types::cn_assisted_ran_tuning:
      c = cn_assisted_ran_tuning_s{};
      break;
    case types::srvcc_operation_possible:
      c = srvcc_operation_possible_e{};
      break;
    case types::enhanced_coverage_restrict:
      c = enhanced_coverage_restrict_e{};
      break;
    case types::extended_connected_time:
      c = uint16_t{};
      break;
    case types::ue_diff_info:
      c = ue_diff_info_s{};
      break;
    case types::nr_v2x_services_authorized:
      c = nr_v2x_services_authorized_s{};
      break;
    case types::ltev2x_services_authorized:
      c = ltev2x_services_authorized_s{};
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c = lte_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::pc5_qos_params:
      c = pc5_qos_params_s{};
      break;
    case types::ce_mode_brestricted:
      c = ce_mode_brestricted_e{};
      break;
    case types::ue_up_c_iot_support:
      c = ue_up_c_iot_support_e{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::management_based_mdt_plmn_list:
      c = mdt_plmn_list_l{};
      break;
    case types::time_sync_assist_info:
      c = time_sync_assist_info_s{};
      break;
    case types::five_g_pro_se_authorized:
      c = five_g_pro_se_authorized_s{};
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c = five_g_pro_se_pc5_qos_params_s{};
      break;
    case types::management_based_mdt_plmn_mod_list:
      c = mdt_plmn_mod_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& path_switch_request_ack_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list()
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
pdu_session_res_released_list_ps_ack_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
core_network_assist_info_for_inactive_s& path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& path_switch_request_ack_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list() const
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
const pdu_session_res_released_list_ps_ack_l&
path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
const allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const core_network_assist_info_for_inactive_s&
path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
void path_switch_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::pdu_session_res_switched_list:
      j.start_array("PDUSessionResourceSwitchedList");
      for (const auto& e1 : c.get<pdu_session_res_switched_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      j.start_array("PDUSessionResourceReleasedListPSAck");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_switched_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_ack_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_switched_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_ack_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "UESecurityCapabilities",
                                "SecurityContext",
                                "NewSecurityContextInd",
                                "PDUSessionResourceSwitchedList",
                                "PDUSessionResourceReleasedListPSAck",
                                "AllowedNSSAI",
                                "CoreNetworkAssistanceInformationForInactive",
                                "RRCInactiveTransitionReportRequest",
                                "CriticalityDiagnostics",
                                "RedirectionVoiceFallback",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "Enhanced-CoverageRestriction",
                                "INTEGER (0..255)",
                                "UE-DifferentiationInfo",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "CEmodeBrestricted",
                                "UE-UP-CIoT-Support",
                                "OCTET STRING",
                                "MDTPLMNList",
                                "TimeSyncAssistanceInfo",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters",
                                "MDTPLMNModificationList"};
  return convert_enum_idx(names, 31, value, "path_switch_request_ack_ies_o::value_c::types");
}

// PathSwitchRequestFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool path_switch_request_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 69:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_fail_ies_o::value_c path_switch_request_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 69:
      ret.set(value_c::types::pdu_session_res_released_list_ps_fail);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 69:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c = pdu_session_res_released_list_ps_fail_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
const crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void path_switch_request_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      j.start_array("PDUSessionResourceReleasedListPSFail");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_fail_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_fail_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceReleasedListPSFail",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "path_switch_request_fail_ies_o::value_c::types");
}

// PathSwitchRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool path_switch_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 100:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 119:
      return crit_e::ignore;
    case 76:
      return crit_e::reject;
    case 57:
      return crit_e::ignore;
    case 237:
      return crit_e::ignore;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ies_o::value_c path_switch_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 100:
      ret.set(value_c::types::source_amf_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 76:
      ret.set(value_c::types::pdu_session_res_to_be_switched_dl_list);
      break;
    case 57:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ps_req);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 76:
      return presence_e::mandatory;
    case 57:
      return presence_e::optional;
    case 237:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::source_amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::ue_security_cap:
      c = ue_security_cap_s{};
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c = pdu_session_res_to_be_switched_dl_list_l{};
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c = pdu_session_res_failed_to_setup_list_ps_req_l{};
      break;
    case types::rrc_resume_cause:
      c = rrc_establishment_cause_e{};
      break;
    case types::red_cap_ind:
      c = red_cap_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id()
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& path_switch_request_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
pdu_session_res_to_be_switched_dl_list_l& path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list()
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id() const
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& path_switch_request_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const pdu_session_res_to_be_switched_dl_list_l&
path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list() const
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
const pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
const rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void path_switch_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      j.start_array("PDUSessionResourceToBeSwitchedDLList");
      for (const auto& e1 : c.get<pdu_session_res_to_be_switched_dl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      j.start_array("PDUSessionResourceFailedToSetupListPSReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ps_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_be_switched_dl_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_be_switched_dl_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), bref, 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "INTEGER (0..1099511627775)",
                                "UserLocationInformation",
                                "UESecurityCapabilities",
                                "PDUSessionResourceToBeSwitchedDLList",
                                "PDUSessionResourceFailedToSetupListPSReq",
                                "RRCEstablishmentCause",
                                "RedCapIndication"};
  return convert_enum_idx(names, 8, value, "path_switch_request_ies_o::value_c::types");
}

// Value ::= OPEN TYPE
void ngap_private_ies_empty_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}
SRSASN_CODE ngap_private_ies_empty_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_private_ies_empty_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}

const char* ngap_private_ies_empty_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {};
  return convert_enum_idx(names, 0, value, "ngap_private_ies_empty_o::value_c::types");
}

// RANCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  return map_enum_number(names, 5, idx, "id");
}
bool ran_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 25:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    case 211:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cp_relocation_ind_ies_o::value_c ran_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 25:
      ret.set(value_c::types::eutra_cgi);
      break;
    case 213:
      ret.set(value_c::types::tai);
      break;
    case 211:
      ret.set(value_c::types::ul_cp_security_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 25:
      return presence_e::mandatory;
    case 213:
      return presence_e::mandatory;
    case 211:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::five_g_s_tmsi:
      c = five_g_s_tmsi_s{};
      break;
    case types::eutra_cgi:
      c = eutra_cgi_s{};
      break;
    case types::tai:
      c = tai_s{};
      break;
    case types::ul_cp_security_info:
      c = ul_cp_security_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
}
uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi()
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
tai_s& ran_cp_relocation_ind_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info()
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
const uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi() const
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
const tai_s& ran_cp_relocation_ind_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info() const
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
void ran_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::eutra_cgi:
      j.write_fieldname("EUTRA-CGI");
      c.get<eutra_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::ul_cp_security_info:
      j.write_fieldname("UL-CP-SecurityInformation");
      c.get<ul_cp_security_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ran_cp_relocation_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..4294967295)", "FiveG-S-TMSI", "EUTRA-CGI", "TAI", "UL-CP-SecurityInformation"};
  return convert_enum_idx(names, 5, value, "ran_cp_relocation_ind_ies_o::value_c::types");
}
uint8_t ran_cp_relocation_ind_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "ran_cp_relocation_ind_ies_o::value_c::types");
}

// RANConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {19};
  return map_enum_number(names, 1, idx, "id");
}
bool ran_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  return 19 == id;
}
crit_e ran_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  if (id == 19) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ran_cfg_upd_ack_ies_o::value_c ran_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 19) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  if (id == 19) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CriticalityDiagnostics");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ran_cfg_upd_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"CriticalityDiagnostics"};
  return convert_enum_idx(names, 1, value, "ran_cfg_upd_ack_ies_o::value_c::types");
}

// RANConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ran_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_fail_ies_o::value_c ran_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cause:
      c = cause_c{};
      break;
    case types::time_to_wait:
      c = time_to_wait_e{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
}
cause_c& ran_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ran_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ran_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ran_cfg_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ran_cfg_upd_fail_ies_o::value_c::types");
}

// RANConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ran_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 167:
      return crit_e::reject;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_ies_o::value_c ran_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 167:
      ret.set(value_c::types::ngran_tnl_assoc_to_rem_list);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::optional;
    case 21:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 167:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ran_node_name:
      c = printable_string<1, 150, true, true>{};
      break;
    case types::supported_ta_list:
      c = supported_ta_list_l{};
      break;
    case types::default_paging_drx:
      c = paging_drx_e{};
      break;
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c = ngran_tnl_assoc_to_rem_list_l{};
      break;
    case types::nb_iot_default_paging_drx:
      c = nb_iot_default_paging_drx_e{};
      break;
    case types::extended_ran_node_name:
      c = extended_ran_node_name_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
}
printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
const nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ran_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      j.start_array("NGRAN-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<ngran_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngran_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngran_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ran_cfg_upd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PrintableString",
                                "SupportedTAList",
                                "PagingDRX",
                                "GlobalRANNodeID",
                                "NGRAN-TNLAssociationToRemoveList",
                                "NB-IoT-DefaultPagingDRX",
                                "Extended-RANNodeName"};
  return convert_enum_idx(names, 7, value, "ran_cfg_upd_ies_o::value_c::types");
}

// RRCInactiveTransitionReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t rrc_inactive_transition_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool rrc_inactive_transition_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e rrc_inactive_transition_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
rrc_inactive_transition_report_ies_o::value_c rrc_inactive_transition_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rrc_inactive_transition_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void rrc_inactive_transition_report_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::rrc_state:
      c = rrc_state_e{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void rrc_inactive_transition_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* rrc_inactive_transition_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "RRCState", "UserLocationInformation"};
  return convert_enum_idx(names, 4, value, "rrc_inactive_transition_report_ies_o::value_c::types");
}

// RerouteNASRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t reroute_nas_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  return map_enum_number(names, 6, idx, "id");
}
bool reroute_nas_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e reroute_nas_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 10:
      return crit_e::ignore;
    case 42:
      return crit_e::reject;
    case 3:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
reroute_nas_request_ies_o::value_c reroute_nas_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 42:
      ret.set(value_c::types::ngap_msg);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e reroute_nas_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 10:
      return presence_e::optional;
    case 42:
      return presence_e::mandatory;
    case 3:
      return presence_e::mandatory;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void reroute_nas_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ngap_msg:
      c = unbounded_octstring<true>{};
      break;
    case types::amf_set_id:
      c = fixed_bitstring<10, false, true>{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::source_to_target_amf_info_reroute:
      c = source_to_target_amf_info_reroute_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg()
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg() const
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
void reroute_nas_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ngap_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reroute_nas_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "INTEGER (0..1099511627775)",
                                "OCTET STRING",
                                "BIT STRING",
                                "AllowedNSSAI",
                                "SourceToTarget-AMFInformationReroute"};
  return convert_enum_idx(names, 6, value, "reroute_nas_request_ies_o::value_c::types");
}

// RetrieveUEInformationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t retrieve_ue_info_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26};
  return map_enum_number(names, 1, idx, "id");
}
bool retrieve_ue_info_ies_o::is_id_valid(const uint32_t& id)
{
  return 26 == id;
}
crit_e retrieve_ue_info_ies_o::get_crit(const uint32_t& id)
{
  if (id == 26) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
retrieve_ue_info_ies_o::value_c retrieve_ue_info_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 26) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e retrieve_ue_info_ies_o::get_presence(const uint32_t& id)
{
  if (id == 26) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void retrieve_ue_info_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("FiveG-S-TMSI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* retrieve_ue_info_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"FiveG-S-TMSI"};
  return convert_enum_idx(names, 1, value, "retrieve_ue_info_ies_o::value_c::types");
}

// SecondaryRATDataUsageReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t secondary_rat_data_usage_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool secondary_rat_data_usage_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e secondary_rat_data_usage_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 142:
      return crit_e::ignore;
    case 143:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
secondary_rat_data_usage_report_ies_o::value_c secondary_rat_data_usage_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 142:
      ret.set(value_c::types::pdu_session_res_secondary_rat_usage_list);
      break;
    case 143:
      ret.set(value_c::types::ho_flag);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e secondary_rat_data_usage_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 142:
      return presence_e::mandatory;
    case 143:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void secondary_rat_data_usage_report_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c = pdu_session_res_secondary_rat_usage_list_l{};
      break;
    case types::ho_flag:
      c = ho_flag_e{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list()
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag()
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list() const
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
const ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag() const
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
const user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void secondary_rat_data_usage_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      j.start_array("PDUSessionResourceSecondaryRATUsageList");
      for (const auto& e1 : c.get<pdu_session_res_secondary_rat_usage_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ho_flag:
      j.write_str("HandoverFlag", "handover-preparation");
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_secondary_rat_usage_list_l>(), 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_secondary_rat_usage_list_l>(), bref, 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* secondary_rat_data_usage_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceSecondaryRATUsageList",
                                "HandoverFlag",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 5, value, "secondary_rat_data_usage_report_ies_o::value_c::types");
}

// TraceFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool trace_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_fail_ind_ies_o::value_c trace_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_fail_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ngran_trace_id:
      c = fixed_octstring<8, true>{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
cause_c& trace_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const cause_c& trace_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void trace_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "Cause"};
  return convert_enum_idx(names, 4, value, "trace_fail_ind_ies_o::value_c::types");
}

// TraceStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 108};
  return map_enum_number(names, 3, idx, "id");
}
bool trace_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 108};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_start_ies_o::value_c trace_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 108:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_start_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::trace_activation:
      c = trace_activation_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
trace_activation_s& trace_start_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const trace_activation_s& trace_start_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
void trace_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_start_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "TraceActivation"};
  return convert_enum_idx(names, 3, value, "trace_start_ies_o::value_c::types");
}

// UEContextModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_fail_ies_o::value_c ue_context_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_mod_fail_ies_o::value_c::types");
}

// UEContextModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  return map_enum_number(names, 30, idx, "id");
}
bool ue_context_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 94:
      return crit_e::reject;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 40:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 162:
      return crit_e::reject;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 238:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 329:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_request_ies_o::value_c ue_context_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 40:
      ret.set(value_c::types::new_amf_ue_ngap_id);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 162:
      ret.set(value_c::types::new_guami);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 329:
      ret.set(value_c::types::qmc_deactivation);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 94:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 119:
      return presence_e::optional;
    case 18:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 40:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 162:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 329:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_paging_prio:
      c = uint16_t{};
      break;
    case types::security_key:
      c = fixed_bitstring<256, false, true>{};
      break;
    case types::idx_to_rfsp:
      c = uint16_t{};
      break;
    case types::ue_aggr_max_bit_rate:
      c = ue_aggr_max_bit_rate_s{};
      break;
    case types::ue_security_cap:
      c = ue_security_cap_s{};
      break;
    case types::core_network_assist_info_for_inactive:
      c = core_network_assist_info_for_inactive_s{};
      break;
    case types::emergency_fallback_ind:
      c = emergency_fallback_ind_s{};
      break;
    case types::new_amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::rrc_inactive_transition_report_request:
      c = rrc_inactive_transition_report_request_e{};
      break;
    case types::new_guami:
      c = guami_s{};
      break;
    case types::cn_assisted_ran_tuning:
      c = cn_assisted_ran_tuning_s{};
      break;
    case types::srvcc_operation_possible:
      c = srvcc_operation_possible_e{};
      break;
    case types::iab_authorized:
      c = iab_authorized_e{};
      break;
    case types::nr_v2x_services_authorized:
      c = nr_v2x_services_authorized_s{};
      break;
    case types::ltev2x_services_authorized:
      c = ltev2x_services_authorized_s{};
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c = lte_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::pc5_qos_params:
      c = pc5_qos_params_s{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::rg_level_wireline_access_characteristics:
      c = unbounded_octstring<true>{};
      break;
    case types::time_sync_assist_info:
      c = time_sync_assist_info_s{};
      break;
    case types::q_mcc_onfig_info:
      c = q_mcc_onfig_info_s{};
      break;
    case types::qmc_deactivation:
      c = qmc_deactivation_s{};
      break;
    case types::ue_slice_max_bit_rate_list:
      c = ue_slice_max_bit_rate_list_l{};
      break;
    case types::management_based_mdt_plmn_mod_list:
      c = mdt_plmn_mod_list_l{};
      break;
    case types::five_g_pro_se_authorized:
      c = five_g_pro_se_authorized_s{};
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c = nr_ue_sidelink_aggr_max_bitrate_s{};
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c = five_g_pro_se_pc5_qos_params_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
core_network_assist_info_for_inactive_s& ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id()
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ue_context_mod_request_ies_o::value_c::new_guami()
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation()
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const core_network_assist_info_for_inactive_s&
ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id() const
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ue_context_mod_request_ies_o::value_c::new_guami() const
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
const cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation() const
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
const ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ue_context_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::new_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::new_guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::qmc_deactivation:
      j.write_fieldname("QMCDeactivation");
      c.get<qmc_deactivation_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "BIT STRING",
                                "INTEGER (1..256,...)",
                                "UEAggregateMaximumBitRate",
                                "UESecurityCapabilities",
                                "CoreNetworkAssistanceInformationForInactive",
                                "EmergencyFallbackIndicator",
                                "INTEGER (0..1099511627775)",
                                "RRCInactiveTransitionReportRequest",
                                "GUAMI",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "IAB-Authorized",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "OCTET STRING",
                                "OCTET STRING",
                                "TimeSyncAssistanceInfo",
                                "QMCConfigInfo",
                                "QMCDeactivation",
                                "UESliceMaximumBitRateList",
                                "MDTPLMNModificationList",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters"};
  return convert_enum_idx(names, 30, value, "ue_context_mod_request_ies_o::value_c::types");
}

// UEContextModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_resp_ies_o::value_c ue_context_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::rrc_state:
      c = rrc_state_e{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "RRCState",
                                "UserLocationInformation",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "ue_context_mod_resp_ies_o::value_c::types");
}

// UEContextReleaseCommand-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {114, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_context_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {114, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 114:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_cmd_ies_o::value_c ue_context_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 114:
      ret.set(value_c::types::ue_ngap_ids);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 114:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_cmd_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ue_ngap_ids:
      c = ue_ngap_ids_c{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids()
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
cause_c& ue_context_release_cmd_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids() const
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
const cause_c& ue_context_release_cmd_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_ngap_ids:
      j.write_fieldname("UE-NGAP-IDs");
      c.get<ue_ngap_ids_c>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UE-NGAP-IDs", "Cause"};
  return convert_enum_idx(names, 2, value, "ue_context_release_cmd_ies_o::value_c::types");
}

// UEContextReleaseComplete-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_complete_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_context_release_complete_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_complete_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 60:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_complete_ies_o::value_c ue_context_release_complete_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 60:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_cpl);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_complete_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 60:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_complete_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c = info_on_recommended_cells_and_ran_nodes_for_paging_s{};
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c = pdu_session_res_list_cxt_rel_cpl_l{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c = paging_assis_datafor_c_ecapab_ue_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
pdu_session_res_list_cxt_rel_cpl_l& ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const pdu_session_res_list_cxt_rel_cpl_l&
ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
const crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_release_complete_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      j.start_array("PDUSessionResourceListCxtRelCpl");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_cpl_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_cpl_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_cpl_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_complete_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "UserLocationInformation",
                                "InfoOnRecommendedCellsAndRANNodesForPaging",
                                "PDUSessionResourceListCxtRelCpl",
                                "CriticalityDiagnostics",
                                "PagingAssisDataforCEcapabUE"};
  return convert_enum_idx(names, 7, value, "ue_context_release_complete_ies_o::value_c::types");
}

// UEContextReleaseRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 133:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_request_ies_o::value_c ue_context_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 133:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_req);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 133:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c = pdu_session_res_list_cxt_rel_req_l{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_list_cxt_rel_req_l& ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
cause_c& ue_context_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_list_cxt_rel_req_l&
ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
const cause_c& ue_context_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      j.start_array("PDUSessionResourceListCxtRelReq");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_req_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_req_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "PDUSessionResourceListCxtRelReq", "Cause"};
  return convert_enum_idx(names, 4, value, "ue_context_release_request_ies_o::value_c::types");
}

// UEContextResumeFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_resume_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_fail_ies_o::value_c ue_context_resume_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_resume_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_resume_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_resume_fail_ies_o::value_c::types");
}

// UEContextResumeRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 237:
      return crit_e::ignore;
    case 232:
      return crit_e::reject;
    case 229:
      return crit_e::reject;
    case 235:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_request_ies_o::value_c ue_context_resume_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 232:
      ret.set(value_c::types::pdu_session_res_resume_list_res_req);
      break;
    case 229:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_req);
      break;
    case 235:
      ret.set(value_c::types::suspend_request_ind);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 237:
      return presence_e::mandatory;
    case 232:
      return presence_e::optional;
    case 229:
      return presence_e::optional;
    case 235:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::rrc_resume_cause:
      c = rrc_establishment_cause_e{};
      break;
    case types::pdu_session_res_resume_list_res_req:
      c = pdu_session_res_resume_list_res_req_l{};
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c = pdu_session_res_failed_to_resume_list_res_req_l{};
      break;
    case types::suspend_request_ind:
      c = suspend_request_ind_e{};
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c = info_on_recommended_cells_and_ran_nodes_for_paging_s{};
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c = paging_assis_datafor_c_ecapab_ue_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
pdu_session_res_resume_list_res_req_l& ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind()
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const pdu_session_res_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
const pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
const suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind() const
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_resume_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::pdu_session_res_resume_list_res_req:
      j.start_array("PDUSessionResourceResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      j.start_array("PDUSessionResourceFailedToResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::suspend_request_ind:
      j.write_str("Suspend-Request-Indication", "suspend-requested");
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "RRCEstablishmentCause",
                                "PDUSessionResourceResumeListRESReq",
                                "PDUSessionResourceFailedToResumeListRESReq",
                                "Suspend-Request-Indication",
                                "InfoOnRecommendedCellsAndRANNodesForPaging",
                                "PagingAssisDataforCEcapabUE"};
  return convert_enum_idx(names, 8, value, "ue_context_resume_request_ies_o::value_c::types");
}

// UEContextResumeResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 233:
      return crit_e::reject;
    case 230:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 236:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_resp_ies_o::value_c ue_context_resume_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 233:
      ret.set(value_c::types::pdu_session_res_resume_list_res_res);
      break;
    case 230:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_res);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 236:
      ret.set(value_c::types::suspend_resp_ind);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 233:
      return presence_e::optional;
    case 230:
      return presence_e::optional;
    case 93:
      return presence_e::optional;
    case 236:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::pdu_session_res_resume_list_res_res:
      c = pdu_session_res_resume_list_res_res_l{};
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c = pdu_session_res_failed_to_resume_list_res_res_l{};
      break;
    case types::security_context:
      c = security_context_s{};
      break;
    case types::suspend_resp_ind:
      c = suspend_resp_ind_e{};
      break;
    case types::extended_connected_time:
      c = uint16_t{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_resume_list_res_res_l& ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
security_context_s& ue_context_resume_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind()
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
const pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
const security_context_s& ue_context_resume_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind() const
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
const uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      j.start_array("PDUSessionResourceResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      j.start_array("PDUSessionResourceFailedToResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::suspend_resp_ind:
      j.write_str("Suspend-Response-Indication", "suspend-indicated");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceResumeListRESRes",
                                "PDUSessionResourceFailedToResumeListRESRes",
                                "SecurityContext",
                                "Suspend-Response-Indication",
                                "INTEGER (0..255)",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 8, value, "ue_context_resume_resp_ies_o::value_c::types");
}

// UEContextSuspendFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_fail_ies_o::value_c ue_context_suspend_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_fail_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::cause:
      c = cause_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_suspend_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_suspend_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_suspend_fail_ies_o::value_c::types");
}

// UEContextSuspendRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_suspend_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    case 231:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_request_ies_o::value_c ue_context_suspend_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    case 231:
      ret.set(value_c::types::pdu_session_res_suspend_list_sus_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    case 231:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c = info_on_recommended_cells_and_ran_nodes_for_paging_s{};
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c = paging_assis_datafor_c_ecapab_ue_s{};
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c = pdu_session_res_suspend_list_sus_req_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req()
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req() const
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
void ue_context_suspend_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      j.start_array("PDUSessionResourceSuspendListSUSReq");
      for (const auto& e1 : c.get<pdu_session_res_suspend_list_sus_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_suspend_list_sus_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_suspend_list_sus_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "InfoOnRecommendedCellsAndRANNodesForPaging",
                                "PagingAssisDataforCEcapabUE",
                                "PDUSessionResourceSuspendListSUSReq"};
  return convert_enum_idx(names, 5, value, "ue_context_suspend_request_ies_o::value_c::types");
}

// UEContextSuspendResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 93:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_resp_ies_o::value_c ue_context_suspend_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 93:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::security_context:
      c = security_context_s{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "SecurityContext", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_suspend_resp_ies_o::value_c::types");
}

// UEInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 26:
      return crit_e::reject;
    case 210:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_info_transfer_ies_o::value_c ue_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 26:
      return presence_e::mandatory;
    case 210:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_info_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::five_g_s_tmsi:
      c = five_g_s_tmsi_s{};
      break;
    case types::nb_iot_ue_prio:
      c = uint16_t{};
      break;
    case types::ue_radio_cap:
      c = unbounded_octstring<true>{};
      break;
    case types::s_nssai:
      c = s_nssai_s{};
      break;
    case types::allowed_nssai:
      c = allowed_nssai_l{};
      break;
    case types::ue_diff_info:
      c = ue_diff_info_s{};
      break;
    case types::masked_imeisv:
      c = fixed_bitstring<64, false, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void ue_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"FiveG-S-TMSI",
                                "INTEGER (0..255,...)",
                                "OCTET STRING",
                                "S-NSSAI",
                                "AllowedNSSAI",
                                "UE-DifferentiationInfo",
                                "BIT STRING"};
  return convert_enum_idx(names, 7, value, "ue_info_transfer_ies_o::value_c::types");
}
uint8_t ue_info_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == nb_iot_ue_prio) {
    return 0;
  }
  invalid_enum_number(value, "ue_info_transfer_ies_o::value_c::types");
  return 0;
}

// UERadioCapabilityCheckRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_request_ies_o::value_c ue_radio_cap_check_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ue_radio_cap:
      c = unbounded_octstring<true>{};
      break;
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_check_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_check_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "ue_radio_cap_check_request_ies_o::value_c::types");
}

// UERadioCapabilityCheckResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 30:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_resp_ies_o::value_c ue_radio_cap_check_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 30:
      ret.set(value_c::types::ims_voice_support_ind);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 30:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ims_voice_support_ind:
      c = ims_voice_support_ind_e{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind()
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind() const
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
const crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_check_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      j.write_str("IMSVoiceSupportIndicator", c.get<ims_voice_support_ind_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_check_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "IMSVoiceSupportIndicator", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_radio_cap_check_resp_ies_o::value_c::types");
}

// UERadioCapabilityIDMappingRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_radio_cap_id_map_request_ies_o::is_id_valid(const uint32_t& id)
{
  return 264 == id;
}
crit_e ue_radio_cap_id_map_request_ies_o::get_crit(const uint32_t& id)
{
  if (id == 264) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_radio_cap_id_map_request_ies_o::value_c ue_radio_cap_id_map_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 264) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_request_ies_o::get_presence(const uint32_t& id)
{
  if (id == 264) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_id_map_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "ue_radio_cap_id_map_request_ies_o::value_c::types");
}

// UERadioCapabilityIDMappingResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264, 117, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ue_radio_cap_id_map_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {264, 117, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_id_map_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 264:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_id_map_resp_ies_o::value_c ue_radio_cap_id_map_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 264:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ue_radio_cap_id:
      c = unbounded_octstring<true>{};
      break;
    case types::ue_radio_cap:
      c = unbounded_octstring<true>{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_id_map_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_id_map_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ue_radio_cap_id_map_resp_ies_o::value_c::types");
}

// UERadioCapabilityInfoIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_info_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_radio_cap_info_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_info_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 265:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_info_ind_ies_o::value_c ue_radio_cap_info_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 265:
      ret.set(value_c::types::ue_radio_cap_eutra_format);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_info_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 118:
      return presence_e::optional;
    case 265:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_info_ind_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ue_radio_cap:
      c = unbounded_octstring<true>{};
      break;
    case types::ue_radio_cap_for_paging:
      c = ue_radio_cap_for_paging_s{};
      break;
    case types::ue_radio_cap_eutra_format:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format()
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format() const
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_info_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::ue_radio_cap_eutra_format:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_info_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "UERadioCapabilityForPaging",
                                "OCTET STRING"};
  return convert_enum_idx(names, 5, value, "ue_radio_cap_info_ind_ies_o::value_c::types");
}

// UETNLABindingReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_tnla_binding_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_tnla_binding_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_tnla_binding_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_tnla_binding_release_request_ies_o::value_c ue_tnla_binding_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_tnla_binding_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_tnla_binding_release_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ue_tnla_binding_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_tnla_binding_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)"};
  return convert_enum_idx(names, 2, value, "ue_tnla_binding_release_request_ies_o::value_c::types");
}

// UplinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  return map_enum_number(names, 7, idx, "id");
}
bool ul_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 239:
      return crit_e::reject;
    case 246:
      return crit_e::reject;
    case 247:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_nas_transport_ies_o::value_c ul_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 239:
      ret.set(value_c::types::w_agf_id_info);
      break;
    case 246:
      ret.set(value_c::types::tngf_id_info);
      break;
    case 247:
      ret.set(value_c::types::twif_id_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 239:
      return presence_e::optional;
    case 246:
      return presence_e::optional;
    case 247:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_nas_transport_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::nas_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::user_location_info:
      c = user_location_info_c{};
      break;
    case types::w_agf_id_info:
      c = unbounded_octstring<true>{};
      break;
    case types::tngf_id_info:
      c = unbounded_octstring<true>{};
      break;
    case types::twif_id_info:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info()
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info()
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info()
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info() const
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info() const
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info() const
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::w_agf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::tngf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::twif_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_nas_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "UserLocationInformation",
                                "OCTET STRING",
                                "OCTET STRING",
                                "OCTET STRING"};
  return convert_enum_idx(names, 7, value, "ul_nas_transport_ies_o::value_c::types");
}

// UplinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c
ul_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c = unbounded_octstring<true>{};
      break;
    case types::nrppa_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_non_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "ul_non_ue_associated_nrppa_transport_ies_o::value_c::types");
}

// UplinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {99, 158, 251};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {99, 158, 251};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 99:
      return crit_e::ignore;
    case 158:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_cfg_transfer_ies_o::value_c ul_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 99:
      ret.set(value_c::types::son_cfg_transfer_ul);
      break;
    case 158:
      ret.set(value_c::types::endc_son_cfg_transfer_ul);
      break;
    case 251:
      ret.set(value_c::types::intersys_son_cfg_transfer_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 99:
      return presence_e::optional;
    case 158:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c = son_cfg_transfer_s{};
      break;
    case types::endc_son_cfg_transfer_ul:
      c = unbounded_octstring<true>{};
      break;
    case types::intersys_son_cfg_transfer_ul:
      c = intersys_son_cfg_transfer_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
}
son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul()
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul()
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul()
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul() const
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul() const
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void ul_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_ul:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_ul:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_ul:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ran_cfg_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SONConfigurationTransfer", "OCTET STRING", "IntersystemSONConfigurationTransfer"};
  return convert_enum_idx(names, 3, value, "ul_ran_cfg_transfer_ies_o::value_c::types");
}

// UplinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_early_status_transfer_ies_o::value_c ul_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::early_status_transfer_transparent_container:
      c = early_status_transfer_transparent_container_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void ul_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ran_early_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "EarlyStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "ul_ran_early_status_transfer_ies_o::value_c::types");
}

// UplinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_status_transfer_ies_o::value_c ul_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_status_transfer_transparent_container:
      c = ran_status_transfer_transparent_container_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void ul_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ran_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "RANStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "ul_ran_status_transfer_ies_o::value_c::types");
}

// UplinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool ul_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e ul_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ul_rim_info_transfer_ies_o::value_c ul_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ul_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ul_rim_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"RIMInformationTransfer"};
  return convert_enum_idx(names, 1, value, "ul_rim_info_transfer_ies_o::value_c::types");
}

// UplinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool ul_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ue_associated_nrppa_transport_ies_o::value_c ul_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::ran_ue_ngap_id:
      c = uint64_t{};
      break;
    case types::routing_id:
      c = unbounded_octstring<true>{};
      break;
    case types::nrppa_pdu:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "ul_ue_associated_nrppa_transport_ies_o::value_c::types");
}

// WriteReplaceWarningRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  return map_enum_number(names, 11, idx, "id");
}
bool write_replace_warning_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 87:
      return crit_e::reject;
    case 47:
      return crit_e::reject;
    case 125:
      return crit_e::ignore;
    case 124:
      return crit_e::ignore;
    case 20:
      return crit_e::ignore;
    case 123:
      return crit_e::ignore;
    case 17:
      return crit_e::reject;
    case 141:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_request_ies_o::value_c write_replace_warning_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 87:
      ret.set(value_c::types::repeat_period);
      break;
    case 47:
      ret.set(value_c::types::nof_broadcasts_requested);
      break;
    case 125:
      ret.set(value_c::types::warning_type);
      break;
    case 124:
      ret.set(value_c::types::warning_security_info);
      break;
    case 20:
      ret.set(value_c::types::data_coding_scheme);
      break;
    case 123:
      ret.set(value_c::types::warning_msg_contents);
      break;
    case 17:
      ret.set(value_c::types::concurrent_warning_msg_ind);
      break;
    case 141:
      ret.set(value_c::types::warning_area_coordinates);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 87:
      return presence_e::mandatory;
    case 47:
      return presence_e::mandatory;
    case 125:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 20:
      return presence_e::optional;
    case 123:
      return presence_e::optional;
    case 17:
      return presence_e::optional;
    case 141:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_request_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::serial_num:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::warning_area_list:
      c = warning_area_list_c{};
      break;
    case types::repeat_period:
      c = uint32_t{};
      break;
    case types::nof_broadcasts_requested:
      c = uint32_t{};
      break;
    case types::warning_type:
      c = fixed_octstring<2, true>{};
      break;
    case types::warning_security_info:
      c = fixed_octstring<50, true>{};
      break;
    case types::data_coding_scheme:
      c = fixed_bitstring<8, false, true>{};
      break;
    case types::warning_msg_contents:
      c = bounded_octstring<1, 9600, true>{};
      break;
    case types::concurrent_warning_msg_ind:
      c = concurrent_warning_msg_ind_e{};
      break;
    case types::warning_area_coordinates:
      c = bounded_octstring<1, 1024, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period()
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested()
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type()
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info()
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme()
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents()
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind()
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates()
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period() const
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested() const
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type() const
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
const fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info() const
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
const fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme() const
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
const bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents() const
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
const concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind() const
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
const bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates() const
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
void write_replace_warning_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::repeat_period:
      j.write_int("INTEGER (0..131071)", c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      j.write_int("INTEGER (0..65535)", c.get<uint32_t>());
      break;
    case types::warning_type:
      j.write_str("OCTET STRING", c.get<fixed_octstring<2, true>>().to_string());
      break;
    case types::warning_security_info:
      j.write_str("OCTET STRING", c.get<fixed_octstring<50, true>>().to_string());
      break;
    case types::data_coding_scheme:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::warning_msg_contents:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 9600, true>>().to_string());
      break;
    case types::concurrent_warning_msg_ind:
      j.write_str("ConcurrentWarningMessageInd", "true");
      break;
    case types::warning_area_coordinates:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 1024, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().pack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().pack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().pack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().pack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().unpack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().unpack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().unpack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().unpack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* write_replace_warning_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING",
                                "BIT STRING",
                                "WarningAreaList",
                                "INTEGER (0..131071)",
                                "INTEGER (0..65535)",
                                "OCTET STRING",
                                "OCTET STRING",
                                "BIT STRING",
                                "OCTET STRING",
                                "ConcurrentWarningMessageInd",
                                "OCTET STRING"};
  return convert_enum_idx(names, 11, value, "write_replace_warning_request_ies_o::value_c::types");
}

// WriteReplaceWarningResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool write_replace_warning_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 13:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_resp_ies_o::value_c write_replace_warning_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 13:
      ret.set(value_c::types::broadcast_completed_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 13:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_resp_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::serial_num:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::broadcast_completed_area_list:
      c = broadcast_completed_area_list_c{};
      break;
    case types::crit_diagnostics:
      c = crit_diagnostics_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list()
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list() const
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
const crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void write_replace_warning_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_completed_area_list:
      j.write_fieldname("BroadcastCompletedAreaList");
      c.get<broadcast_completed_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* write_replace_warning_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING", "BroadcastCompletedAreaList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "write_replace_warning_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<location_report_ies_o>;

SRSASN_CODE location_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += ue_presence_in_area_of_interest_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (ue_presence_in_area_of_interest_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)116, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_presence_in_area_of_interest_list, 1, 64, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 116: {
        ue_presence_in_area_of_interest_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_presence_in_area_of_interest_list, bref, 1, 64, true));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  if (ue_presence_in_area_of_interest_list_present) {
    j.write_int("id", 116);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_presence_in_area_of_interest_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 33);
  j.write_str("criticality", "ignore");
  location_report_request_type.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<location_report_ctrl_ies_o>;

SRSASN_CODE location_report_ctrl_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ctrl_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 33);
  j.write_str("criticality", "ignore");
  location_report_request_type.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<location_report_fail_ind_ies_o>;

SRSASN_CODE location_report_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_group_paging_ies_o>;

SRSASN_CODE multicast_group_paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_service_area_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)307, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, multicast_group_paging_area_list, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.unpack(bref));
        break;
      }
      case 307: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(multicast_group_paging_area_list, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_group_paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "ignore");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_int("id", 298);
    j.write_str("criticality", "ignore");
    mbs_service_area.to_json(j);
  }
  j.write_int("id", 307);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : multicast_group_paging_area_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_activation_fail_ies_o>;

SRSASN_CODE multicast_session_activation_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_activation_request_ies_o>;

SRSASN_CODE multicast_session_activation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)304, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(multicast_session_activation_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 304: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_activation_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 304);
  j.write_str("criticality", "reject");
  j.write_str("Value", multicast_session_activation_request_transfer.to_string());
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_activation_resp_ies_o>;

SRSASN_CODE multicast_session_activation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_deactivation_request_ies_o>;

SRSASN_CODE multicast_session_deactivation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)305, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(multicast_session_deactivation_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 305: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_deactivation_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 305);
  j.write_str("criticality", "reject");
  j.write_str("Value", multicast_session_deactivation_request_transfer.to_string());
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_deactivation_resp_ies_o>;

SRSASN_CODE multicast_session_deactivation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_fail_ies_o>;

SRSASN_CODE multicast_session_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_request_ies_o>;

SRSASN_CODE multicast_session_upd_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)306, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(multicast_session_upd_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 306: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_upd_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 306);
  j.write_str("criticality", "reject");
  j.write_str("Value", multicast_session_upd_request_transfer.to_string());
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_resp_ies_o>;

SRSASN_CODE multicast_session_upd_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<nas_non_delivery_ind_ies_o>;

SRSASN_CODE nas_non_delivery_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void nas_non_delivery_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 38);
  j.write_str("criticality", "ignore");
  j.write_str("Value", nas_pdu.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_reset_ies_o>;

SRSASN_CODE ng_reset_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)88, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(reset_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 88: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(reset_type.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_reset_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.write_int("id", 88);
  j.write_str("criticality", "reject");
  reset_type.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_reset_ack_ies_o>;

SRSASN_CODE ng_reset_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ue_associated_lc_ng_conn_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ue_associated_lc_ng_conn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)111, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_associated_lc_ng_conn_list, 1, 65536, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 111: {
        ue_associated_lc_ng_conn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_associated_lc_ng_conn_list, bref, 1, 65536, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ng_reset_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_associated_lc_ng_conn_list_present) {
    j.write_int("id", 111);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_associated_lc_ng_conn_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_setup_fail_ies_o>;

SRSASN_CODE ng_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (time_to_wait_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)107, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_int("id", 107);
    j.write_str("criticality", "ignore");
    j.write_str("Value", time_to_wait.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_setup_request_ies_o>;

SRSASN_CODE ng_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)82, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)102, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, supported_ta_list, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)21, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(default_paging_drx.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)147, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)204, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)273, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 27: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 82: {
        ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.unpack(bref));
        break;
      }
      case 102: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(supported_ta_list, bref, 1, 256, true));
        break;
      }
      case 21: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.unpack(bref));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 27);
  j.write_str("criticality", "reject");
  global_ran_node_id.to_json(j);
  if (ran_node_name_present) {
    j.write_int("id", 82);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ran_node_name.to_string());
  }
  j.write_int("id", 102);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : supported_ta_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 21);
  j.write_str("criticality", "ignore");
  j.write_str("Value", default_paging_drx.to_string());
  if (ue_retention_info_present) {
    j.write_int("id", 147);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "ues-retained");
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_int("id", 204);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nb_iot_default_paging_drx.to_string());
  }
  if (extended_ran_node_name_present) {
    j.write_int("id", 273);
    j.write_str("criticality", "ignore");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_setup_resp_ies_o>;

SRSASN_CODE ng_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += iab_supported_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)1, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_name.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)96, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, served_guami_list, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)86, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, relative_amf_capacity, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)80, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, plmn_support_list, 1, 12, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)147, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (iab_supported_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)200, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_supported.pack(bref));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)274, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 1: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.unpack(bref));
        break;
      }
      case 96: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(served_guami_list, bref, 1, 256, true));
        break;
      }
      case 86: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(relative_amf_capacity, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 80: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(plmn_support_list, bref, 1, 12, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.unpack(bref));
        break;
      }
      case 200: {
        iab_supported_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_supported.unpack(bref));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 1);
  j.write_str("criticality", "reject");
  j.write_str("Value", amf_name.to_string());
  j.write_int("id", 96);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : served_guami_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 86);
  j.write_str("criticality", "ignore");
  j.write_int("Value", relative_amf_capacity);
  j.write_int("id", 80);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : plmn_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (ue_retention_info_present) {
    j.write_int("id", 147);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "ues-retained");
  }
  if (iab_supported_present) {
    j.write_int("id", 200);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "true");
  }
  if (extended_amf_name_present) {
    j.write_int("id", 274);
    j.write_str("criticality", "ignore");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<overload_start_ies_o>;

SRSASN_CODE overload_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_overload_resp_present ? 1 : 0;
  nof_ies += amf_traffic_load_reduction_ind_present ? 1 : 0;
  nof_ies += overload_start_nssai_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_overload_resp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)2, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_overload_resp.pack(bref));
  }
  if (amf_traffic_load_reduction_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)9, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_traffic_load_reduction_ind, (uint8_t)1u, (uint8_t)99u, false, true));
  }
  if (overload_start_nssai_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)49, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, overload_start_nssai_list, 1, 1024, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 2: {
        amf_overload_resp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_overload_resp.unpack(bref));
        break;
      }
      case 9: {
        amf_traffic_load_reduction_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_traffic_load_reduction_ind, bref, (uint8_t)1u, (uint8_t)99u, false, true));
        break;
      }
      case 49: {
        overload_start_nssai_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(overload_start_nssai_list, bref, 1, 1024, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void overload_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_overload_resp_present) {
    j.write_int("id", 2);
    j.write_str("criticality", "reject");
    amf_overload_resp.to_json(j);
  }
  if (amf_traffic_load_reduction_ind_present) {
    j.write_int("id", 9);
    j.write_str("criticality", "ignore");
    j.write_int("Value", amf_traffic_load_reduction_ind);
  }
  if (overload_start_nssai_list_present) {
    j.write_int("id", 49);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : overload_start_nssai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_confirm_ies_o>;

SRSASN_CODE pdu_session_res_modify_confirm_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_modify_list_mod_cfm_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)62, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_cfm, 1, 256, true));
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)131, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_modify_list_mod_cfm, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 62: {
        pdu_session_res_modify_list_mod_cfm_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_cfm, bref, 1, 256, true));
        break;
      }
      case 131: {
        pdu_session_res_failed_to_modify_list_mod_cfm_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_modify_list_mod_cfm, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_modify_list_mod_cfm_present) {
    j.write_int("id", 62);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_modify_list_mod_cfm) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    j.write_int("id", 131);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_modify_list_mod_cfm) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_ind_ies_o>;

SRSASN_CODE pdu_session_res_modify_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)63, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_ind, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 63: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_ind, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 63);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_modify_list_mod_ind) {
    e1.to_json(j);
  }
  j.end_array();
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_request_ies_o>;

SRSASN_CODE pdu_session_res_modify_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)64, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_req, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 64: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_req, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  j.write_int("id", 64);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_modify_list_mod_req) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_resp_ies_o>;

SRSASN_CODE pdu_session_res_modify_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_res_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_modify_list_mod_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)65, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)54, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_modify_list_mod_res, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 65: {
        pdu_session_res_modify_list_mod_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_res, bref, 1, 256, true));
        break;
      }
      case 54: {
        pdu_session_res_failed_to_modify_list_mod_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_modify_list_mod_res, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_modify_list_mod_res_present) {
    j.write_int("id", 65);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_modify_list_mod_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    j.write_int("id", 54);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_modify_list_mod_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_notify_ies_o>;

SRSASN_CODE pdu_session_res_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_notify_list_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_not_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_notify_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)66, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_notify_list, 1, 256, true));
  }
  if (pdu_session_res_released_list_not_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)67, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_not, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 66: {
        pdu_session_res_notify_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_notify_list, bref, 1, 256, true));
        break;
      }
      case 67: {
        pdu_session_res_released_list_not_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_not, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_notify_list_present) {
    j.write_int("id", 66);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_notify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_released_list_not_present) {
    j.write_int("id", 67);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_released_list_not) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_release_cmd_ies_o>;

SRSASN_CODE pdu_session_res_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)79, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_to_release_list_rel_cmd, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 79: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_to_release_list_rel_cmd, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  if (nas_pdu_present) {
    j.write_int("id", 38);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nas_pdu.to_string());
  }
  j.write_int("id", 79);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_to_release_list_rel_cmd) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_release_resp_ies_o>;

SRSASN_CODE pdu_session_res_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)70, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_rel_res, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 70: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_rel_res, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 70);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_released_list_rel_res) {
    e1.to_json(j);
  }
  j.end_array();
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_setup_request_ies_o>;

SRSASN_CODE pdu_session_res_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)74, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_su_req, 1, 256, true));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 74: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_su_req, bref, 1, 256, true));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  if (nas_pdu_present) {
    j.write_int("id", 38);
    j.write_str("criticality", "reject");
    j.write_str("Value", nas_pdu.to_string());
  }
  j.write_int("id", 74);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_setup_list_su_req) {
    e1.to_json(j);
  }
  j.end_array();
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "ignore");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_setup_resp_ies_o>;

SRSASN_CODE pdu_session_res_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_su_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_su_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_setup_list_su_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)75, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_su_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)58, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_su_res, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 75: {
        pdu_session_res_setup_list_su_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_su_res, bref, 1, 256, true));
        break;
      }
      case 58: {
        pdu_session_res_failed_to_setup_list_su_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_su_res, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_setup_list_su_res_present) {
    j.write_int("id", 75);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_setup_list_su_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    j.write_int("id", 58);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_su_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_cancel_request_ies_o>;

SRSASN_CODE pws_cancel_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += cancel_all_warning_msgs_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (warning_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)122, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  if (cancel_all_warning_msgs_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)14, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cancel_all_warning_msgs.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.unpack(bref));
        break;
      }
      case 14: {
        cancel_all_warning_msgs_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cancel_all_warning_msgs.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (warning_area_list_present) {
    j.write_int("id", 122);
    j.write_str("criticality", "ignore");
    warning_area_list.to_json(j);
  }
  if (cancel_all_warning_msgs_present) {
    j.write_int("id", 14);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_cancel_resp_ies_o>;

SRSASN_CODE pws_cancel_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_cancelled_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (broadcast_cancelled_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)12, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(broadcast_cancelled_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 12: {
        broadcast_cancelled_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_cancelled_area_list.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (broadcast_cancelled_area_list_present) {
    j.write_int("id", 12);
    j.write_str("criticality", "ignore");
    broadcast_cancelled_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_fail_ind_ies_o>;

SRSASN_CODE pws_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)81, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pws_failed_cell_id_list.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 81: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pws_failed_cell_id_list.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 81);
  j.write_str("criticality", "reject");
  pws_failed_cell_id_list.to_json(j);
  j.write_int("id", 27);
  j.write_str("criticality", "reject");
  global_ran_node_id.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_restart_ind_ies_o>;

SRSASN_CODE pws_restart_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += emergency_area_id_list_for_restart_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)16, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cell_id_list_for_restart.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)104, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_list_for_restart, 1, 2048, true));
  }
  if (emergency_area_id_list_for_restart_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)23, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, emergency_area_id_list_for_restart, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 16: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cell_id_list_for_restart.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 104: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_list_for_restart, bref, 1, 2048, true));
        break;
      }
      case 23: {
        emergency_area_id_list_for_restart_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(emergency_area_id_list_for_restart, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_restart_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 16);
  j.write_str("criticality", "reject");
  cell_id_list_for_restart.to_json(j);
  j.write_int("id", 27);
  j.write_str("criticality", "reject");
  global_ran_node_id.to_json(j);
  j.write_int("id", 104);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : tai_list_for_restart) {
    e1.to_json(j);
  }
  j.end_array();
  if (emergency_area_id_list_for_restart_present) {
    j.write_int("id", 23);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : emergency_area_id_list_for_restart) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<paging_ies_o>;

SRSASN_CODE paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += paging_drx_present ? 1 : 0;
  nof_ies += paging_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += paging_origin_present ? 1 : 0;
  nof_ies += assist_data_for_paging_present ? 1 : 0;
  nof_ies += nb_iot_paging_e_drx_info_present ? 1 : 0;
  nof_ies += nb_iot_paging_drx_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += wus_assist_info_present ? 1 : 0;
  nof_ies += eutra_paginge_drx_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += nr_paginge_drx_info_present ? 1 : 0;
  nof_ies += paging_cause_present ? 1 : 0;
  nof_ies += pe_ip_sassist_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)115, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_paging_id.pack(bref));
  }
  if (paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)50, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_drx.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)103, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_list_for_paging, 1, 16, true));
  }
  if (paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)52, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_prio.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (paging_origin_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)51, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_origin.pack(bref));
  }
  if (assist_data_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)11, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(assist_data_for_paging.pack(bref));
  }
  if (nb_iot_paging_e_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)203, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_paging_e_drx_info.pack(bref));
  }
  if (nb_iot_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)202, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_paging_drx.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (wus_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)208, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(wus_assist_info.pack(bref));
  }
  if (eutra_paginge_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)223, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(eutra_paginge_drx_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (nr_paginge_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)332, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_paginge_drx_info.pack(bref));
  }
  if (paging_cause_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)342, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_cause.pack(bref));
  }
  if (pe_ip_sassist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)344, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pe_ip_sassist_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 115: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_paging_id.unpack(bref));
        break;
      }
      case 50: {
        paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_drx.unpack(bref));
        break;
      }
      case 103: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_list_for_paging, bref, 1, 16, true));
        break;
      }
      case 52: {
        paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_prio.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.unpack(bref));
        break;
      }
      case 51: {
        paging_origin_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_origin.unpack(bref));
        break;
      }
      case 11: {
        assist_data_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(assist_data_for_paging.unpack(bref));
        break;
      }
      case 203: {
        nb_iot_paging_e_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_e_drx_info.unpack(bref));
        break;
      }
      case 202: {
        nb_iot_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_drx.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 208: {
        wus_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(wus_assist_info.unpack(bref));
        break;
      }
      case 223: {
        eutra_paginge_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_paginge_drx_info.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 332: {
        nr_paginge_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_paginge_drx_info.unpack(bref));
        break;
      }
      case 342: {
        paging_cause_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_cause.unpack(bref));
        break;
      }
      case 344: {
        pe_ip_sassist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pe_ip_sassist_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 115);
  j.write_str("criticality", "ignore");
  ue_paging_id.to_json(j);
  if (paging_drx_present) {
    j.write_int("id", 50);
    j.write_str("criticality", "ignore");
    j.write_str("Value", paging_drx.to_string());
  }
  j.write_int("id", 103);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : tai_list_for_paging) {
    e1.to_json(j);
  }
  j.end_array();
  if (paging_prio_present) {
    j.write_int("id", 52);
    j.write_str("criticality", "ignore");
    j.write_str("Value", paging_prio.to_string());
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "ignore");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (paging_origin_present) {
    j.write_int("id", 51);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "non-3gpp");
  }
  if (assist_data_for_paging_present) {
    j.write_int("id", 11);
    j.write_str("criticality", "ignore");
    assist_data_for_paging.to_json(j);
  }
  if (nb_iot_paging_e_drx_info_present) {
    j.write_int("id", 203);
    j.write_str("criticality", "ignore");
    nb_iot_paging_e_drx_info.to_json(j);
  }
  if (nb_iot_paging_drx_present) {
    j.write_int("id", 202);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nb_iot_paging_drx.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (wus_assist_info_present) {
    j.write_int("id", 208);
    j.write_str("criticality", "ignore");
    wus_assist_info.to_json(j);
  }
  if (eutra_paginge_drx_info_present) {
    j.write_int("id", 223);
    j.write_str("criticality", "ignore");
    eutra_paginge_drx_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (nr_paginge_drx_info_present) {
    j.write_int("id", 332);
    j.write_str("criticality", "ignore");
    nr_paginge_drx_info.to_json(j);
  }
  if (paging_cause_present) {
    j.write_int("id", 342);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "voice");
  }
  if (pe_ip_sassist_info_present) {
    j.write_int("id", 344);
    j.write_str("criticality", "ignore");
    pe_ip_sassist_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<path_switch_request_ies_o>;

SRSASN_CODE path_switch_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += pdu_session_res_failed_to_setup_list_ps_req_present ? 1 : 0;
  nof_ies += rrc_resume_cause_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)100, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, source_amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)76, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_to_be_switched_dl_list, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)57, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_ps_req, 1, 256, true));
  }
  if (rrc_resume_cause_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)237, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)333, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 100: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(source_amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 76: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_to_be_switched_dl_list, bref, 1, 256, true));
        break;
      }
      case 57: {
        pdu_session_res_failed_to_setup_list_ps_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_ps_req, bref, 1, 256, true));
        break;
      }
      case 237: {
        rrc_resume_cause_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 100);
  j.write_str("criticality", "reject");
  j.write_int("Value", source_amf_ue_ngap_id);
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  j.write_int("id", 119);
  j.write_str("criticality", "ignore");
  ue_security_cap.to_json(j);
  j.write_int("id", 76);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_to_be_switched_dl_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    j.write_int("id", 57);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_ps_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rrc_resume_cause_present) {
    j.write_int("id", 237);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_resume_cause.to_string());
  }
  if (red_cap_ind_present) {
    j.write_int("id", 333);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "redcap");
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<path_switch_request_ack_ies_o>;

SRSASN_CODE path_switch_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_ps_ack_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ue_security_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (new_security_context_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)41, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)77, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_switched_list, 1, 256, true));
  }
  if (pdu_session_res_released_list_ps_ack_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)68, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_ps_ack, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)254, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_list, 1, 16, true));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)359, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_mod_list, 0, 16, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.unpack(bref));
        break;
      }
      case 77: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_switched_list, bref, 1, 256, true));
        break;
      }
      case 68: {
        pdu_session_res_released_list_ps_ack_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_ps_ack, bref, 1, 256, true));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_list, bref, 1, 16, true));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_mod_list, bref, 0, 16, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (ue_security_cap_present) {
    j.write_int("id", 119);
    j.write_str("criticality", "reject");
    ue_security_cap.to_json(j);
  }
  j.write_int("id", 93);
  j.write_str("criticality", "reject");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_int("id", 41);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  j.write_int("id", 77);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_switched_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pdu_session_res_released_list_ps_ack_present) {
    j.write_int("id", 68);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_released_list_ps_ack) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 0);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : allowed_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redirection_voice_fallback.to_string());
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_up_c_iot_support_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "supported");
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_int("id", 254);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_int("id", 359);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_mod_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<path_switch_request_fail_ies_o>;

SRSASN_CODE path_switch_request_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)69, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_ps_fail, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 69: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_ps_fail, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 69);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_released_list_ps_fail) {
    e1.to_json(j);
  }
  j.end_array();
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE private_ie_container_empty_l::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_ie_container_empty_l::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);
  if (nof_ies > 0) {
    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void private_ie_container_empty_l::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}

// PrivateMessage ::= SEQUENCE
SRSASN_CODE private_msg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(private_ies.pack(bref));

  bref.align_bytes_zero();

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_msg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(private_ies.unpack(bref));

  bref.align_bytes();

  return SRSASN_SUCCESS;
}
void private_msg_s::to_json(json_writer& j) const
{
  j.start_array();
  j.start_obj();
  j.start_obj("PrivateMessage");
  j.write_fieldname("privateIEs");
  private_ies.to_json(j);
  j.end_obj();
  j.end_obj();
  j.end_array();
}

template struct asn1::protocol_ie_field_s<ran_cp_relocation_ind_ies_o>;

SRSASN_CODE ran_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)25, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(eutra_cgi.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)213, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tai.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)211, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_cp_security_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 26: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      case 25: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_cgi.unpack(bref));
        break;
      }
      case 213: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai.unpack(bref));
        break;
      }
      case 211: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_cp_security_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 26);
  j.write_str("criticality", "reject");
  five_g_s_tmsi.to_json(j);
  j.write_int("id", 25);
  j.write_str("criticality", "ignore");
  eutra_cgi.to_json(j);
  j.write_int("id", 213);
  j.write_str("criticality", "ignore");
  tai.to_json(j);
  j.write_int("id", 211);
  j.write_str("criticality", "reject");
  ul_cp_security_info.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ran_cfg_upd_ies_o>;

SRSASN_CODE ran_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += supported_ta_list_present ? 1 : 0;
  nof_ies += default_paging_drx_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += ngran_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)82, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  if (supported_ta_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)102, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, supported_ta_list, 1, 256, true));
  }
  if (default_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)21, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(default_paging_drx.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)167, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ngran_tnl_assoc_to_rem_list, 1, 32, true));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)204, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)273, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 82: {
        ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.unpack(bref));
        break;
      }
      case 102: {
        supported_ta_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(supported_ta_list, bref, 1, 256, true));
        break;
      }
      case 21: {
        default_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 167: {
        ngran_tnl_assoc_to_rem_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ngran_tnl_assoc_to_rem_list, bref, 1, 32, true));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ran_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ran_node_name_present) {
    j.write_int("id", 82);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ran_node_name.to_string());
  }
  if (supported_ta_list_present) {
    j.write_int("id", 102);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : supported_ta_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (default_paging_drx_present) {
    j.write_int("id", 21);
    j.write_str("criticality", "ignore");
    j.write_str("Value", default_paging_drx.to_string());
  }
  if (global_ran_node_id_present) {
    j.write_int("id", 27);
    j.write_str("criticality", "ignore");
    global_ran_node_id.to_json(j);
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    j.write_int("id", 167);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : ngran_tnl_assoc_to_rem_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_int("id", 204);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nb_iot_default_paging_drx.to_string());
  }
  if (extended_ran_node_name_present) {
    j.write_int("id", 273);
    j.write_str("criticality", "ignore");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ran_cfg_upd_fail_ies_o>;

SRSASN_CODE ran_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (time_to_wait_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)107, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_int("id", 107);
    j.write_str("criticality", "ignore");
    j.write_str("Value", time_to_wait.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<rrc_inactive_transition_report_ies_o>;

SRSASN_CODE rrc_inactive_transition_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)92, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_state.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 92: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void rrc_inactive_transition_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 92);
  j.write_str("criticality", "ignore");
  j.write_str("Value", rrc_state.to_string());
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<reroute_nas_request_ies_o>;

SRSASN_CODE reroute_nas_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)42, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngap_msg.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)3, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_set_id.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)171, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 10: {
        amf_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 42: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngap_msg.unpack(bref));
        break;
      }
      case 3: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void reroute_nas_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (amf_ue_ngap_id_present) {
    j.write_int("id", 10);
    j.write_str("criticality", "ignore");
    j.write_int("Value", amf_ue_ngap_id);
  }
  j.write_int("id", 42);
  j.write_str("criticality", "reject");
  j.write_str("Value", ngap_msg.to_string());
  j.write_int("id", 3);
  j.write_str("criticality", "reject");
  j.write_str("Value", amf_set_id.to_string());
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_int("id", 171);
    j.write_str("criticality", "ignore");
    source_to_target_amf_info_reroute.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<secondary_rat_data_usage_report_ies_o>;

SRSASN_CODE secondary_rat_data_usage_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ho_flag_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)142, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_secondary_rat_usage_list, 1, 256, true));
  }
  if (ho_flag_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)143, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ho_flag.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 142: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_secondary_rat_usage_list, bref, 1, 256, true));
        break;
      }
      case 143: {
        ho_flag_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ho_flag.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 142);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_secondary_rat_usage_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ho_flag_present) {
    j.write_int("id", 143);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "handover-preparation");
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<trace_fail_ind_ies_o>;

SRSASN_CODE trace_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)44, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_trace_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 44);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ngran_trace_id.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<trace_start_ies_o>;

SRSASN_CODE trace_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)108, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_activation.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 108: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 108);
  j.write_str("criticality", "ignore");
  trace_activation.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_mod_fail_ies_o>;

SRSASN_CODE ue_context_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_mod_request_ies_o>;

SRSASN_CODE ue_context_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += security_key_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += new_amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += new_guami_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += qmc_deactivation_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (security_key_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)94, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_key.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)31, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_security_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)24, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (new_amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)40, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, new_amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (new_guami_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)162, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(new_guami.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)199, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)238, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)328, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (qmc_deactivation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)329, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(qmc_deactivation.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)359, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_mod_list, 0, 16, true));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 94: {
        security_key_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.unpack(bref));
        break;
      }
      case 40: {
        new_amf_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(new_amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 162: {
        new_guami_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_guami.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.unpack(bref));
        break;
      }
      case 329: {
        qmc_deactivation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qmc_deactivation.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_mod_list, bref, 0, 16, true));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  if (security_key_present) {
    j.write_int("id", 94);
    j.write_str("criticality", "reject");
    j.write_str("Value", security_key.to_string());
  }
  if (idx_to_rfsp_present) {
    j.write_int("id", 31);
    j.write_str("criticality", "ignore");
    j.write_int("Value", idx_to_rfsp);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "ignore");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_security_cap_present) {
    j.write_int("id", 119);
    j.write_str("criticality", "reject");
    ue_security_cap.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (emergency_fallback_ind_present) {
    j.write_int("id", 24);
    j.write_str("criticality", "reject");
    emergency_fallback_ind.to_json(j);
  }
  if (new_amf_ue_ngap_id_present) {
    j.write_int("id", 40);
    j.write_str("criticality", "reject");
    j.write_int("Value", new_amf_ue_ngap_id);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  if (new_guami_present) {
    j.write_int("id", 162);
    j.write_str("criticality", "reject");
    new_guami.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (iab_authorized_present) {
    j.write_int("id", 199);
    j.write_str("criticality", "ignore");
    j.write_str("Value", iab_authorized.to_string());
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_int("id", 238);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rg_level_wireline_access_characteristics.to_string());
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_int("id", 328);
    j.write_str("criticality", "ignore");
    q_mcc_onfig_info.to_json(j);
  }
  if (qmc_deactivation_present) {
    j.write_int("id", 329);
    j.write_str("criticality", "ignore");
    qmc_deactivation.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_int("id", 359);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_mod_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_mod_resp_ies_o>;

SRSASN_CODE ue_context_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += rrc_state_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (rrc_state_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)92, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_state.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 92: {
        rrc_state_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (rrc_state_present) {
    j.write_int("id", 92);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_state.to_string());
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_release_cmd_ies_o>;

SRSASN_CODE ue_context_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)114, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_ngap_ids.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 114: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_ngap_ids.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 114);
  j.write_str("criticality", "reject");
  ue_ngap_ids.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_release_complete_ies_o>;

SRSASN_CODE ue_context_release_complete_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += pdu_session_res_list_cxt_rel_cpl_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)32, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)60, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_list_cxt_rel_cpl, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.unpack(bref));
        break;
      }
      case 60: {
        pdu_session_res_list_cxt_rel_cpl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_list_cxt_rel_cpl, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_complete_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_int("id", 32);
    j.write_str("criticality", "ignore");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    j.write_int("id", 60);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_list_cxt_rel_cpl) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_release_request_ies_o>;

SRSASN_CODE ue_context_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_list_cxt_rel_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_list_cxt_rel_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)133, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_list_cxt_rel_req, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 133: {
        pdu_session_res_list_cxt_rel_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_list_cxt_rel_req, bref, 1, 256, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_list_cxt_rel_req_present) {
    j.write_int("id", 133);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_list_cxt_rel_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_resume_fail_ies_o>;

SRSASN_CODE ue_context_resume_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_resume_request_ies_o>;

SRSASN_CODE ue_context_resume_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_resume_list_res_req_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_req_present ? 1 : 0;
  nof_ies += suspend_request_ind_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)237, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }
  if (pdu_session_res_resume_list_res_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)232, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_resume_list_res_req, 1, 256, true));
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)229, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_resume_list_res_req, 1, 256, true));
  }
  if (suspend_request_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)235, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(suspend_request_ind.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)32, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 237: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.unpack(bref));
        break;
      }
      case 232: {
        pdu_session_res_resume_list_res_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_resume_list_res_req, bref, 1, 256, true));
        break;
      }
      case 229: {
        pdu_session_res_failed_to_resume_list_res_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_resume_list_res_req, bref, 1, 256, true));
        break;
      }
      case 235: {
        suspend_request_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_request_ind.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 237);
  j.write_str("criticality", "ignore");
  j.write_str("Value", rrc_resume_cause.to_string());
  if (pdu_session_res_resume_list_res_req_present) {
    j.write_int("id", 232);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_resume_list_res_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    j.write_int("id", 229);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_resume_list_res_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (suspend_request_ind_present) {
    j.write_int("id", 235);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "suspend-requested");
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_int("id", 32);
    j.write_str("criticality", "ignore");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_resume_resp_ies_o>;

SRSASN_CODE ue_context_resume_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_resume_list_res_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_res_present ? 1 : 0;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += suspend_resp_ind_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_resume_list_res_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)233, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_resume_list_res_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)230, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_resume_list_res_res, 1, 256, true));
  }
  if (security_context_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (suspend_resp_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)236, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(suspend_resp_ind.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 233: {
        pdu_session_res_resume_list_res_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_resume_list_res_res, bref, 1, 256, true));
        break;
      }
      case 230: {
        pdu_session_res_failed_to_resume_list_res_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_resume_list_res_res, bref, 1, 256, true));
        break;
      }
      case 93: {
        security_context_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 236: {
        suspend_resp_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_resp_ind.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_resume_list_res_res_present) {
    j.write_int("id", 233);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_resume_list_res_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    j.write_int("id", 230);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_resume_list_res_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (security_context_present) {
    j.write_int("id", 93);
    j.write_str("criticality", "reject");
    security_context.to_json(j);
  }
  if (suspend_resp_ind_present) {
    j.write_int("id", 236);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "suspend-indicated");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_suspend_fail_ies_o>;

SRSASN_CODE ue_context_suspend_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_suspend_request_ies_o>;

SRSASN_CODE ue_context_suspend_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  nof_ies += pdu_session_res_suspend_list_sus_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)32, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)231, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_suspend_list_sus_req, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.unpack(bref));
        break;
      }
      case 231: {
        pdu_session_res_suspend_list_sus_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_suspend_list_sus_req, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_int("id", 32);
    j.write_str("criticality", "ignore");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    j.write_int("id", 231);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_suspend_list_sus_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_suspend_resp_ies_o>;

SRSASN_CODE ue_context_suspend_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (security_context_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 93: {
        security_context_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (security_context_present) {
    j.write_int("id", 93);
    j.write_str("criticality", "reject");
    security_context.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_info_transfer_ies_o>;

SRSASN_CODE ue_info_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)210, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, nb_iot_ue_prio, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 26: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(nb_iot_ue_prio, bref, (uint16_t)0u, (uint16_t)255u, true, true));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_info_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 26);
  j.write_str("criticality", "reject");
  five_g_s_tmsi.to_json(j);
  if (nb_iot_ue_prio_present) {
    j.write_int("id", 210);
    j.write_str("criticality", "ignore");
    j.write_int("Value", nb_iot_ue_prio);
  }
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (s_nssai_present) {
    j.write_int("id", 148);
    j.write_str("criticality", "ignore");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_check_request_ies_o>;

SRSASN_CODE ue_radio_cap_check_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_check_resp_ies_o>;

SRSASN_CODE ue_radio_cap_check_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)30, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ims_voice_support_ind.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 30: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ims_voice_support_ind.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 30);
  j.write_str("criticality", "reject");
  j.write_str("Value", ims_voice_support_ind.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_id_map_resp_ies_o>;

SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 264: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_id_map_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 264);
  j.write_str("criticality", "reject");
  j.write_str("Value", ue_radio_cap_id.to_string());
  j.write_int("id", 117);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ue_radio_cap.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_info_ind_ies_o>;

SRSASN_CODE ue_radio_cap_info_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += ue_radio_cap_eutra_format_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (ue_radio_cap_eutra_format_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)265, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_eutra_format.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.unpack(bref));
        break;
      }
      case 265: {
        ue_radio_cap_eutra_format_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_eutra_format.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_info_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 117);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ue_radio_cap.to_string());
  if (ue_radio_cap_for_paging_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "ignore");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (ue_radio_cap_eutra_format_present) {
    j.write_int("id", 265);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap_eutra_format.to_string());
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_tnla_binding_release_request_ies_o>;

SRSASN_CODE ue_tnla_binding_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_tnla_binding_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_nas_transport_ies_o>;

SRSASN_CODE ul_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += w_agf_id_info_present ? 1 : 0;
  nof_ies += tngf_id_info_present ? 1 : 0;
  nof_ies += twif_id_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (w_agf_id_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)239, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(w_agf_id_info.pack(bref));
  }
  if (tngf_id_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)246, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tngf_id_info.pack(bref));
  }
  if (twif_id_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)247, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(twif_id_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 239: {
        w_agf_id_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(w_agf_id_info.unpack(bref));
        break;
      }
      case 246: {
        tngf_id_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tngf_id_info.unpack(bref));
        break;
      }
      case 247: {
        twif_id_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(twif_id_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 38);
  j.write_str("criticality", "reject");
  j.write_str("Value", nas_pdu.to_string());
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  if (w_agf_id_info_present) {
    j.write_int("id", 239);
    j.write_str("criticality", "reject");
    j.write_str("Value", w_agf_id_info.to_string());
  }
  if (tngf_id_info_present) {
    j.write_int("id", 246);
    j.write_str("criticality", "reject");
    j.write_str("Value", tngf_id_info.to_string());
  }
  if (twif_id_info_present) {
    j.write_int("id", 247);
    j.write_str("criticality", "reject");
    j.write_str("Value", twif_id_info.to_string());
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_non_ue_associated_nrppa_transport_ies_o>;

SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ran_cfg_transfer_ies_o>;

SRSASN_CODE ul_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)99, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(son_cfg_transfer_ul.pack(bref));
  }
  if (endc_son_cfg_transfer_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)158, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(endc_son_cfg_transfer_ul.pack(bref));
  }
  if (intersys_son_cfg_transfer_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)251, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(intersys_son_cfg_transfer_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 99: {
        son_cfg_transfer_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_ul.unpack(bref));
        break;
      }
      case 158: {
        endc_son_cfg_transfer_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_ul.unpack(bref));
        break;
      }
      case 251: {
        intersys_son_cfg_transfer_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_ul.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_ul_present) {
    j.write_int("id", 99);
    j.write_str("criticality", "ignore");
    son_cfg_transfer_ul.to_json(j);
  }
  if (endc_son_cfg_transfer_ul_present) {
    j.write_int("id", 158);
    j.write_str("criticality", "ignore");
    j.write_str("Value", endc_son_cfg_transfer_ul.to_string());
  }
  if (intersys_son_cfg_transfer_ul_present) {
    j.write_int("id", 251);
    j.write_str("criticality", "ignore");
    intersys_son_cfg_transfer_ul.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ran_early_status_transfer_ies_o>;

SRSASN_CODE ul_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)268, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 268);
  j.write_str("criticality", "reject");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ran_status_transfer_ies_o>;

SRSASN_CODE ul_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)84, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 84);
  j.write_str("criticality", "reject");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ue_associated_nrppa_transport_ies_o>;

SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<write_replace_warning_request_ies_o>;

SRSASN_CODE write_replace_warning_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += warning_type_present ? 1 : 0;
  nof_ies += warning_security_info_present ? 1 : 0;
  nof_ies += data_coding_scheme_present ? 1 : 0;
  nof_ies += warning_msg_contents_present ? 1 : 0;
  nof_ies += concurrent_warning_msg_ind_present ? 1 : 0;
  nof_ies += warning_area_coordinates_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (warning_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)122, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)87, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, repeat_period, (uint32_t)0u, (uint32_t)131071u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)47, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, nof_broadcasts_requested, (uint32_t)0u, (uint32_t)65535u, false, true));
  }
  if (warning_type_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)125, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_type.pack(bref));
  }
  if (warning_security_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)124, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_security_info.pack(bref));
  }
  if (data_coding_scheme_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)20, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(data_coding_scheme.pack(bref));
  }
  if (warning_msg_contents_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)123, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_msg_contents.pack(bref));
  }
  if (concurrent_warning_msg_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)17, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(concurrent_warning_msg_ind.pack(bref));
  }
  if (warning_area_coordinates_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)141, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_area_coordinates.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.unpack(bref));
        break;
      }
      case 87: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(repeat_period, bref, (uint32_t)0u, (uint32_t)131071u, false, true));
        break;
      }
      case 47: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(nof_broadcasts_requested, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
        break;
      }
      case 125: {
        warning_type_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_type.unpack(bref));
        break;
      }
      case 124: {
        warning_security_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_security_info.unpack(bref));
        break;
      }
      case 20: {
        data_coding_scheme_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_coding_scheme.unpack(bref));
        break;
      }
      case 123: {
        warning_msg_contents_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_msg_contents.unpack(bref));
        break;
      }
      case 17: {
        concurrent_warning_msg_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(concurrent_warning_msg_ind.unpack(bref));
        break;
      }
      case 141: {
        warning_area_coordinates_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_coordinates.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (warning_area_list_present) {
    j.write_int("id", 122);
    j.write_str("criticality", "ignore");
    warning_area_list.to_json(j);
  }
  j.write_int("id", 87);
  j.write_str("criticality", "reject");
  j.write_int("Value", repeat_period);
  j.write_int("id", 47);
  j.write_str("criticality", "reject");
  j.write_int("Value", nof_broadcasts_requested);
  if (warning_type_present) {
    j.write_int("id", 125);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_type.to_string());
  }
  if (warning_security_info_present) {
    j.write_int("id", 124);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_security_info.to_string());
  }
  if (data_coding_scheme_present) {
    j.write_int("id", 20);
    j.write_str("criticality", "ignore");
    j.write_str("Value", data_coding_scheme.to_string());
  }
  if (warning_msg_contents_present) {
    j.write_int("id", 123);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_msg_contents.to_string());
  }
  if (concurrent_warning_msg_ind_present) {
    j.write_int("id", 17);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  if (warning_area_coordinates_present) {
    j.write_int("id", 141);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_area_coordinates.to_string());
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<write_replace_warning_resp_ies_o>;

SRSASN_CODE write_replace_warning_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_completed_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (broadcast_completed_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)13, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(broadcast_completed_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 13: {
        broadcast_completed_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_completed_area_list.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (broadcast_completed_area_list_present) {
    j.write_int("id", 13);
    j.write_str("criticality", "ignore");
    broadcast_completed_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}
