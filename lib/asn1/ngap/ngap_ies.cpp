/*
 *
 * Copyright 2021-2024 Software Radio Systems Limited
 *
 * This file is part of srsRAN.
 *
 * srsRAN is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsRAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srsran/asn1/ngap/ngap_ies.h"
using namespace asn1;
using namespace asn1::ngap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// EndpointIPAddressAndPort ::= SEQUENCE
SRSASN_CODE endpoint_ip_address_and_port_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(endpoint_ip_address.pack(bref));
  HANDLE_CODE(port_num.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE endpoint_ip_address_and_port_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(endpoint_ip_address.unpack(bref));
  HANDLE_CODE(port_num.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void endpoint_ip_address_and_port_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("endpointIPAddress", endpoint_ip_address.to_string());
  j.write_str("portNumber", port_num.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPTransportLayerInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t cp_transport_layer_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {169};
  return map_enum_number(names, 1, idx, "id");
}
bool cp_transport_layer_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 169 == id;
}
crit_e cp_transport_layer_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 169) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
cp_transport_layer_info_ext_ies_o::value_c cp_transport_layer_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 169) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cp_transport_layer_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 169) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void cp_transport_layer_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("EndpointIPAddressAndPort");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE cp_transport_layer_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_transport_layer_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* cp_transport_layer_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"EndpointIPAddressAndPort"};
  return convert_enum_idx(names, 1, value, "cp_transport_layer_info_ext_ies_o::value_c::types");
}

template struct asn1::protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>;

// CPTransportLayerInformation ::= CHOICE
void cp_transport_layer_info_c::destroy_()
{
  switch (type_) {
    case types::endpoint_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cp_transport_layer_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::endpoint_ip_address:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
}
cp_transport_layer_info_c::cp_transport_layer_info_c(const cp_transport_layer_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::endpoint_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
}
cp_transport_layer_info_c& cp_transport_layer_info_c::operator=(const cp_transport_layer_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::endpoint_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }

  return *this;
}
bounded_bitstring<1, 160, true, true>& cp_transport_layer_info_c::set_endpoint_ip_address()
{
  set(types::endpoint_ip_address);
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>& cp_transport_layer_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
}
void cp_transport_layer_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::endpoint_ip_address:
      j.write_str("endpointIPAddress", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
  j.end_obj();
}
SRSASN_CODE cp_transport_layer_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_transport_layer_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cp_transport_layer_info_c::types_opts::to_string() const
{
  static const char* names[] = {"endpointIPAddress", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "cp_transport_layer_info_c::types");
}

// AMF-TNLAssociationSetupItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLAssociationUsage ::= ENUMERATED
const char* tnl_assoc_usage_opts::to_string() const
{
  static const char* names[] = {"ue", "non-ue", "both"};
  return convert_enum_idx(names, 3, value, "tnl_assoc_usage_e");
}

// AMF-TNLAssociationToAddItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_to_add_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.pack(bref));
  }
  HANDLE_CODE(pack_integer(bref, tnla_ddress_weight_factor, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_add_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  }
  HANDLE_CODE(unpack_integer(tnla_ddress_weight_factor, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_to_add_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (tnl_assoc_usage_present) {
    j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  }
  j.write_int("tNLAddressWeightFactor", tnla_ddress_weight_factor);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMF-TNLAssociationToRemoveItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t amf_tnl_assoc_to_rem_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {168};
  return map_enum_number(names, 1, idx, "id");
}
bool amf_tnl_assoc_to_rem_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 168 == id;
}
crit_e amf_tnl_assoc_to_rem_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 168) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c amf_tnl_assoc_to_rem_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 168) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_tnl_assoc_to_rem_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 168) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CPTransportLayerInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"CPTransportLayerInformation"};
  return convert_enum_idx(names, 1, value, "amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::types");
}

// AMF-TNLAssociationToRemoveItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_to_rem_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_rem_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// AMF-TNLAssociationToUpdateItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_to_upd_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.pack(tnla_ddress_weight_factor_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.pack(bref));
  }
  if (tnla_ddress_weight_factor_present) {
    HANDLE_CODE(pack_integer(bref, tnla_ddress_weight_factor, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_upd_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.unpack(tnla_ddress_weight_factor_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  }
  if (tnla_ddress_weight_factor_present) {
    HANDLE_CODE(unpack_integer(tnla_ddress_weight_factor, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_to_upd_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (tnl_assoc_usage_present) {
    j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  }
  if (tnla_ddress_weight_factor_present) {
    j.write_int("tNLAddressWeightFactor", tnla_ddress_weight_factor);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// S-NSSAI ::= SEQUENCE
SRSASN_CODE s_nssai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sd_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sst.pack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s_nssai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(sd_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sst.unpack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void s_nssai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sST", sst.to_string());
  if (sd_present) {
    j.write_str("sD", sd.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AllowedNSSAI-Item ::= SEQUENCE
SRSASN_CODE allowed_nssai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE allowed_nssai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void allowed_nssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceSupportItem ::= SEQUENCE
SRSASN_CODE slice_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GUAMIType ::= ENUMERATED
const char* guami_type_opts::to_string() const
{
  static const char* names[] = {"native", "mapped"};
  return convert_enum_idx(names, 2, value, "guami_type_e");
}

// NPN-Support ::= CHOICE
void npn_support_c::destroy_()
{
  switch (type_) {
    case types::sn_pn:
      c.destroy<fixed_bitstring<44, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_support_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sn_pn:
      c.init<fixed_bitstring<44, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
}
npn_support_c::npn_support_c(const npn_support_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sn_pn:
      c.init(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
}
npn_support_c& npn_support_c::operator=(const npn_support_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sn_pn:
      c.set(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }

  return *this;
}
fixed_bitstring<44, false, true>& npn_support_c::set_sn_pn()
{
  set(types::sn_pn);
  return c.get<fixed_bitstring<44, false, true>>();
}
protocol_ie_single_container_s<npn_support_ext_ies_o>& npn_support_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
}
void npn_support_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sn_pn:
      j.write_str("sNPN", c.get<fixed_bitstring<44, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_support_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sn_pn:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_support_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sn_pn:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_support_c::types_opts::to_string() const
{
  static const char* names[] = {"sNPN", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "npn_support_c::types");
}

// OnboardingSupport ::= ENUMERATED
const char* onboarding_support_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "onboarding_support_e");
}

// GUAMI ::= SEQUENCE
SRSASN_CODE guami_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(amf_region_id.pack(bref));
  HANDLE_CODE(amf_set_id.pack(bref));
  HANDLE_CODE(amf_pointer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE guami_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(amf_region_id.unpack(bref));
  HANDLE_CODE(amf_set_id.unpack(bref));
  HANDLE_CODE(amf_pointer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void guami_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("aMFRegionID", amf_region_id.to_string());
  j.write_str("aMFSetID", amf_set_id.to_string());
  j.write_str("aMFPointer", amf_pointer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PLMNSupportItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t plmn_support_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {258, 270, 325};
  return map_enum_number(names, 3, idx, "id");
}
bool plmn_support_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {258, 270, 325};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e plmn_support_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 258:
      return crit_e::reject;
    case 270:
      return crit_e::reject;
    case 325:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
plmn_support_item_ext_ies_o::ext_c plmn_support_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 258:
      ret.set(ext_c::types::npn_support);
      break;
    case 270:
      ret.set(ext_c::types::extended_slice_support_list);
      break;
    case 325:
      ret.set(ext_c::types::onboarding_support);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e plmn_support_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 258:
      return presence_e::optional;
    case 270:
      return presence_e::optional;
    case 325:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void plmn_support_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::npn_support:
      c = npn_support_c{};
      break;
    case types::extended_slice_support_list:
      c = extended_slice_support_list_l{};
      break;
    case types::onboarding_support:
      c = onboarding_support_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
  }
}
npn_support_c& plmn_support_item_ext_ies_o::ext_c::npn_support()
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
extended_slice_support_list_l& plmn_support_item_ext_ies_o::ext_c::extended_slice_support_list()
{
  assert_choice_type(types::extended_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
onboarding_support_e& plmn_support_item_ext_ies_o::ext_c::onboarding_support()
{
  assert_choice_type(types::onboarding_support, type_, "Extension");
  return c.get<onboarding_support_e>();
}
const npn_support_c& plmn_support_item_ext_ies_o::ext_c::npn_support() const
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
const extended_slice_support_list_l& plmn_support_item_ext_ies_o::ext_c::extended_slice_support_list() const
{
  assert_choice_type(types::extended_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
const onboarding_support_e& plmn_support_item_ext_ies_o::ext_c::onboarding_support() const
{
  assert_choice_type(types::onboarding_support, type_, "Extension");
  return c.get<onboarding_support_e>();
}
void plmn_support_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_support:
      j.write_fieldname("NPN-Support");
      c.get<npn_support_c>().to_json(j);
      break;
    case types::extended_slice_support_list:
      j.start_array("ExtendedSliceSupportList");
      for (const auto& e1 : c.get<extended_slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::onboarding_support:
      j.write_str("OnboardingSupport", "true");
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE plmn_support_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().pack(bref));
      break;
    case types::extended_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_slice_support_list_l>(), 1, 65535, true));
      break;
    case types::onboarding_support:
      HANDLE_CODE(c.get<onboarding_support_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_support_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().unpack(bref));
      break;
    case types::extended_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_slice_support_list_l>(), bref, 1, 65535, true));
      break;
    case types::onboarding_support:
      HANDLE_CODE(c.get<onboarding_support_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* plmn_support_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPN-Support", "ExtendedSliceSupportList", "OnboardingSupport"};
  return convert_enum_idx(names, 3, value, "plmn_support_item_ext_ies_o::ext_c::types");
}

// ServedGUAMIItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t served_guami_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {176};
  return map_enum_number(names, 1, idx, "id");
}
bool served_guami_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 176 == id;
}
crit_e served_guami_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 176) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
served_guami_item_ext_ies_o::ext_c served_guami_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 176) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_guami_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 176) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void served_guami_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("GUAMIType", c.to_string());
  j.end_obj();
}
SRSASN_CODE served_guami_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_guami_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* served_guami_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"GUAMIType"};
  return convert_enum_idx(names, 1, value, "served_guami_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<plmn_support_item_ext_ies_o>;

SRSASN_CODE plmn_support_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_support_present ? 1 : 0;
  nof_ies += extended_slice_support_list_present ? 1 : 0;
  nof_ies += onboarding_support_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)258, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_support.pack(bref));
  }
  if (extended_slice_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)270, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_slice_support_list, 1, 65535, true));
  }
  if (onboarding_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)325, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(onboarding_support.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_support_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 258: {
        npn_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_support.unpack(bref));
        break;
      }
      case 270: {
        extended_slice_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_slice_support_list, bref, 1, 65535, true));
        break;
      }
      case 325: {
        onboarding_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(onboarding_support.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void plmn_support_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_support_present) {
    j.write_int("id", 258);
    j.write_str("criticality", "reject");
    npn_support.to_json(j);
  }
  if (extended_slice_support_list_present) {
    j.write_int("id", 270);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : extended_slice_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (onboarding_support_present) {
    j.write_int("id", 325);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// PLMNSupportItem ::= SEQUENCE
SRSASN_CODE plmn_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, slice_support_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(slice_support_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void plmn_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("sliceSupportList");
  for (const auto& e1 : slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedGUAMIItem ::= SEQUENCE
SRSASN_CODE served_guami_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(backup_amf_name_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(guami.pack(bref));
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_guami_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(backup_amf_name_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(guami.unpack(bref));
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void served_guami_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gUAMI");
  guami.to_json(j);
  if (backup_amf_name_present) {
    j.write_str("backupAMFName", backup_amf_name.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// Extended-AMFName ::= SEQUENCE
SRSASN_CODE extended_amf_name_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(amf_name_visible_string_present, 1));
  HANDLE_CODE(bref.pack(amf_name_utf8_string_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (amf_name_visible_string_present) {
    HANDLE_CODE(amf_name_visible_string.pack(bref));
  }
  if (amf_name_utf8_string_present) {
    HANDLE_CODE(amf_name_utf8_string.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_amf_name_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(amf_name_visible_string_present, 1));
  HANDLE_CODE(bref.unpack(amf_name_utf8_string_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (amf_name_visible_string_present) {
    HANDLE_CODE(amf_name_visible_string.unpack(bref));
  }
  if (amf_name_utf8_string_present) {
    HANDLE_CODE(amf_name_utf8_string.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_amf_name_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_name_visible_string_present) {
    j.write_str("aMFNameVisibleString", amf_name_visible_string.to_string());
  }
  if (amf_name_utf8_string_present) {
    j.write_str("aMFNameUTF8String", amf_name_utf8_string.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CauseMisc ::= ENUMERATED
const char* cause_misc_opts::to_string() const
{
  static const char* names[] = {"control-processing-overload",
                                "not-enough-user-plane-processing-resources",
                                "hardware-failure",
                                "om-intervention",
                                "unknown-PLMN-or-SNPN",
                                "unspecified"};
  return convert_enum_idx(names, 6, value, "cause_misc_e");
}

// CauseNas ::= ENUMERATED
const char* cause_nas_opts::to_string() const
{
  static const char* names[] = {
      "normal-release", "authentication-failure", "deregister", "unspecified", "uE-not-in-PLMN-serving-area"};
  return convert_enum_idx(names, 5, value, "cause_nas_e");
}

// CauseProtocol ::= ENUMERATED
const char* cause_protocol_opts::to_string() const
{
  static const char* names[] = {"transfer-syntax-error",
                                "abstract-syntax-error-reject",
                                "abstract-syntax-error-ignore-and-notify",
                                "message-not-compatible-with-receiver-state",
                                "semantic-error",
                                "abstract-syntax-error-falsely-constructed-message",
                                "unspecified"};
  return convert_enum_idx(names, 7, value, "cause_protocol_e");
}

// CauseRadioNetwork ::= ENUMERATED
const char* cause_radio_network_opts::to_string() const
{
  static const char* names[] = {"unspecified",
                                "txnrelocoverall-expiry",
                                "successful-handover",
                                "release-due-to-ngran-generated-reason",
                                "release-due-to-5gc-generated-reason",
                                "handover-cancelled",
                                "partial-handover",
                                "ho-failure-in-target-5GC-ngran-node-or-target-system",
                                "ho-target-not-allowed",
                                "tngrelocoverall-expiry",
                                "tngrelocprep-expiry",
                                "cell-not-available",
                                "unknown-targetID",
                                "no-radio-resources-available-in-target-cell",
                                "unknown-local-UE-NGAP-ID",
                                "inconsistent-remote-UE-NGAP-ID",
                                "handover-desirable-for-radio-reason",
                                "time-critical-handover",
                                "resource-optimisation-handover",
                                "reduce-load-in-serving-cell",
                                "user-inactivity",
                                "radio-connection-with-ue-lost",
                                "radio-resources-not-available",
                                "invalid-qos-combination",
                                "failure-in-radio-interface-procedure",
                                "interaction-with-other-procedure",
                                "unknown-PDU-session-ID",
                                "unkown-qos-flow-ID",
                                "multiple-PDU-session-ID-instances",
                                "multiple-qos-flow-ID-instances",
                                "encryption-and-or-integrity-protection-algorithms-not-supported",
                                "ng-intra-system-handover-triggered",
                                "ng-inter-system-handover-triggered",
                                "xn-handover-triggered",
                                "not-supported-5QI-value",
                                "ue-context-transfer",
                                "ims-voice-eps-fallback-or-rat-fallback-triggered",
                                "up-integrity-protection-not-possible",
                                "up-confidentiality-protection-not-possible",
                                "slice-not-supported",
                                "ue-in-rrc-inactive-state-not-reachable",
                                "redirection",
                                "resources-not-available-for-the-slice",
                                "ue-max-integrity-protected-data-rate-reason",
                                "release-due-to-cn-detected-mobility",
                                "n26-interface-not-available",
                                "release-due-to-pre-emption",
                                "multiple-location-reporting-reference-ID-instances",
                                "rsn-not-available-for-the-up",
                                "npn-access-denied",
                                "cag-only-access-denied",
                                "insufficient-ue-capabilities",
                                "redcap-ue-not-supported",
                                "unknown-MBS-Session-ID",
                                "indicated-MBS-session-area-information-not-served-by-the-gNB",
                                "inconsistent-slice-info-for-the-session",
                                "misaligned-association-for-multicast-unicast"};
  return convert_enum_idx(names, 57, value, "cause_radio_network_e");
}

// CauseTransport ::= ENUMERATED
const char* cause_transport_opts::to_string() const
{
  static const char* names[] = {"transport-resource-unavailable", "unspecified"};
  return convert_enum_idx(names, 2, value, "cause_transport_e");
}

// TypeOfError ::= ENUMERATED
const char* type_of_error_opts::to_string() const
{
  static const char* names[] = {"not-understood", "missing"};
  return convert_enum_idx(names, 2, value, "type_of_error_e");
}

// Cause ::= CHOICE
void cause_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cause_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::radio_network:
      break;
    case types::transport:
      break;
    case types::nas:
      break;
    case types::protocol:
      break;
    case types::misc:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c::cause_c(const cause_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::radio_network:
      c.init(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.init(other.c.get<cause_transport_e>());
      break;
    case types::nas:
      c.init(other.c.get<cause_nas_e>());
      break;
    case types::protocol:
      c.init(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.init(other.c.get<cause_misc_e>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c& cause_c::operator=(const cause_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::radio_network:
      c.set(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.set(other.c.get<cause_transport_e>());
      break;
    case types::nas:
      c.set(other.c.get<cause_nas_e>());
      break;
    case types::protocol:
      c.set(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.set(other.c.get<cause_misc_e>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }

  return *this;
}
cause_radio_network_e& cause_c::set_radio_network()
{
  set(types::radio_network);
  return c.get<cause_radio_network_e>();
}
cause_transport_e& cause_c::set_transport()
{
  set(types::transport);
  return c.get<cause_transport_e>();
}
cause_nas_e& cause_c::set_nas()
{
  set(types::nas);
  return c.get<cause_nas_e>();
}
cause_protocol_e& cause_c::set_protocol()
{
  set(types::protocol);
  return c.get<cause_protocol_e>();
}
cause_misc_e& cause_c::set_misc()
{
  set(types::misc);
  return c.get<cause_misc_e>();
}
protocol_ie_single_container_s<cause_ext_ies_o>& cause_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<cause_ext_ies_o>>();
}
void cause_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::radio_network:
      j.write_str("radioNetwork", c.get<cause_radio_network_e>().to_string());
      break;
    case types::transport:
      j.write_str("transport", c.get<cause_transport_e>().to_string());
      break;
    case types::nas:
      j.write_str("nas", c.get<cause_nas_e>().to_string());
      break;
    case types::protocol:
      j.write_str("protocol", c.get<cause_protocol_e>().to_string());
      break;
    case types::misc:
      j.write_str("misc", c.get<cause_misc_e>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
  j.end_obj();
}
SRSASN_CODE cause_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().pack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().pack(bref));
      break;
    case types::nas:
      HANDLE_CODE(c.get<cause_nas_e>().pack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().pack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cause_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().unpack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().unpack(bref));
      break;
    case types::nas:
      HANDLE_CODE(c.get<cause_nas_e>().unpack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().unpack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cause_c::types_opts::to_string() const
{
  static const char* names[] = {"radioNetwork", "transport", "nas", "protocol", "misc", "choice-Extensions"};
  return convert_enum_idx(names, 6, value, "cause_c::types");
}
uint8_t cause_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {2};
  return map_enum_number(numbers, 1, value, "cause_c::types");
}

// CriticalityDiagnostics-IE-Item ::= SEQUENCE
SRSASN_CODE crit_diagnostics_ie_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.pack(bref));
  HANDLE_CODE(pack_integer(bref, ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_ie_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.unpack(bref));
  HANDLE_CODE(unpack_integer(ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_ie_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iECriticality", ie_crit.to_string());
  j.write_int("iE-ID", ie_id);
  j.write_str("typeOfError", type_of_error.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLAssociationItem ::= SEQUENCE
SRSASN_CODE tnl_assoc_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_address.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_assoc_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_address.unpack(bref));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_assoc_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationAddress");
  tnl_assoc_address.to_json(j);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TriggeringMessage ::= ENUMERATED
const char* trigger_msg_opts::to_string() const
{
  static const char* names[] = {"initiating-message", "successful-outcome", "unsuccessful-outcome"};
  return convert_enum_idx(names, 3, value, "trigger_msg_e");
}

// CriticalityDiagnostics ::= SEQUENCE
SRSASN_CODE crit_diagnostics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(proc_code_present, 1));
  HANDLE_CODE(bref.pack(trigger_msg_present, 1));
  HANDLE_CODE(bref.pack(proc_crit_present, 1));
  HANDLE_CODE(bref.pack(ies_crit_diagnostics.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.pack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.pack(bref));
  }
  if (ies_crit_diagnostics.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ies_crit_diagnostics, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(proc_code_present, 1));
  HANDLE_CODE(bref.unpack(trigger_msg_present, 1));
  HANDLE_CODE(bref.unpack(proc_crit_present, 1));
  bool ies_crit_diagnostics_present;
  HANDLE_CODE(bref.unpack(ies_crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.unpack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.unpack(bref));
  }
  if (ies_crit_diagnostics_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ies_crit_diagnostics, bref, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (proc_code_present) {
    j.write_int("procedureCode", proc_code);
  }
  if (trigger_msg_present) {
    j.write_str("triggeringMessage", trigger_msg.to_string());
  }
  if (proc_crit_present) {
    j.write_str("procedureCriticality", proc_crit.to_string());
  }
  if (ies_crit_diagnostics.size() > 0) {
    j.start_array("iEsCriticalityDiagnostics");
    for (const auto& e1 : ies_crit_diagnostics) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TimeToWait ::= ENUMERATED
const char* time_to_wait_opts::to_string() const
{
  static const char* names[] = {"v1s", "v2s", "v5s", "v10s", "v20s", "v60s"};
  return convert_enum_idx(names, 6, value, "time_to_wait_e");
}
uint8_t time_to_wait_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 5, 10, 20, 60};
  return map_enum_number(numbers, 6, value, "time_to_wait_e");
}

// TNGF-ID ::= CHOICE
void tngf_id_c::destroy_()
{
  switch (type_) {
    case types::tngf_id:
      c.destroy<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<tngf_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void tngf_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tngf_id:
      c.init<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<tngf_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }
}
tngf_id_c::tngf_id_c(const tngf_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tngf_id:
      c.init(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }
}
tngf_id_c& tngf_id_c::operator=(const tngf_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tngf_id:
      c.set(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }

  return *this;
}
fixed_bitstring<32, true, true>& tngf_id_c::set_tngf_id()
{
  set(types::tngf_id);
  return c.get<fixed_bitstring<32, true, true>>();
}
protocol_ie_single_container_s<tngf_id_ext_ies_o>& tngf_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>();
}
void tngf_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tngf_id:
      j.write_str("tNGF-ID", c.get<fixed_bitstring<32, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }
  j.end_obj();
}
SRSASN_CODE tngf_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::tngf_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE tngf_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::tngf_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* tngf_id_c::types_opts::to_string() const
{
  static const char* names[] = {"tNGF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "tngf_id_c::types");
}

// TWIF-ID ::= CHOICE
void twif_id_c::destroy_()
{
  switch (type_) {
    case types::twif_id:
      c.destroy<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<twif_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void twif_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::twif_id:
      c.init<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<twif_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }
}
twif_id_c::twif_id_c(const twif_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::twif_id:
      c.init(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }
}
twif_id_c& twif_id_c::operator=(const twif_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::twif_id:
      c.set(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }

  return *this;
}
fixed_bitstring<32, true, true>& twif_id_c::set_twif_id()
{
  set(types::twif_id);
  return c.get<fixed_bitstring<32, true, true>>();
}
protocol_ie_single_container_s<twif_id_ext_ies_o>& twif_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>();
}
void twif_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::twif_id:
      j.write_str("tWIF-ID", c.get<fixed_bitstring<32, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }
  j.end_obj();
}
SRSASN_CODE twif_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::twif_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE twif_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::twif_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* twif_id_c::types_opts::to_string() const
{
  static const char* names[] = {"tWIF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "twif_id_c::types");
}

// W-AGF-ID ::= CHOICE
void w_agf_id_c::destroy_()
{
  switch (type_) {
    case types::w_agf_id:
      c.destroy<fixed_bitstring<16, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void w_agf_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::w_agf_id:
      c.init<fixed_bitstring<16, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }
}
w_agf_id_c::w_agf_id_c(const w_agf_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::w_agf_id:
      c.init(other.c.get<fixed_bitstring<16, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }
}
w_agf_id_c& w_agf_id_c::operator=(const w_agf_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::w_agf_id:
      c.set(other.c.get<fixed_bitstring<16, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }

  return *this;
}
fixed_bitstring<16, true, true>& w_agf_id_c::set_w_agf_id()
{
  set(types::w_agf_id);
  return c.get<fixed_bitstring<16, true, true>>();
}
protocol_ie_single_container_s<w_agf_id_ext_ies_o>& w_agf_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>();
}
void w_agf_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::w_agf_id:
      j.write_str("w-AGF-ID", c.get<fixed_bitstring<16, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }
  j.end_obj();
}
SRSASN_CODE w_agf_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::w_agf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE w_agf_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::w_agf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* w_agf_id_c::types_opts::to_string() const
{
  static const char* names[] = {"w-AGF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "w_agf_id_c::types");
}

// GNB-ID ::= CHOICE
void gnb_id_c::destroy_()
{
  switch (type_) {
    case types::gnb_id:
      c.destroy<bounded_bitstring<22, 32, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<gnb_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void gnb_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gnb_id:
      c.init<bounded_bitstring<22, 32, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<gnb_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }
}
gnb_id_c::gnb_id_c(const gnb_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gnb_id:
      c.init(other.c.get<bounded_bitstring<22, 32, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }
}
gnb_id_c& gnb_id_c::operator=(const gnb_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gnb_id:
      c.set(other.c.get<bounded_bitstring<22, 32, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }

  return *this;
}
bounded_bitstring<22, 32, false, true>& gnb_id_c::set_gnb_id()
{
  set(types::gnb_id);
  return c.get<bounded_bitstring<22, 32, false, true>>();
}
protocol_ie_single_container_s<gnb_id_ext_ies_o>& gnb_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>();
}
void gnb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gnb_id:
      j.write_str("gNB-ID", c.get<bounded_bitstring<22, 32, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gnb_id:
      HANDLE_CODE((c.get<bounded_bitstring<22, 32, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gnb_id:
      HANDLE_CODE((c.get<bounded_bitstring<22, 32, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* gnb_id_c::types_opts::to_string() const
{
  static const char* names[] = {"gNB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "gnb_id_c::types");
}

// GlobalTNGF-ID ::= SEQUENCE
SRSASN_CODE global_tngf_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(tngf_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_tngf_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(tngf_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_tngf_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("tNGF-ID");
  tngf_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalTWIF-ID ::= SEQUENCE
SRSASN_CODE global_twif_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(twif_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_twif_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(twif_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_twif_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("tWIF-ID");
  twif_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalW-AGF-ID ::= SEQUENCE
SRSASN_CODE global_w_agf_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(w_agf_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_w_agf_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(w_agf_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_w_agf_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("w-AGF-ID");
  w_agf_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// N3IWF-ID ::= CHOICE
void n3_iwf_id_c::destroy_()
{
  switch (type_) {
    case types::n3_iwf_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void n3_iwf_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::n3_iwf_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }
}
n3_iwf_id_c::n3_iwf_id_c(const n3_iwf_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::n3_iwf_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }
}
n3_iwf_id_c& n3_iwf_id_c::operator=(const n3_iwf_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::n3_iwf_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& n3_iwf_id_c::set_n3_iwf_id()
{
  set(types::n3_iwf_id);
  return c.get<fixed_bitstring<16, false, true>>();
}
protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>& n3_iwf_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>();
}
void n3_iwf_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::n3_iwf_id:
      j.write_str("n3IWF-ID", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }
  j.end_obj();
}
SRSASN_CODE n3_iwf_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::n3_iwf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE n3_iwf_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::n3_iwf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* n3_iwf_id_c::types_opts::to_string() const
{
  static const char* names[] = {"n3IWF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "n3_iwf_id_c::types");
}
uint8_t n3_iwf_id_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {3};
  return map_enum_number(numbers, 1, value, "n3_iwf_id_c::types");
}

// NgENB-ID ::= CHOICE
void ng_enb_id_c::destroy_()
{
  switch (type_) {
    case types::macro_ng_enb_id:
      c.destroy<fixed_bitstring<20, false, true>>();
      break;
    case types::short_macro_ng_enb_id:
      c.destroy<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_ng_enb_id:
      c.destroy<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ng_enb_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::macro_ng_enb_id:
      c.init<fixed_bitstring<20, false, true>>();
      break;
    case types::short_macro_ng_enb_id:
      c.init<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_ng_enb_id:
      c.init<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }
}
ng_enb_id_c::ng_enb_id_c(const ng_enb_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::macro_ng_enb_id:
      c.init(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::short_macro_ng_enb_id:
      c.init(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_ng_enb_id:
      c.init(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }
}
ng_enb_id_c& ng_enb_id_c::operator=(const ng_enb_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::macro_ng_enb_id:
      c.set(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::short_macro_ng_enb_id:
      c.set(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_ng_enb_id:
      c.set(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }

  return *this;
}
fixed_bitstring<20, false, true>& ng_enb_id_c::set_macro_ng_enb_id()
{
  set(types::macro_ng_enb_id);
  return c.get<fixed_bitstring<20, false, true>>();
}
fixed_bitstring<18, false, true>& ng_enb_id_c::set_short_macro_ng_enb_id()
{
  set(types::short_macro_ng_enb_id);
  return c.get<fixed_bitstring<18, false, true>>();
}
fixed_bitstring<21, false, true>& ng_enb_id_c::set_long_macro_ng_enb_id()
{
  set(types::long_macro_ng_enb_id);
  return c.get<fixed_bitstring<21, false, true>>();
}
protocol_ie_single_container_s<ng_enb_id_ext_ies_o>& ng_enb_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>();
}
void ng_enb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::macro_ng_enb_id:
      j.write_str("macroNgENB-ID", c.get<fixed_bitstring<20, false, true>>().to_string());
      break;
    case types::short_macro_ng_enb_id:
      j.write_str("shortMacroNgENB-ID", c.get<fixed_bitstring<18, false, true>>().to_string());
      break;
    case types::long_macro_ng_enb_id:
      j.write_str("longMacroNgENB-ID", c.get<fixed_bitstring<21, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_enb_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().pack(bref)));
      break;
    case types::short_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().pack(bref)));
      break;
    case types::long_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_enb_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().unpack(bref)));
      break;
    case types::short_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().unpack(bref)));
      break;
    case types::long_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_enb_id_c::types_opts::to_string() const
{
  static const char* names[] = {"macroNgENB-ID", "shortMacroNgENB-ID", "longMacroNgENB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "ng_enb_id_c::types");
}

// GlobalGNB-ID ::= SEQUENCE
SRSASN_CODE global_gnb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(gnb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_gnb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(gnb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_gnb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("gNB-ID");
  gnb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalN3IWF-ID ::= SEQUENCE
SRSASN_CODE global_n3_iwf_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(n3_iwf_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_n3_iwf_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(n3_iwf_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_n3_iwf_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("n3IWF-ID");
  n3_iwf_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalNgENB-ID ::= SEQUENCE
SRSASN_CODE global_ng_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(ng_enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ng_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(ng_enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_ng_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("ngENB-ID");
  ng_enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalRANNodeID-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t global_ran_node_id_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {240, 241, 242};
  return map_enum_number(names, 3, idx, "id");
}
bool global_ran_node_id_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {240, 241, 242};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e global_ran_node_id_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 240:
      return crit_e::reject;
    case 241:
      return crit_e::reject;
    case 242:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
global_ran_node_id_ext_ies_o::value_c global_ran_node_id_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 240:
      ret.set(value_c::types::global_tngf_id);
      break;
    case 241:
      ret.set(value_c::types::global_twif_id);
      break;
    case 242:
      ret.set(value_c::types::global_w_agf_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e global_ran_node_id_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 240:
      return presence_e::mandatory;
    case 241:
      return presence_e::mandatory;
    case 242:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void global_ran_node_id_ext_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::global_tngf_id:
      c = global_tngf_id_s{};
      break;
    case types::global_twif_id:
      c = global_twif_id_s{};
      break;
    case types::global_w_agf_id:
      c = global_w_agf_id_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
  }
}
global_tngf_id_s& global_ran_node_id_ext_ies_o::value_c::global_tngf_id()
{
  assert_choice_type(types::global_tngf_id, type_, "Value");
  return c.get<global_tngf_id_s>();
}
global_twif_id_s& global_ran_node_id_ext_ies_o::value_c::global_twif_id()
{
  assert_choice_type(types::global_twif_id, type_, "Value");
  return c.get<global_twif_id_s>();
}
global_w_agf_id_s& global_ran_node_id_ext_ies_o::value_c::global_w_agf_id()
{
  assert_choice_type(types::global_w_agf_id, type_, "Value");
  return c.get<global_w_agf_id_s>();
}
const global_tngf_id_s& global_ran_node_id_ext_ies_o::value_c::global_tngf_id() const
{
  assert_choice_type(types::global_tngf_id, type_, "Value");
  return c.get<global_tngf_id_s>();
}
const global_twif_id_s& global_ran_node_id_ext_ies_o::value_c::global_twif_id() const
{
  assert_choice_type(types::global_twif_id, type_, "Value");
  return c.get<global_twif_id_s>();
}
const global_w_agf_id_s& global_ran_node_id_ext_ies_o::value_c::global_w_agf_id() const
{
  assert_choice_type(types::global_w_agf_id, type_, "Value");
  return c.get<global_w_agf_id_s>();
}
void global_ran_node_id_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_tngf_id:
      j.write_fieldname("GlobalTNGF-ID");
      c.get<global_tngf_id_s>().to_json(j);
      break;
    case types::global_twif_id:
      j.write_fieldname("GlobalTWIF-ID");
      c.get<global_twif_id_s>().to_json(j);
      break;
    case types::global_w_agf_id:
      j.write_fieldname("GlobalW-AGF-ID");
      c.get<global_w_agf_id_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE global_ran_node_id_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_tngf_id:
      HANDLE_CODE(c.get<global_tngf_id_s>().pack(bref));
      break;
    case types::global_twif_id:
      HANDLE_CODE(c.get<global_twif_id_s>().pack(bref));
      break;
    case types::global_w_agf_id:
      HANDLE_CODE(c.get<global_w_agf_id_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ran_node_id_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_tngf_id:
      HANDLE_CODE(c.get<global_tngf_id_s>().unpack(bref));
      break;
    case types::global_twif_id:
      HANDLE_CODE(c.get<global_twif_id_s>().unpack(bref));
      break;
    case types::global_w_agf_id:
      HANDLE_CODE(c.get<global_w_agf_id_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* global_ran_node_id_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"GlobalTNGF-ID", "GlobalTWIF-ID", "GlobalW-AGF-ID"};
  return convert_enum_idx(names, 3, value, "global_ran_node_id_ext_ies_o::value_c::types");
}

template struct asn1::protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>;

// GlobalRANNodeID ::= CHOICE
void global_ran_node_id_c::destroy_()
{
  switch (type_) {
    case types::global_gnb_id:
      c.destroy<global_gnb_id_s>();
      break;
    case types::global_ng_enb_id:
      c.destroy<global_ng_enb_id_s>();
      break;
    case types::global_n3_iwf_id:
      c.destroy<global_n3_iwf_id_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void global_ran_node_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_gnb_id:
      c.init<global_gnb_id_s>();
      break;
    case types::global_ng_enb_id:
      c.init<global_ng_enb_id_s>();
      break;
    case types::global_n3_iwf_id:
      c.init<global_n3_iwf_id_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
}
global_ran_node_id_c::global_ran_node_id_c(const global_ran_node_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_gnb_id:
      c.init(other.c.get<global_gnb_id_s>());
      break;
    case types::global_ng_enb_id:
      c.init(other.c.get<global_ng_enb_id_s>());
      break;
    case types::global_n3_iwf_id:
      c.init(other.c.get<global_n3_iwf_id_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
}
global_ran_node_id_c& global_ran_node_id_c::operator=(const global_ran_node_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_gnb_id:
      c.set(other.c.get<global_gnb_id_s>());
      break;
    case types::global_ng_enb_id:
      c.set(other.c.get<global_ng_enb_id_s>());
      break;
    case types::global_n3_iwf_id:
      c.set(other.c.get<global_n3_iwf_id_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }

  return *this;
}
global_gnb_id_s& global_ran_node_id_c::set_global_gnb_id()
{
  set(types::global_gnb_id);
  return c.get<global_gnb_id_s>();
}
global_ng_enb_id_s& global_ran_node_id_c::set_global_ng_enb_id()
{
  set(types::global_ng_enb_id);
  return c.get<global_ng_enb_id_s>();
}
global_n3_iwf_id_s& global_ran_node_id_c::set_global_n3_iwf_id()
{
  set(types::global_n3_iwf_id);
  return c.get<global_n3_iwf_id_s>();
}
protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>& global_ran_node_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>();
}
void global_ran_node_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_gnb_id:
      j.write_fieldname("globalGNB-ID");
      c.get<global_gnb_id_s>().to_json(j);
      break;
    case types::global_ng_enb_id:
      j.write_fieldname("globalNgENB-ID");
      c.get<global_ng_enb_id_s>().to_json(j);
      break;
    case types::global_n3_iwf_id:
      j.write_fieldname("globalN3IWF-ID");
      c.get<global_n3_iwf_id_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
  j.end_obj();
}
SRSASN_CODE global_ran_node_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::global_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().pack(bref));
      break;
    case types::global_ng_enb_id:
      HANDLE_CODE(c.get<global_ng_enb_id_s>().pack(bref));
      break;
    case types::global_n3_iwf_id:
      HANDLE_CODE(c.get<global_n3_iwf_id_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ran_node_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::global_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().unpack(bref));
      break;
    case types::global_ng_enb_id:
      HANDLE_CODE(c.get<global_ng_enb_id_s>().unpack(bref));
      break;
    case types::global_n3_iwf_id:
      HANDLE_CODE(c.get<global_n3_iwf_id_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* global_ran_node_id_c::types_opts::to_string() const
{
  static const char* names[] = {"globalGNB-ID", "globalNgENB-ID", "globalN3IWF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "global_ran_node_id_c::types");
}
uint8_t global_ran_node_id_c::types_opts::to_number() const
{
  if (value == global_n3_iwf_id) {
    return 3;
  }
  invalid_enum_number(value, "global_ran_node_id_c::types");
  return 0;
}

// TAI ::= SEQUENCE
SRSASN_CODE tai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("tAC", tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMFPagingTarget ::= CHOICE
void amf_paging_target_c::destroy_()
{
  switch (type_) {
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void amf_paging_target_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }
}
amf_paging_target_c::amf_paging_target_c(const amf_paging_target_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }
}
amf_paging_target_c& amf_paging_target_c::operator=(const amf_paging_target_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }

  return *this;
}
global_ran_node_id_c& amf_paging_target_c::set_global_ran_node_id()
{
  set(types::global_ran_node_id);
  return c.get<global_ran_node_id_c>();
}
tai_s& amf_paging_target_c::set_tai()
{
  set(types::tai);
  return c.get<tai_s>();
}
protocol_ie_single_container_s<amf_paging_target_ext_ies_o>& amf_paging_target_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>();
}
void amf_paging_target_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_ran_node_id:
      j.write_fieldname("globalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("tAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_paging_target_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_paging_target_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_paging_target_c::types_opts::to_string() const
{
  static const char* names[] = {"globalRANNodeID", "tAI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "amf_paging_target_c::types");
}

// TimerApproachForGUAMIRemoval ::= ENUMERATED
const char* timer_approach_for_guami_removal_opts::to_string() const
{
  static const char* names[] = {"apply-timer"};
  return convert_enum_idx(names, 1, value, "timer_approach_for_guami_removal_e");
}

// UnavailableGUAMIItem ::= SEQUENCE
SRSASN_CODE unavailable_guami_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(timer_approach_for_guami_removal_present, 1));
  HANDLE_CODE(bref.pack(backup_amf_name_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(guami.pack(bref));
  if (timer_approach_for_guami_removal_present) {
    HANDLE_CODE(timer_approach_for_guami_removal.pack(bref));
  }
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE unavailable_guami_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(timer_approach_for_guami_removal_present, 1));
  HANDLE_CODE(bref.unpack(backup_amf_name_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(guami.unpack(bref));
  if (timer_approach_for_guami_removal_present) {
    HANDLE_CODE(timer_approach_for_guami_removal.unpack(bref));
  }
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void unavailable_guami_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gUAMI");
  guami.to_json(j);
  if (timer_approach_for_guami_removal_present) {
    j.write_str("timerApproachForGUAMIRemoval", "apply-timer");
  }
  if (backup_amf_name_present) {
    j.write_str("backupAMFName", backup_amf_name.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRA-CGI ::= SEQUENCE
SRSASN_CODE eutra_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(eutra_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(eutra_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("eUTRACellIdentity", eutra_cell_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NR-CGI ::= SEQUENCE
SRSASN_CODE nr_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(nr_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(nr_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("nRCellIdentity", nr_cell_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-CGI ::= CHOICE
void ngran_cgi_c::destroy_()
{
  switch (type_) {
    case types::nr_cgi:
      c.destroy<nr_cgi_s>();
      break;
    case types::eutra_cgi:
      c.destroy<eutra_cgi_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ngran_cgi_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr_cgi:
      c.init<nr_cgi_s>();
      break;
    case types::eutra_cgi:
      c.init<eutra_cgi_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }
}
ngran_cgi_c::ngran_cgi_c(const ngran_cgi_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr_cgi:
      c.init(other.c.get<nr_cgi_s>());
      break;
    case types::eutra_cgi:
      c.init(other.c.get<eutra_cgi_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }
}
ngran_cgi_c& ngran_cgi_c::operator=(const ngran_cgi_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr_cgi:
      c.set(other.c.get<nr_cgi_s>());
      break;
    case types::eutra_cgi:
      c.set(other.c.get<eutra_cgi_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }

  return *this;
}
nr_cgi_s& ngran_cgi_c::set_nr_cgi()
{
  set(types::nr_cgi);
  return c.get<nr_cgi_s>();
}
eutra_cgi_s& ngran_cgi_c::set_eutra_cgi()
{
  set(types::eutra_cgi);
  return c.get<eutra_cgi_s>();
}
protocol_ie_single_container_s<ngran_cgi_ext_ies_o>& ngran_cgi_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>();
}
void ngran_cgi_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr_cgi:
      j.write_fieldname("nR-CGI");
      c.get<nr_cgi_s>().to_json(j);
      break;
    case types::eutra_cgi:
      j.write_fieldname("eUTRA-CGI");
      c.get<eutra_cgi_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }
  j.end_obj();
}
SRSASN_CODE ngran_cgi_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().pack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_cgi_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().unpack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ngran_cgi_c::types_opts::to_string() const
{
  static const char* names[] = {"nR-CGI", "eUTRA-CGI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "ngran_cgi_c::types");
}

// DataForwardingAccepted ::= ENUMERATED
const char* data_forwarding_accepted_opts::to_string() const
{
  static const char* names[] = {"data-forwarding-accepted"};
  return convert_enum_idx(names, 1, value, "data_forwarding_accepted_e");
}

// GTPTunnel ::= SEQUENCE
SRSASN_CODE gtp_tunnel_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gtp_tunnel_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gtp_tunnel_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowItemWithDataForwarding-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_item_with_data_forwarding_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_item_with_data_forwarding_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_item_with_data_forwarding_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_item_with_data_forwarding_ext_ies_o::ext_c
qos_flow_item_with_data_forwarding_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_item_with_data_forwarding_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types");
}

// QosFlowItemWithDataForwarding ::= SEQUENCE
SRSASN_CODE qos_flow_item_with_data_forwarding_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(data_forwarding_accepted_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (data_forwarding_accepted_present) {
    HANDLE_CODE(data_forwarding_accepted.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_item_with_data_forwarding_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(data_forwarding_accepted_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (data_forwarding_accepted_present) {
    HANDLE_CODE(data_forwarding_accepted.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_item_with_data_forwarding_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (data_forwarding_accepted_present) {
    j.write_str("dataForwardingAccepted", "data-forwarding-accepted");
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UPTransportLayerInformation ::= CHOICE
void up_transport_layer_info_c::destroy_()
{
  switch (type_) {
    case types::gtp_tunnel:
      c.destroy<gtp_tunnel_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void up_transport_layer_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gtp_tunnel:
      c.init<gtp_tunnel_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c::up_transport_layer_info_c(const up_transport_layer_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gtp_tunnel:
      c.init(other.c.get<gtp_tunnel_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c& up_transport_layer_info_c::operator=(const up_transport_layer_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gtp_tunnel:
      c.set(other.c.get<gtp_tunnel_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }

  return *this;
}
gtp_tunnel_s& up_transport_layer_info_c::set_gtp_tunnel()
{
  set(types::gtp_tunnel);
  return c.get<gtp_tunnel_s>();
}
protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>& up_transport_layer_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
}
void up_transport_layer_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gtp_tunnel:
      j.write_fieldname("gTPTunnel");
      c.get<gtp_tunnel_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
  j.end_obj();
}
SRSASN_CODE up_transport_layer_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* up_transport_layer_info_c::types_opts::to_string() const
{
  static const char* names[] = {"gTPTunnel", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "up_transport_layer_info_c::types");
}

// AdditionalDLUPTNLInformationForHOItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t add_dl_up_tnl_info_for_ho_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {183};
  return map_enum_number(names, 1, idx, "id");
}
bool add_dl_up_tnl_info_for_ho_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 183 == id;
}
crit_e add_dl_up_tnl_info_for_ho_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 183) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c add_dl_up_tnl_info_for_ho_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 183) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e add_dl_up_tnl_info_for_ho_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 183) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("UPTransportLayerInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformation"};
  return convert_enum_idx(names, 1, value, "add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::types");
}

// AdditionalDLUPTNLInformationForHOItem ::= SEQUENCE
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(add_dl_ngu_up_tnl_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, add_qos_flow_setup_resp_list, 1, 64, true));
  if (add_dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(add_dl_forwarding_up_tnl_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(add_dl_forwarding_up_tnl_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(add_dl_ngu_up_tnl_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(add_qos_flow_setup_resp_list, bref, 1, 64, true));
  if (add_dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(add_dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void add_dl_up_tnl_info_for_ho_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("additionalDL-NGU-UP-TNLInformation");
  add_dl_ngu_up_tnl_info.to_json(j);
  j.start_array("additionalQosFlowSetupResponseList");
  for (const auto& e1 : add_qos_flow_setup_resp_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (add_dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("additionalDLForwardingUPTNLInformation");
    add_dl_forwarding_up_tnl_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// Pre-emptionCapability ::= ENUMERATED
const char* pre_emption_cap_opts::to_string() const
{
  static const char* names[] = {"shall-not-trigger-pre-emption", "may-trigger-pre-emption"};
  return convert_enum_idx(names, 2, value, "pre_emption_cap_e");
}

// Pre-emptionVulnerability ::= ENUMERATED
const char* pre_emption_vulnerability_opts::to_string() const
{
  static const char* names[] = {"not-pre-emptable", "pre-emptable"};
  return convert_enum_idx(names, 2, value, "pre_emption_vulnerability_e");
}

// AllocationAndRetentionPriority ::= SEQUENCE
SRSASN_CODE alloc_and_retention_prio_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level_arp, (uint8_t)1u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.pack(bref));
  HANDLE_CODE(pre_emption_vulnerability.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alloc_and_retention_prio_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level_arp, bref, (uint8_t)1u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.unpack(bref));
  HANDLE_CODE(pre_emption_vulnerability.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alloc_and_retention_prio_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevelARP", prio_level_arp);
  j.write_str("pre-emptionCapability", pre_emption_cap.to_string());
  j.write_str("pre-emptionVulnerability", pre_emption_vulnerability.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Allowed-PNI-NPN-Item ::= SEQUENCE
SRSASN_CODE allowed_pni_npn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pni_npn_restricted.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, allowed_cag_list_per_plmn, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE allowed_pni_npn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(pni_npn_restricted.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(allowed_cag_list_per_plmn, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void allowed_pni_npn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("pNI-NPN-restricted", pni_npn_restricted.to_string());
  j.start_array("allowed-CAG-List-per-PLMN");
  for (const auto& e1 : allowed_cag_list_per_plmn) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* allowed_pni_npn_item_s::pni_npn_restricted_opts::to_string() const
{
  static const char* names[] = {"restricted", "not-restricted"};
  return convert_enum_idx(names, 2, value, "allowed_pni_npn_item_s::pni_npn_restricted_e_");
}

// PacketErrorRate ::= SEQUENCE
SRSASN_CODE packet_error_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, per_scalar, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(pack_integer(bref, per_exponent, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE packet_error_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(per_scalar, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(unpack_integer(per_exponent, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void packet_error_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pERScalar", per_scalar);
  j.write_int("pERExponent", per_exponent);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AlternativeQoSParaSetItem ::= SEQUENCE
SRSASN_CODE alt_qos_para_set_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.pack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, alt_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alt_qos_para_set_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.unpack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.unpack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(alt_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alt_qos_para_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("alternativeQoSParaSetIndex", alt_qos_para_set_idx);
  if (guaranteed_flow_bit_rate_dl_present) {
    j.write_int("guaranteedFlowBitRateDL", guaranteed_flow_bit_rate_dl);
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    j.write_int("guaranteedFlowBitRateUL", guaranteed_flow_bit_rate_ul);
  }
  if (packet_delay_budget_present) {
    j.write_int("packetDelayBudget", packet_delay_budget);
  }
  if (packet_error_rate_present) {
    j.write_fieldname("packetErrorRate");
    packet_error_rate.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestCellItem ::= SEQUENCE
SRSASN_CODE area_of_interest_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestRANNodeItem ::= SEQUENCE
SRSASN_CODE area_of_interest_ran_node_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_ran_node_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_ran_node_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestTAIItem ::= SEQUENCE
SRSASN_CODE area_of_interest_tai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_tai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_tai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterest ::= SEQUENCE
SRSASN_CODE area_of_interest_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(area_of_interest_tai_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(area_of_interest_cell_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(area_of_interest_ran_node_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (area_of_interest_tai_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_tai_list, 1, 16, true));
  }
  if (area_of_interest_cell_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_cell_list, 1, 256, true));
  }
  if (area_of_interest_ran_node_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_ran_node_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool area_of_interest_tai_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_tai_list_present, 1));
  bool area_of_interest_cell_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_cell_list_present, 1));
  bool area_of_interest_ran_node_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_ran_node_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (area_of_interest_tai_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_tai_list, bref, 1, 16, true));
  }
  if (area_of_interest_cell_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_cell_list, bref, 1, 256, true));
  }
  if (area_of_interest_ran_node_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_ran_node_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (area_of_interest_tai_list.size() > 0) {
    j.start_array("areaOfInterestTAIList");
    for (const auto& e1 : area_of_interest_tai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (area_of_interest_cell_list.size() > 0) {
    j.start_array("areaOfInterestCellList");
    for (const auto& e1 : area_of_interest_cell_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (area_of_interest_ran_node_list.size() > 0) {
    j.start_array("areaOfInterestRANNodeList");
    for (const auto& e1 : area_of_interest_ran_node_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestItem ::= SEQUENCE
SRSASN_CODE area_of_interest_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(area_of_interest.pack(bref));
  HANDLE_CODE(pack_integer(bref, location_report_ref_id, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(area_of_interest.unpack(bref));
  HANDLE_CODE(unpack_integer(location_report_ref_id, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("areaOfInterest");
  area_of_interest.to_json(j);
  j.write_int("locationReportingReferenceID", location_report_ref_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellBasedMDT-EUTRA ::= SEQUENCE
SRSASN_CODE cell_based_mdt_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_mdt, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_mdt_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_mdt, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_mdt_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforMDT");
  for (const auto& e1 : cell_id_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedMDT ::= SEQUENCE
SRSASN_CODE ta_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ta_listfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ta_listfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforMDT");
  for (const auto& e1 : ta_listfor_mdt) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedMDT ::= SEQUENCE
SRSASN_CODE tai_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforMDT");
  for (const auto& e1 : tai_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfMDT-EUTRA ::= CHOICE
void area_scope_of_mdt_eutra_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_mdt_eutra_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void area_scope_of_mdt_eutra_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_mdt_eutra_s>();
      break;
    case types::ta_based:
      c.init<ta_based_mdt_s>();
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
}
area_scope_of_mdt_eutra_c::area_scope_of_mdt_eutra_c(const area_scope_of_mdt_eutra_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_mdt_eutra_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
}
area_scope_of_mdt_eutra_c& area_scope_of_mdt_eutra_c::operator=(const area_scope_of_mdt_eutra_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_mdt_eutra_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }

  return *this;
}
cell_based_mdt_eutra_s& area_scope_of_mdt_eutra_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_mdt_eutra_s>();
}
ta_based_mdt_s& area_scope_of_mdt_eutra_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_mdt_s>();
}
void area_scope_of_mdt_eutra_c::set_plmn_wide()
{
  set(types::plmn_wide);
}
tai_based_mdt_s& area_scope_of_mdt_eutra_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_mdt_s>();
}
protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>& area_scope_of_mdt_eutra_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>();
}
void area_scope_of_mdt_eutra_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_mdt_eutra_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_mdt_s>().to_json(j);
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_mdt_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_mdt_eutra_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_eutra_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().pack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_mdt_eutra_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_eutra_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().unpack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_mdt_eutra_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "pLMNWide", "tAIBased", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "area_scope_of_mdt_eutra_c::types");
}

// CellBasedMDT-NR ::= SEQUENCE
SRSASN_CODE cell_based_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_mdt, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_mdt, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforMDT");
  for (const auto& e1 : cell_id_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfMDT-NR ::= CHOICE
void area_scope_of_mdt_nr_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_mdt_nr_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void area_scope_of_mdt_nr_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_mdt_nr_s>();
      break;
    case types::ta_based:
      c.init<ta_based_mdt_s>();
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
}
area_scope_of_mdt_nr_c::area_scope_of_mdt_nr_c(const area_scope_of_mdt_nr_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_mdt_nr_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
}
area_scope_of_mdt_nr_c& area_scope_of_mdt_nr_c::operator=(const area_scope_of_mdt_nr_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_mdt_nr_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }

  return *this;
}
cell_based_mdt_nr_s& area_scope_of_mdt_nr_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_mdt_nr_s>();
}
ta_based_mdt_s& area_scope_of_mdt_nr_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_mdt_s>();
}
void area_scope_of_mdt_nr_c::set_plmn_wide()
{
  set(types::plmn_wide);
}
tai_based_mdt_s& area_scope_of_mdt_nr_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_mdt_s>();
}
protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>& area_scope_of_mdt_nr_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>();
}
void area_scope_of_mdt_nr_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_mdt_nr_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_mdt_s>().to_json(j);
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_mdt_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_mdt_nr_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_nr_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().pack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_mdt_nr_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_nr_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().unpack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_mdt_nr_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "pLMNWide", "tAIBased", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "area_scope_of_mdt_nr_c::types");
}

// NRFrequencyBandItem ::= SEQUENCE
SRSASN_CODE nr_freq_band_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_freq_band, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_band_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_freq_band, bref, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_freq_band_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nr-frequency-band", nr_freq_band);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NRFrequencyInfo ::= SEQUENCE
SRSASN_CODE nr_freq_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, freq_band_list, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(freq_band_list, bref, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_freq_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nrARFCN", nr_arfcn);
  j.start_array("frequencyBand-List");
  for (const auto& e1 : freq_band_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfNeighCellsItem ::= SEQUENCE
SRSASN_CODE area_scope_of_neigh_cells_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pci_list_for_mdt.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.pack(bref));
  if (pci_list_for_mdt.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, pci_list_for_mdt, 1, 32, integer_packer<uint16_t>(0, 1007, true, true)));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_neigh_cells_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool pci_list_for_mdt_present;
  HANDLE_CODE(bref.unpack(pci_list_for_mdt_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.unpack(bref));
  if (pci_list_for_mdt_present) {
    HANDLE_CODE(unpack_dyn_seq_of(pci_list_for_mdt, bref, 1, 32, integer_packer<uint16_t>(0, 1007, true, true)));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_scope_of_neigh_cells_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nrFrequencyInfo");
  nr_freq_info.to_json(j);
  if (pci_list_for_mdt.size() > 0) {
    j.start_array("pciListForMDT");
    for (const auto& e1 : pci_list_for_mdt) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellBasedQMC ::= SEQUENCE
SRSASN_CODE cell_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_qmc, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_qmc, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforQMC");
  for (const auto& e1 : cell_id_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PLMNAreaBasedQMC ::= SEQUENCE
SRSASN_CODE plmn_area_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, plmn_listfor_qmc, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_area_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(plmn_listfor_qmc, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void plmn_area_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("plmnListforQMC");
  for (const auto& e1 : plmn_listfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedQMC ::= SEQUENCE
SRSASN_CODE ta_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ta_listfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ta_listfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforQMC");
  for (const auto& e1 : ta_listfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedQMC ::= SEQUENCE
SRSASN_CODE tai_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforQMC");
  for (const auto& e1 : tai_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfQMC ::= CHOICE
void area_scope_of_qmc_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_qmc_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.destroy<plmn_area_based_qmc_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void area_scope_of_qmc_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_qmc_s>();
      break;
    case types::ta_based:
      c.init<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.init<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.init<plmn_area_based_qmc_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c::area_scope_of_qmc_c(const area_scope_of_qmc_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_qmc_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.init(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c& area_scope_of_qmc_c::operator=(const area_scope_of_qmc_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_qmc_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.set(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }

  return *this;
}
cell_based_qmc_s& area_scope_of_qmc_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_qmc_s>();
}
ta_based_qmc_s& area_scope_of_qmc_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_qmc_s>();
}
tai_based_qmc_s& area_scope_of_qmc_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_qmc_s>();
}
plmn_area_based_qmc_s& area_scope_of_qmc_c::set_plmn_area_based()
{
  set(types::plmn_area_based);
  return c.get<plmn_area_based_qmc_s>();
}
protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>& area_scope_of_qmc_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
}
void area_scope_of_qmc_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_qmc_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_qmc_s>().to_json(j);
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_qmc_s>().to_json(j);
      break;
    case types::plmn_area_based:
      j.write_fieldname("pLMNAreaBased");
      c.get<plmn_area_based_qmc_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_qmc_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_qmc_s>().pack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().pack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_qmc_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_qmc_s>().unpack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().unpack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_qmc_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "tAIBased", "pLMNAreaBased", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "area_scope_of_qmc_c::types");
}

// RecommendedCellItem ::= SEQUENCE
SRSASN_CODE recommended_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(pack_integer(bref, time_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(unpack_integer(time_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (time_stayed_in_cell_present) {
    j.write_int("timeStayedInCell", time_stayed_in_cell);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-PagingAssistanceInformation ::= CHOICE
void npn_paging_assist_info_c::destroy_()
{
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.destroy<allowed_pni_npn_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_paging_assist_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.init<allowed_pni_npn_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
}
npn_paging_assist_info_c::npn_paging_assist_info_c(const npn_paging_assist_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.init(other.c.get<allowed_pni_npn_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
}
npn_paging_assist_info_c& npn_paging_assist_info_c::operator=(const npn_paging_assist_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.set(other.c.get<allowed_pni_npn_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }

  return *this;
}
allowed_pni_npn_list_l& npn_paging_assist_info_c::set_pni_npn_paging_assist()
{
  set(types::pni_npn_paging_assist);
  return c.get<allowed_pni_npn_list_l>();
}
protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>& npn_paging_assist_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
}
void npn_paging_assist_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pni_npn_paging_assist:
      j.start_array("pNI-NPN-PagingAssistance");
      for (const auto& e1 : c.get<allowed_pni_npn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_paging_assist_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pni_npn_paging_assist:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_pni_npn_list_l>(), 1, 16, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_paging_assist_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pni_npn_paging_assist:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_pni_npn_list_l>(), bref, 1, 16, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_paging_assist_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pNI-NPN-PagingAssistance", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "npn_paging_assist_info_c::types");
}

// NextPagingAreaScope ::= ENUMERATED
const char* next_paging_area_scope_opts::to_string() const
{
  static const char* names[] = {"same", "changed"};
  return convert_enum_idx(names, 2, value, "next_paging_area_scope_e");
}

// PagingAssisDataforCEcapabUE ::= SEQUENCE
SRSASN_CODE paging_assis_datafor_c_ecapab_ue_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(coverage_enhancement_level.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_assis_datafor_c_ecapab_ue_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(coverage_enhancement_level.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void paging_assis_datafor_c_ecapab_ue_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_str("coverageEnhancementLevel", coverage_enhancement_level.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedCellsForPaging ::= SEQUENCE
SRSASN_CODE recommended_cells_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, recommended_cell_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_cells_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(recommended_cell_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_cells_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("recommendedCellList");
  for (const auto& e1 : recommended_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssistanceDataForPaging-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t assist_data_for_paging_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {260, 207};
  return map_enum_number(names, 2, idx, "id");
}
bool assist_data_for_paging_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {260, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e assist_data_for_paging_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 260:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
assist_data_for_paging_ext_ies_o::ext_c assist_data_for_paging_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 260:
      ret.set(ext_c::types::npn_paging_assist_info);
      break;
    case 207:
      ret.set(ext_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e assist_data_for_paging_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 260:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void assist_data_for_paging_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::npn_paging_assist_info:
      c = npn_paging_assist_info_c{};
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c = paging_assis_datafor_c_ecapab_ue_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
  }
}
npn_paging_assist_info_c& assist_data_for_paging_ext_ies_o::ext_c::npn_paging_assist_info()
{
  assert_choice_type(types::npn_paging_assist_info, type_, "Extension");
  return c.get<npn_paging_assist_info_c>();
}
paging_assis_datafor_c_ecapab_ue_s& assist_data_for_paging_ext_ies_o::ext_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Extension");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const npn_paging_assist_info_c& assist_data_for_paging_ext_ies_o::ext_c::npn_paging_assist_info() const
{
  assert_choice_type(types::npn_paging_assist_info, type_, "Extension");
  return c.get<npn_paging_assist_info_c>();
}
const paging_assis_datafor_c_ecapab_ue_s&
assist_data_for_paging_ext_ies_o::ext_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Extension");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void assist_data_for_paging_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_paging_assist_info:
      j.write_fieldname("NPN-PagingAssistanceInformation");
      c.get<npn_paging_assist_info_c>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE assist_data_for_paging_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_paging_assist_info:
      HANDLE_CODE(c.get<npn_paging_assist_info_c>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_paging_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_paging_assist_info:
      HANDLE_CODE(c.get<npn_paging_assist_info_c>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* assist_data_for_paging_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPN-PagingAssistanceInformation", "PagingAssisDataforCEcapabUE"};
  return convert_enum_idx(names, 2, value, "assist_data_for_paging_ext_ies_o::ext_c::types");
}

// AssistanceDataForRecommendedCells ::= SEQUENCE
SRSASN_CODE assist_data_for_recommended_cells_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_recommended_cells_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_recommended_cells_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("recommendedCellsForPaging");
  recommended_cells_for_paging.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingAttemptInformation ::= SEQUENCE
SRSASN_CODE paging_attempt_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, paging_attempt_count, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(pack_integer(bref, intended_nof_paging_attempts, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_attempt_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(paging_attempt_count, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(unpack_integer(intended_nof_paging_attempts, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void paging_attempt_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pagingAttemptCount", paging_attempt_count);
  j.write_int("intendedNumberOfPagingAttempts", intended_nof_paging_attempts);
  if (next_paging_area_scope_present) {
    j.write_str("nextPagingAreaScope", next_paging_area_scope.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<assist_data_for_paging_ext_ies_o>;

SRSASN_CODE assist_data_for_paging_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_paging_assist_info_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_paging_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)260, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_paging_assist_info.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_paging_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 260: {
        npn_paging_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_paging_assist_info.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_paging_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_paging_assist_info_present) {
    j.write_int("id", 260);
    j.write_str("criticality", "ignore");
    npn_paging_assist_info.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

// AssistanceDataForPaging ::= SEQUENCE
SRSASN_CODE assist_data_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(assist_data_for_recommended_cells_present, 1));
  HANDLE_CODE(bref.pack(paging_attempt_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (assist_data_for_recommended_cells_present) {
    HANDLE_CODE(assist_data_for_recommended_cells.pack(bref));
  }
  if (paging_attempt_info_present) {
    HANDLE_CODE(paging_attempt_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(assist_data_for_recommended_cells_present, 1));
  HANDLE_CODE(bref.unpack(paging_attempt_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (assist_data_for_recommended_cells_present) {
    HANDLE_CODE(assist_data_for_recommended_cells.unpack(bref));
  }
  if (paging_attempt_info_present) {
    HANDLE_CODE(paging_attempt_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (assist_data_for_recommended_cells_present) {
    j.write_fieldname("assistanceDataForRecommendedCells");
    assist_data_for_recommended_cells.to_json(j);
  }
  if (paging_attempt_info_present) {
    j.write_fieldname("pagingAttemptInformation");
    paging_attempt_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssociatedMBSQosFlowSetupRequestItem ::= SEQUENCE
SRSASN_CODE associated_mbs_qos_flow_setup_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(pack_integer(bref, associated_unicast_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_mbs_qos_flow_setup_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(unpack_integer(associated_unicast_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void associated_mbs_qos_flow_setup_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-QosFlowIdentifier", mbs_qos_flow_id);
  j.write_int("associatedUnicastQosFlowIdentifier", associated_unicast_qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssociatedMBSQosFlowSetuporModifyRequestItem ::= SEQUENCE
SRSASN_CODE associated_mbs_qos_flow_setupor_modify_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(pack_integer(bref, associated_unicast_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_mbs_qos_flow_setupor_modify_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(unpack_integer(associated_unicast_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void associated_mbs_qos_flow_setupor_modify_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-QosFlowIdentifier", mbs_qos_flow_id);
  j.write_int("associatedUnicastQosFlowIdentifier", associated_unicast_qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssociatedQosFlowItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t associated_qos_flow_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool associated_qos_flow_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e associated_qos_flow_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
associated_qos_flow_item_ext_ies_o::ext_c associated_qos_flow_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e associated_qos_flow_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void associated_qos_flow_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE associated_qos_flow_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_qos_flow_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* associated_qos_flow_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "associated_qos_flow_item_ext_ies_o::ext_c::types");
}
uint8_t associated_qos_flow_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "associated_qos_flow_item_ext_ies_o::ext_c::types");
}

// AssociatedQosFlowItem ::= SEQUENCE
SRSASN_CODE associated_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_flow_map_ind_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void associated_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (qos_flow_map_ind_present) {
    j.write_str("qosFlowMappingIndication", qos_flow_map_ind.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* associated_qos_flow_item_s::qos_flow_map_ind_opts::to_string() const
{
  static const char* names[] = {"ul", "dl"};
  return convert_enum_idx(names, 2, value, "associated_qos_flow_item_s::qos_flow_map_ind_e_");
}

// AvailableRANVisibleQoEMetrics ::= SEQUENCE
SRSASN_CODE available_ran_visible_qo_e_metrics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(application_layer_buffer_level_list_present, 1));
  HANDLE_CODE(bref.pack(playout_delay_for_media_startup_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (application_layer_buffer_level_list_present) {
    HANDLE_CODE(application_layer_buffer_level_list.pack(bref));
  }
  if (playout_delay_for_media_startup_present) {
    HANDLE_CODE(playout_delay_for_media_startup.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE available_ran_visible_qo_e_metrics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(application_layer_buffer_level_list_present, 1));
  HANDLE_CODE(bref.unpack(playout_delay_for_media_startup_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (application_layer_buffer_level_list_present) {
    HANDLE_CODE(application_layer_buffer_level_list.unpack(bref));
  }
  if (playout_delay_for_media_startup_present) {
    HANDLE_CODE(playout_delay_for_media_startup.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void available_ran_visible_qo_e_metrics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (application_layer_buffer_level_list_present) {
    j.write_str("applicationLayerBufferLevelList", "true");
  }
  if (playout_delay_for_media_startup_present) {
    j.write_str("playoutDelayForMediaStartup", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* available_ran_visible_qo_e_metrics_s::application_layer_buffer_level_list_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(
      names, 1, value, "available_ran_visible_qo_e_metrics_s::application_layer_buffer_level_list_e_");
}

const char* available_ran_visible_qo_e_metrics_s::playout_delay_for_media_startup_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "available_ran_visible_qo_e_metrics_s::playout_delay_for_media_startup_e_");
}

// BeamMeasurementsReportQuantity ::= SEQUENCE
SRSASN_CODE beam_meass_report_quant_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rsrp.pack(bref));
  HANDLE_CODE(rsrq.pack(bref));
  HANDLE_CODE(sinr.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE beam_meass_report_quant_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rsrp.unpack(bref));
  HANDLE_CODE(rsrq.unpack(bref));
  HANDLE_CODE(sinr.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void beam_meass_report_quant_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rSRP", "true");
  j.write_str("rSRQ", "true");
  j.write_str("sINR", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* beam_meass_report_quant_s::rsrp_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::rsrp_e_");
}

const char* beam_meass_report_quant_s::rsrq_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::rsrq_e_");
}

const char* beam_meass_report_quant_s::sinr_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::sinr_e_");
}

// BeamMeasurementsReportConfiguration ::= SEQUENCE
SRSASN_CODE beam_meass_report_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(beam_meass_report_quant_present, 1));
  HANDLE_CODE(bref.pack(max_nrof_rs_idxes_to_report_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (beam_meass_report_quant_present) {
    HANDLE_CODE(beam_meass_report_quant.pack(bref));
  }
  if (max_nrof_rs_idxes_to_report_present) {
    HANDLE_CODE(pack_integer(bref, max_nrof_rs_idxes_to_report, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE beam_meass_report_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(beam_meass_report_quant_present, 1));
  HANDLE_CODE(bref.unpack(max_nrof_rs_idxes_to_report_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (beam_meass_report_quant_present) {
    HANDLE_CODE(beam_meass_report_quant.unpack(bref));
  }
  if (max_nrof_rs_idxes_to_report_present) {
    HANDLE_CODE(unpack_integer(max_nrof_rs_idxes_to_report, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void beam_meass_report_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (beam_meass_report_quant_present) {
    j.write_fieldname("beamMeasurementsReportQuantity");
    beam_meass_report_quant.to_json(j);
  }
  if (max_nrof_rs_idxes_to_report_present) {
    j.write_int("maxNrofRS-IndexesToReport", max_nrof_rs_idxes_to_report);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BluetoothMeasConfigNameItem ::= SEQUENCE
SRSASN_CODE bluetooth_meas_cfg_name_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_name.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bluetooth_meas_cfg_name_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_name.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bluetooth_meas_cfg_name_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bluetoothName", bluetooth_name.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BluetoothMeasConfig ::= ENUMERATED
const char* bluetooth_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "bluetooth_meas_cfg_e");
}

// BluetoothMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE bluetooth_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(bt_rssi_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  if (bluetooth_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, bluetooth_meas_cfg_name_list, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bluetooth_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool bluetooth_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(bt_rssi_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  if (bluetooth_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(bluetooth_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bluetooth_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bluetoothMeasConfig", "setup");
  if (bluetooth_meas_cfg_name_list.size() > 0) {
    j.start_array("bluetoothMeasConfigNameList");
    for (const auto& e1 : bluetooth_meas_cfg_name_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (bt_rssi_present) {
    j.write_str("bt-rssi", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* bluetooth_meas_cfg_s::bt_rssi_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "bluetooth_meas_cfg_s::bt_rssi_e_");
}

// CancelledCellsInEAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_eai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_eai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_eai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelledCellsInEAI-NR-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_eai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_eai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_eai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelledCellsInTAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_tai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_tai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_tai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelledCellsInTAI-NR-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_tai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_tai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_tai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDCancelledEUTRA-Item ::= SEQUENCE
SRSASN_CODE cell_id_cancelled_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_cancelled_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_cancelled_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDCancelledNR-Item ::= SEQUENCE
SRSASN_CODE cell_id_cancelled_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_cancelled_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_cancelled_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDCancelledEUTRA-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_cancelled_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_eai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_cancelled_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_eai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_cancelled_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("cancelledCellsInEAI-EUTRA");
  for (const auto& e1 : cancelled_cells_in_eai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDCancelledNR-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_cancelled_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_eai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_cancelled_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_eai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_cancelled_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("cancelledCellsInEAI-NR");
  for (const auto& e1 : cancelled_cells_in_eai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAICancelledEUTRA-Item ::= SEQUENCE
SRSASN_CODE tai_cancelled_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_tai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_cancelled_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_tai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_cancelled_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("cancelledCellsInTAI-EUTRA");
  for (const auto& e1 : cancelled_cells_in_tai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAICancelledNR-Item ::= SEQUENCE
SRSASN_CODE tai_cancelled_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_tai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_cancelled_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_tai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_cancelled_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("cancelledCellsInTAI-NR");
  for (const auto& e1 : cancelled_cells_in_tai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastCancelledAreaList ::= CHOICE
void broadcast_cancelled_area_list_c::destroy_()
{
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.destroy<cell_id_cancelled_eutra_l>();
      break;
    case types::tai_cancelled_eutra:
      c.destroy<tai_cancelled_eutra_l>();
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.destroy<emergency_area_id_cancelled_eutra_l>();
      break;
    case types::cell_id_cancelled_nr:
      c.destroy<cell_id_cancelled_nr_l>();
      break;
    case types::tai_cancelled_nr:
      c.destroy<tai_cancelled_nr_l>();
      break;
    case types::emergency_area_id_cancelled_nr:
      c.destroy<emergency_area_id_cancelled_nr_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void broadcast_cancelled_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.init<cell_id_cancelled_eutra_l>();
      break;
    case types::tai_cancelled_eutra:
      c.init<tai_cancelled_eutra_l>();
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.init<emergency_area_id_cancelled_eutra_l>();
      break;
    case types::cell_id_cancelled_nr:
      c.init<cell_id_cancelled_nr_l>();
      break;
    case types::tai_cancelled_nr:
      c.init<tai_cancelled_nr_l>();
      break;
    case types::emergency_area_id_cancelled_nr:
      c.init<emergency_area_id_cancelled_nr_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
}
broadcast_cancelled_area_list_c::broadcast_cancelled_area_list_c(const broadcast_cancelled_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.init(other.c.get<cell_id_cancelled_eutra_l>());
      break;
    case types::tai_cancelled_eutra:
      c.init(other.c.get<tai_cancelled_eutra_l>());
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.init(other.c.get<emergency_area_id_cancelled_eutra_l>());
      break;
    case types::cell_id_cancelled_nr:
      c.init(other.c.get<cell_id_cancelled_nr_l>());
      break;
    case types::tai_cancelled_nr:
      c.init(other.c.get<tai_cancelled_nr_l>());
      break;
    case types::emergency_area_id_cancelled_nr:
      c.init(other.c.get<emergency_area_id_cancelled_nr_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
}
broadcast_cancelled_area_list_c&
broadcast_cancelled_area_list_c::operator=(const broadcast_cancelled_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.set(other.c.get<cell_id_cancelled_eutra_l>());
      break;
    case types::tai_cancelled_eutra:
      c.set(other.c.get<tai_cancelled_eutra_l>());
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.set(other.c.get<emergency_area_id_cancelled_eutra_l>());
      break;
    case types::cell_id_cancelled_nr:
      c.set(other.c.get<cell_id_cancelled_nr_l>());
      break;
    case types::tai_cancelled_nr:
      c.set(other.c.get<tai_cancelled_nr_l>());
      break;
    case types::emergency_area_id_cancelled_nr:
      c.set(other.c.get<emergency_area_id_cancelled_nr_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }

  return *this;
}
cell_id_cancelled_eutra_l& broadcast_cancelled_area_list_c::set_cell_id_cancelled_eutra()
{
  set(types::cell_id_cancelled_eutra);
  return c.get<cell_id_cancelled_eutra_l>();
}
tai_cancelled_eutra_l& broadcast_cancelled_area_list_c::set_tai_cancelled_eutra()
{
  set(types::tai_cancelled_eutra);
  return c.get<tai_cancelled_eutra_l>();
}
emergency_area_id_cancelled_eutra_l& broadcast_cancelled_area_list_c::set_emergency_area_id_cancelled_eutra()
{
  set(types::emergency_area_id_cancelled_eutra);
  return c.get<emergency_area_id_cancelled_eutra_l>();
}
cell_id_cancelled_nr_l& broadcast_cancelled_area_list_c::set_cell_id_cancelled_nr()
{
  set(types::cell_id_cancelled_nr);
  return c.get<cell_id_cancelled_nr_l>();
}
tai_cancelled_nr_l& broadcast_cancelled_area_list_c::set_tai_cancelled_nr()
{
  set(types::tai_cancelled_nr);
  return c.get<tai_cancelled_nr_l>();
}
emergency_area_id_cancelled_nr_l& broadcast_cancelled_area_list_c::set_emergency_area_id_cancelled_nr()
{
  set(types::emergency_area_id_cancelled_nr);
  return c.get<emergency_area_id_cancelled_nr_l>();
}
protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>&
broadcast_cancelled_area_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>();
}
void broadcast_cancelled_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      j.start_array("cellIDCancelledEUTRA");
      for (const auto& e1 : c.get<cell_id_cancelled_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_cancelled_eutra:
      j.start_array("tAICancelledEUTRA");
      for (const auto& e1 : c.get<tai_cancelled_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_cancelled_eutra:
      j.start_array("emergencyAreaIDCancelledEUTRA");
      for (const auto& e1 : c.get<emergency_area_id_cancelled_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cell_id_cancelled_nr:
      j.start_array("cellIDCancelledNR");
      for (const auto& e1 : c.get<cell_id_cancelled_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_cancelled_nr:
      j.start_array("tAICancelledNR");
      for (const auto& e1 : c.get<tai_cancelled_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_cancelled_nr:
      j.start_array("emergencyAreaIDCancelledNR");
      for (const auto& e1 : c.get<emergency_area_id_cancelled_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_cancelled_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_cancelled_eutra_l>(), 1, 65535, true));
      break;
    case types::tai_cancelled_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_cancelled_eutra_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_cancelled_eutra_l>(), 1, 65535, true));
      break;
    case types::cell_id_cancelled_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_cancelled_nr_l>(), 1, 65535, true));
      break;
    case types::tai_cancelled_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_cancelled_nr_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_cancelled_nr_l>(), 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_cancelled_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_cancelled_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::tai_cancelled_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_cancelled_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_cancelled_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::cell_id_cancelled_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_cancelled_nr_l>(), bref, 1, 65535, true));
      break;
    case types::tai_cancelled_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_cancelled_nr_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_cancelled_nr_l>(), bref, 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_cancelled_area_list_c::types_opts::to_string() const
{
  static const char* names[] = {"cellIDCancelledEUTRA",
                                "tAICancelledEUTRA",
                                "emergencyAreaIDCancelledEUTRA",
                                "cellIDCancelledNR",
                                "tAICancelledNR",
                                "emergencyAreaIDCancelledNR",
                                "choice-Extensions"};
  return convert_enum_idx(names, 7, value, "broadcast_cancelled_area_list_c::types");
}

// CompletedCellsInEAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_eai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_eai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_eai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompletedCellsInEAI-NR-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_eai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_eai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_eai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompletedCellsInTAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_tai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_tai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_tai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompletedCellsInTAI-NR-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_tai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_tai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_tai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDBroadcastEUTRA-Item ::= SEQUENCE
SRSASN_CODE cell_id_broadcast_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_broadcast_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_broadcast_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDBroadcastNR-Item ::= SEQUENCE
SRSASN_CODE cell_id_broadcast_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_broadcast_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_broadcast_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDBroadcastEUTRA-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_broadcast_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_eai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_broadcast_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_eai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_broadcast_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("completedCellsInEAI-EUTRA");
  for (const auto& e1 : completed_cells_in_eai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDBroadcastNR-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_broadcast_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_eai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_broadcast_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_eai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_broadcast_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("completedCellsInEAI-NR");
  for (const auto& e1 : completed_cells_in_eai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBroadcastEUTRA-Item ::= SEQUENCE
SRSASN_CODE tai_broadcast_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_tai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_broadcast_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_tai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_broadcast_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("completedCellsInTAI-EUTRA");
  for (const auto& e1 : completed_cells_in_tai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBroadcastNR-Item ::= SEQUENCE
SRSASN_CODE tai_broadcast_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_tai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_broadcast_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_tai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_broadcast_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("completedCellsInTAI-NR");
  for (const auto& e1 : completed_cells_in_tai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastCompletedAreaList ::= CHOICE
void broadcast_completed_area_list_c::destroy_()
{
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.destroy<cell_id_broadcast_eutra_l>();
      break;
    case types::tai_broadcast_eutra:
      c.destroy<tai_broadcast_eutra_l>();
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.destroy<emergency_area_id_broadcast_eutra_l>();
      break;
    case types::cell_id_broadcast_nr:
      c.destroy<cell_id_broadcast_nr_l>();
      break;
    case types::tai_broadcast_nr:
      c.destroy<tai_broadcast_nr_l>();
      break;
    case types::emergency_area_id_broadcast_nr:
      c.destroy<emergency_area_id_broadcast_nr_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void broadcast_completed_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.init<cell_id_broadcast_eutra_l>();
      break;
    case types::tai_broadcast_eutra:
      c.init<tai_broadcast_eutra_l>();
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.init<emergency_area_id_broadcast_eutra_l>();
      break;
    case types::cell_id_broadcast_nr:
      c.init<cell_id_broadcast_nr_l>();
      break;
    case types::tai_broadcast_nr:
      c.init<tai_broadcast_nr_l>();
      break;
    case types::emergency_area_id_broadcast_nr:
      c.init<emergency_area_id_broadcast_nr_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
}
broadcast_completed_area_list_c::broadcast_completed_area_list_c(const broadcast_completed_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.init(other.c.get<cell_id_broadcast_eutra_l>());
      break;
    case types::tai_broadcast_eutra:
      c.init(other.c.get<tai_broadcast_eutra_l>());
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.init(other.c.get<emergency_area_id_broadcast_eutra_l>());
      break;
    case types::cell_id_broadcast_nr:
      c.init(other.c.get<cell_id_broadcast_nr_l>());
      break;
    case types::tai_broadcast_nr:
      c.init(other.c.get<tai_broadcast_nr_l>());
      break;
    case types::emergency_area_id_broadcast_nr:
      c.init(other.c.get<emergency_area_id_broadcast_nr_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
}
broadcast_completed_area_list_c&
broadcast_completed_area_list_c::operator=(const broadcast_completed_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.set(other.c.get<cell_id_broadcast_eutra_l>());
      break;
    case types::tai_broadcast_eutra:
      c.set(other.c.get<tai_broadcast_eutra_l>());
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.set(other.c.get<emergency_area_id_broadcast_eutra_l>());
      break;
    case types::cell_id_broadcast_nr:
      c.set(other.c.get<cell_id_broadcast_nr_l>());
      break;
    case types::tai_broadcast_nr:
      c.set(other.c.get<tai_broadcast_nr_l>());
      break;
    case types::emergency_area_id_broadcast_nr:
      c.set(other.c.get<emergency_area_id_broadcast_nr_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }

  return *this;
}
cell_id_broadcast_eutra_l& broadcast_completed_area_list_c::set_cell_id_broadcast_eutra()
{
  set(types::cell_id_broadcast_eutra);
  return c.get<cell_id_broadcast_eutra_l>();
}
tai_broadcast_eutra_l& broadcast_completed_area_list_c::set_tai_broadcast_eutra()
{
  set(types::tai_broadcast_eutra);
  return c.get<tai_broadcast_eutra_l>();
}
emergency_area_id_broadcast_eutra_l& broadcast_completed_area_list_c::set_emergency_area_id_broadcast_eutra()
{
  set(types::emergency_area_id_broadcast_eutra);
  return c.get<emergency_area_id_broadcast_eutra_l>();
}
cell_id_broadcast_nr_l& broadcast_completed_area_list_c::set_cell_id_broadcast_nr()
{
  set(types::cell_id_broadcast_nr);
  return c.get<cell_id_broadcast_nr_l>();
}
tai_broadcast_nr_l& broadcast_completed_area_list_c::set_tai_broadcast_nr()
{
  set(types::tai_broadcast_nr);
  return c.get<tai_broadcast_nr_l>();
}
emergency_area_id_broadcast_nr_l& broadcast_completed_area_list_c::set_emergency_area_id_broadcast_nr()
{
  set(types::emergency_area_id_broadcast_nr);
  return c.get<emergency_area_id_broadcast_nr_l>();
}
protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>&
broadcast_completed_area_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>();
}
void broadcast_completed_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      j.start_array("cellIDBroadcastEUTRA");
      for (const auto& e1 : c.get<cell_id_broadcast_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_broadcast_eutra:
      j.start_array("tAIBroadcastEUTRA");
      for (const auto& e1 : c.get<tai_broadcast_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_broadcast_eutra:
      j.start_array("emergencyAreaIDBroadcastEUTRA");
      for (const auto& e1 : c.get<emergency_area_id_broadcast_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cell_id_broadcast_nr:
      j.start_array("cellIDBroadcastNR");
      for (const auto& e1 : c.get<cell_id_broadcast_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_broadcast_nr:
      j.start_array("tAIBroadcastNR");
      for (const auto& e1 : c.get<tai_broadcast_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_broadcast_nr:
      j.start_array("emergencyAreaIDBroadcastNR");
      for (const auto& e1 : c.get<emergency_area_id_broadcast_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_completed_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_broadcast_eutra_l>(), 1, 65535, true));
      break;
    case types::tai_broadcast_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_broadcast_eutra_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_broadcast_eutra_l>(), 1, 65535, true));
      break;
    case types::cell_id_broadcast_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_broadcast_nr_l>(), 1, 65535, true));
      break;
    case types::tai_broadcast_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_broadcast_nr_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_broadcast_nr_l>(), 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_completed_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_broadcast_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::tai_broadcast_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_broadcast_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_broadcast_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::cell_id_broadcast_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_broadcast_nr_l>(), bref, 1, 65535, true));
      break;
    case types::tai_broadcast_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_broadcast_nr_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_broadcast_nr_l>(), bref, 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_completed_area_list_c::types_opts::to_string() const
{
  static const char* names[] = {"cellIDBroadcastEUTRA",
                                "tAIBroadcastEUTRA",
                                "emergencyAreaIDBroadcastEUTRA",
                                "cellIDBroadcastNR",
                                "tAIBroadcastNR",
                                "emergencyAreaIDBroadcastNR",
                                "choice-Extensions"};
  return convert_enum_idx(names, 7, value, "broadcast_completed_area_list_c::types");
}

// TAINSAGSupportItem ::= SEQUENCE
SRSASN_CODE tai_nsag_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nsag_id, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, nsag_slice_support_list, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_nsag_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nsag_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(nsag_slice_support_list, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_nsag_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nSAG-ID", nsag_id);
  j.start_array("nSAGSliceSupportList");
  for (const auto& e1 : nsag_slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastPLMNItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t broadcast_plmn_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {258, 271, 353};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_plmn_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {258, 271, 353};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_plmn_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 258:
      return crit_e::reject;
    case 271:
      return crit_e::reject;
    case 353:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_plmn_item_ext_ies_o::ext_c broadcast_plmn_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 258:
      ret.set(ext_c::types::npn_support);
      break;
    case 271:
      ret.set(ext_c::types::extended_tai_slice_support_list);
      break;
    case 353:
      ret.set(ext_c::types::tai_nsag_support_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_plmn_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 258:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    case 353:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void broadcast_plmn_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::npn_support:
      c = npn_support_c{};
      break;
    case types::extended_tai_slice_support_list:
      c = extended_slice_support_list_l{};
      break;
    case types::tai_nsag_support_list:
      c = tai_nsag_support_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
  }
}
npn_support_c& broadcast_plmn_item_ext_ies_o::ext_c::npn_support()
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
extended_slice_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::extended_tai_slice_support_list()
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
tai_nsag_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::tai_nsag_support_list()
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<tai_nsag_support_list_l>();
}
const npn_support_c& broadcast_plmn_item_ext_ies_o::ext_c::npn_support() const
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
const extended_slice_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::extended_tai_slice_support_list() const
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
const tai_nsag_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::tai_nsag_support_list() const
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<tai_nsag_support_list_l>();
}
void broadcast_plmn_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_support:
      j.write_fieldname("NPN-Support");
      c.get<npn_support_c>().to_json(j);
      break;
    case types::extended_tai_slice_support_list:
      j.start_array("ExtendedSliceSupportList");
      for (const auto& e1 : c.get<extended_slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_nsag_support_list:
      j.start_array("TAINSAGSupportList");
      for (const auto& e1 : c.get<tai_nsag_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_plmn_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().pack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_slice_support_list_l>(), 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_nsag_support_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().unpack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_slice_support_list_l>(), bref, 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_nsag_support_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_plmn_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPN-Support", "ExtendedSliceSupportList", "TAINSAGSupportList"};
  return convert_enum_idx(names, 3, value, "broadcast_plmn_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<broadcast_plmn_item_ext_ies_o>;

SRSASN_CODE broadcast_plmn_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_support_present ? 1 : 0;
  nof_ies += extended_tai_slice_support_list_present ? 1 : 0;
  nof_ies += tai_nsag_support_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)258, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_support.pack(bref));
  }
  if (extended_tai_slice_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)271, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_tai_slice_support_list, 1, 65535, true));
  }
  if (tai_nsag_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)353, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_nsag_support_list, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 258: {
        npn_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_support.unpack(bref));
        break;
      }
      case 271: {
        extended_tai_slice_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_tai_slice_support_list, bref, 1, 65535, true));
        break;
      }
      case 353: {
        tai_nsag_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_nsag_support_list, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void broadcast_plmn_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_support_present) {
    j.write_int("id", 258);
    j.write_str("criticality", "reject");
    npn_support.to_json(j);
  }
  if (extended_tai_slice_support_list_present) {
    j.write_int("id", 271);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : extended_tai_slice_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (tai_nsag_support_list_present) {
    j.write_int("id", 353);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : tai_nsag_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// BroadcastPLMNItem ::= SEQUENCE
SRSASN_CODE broadcast_plmn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, tai_slice_support_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(tai_slice_support_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_plmn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("tAISliceSupportList");
  for (const auto& e1 : tai_slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionID ::= SEQUENCE
SRSASN_CODE mbs_session_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.pack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.unpack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tMGI", tmgi.to_string());
  if (nid_present) {
    j.write_str("nID", nid.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceAreaInformation ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_service_area_cell_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_tai_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_service_area_cell_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_cell_list, 1, 8192, true));
  }
  if (mbs_service_area_tai_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_tai_list, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mbs_service_area_cell_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_cell_list_present, 1));
  bool mbs_service_area_tai_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_tai_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_service_area_cell_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_cell_list, bref, 1, 8192, true));
  }
  if (mbs_service_area_tai_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_tai_list, bref, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_service_area_cell_list.size() > 0) {
    j.start_array("mBS-ServiceAreaCellList");
    for (const auto& e1 : mbs_service_area_cell_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_service_area_tai_list.size() > 0) {
    j.start_array("mBS-ServiceAreaTAIList");
    for (const auto& e1 : mbs_service_area_tai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceAreaInformationItem ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  j.write_fieldname("mBS-ServiceAreaInformation");
  mbs_service_area_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceArea ::= CHOICE
void mbs_service_area_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.destroy<mbs_service_area_info_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_service_area_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.init<mbs_service_area_info_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c::mbs_service_area_c(const mbs_service_area_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c& mbs_service_area_c::operator=(const mbs_service_area_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }

  return *this;
}
mbs_service_area_info_s& mbs_service_area_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<mbs_service_area_info_s>();
}
mbs_service_area_info_list_l& mbs_service_area_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_service_area_info_list_l>();
}
protocol_ie_single_container_s<mbs_service_area_ext_ies_o>& mbs_service_area_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
}
void mbs_service_area_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<mbs_service_area_info_s>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_service_area_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_service_area_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_service_area_info_list_l>(), 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_service_area_info_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_service_area_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mbs_service_area_c::types");
}

// ExpectedUEMovingTrajectoryItem ::= SEQUENCE
SRSASN_CODE expected_ue_moving_trajectory_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(pack_integer(bref, time_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_moving_trajectory_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(unpack_integer(time_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_moving_trajectory_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (time_stayed_in_cell_present) {
    j.write_int("timeStayedInCell", time_stayed_in_cell);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SourceOfUEActivityBehaviourInformation ::= ENUMERATED
const char* source_of_ue_activity_behaviour_info_opts::to_string() const
{
  static const char* names[] = {"subscription-information", "statistics"};
  return convert_enum_idx(names, 2, value, "source_of_ue_activity_behaviour_info_e");
}

// ExpectedHOInterval ::= ENUMERATED
const char* expected_ho_interv_opts::to_string() const
{
  static const char* names[] = {"sec15", "sec30", "sec60", "sec90", "sec120", "sec180", "long-time"};
  return convert_enum_idx(names, 7, value, "expected_ho_interv_e");
}
uint8_t expected_ho_interv_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 60, 90, 120, 180};
  return map_enum_number(numbers, 6, value, "expected_ho_interv_e");
}

// ExpectedUEActivityBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_activity_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.pack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.pack(source_of_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_activity_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_idle_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (source_of_ue_activity_behaviour_info_present) {
    HANDLE_CODE(source_of_ue_activity_behaviour_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_activity_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.unpack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.unpack(source_of_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(unpack_integer(expected_activity_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(unpack_integer(expected_idle_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (source_of_ue_activity_behaviour_info_present) {
    HANDLE_CODE(source_of_ue_activity_behaviour_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_activity_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_activity_period_present) {
    j.write_int("expectedActivityPeriod", expected_activity_period);
  }
  if (expected_idle_period_present) {
    j.write_int("expectedIdlePeriod", expected_idle_period);
  }
  if (source_of_ue_activity_behaviour_info_present) {
    j.write_str("sourceOfUEActivityBehaviourInformation", source_of_ue_activity_behaviour_info.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExpectedUEMobility ::= ENUMERATED
const char* expected_ue_mob_opts::to_string() const
{
  static const char* names[] = {"stationary", "mobile"};
  return convert_enum_idx(names, 2, value, "expected_ue_mob_e");
}

// ExpectedUEBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_ue_activity_behaviour_present, 1));
  HANDLE_CODE(bref.pack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_mob_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_moving_trajectory.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_ue_activity_behaviour_present) {
    HANDLE_CODE(expected_ue_activity_behaviour.pack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.pack(bref));
  }
  if (expected_ue_mob_present) {
    HANDLE_CODE(expected_ue_mob.pack(bref));
  }
  if (expected_ue_moving_trajectory.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, expected_ue_moving_trajectory, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_ue_activity_behaviour_present, 1));
  HANDLE_CODE(bref.unpack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.unpack(expected_ue_mob_present, 1));
  bool expected_ue_moving_trajectory_present;
  HANDLE_CODE(bref.unpack(expected_ue_moving_trajectory_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_ue_activity_behaviour_present) {
    HANDLE_CODE(expected_ue_activity_behaviour.unpack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.unpack(bref));
  }
  if (expected_ue_mob_present) {
    HANDLE_CODE(expected_ue_mob.unpack(bref));
  }
  if (expected_ue_moving_trajectory_present) {
    HANDLE_CODE(unpack_dyn_seq_of(expected_ue_moving_trajectory, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_ue_activity_behaviour_present) {
    j.write_fieldname("expectedUEActivityBehaviour");
    expected_ue_activity_behaviour.to_json(j);
  }
  if (expected_ho_interv_present) {
    j.write_str("expectedHOInterval", expected_ho_interv.to_string());
  }
  if (expected_ue_mob_present) {
    j.write_str("expectedUEMobility", expected_ue_mob.to_string());
  }
  if (expected_ue_moving_trajectory.size() > 0) {
    j.start_array("expectedUEMovingTrajectory");
    for (const auto& e1 : expected_ue_moving_trajectory) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNAssistedRANTuning ::= SEQUENCE
SRSASN_CODE cn_assisted_ran_tuning_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cn_assisted_ran_tuning_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cn_assisted_ran_tuning_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_ue_behaviour_present) {
    j.write_fieldname("expectedUEBehaviour");
    expected_ue_behaviour.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNTypeRestrictionsForEquivalentItem ::= SEQUENCE
SRSASN_CODE cn_type_restricts_for_equivalent_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(cn_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cn_type_restricts_for_equivalent_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(cn_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cn_type_restricts_for_equivalent_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmnIdentity", plmn_id.to_string());
  j.write_str("cn-Type", cn_type.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* cn_type_restricts_for_equivalent_item_s::cn_type_opts::to_string() const
{
  static const char* names[] = {"epc-forbidden", "fiveGC-forbidden"};
  return convert_enum_idx(names, 2, value, "cn_type_restricts_for_equivalent_item_s::cn_type_e_");
}
uint8_t cn_type_restricts_for_equivalent_item_s::cn_type_opts::to_number() const
{
  if (value == five_gc_forbidden) {
    return 5;
  }
  invalid_enum_number(value, "cn_type_restricts_for_equivalent_item_s::cn_type_e_");
  return 0;
}

// COUNTValueForPDCP-SN12 ::= SEQUENCE
SRSASN_CODE count_value_for_pdcp_sn12_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn12, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn_pdcp_sn12, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE count_value_for_pdcp_sn12_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn12, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(unpack_integer(hfn_pdcp_sn12, bref, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void count_value_for_pdcp_sn12_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDCP-SN12", pdcp_sn12);
  j.write_int("hFN-PDCP-SN12", hfn_pdcp_sn12);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// COUNTValueForPDCP-SN18 ::= SEQUENCE
SRSASN_CODE count_value_for_pdcp_sn18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn18, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn_pdcp_sn18, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE count_value_for_pdcp_sn18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn18, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(unpack_integer(hfn_pdcp_sn18, bref, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void count_value_for_pdcp_sn18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDCP-SN18", pdcp_sn18);
  j.write_int("hFN-PDCP-SN18", hfn_pdcp_sn18);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CandidateCellID ::= SEQUENCE
SRSASN_CODE candidate_cell_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_cell_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void candidate_cell_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("candidateCellID");
  candidate_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CandidatePCI ::= SEQUENCE
SRSASN_CODE candidate_pci_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, candidate_pci, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(pack_integer(bref, candidate_nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_pci_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(candidate_pci, bref, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(unpack_integer(candidate_nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void candidate_pci_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("candidatePCI", candidate_pci);
  j.write_int("candidateNRARFCN", candidate_nr_arfcn);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CandidateCell ::= CHOICE
void candidate_cell_c::destroy_()
{
  switch (type_) {
    case types::candidate_cgi:
      c.destroy<candidate_cell_id_s>();
      break;
    case types::candidate_pci:
      c.destroy<candidate_pci_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void candidate_cell_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::candidate_cgi:
      c.init<candidate_cell_id_s>();
      break;
    case types::candidate_pci:
      c.init<candidate_pci_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }
}
candidate_cell_c::candidate_cell_c(const candidate_cell_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::candidate_cgi:
      c.init(other.c.get<candidate_cell_id_s>());
      break;
    case types::candidate_pci:
      c.init(other.c.get<candidate_pci_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }
}
candidate_cell_c& candidate_cell_c::operator=(const candidate_cell_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::candidate_cgi:
      c.set(other.c.get<candidate_cell_id_s>());
      break;
    case types::candidate_pci:
      c.set(other.c.get<candidate_pci_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }

  return *this;
}
candidate_cell_id_s& candidate_cell_c::set_candidate_cgi()
{
  set(types::candidate_cgi);
  return c.get<candidate_cell_id_s>();
}
candidate_pci_s& candidate_cell_c::set_candidate_pci()
{
  set(types::candidate_pci);
  return c.get<candidate_pci_s>();
}
protocol_ie_single_container_s<candidate_cell_ext_ies_o>& candidate_cell_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>();
}
void candidate_cell_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::candidate_cgi:
      j.write_fieldname("candidateCGI");
      c.get<candidate_cell_id_s>().to_json(j);
      break;
    case types::candidate_pci:
      j.write_fieldname("candidatePCI");
      c.get<candidate_pci_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }
  j.end_obj();
}
SRSASN_CODE candidate_cell_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::candidate_cgi:
      HANDLE_CODE(c.get<candidate_cell_id_s>().pack(bref));
      break;
    case types::candidate_pci:
      HANDLE_CODE(c.get<candidate_pci_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_cell_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::candidate_cgi:
      HANDLE_CODE(c.get<candidate_cell_id_s>().unpack(bref));
      break;
    case types::candidate_pci:
      HANDLE_CODE(c.get<candidate_pci_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* candidate_cell_c::types_opts::to_string() const
{
  static const char* names[] = {"candidateCGI", "candidatePCI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "candidate_cell_c::types");
}

// CandidateCellItem ::= SEQUENCE
SRSASN_CODE candidate_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void candidate_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("candidateCell");
  candidate_cell.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Cell-CAGInformation ::= SEQUENCE
SRSASN_CODE cell_cag_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cell_cag_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_cag_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cell_cag_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_cag_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  j.start_array("cellCAGList");
  for (const auto& e1 : cell_cag_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDListForRestart ::= CHOICE
void cell_id_list_for_restart_c::destroy_()
{
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.destroy<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_listfor_restart:
      c.destroy<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cell_id_list_for_restart_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.init<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_listfor_restart:
      c.init<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }
}
cell_id_list_for_restart_c::cell_id_list_for_restart_c(const cell_id_list_for_restart_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.init(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_listfor_restart:
      c.init(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }
}
cell_id_list_for_restart_c& cell_id_list_for_restart_c::operator=(const cell_id_list_for_restart_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.set(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_listfor_restart:
      c.set(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }

  return *this;
}
eutra_cgi_list_l& cell_id_list_for_restart_c::set_eutra_cgi_listfor_restart()
{
  set(types::eutra_cgi_listfor_restart);
  return c.get<eutra_cgi_list_l>();
}
nr_cgi_list_l& cell_id_list_for_restart_c::set_nr_cgi_listfor_restart()
{
  set(types::nr_cgi_listfor_restart);
  return c.get<nr_cgi_list_l>();
}
protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>& cell_id_list_for_restart_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>();
}
void cell_id_list_for_restart_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      j.start_array("eUTRA-CGIListforRestart");
      for (const auto& e1 : c.get<eutra_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nr_cgi_listfor_restart:
      j.start_array("nR-CGIListforRestart");
      for (const auto& e1 : c.get<nr_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_id_list_for_restart_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<eutra_cgi_list_l>(), 1, 256, true));
      break;
    case types::nr_cgi_listfor_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_cgi_list_l>(), 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_list_for_restart_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<eutra_cgi_list_l>(), bref, 1, 256, true));
      break;
    case types::nr_cgi_listfor_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_cgi_list_l>(), bref, 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_id_list_for_restart_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRA-CGIListforRestart", "nR-CGIListforRestart", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "cell_id_list_for_restart_c::types");
}

// PrivacyIndicator ::= ENUMERATED
const char* privacy_ind_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT", "logged-MDT"};
  return convert_enum_idx(names, 2, value, "privacy_ind_e");
}

// CellSize ::= ENUMERATED
const char* cell_size_opts::to_string() const
{
  static const char* names[] = {"verysmall", "small", "medium", "large"};
  return convert_enum_idx(names, 4, value, "cell_size_e");
}

// CellType ::= SEQUENCE
SRSASN_CODE cell_type_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_type_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cellSize", cell_size.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompositeAvailableCapacity ::= SEQUENCE
SRSASN_CODE composite_available_capacity_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(pack_integer(bref, cell_capacity_class_value, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(pack_integer(bref, capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(unpack_integer(cell_capacity_class_value, bref, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(unpack_integer(capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void composite_available_capacity_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cell_capacity_class_value_present) {
    j.write_int("cellCapacityClassValue", cell_capacity_class_value);
  }
  j.write_int("capacityValue", capacity_value);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ScheduledCommunicationTime ::= SEQUENCE
SRSASN_CODE sched_communication_time_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dayof_week_present, 1));
  HANDLE_CODE(bref.pack(timeof_day_start_present, 1));
  HANDLE_CODE(bref.pack(timeof_day_end_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dayof_week_present) {
    HANDLE_CODE(dayof_week.pack(bref));
  }
  if (timeof_day_start_present) {
    HANDLE_CODE(pack_integer(bref, timeof_day_start, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (timeof_day_end_present) {
    HANDLE_CODE(pack_integer(bref, timeof_day_end, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sched_communication_time_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dayof_week_present, 1));
  HANDLE_CODE(bref.unpack(timeof_day_start_present, 1));
  HANDLE_CODE(bref.unpack(timeof_day_end_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dayof_week_present) {
    HANDLE_CODE(dayof_week.unpack(bref));
  }
  if (timeof_day_start_present) {
    HANDLE_CODE(unpack_integer(timeof_day_start, bref, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (timeof_day_end_present) {
    HANDLE_CODE(unpack_integer(timeof_day_end, bref, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sched_communication_time_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dayof_week_present) {
    j.write_str("dayofWeek", dayof_week.to_string());
  }
  if (timeof_day_start_present) {
    j.write_int("timeofDayStart", timeof_day_start);
  }
  if (timeof_day_end_present) {
    j.write_int("timeofDayEnd", timeof_day_end);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CEmodeBrestricted ::= ENUMERATED
const char* ce_mode_brestricted_opts::to_string() const
{
  static const char* names[] = {"restricted", "not-restricted"};
  return convert_enum_idx(names, 2, value, "ce_mode_brestricted_e");
}

// DL-CP-SecurityInformation ::= SEQUENCE
SRSASN_CODE dl_cp_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_nas_mac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_cp_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_nas_mac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_cp_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dl-NAS-MAC", dl_nas_mac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EndIndication ::= ENUMERATED
const char* end_ind_opts::to_string() const
{
  static const char* names[] = {"no-further-data", "further-data-exists"};
  return convert_enum_idx(names, 2, value, "end_ind_e");
}

// Enhanced-CoverageRestriction ::= ENUMERATED
const char* enhanced_coverage_restrict_opts::to_string() const
{
  static const char* names[] = {"restricted"};
  return convert_enum_idx(names, 1, value, "enhanced_coverage_restrict_e");
}

// UE-DifferentiationInfo ::= SEQUENCE
SRSASN_CODE ue_diff_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(periodic_communication_ind_present, 1));
  HANDLE_CODE(bref.pack(periodic_time_present, 1));
  HANDLE_CODE(bref.pack(sched_communication_time_present, 1));
  HANDLE_CODE(bref.pack(stationary_ind_present, 1));
  HANDLE_CODE(bref.pack(traffic_profile_present, 1));
  HANDLE_CODE(bref.pack(battery_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (periodic_communication_ind_present) {
    HANDLE_CODE(periodic_communication_ind.pack(bref));
  }
  if (periodic_time_present) {
    HANDLE_CODE(pack_integer(bref, periodic_time, (uint16_t)1u, (uint16_t)3600u, true, true));
  }
  if (sched_communication_time_present) {
    HANDLE_CODE(sched_communication_time.pack(bref));
  }
  if (stationary_ind_present) {
    HANDLE_CODE(stationary_ind.pack(bref));
  }
  if (traffic_profile_present) {
    HANDLE_CODE(traffic_profile.pack(bref));
  }
  if (battery_ind_present) {
    HANDLE_CODE(battery_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_diff_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(periodic_communication_ind_present, 1));
  HANDLE_CODE(bref.unpack(periodic_time_present, 1));
  HANDLE_CODE(bref.unpack(sched_communication_time_present, 1));
  HANDLE_CODE(bref.unpack(stationary_ind_present, 1));
  HANDLE_CODE(bref.unpack(traffic_profile_present, 1));
  HANDLE_CODE(bref.unpack(battery_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (periodic_communication_ind_present) {
    HANDLE_CODE(periodic_communication_ind.unpack(bref));
  }
  if (periodic_time_present) {
    HANDLE_CODE(unpack_integer(periodic_time, bref, (uint16_t)1u, (uint16_t)3600u, true, true));
  }
  if (sched_communication_time_present) {
    HANDLE_CODE(sched_communication_time.unpack(bref));
  }
  if (stationary_ind_present) {
    HANDLE_CODE(stationary_ind.unpack(bref));
  }
  if (traffic_profile_present) {
    HANDLE_CODE(traffic_profile.unpack(bref));
  }
  if (battery_ind_present) {
    HANDLE_CODE(battery_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_diff_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (periodic_communication_ind_present) {
    j.write_str("periodicCommunicationIndicator", periodic_communication_ind.to_string());
  }
  if (periodic_time_present) {
    j.write_int("periodicTime", periodic_time);
  }
  if (sched_communication_time_present) {
    j.write_fieldname("scheduledCommunicationTime");
    sched_communication_time.to_json(j);
  }
  if (stationary_ind_present) {
    j.write_str("stationaryIndication", stationary_ind.to_string());
  }
  if (traffic_profile_present) {
    j.write_str("trafficProfile", traffic_profile.to_string());
  }
  if (battery_ind_present) {
    j.write_str("batteryIndication", battery_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ue_diff_info_s::periodic_communication_ind_opts::to_string() const
{
  static const char* names[] = {"periodically", "ondemand"};
  return convert_enum_idx(names, 2, value, "ue_diff_info_s::periodic_communication_ind_e_");
}

const char* ue_diff_info_s::stationary_ind_opts::to_string() const
{
  static const char* names[] = {"stationary", "mobile"};
  return convert_enum_idx(names, 2, value, "ue_diff_info_s::stationary_ind_e_");
}

const char* ue_diff_info_s::traffic_profile_opts::to_string() const
{
  static const char* names[] = {"single-packet", "dual-packets", "multiple-packets"};
  return convert_enum_idx(names, 3, value, "ue_diff_info_s::traffic_profile_e_");
}

const char* ue_diff_info_s::battery_ind_opts::to_string() const
{
  static const char* names[] = {
      "battery-powered", "battery-powered-not-rechargeable-or-replaceable", "not-battery-powered"};
  return convert_enum_idx(names, 3, value, "ue_diff_info_s::battery_ind_e_");
}

// EUTRA-Paging-Time-Window ::= ENUMERATED
const char* eutra_paging_time_win_opts::to_string() const
{
  static const char* names[] = {
      "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"};
  return convert_enum_idx(names, 16, value, "eutra_paging_time_win_e");
}
uint8_t eutra_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
  return map_enum_number(numbers, 16, value, "eutra_paging_time_win_e");
}

// EUTRA-Paging-eDRX-Cycle ::= ENUMERATED
const char* eutra_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hfhalf", "hf1", "hf2", "hf4", "hf6", "hf8", "hf10", "hf12", "hf14", "hf16", "hf32", "hf64", "hf128", "hf256"};
  return convert_enum_idx(names, 14, value, "eutra_paging_e_drx_cycle_e");
}
float eutra_paging_e_drx_cycle_opts::to_number() const
{
  static const float numbers[] = {0.5, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 32.0, 64.0, 128.0, 256.0};
  return map_enum_number(numbers, 14, value, "eutra_paging_e_drx_cycle_e");
}
const char* eutra_paging_e_drx_cycle_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.5", "1", "2", "4", "6", "8", "10", "12", "14", "16", "32", "64", "128", "256"};
  return convert_enum_idx(number_strs, 14, value, "eutra_paging_e_drx_cycle_e");
}

// NR-Paging-Time-Window ::= ENUMERATED
const char* nr_paging_time_win_opts::to_string() const
{
  static const char* names[] = {"s1",  "s2",  "s3",  "s4",  "s5",  "s6",  "s7",  "s8",  "s9",  "s10", "s11",
                                "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21", "s22",
                                "s23", "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31", "s32"};
  return convert_enum_idx(names, 32, value, "nr_paging_time_win_e");
}
uint8_t nr_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,
                                    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32};
  return map_enum_number(numbers, 32, value, "nr_paging_time_win_e");
}

// NR-Paging-eDRX-Cycle ::= ENUMERATED
const char* nr_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hfquarter", "hfhalf", "hf1", "hf2", "hf4", "hf8", "hf16", "hf32", "hf64", "hf128", "hf256", "hf512", "hf1024"};
  return convert_enum_idx(names, 13, value, "nr_paging_e_drx_cycle_e");
}
float nr_paging_e_drx_cycle_opts::to_number() const
{
  static const float numbers[] = {0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0};
  return map_enum_number(numbers, 13, value, "nr_paging_e_drx_cycle_e");
}
const char* nr_paging_e_drx_cycle_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25", "0.5", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024"};
  return convert_enum_idx(number_strs, 13, value, "nr_paging_e_drx_cycle_e");
}

// UERadioCapabilityForPaging-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ue_radio_cap_for_paging_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {214};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_radio_cap_for_paging_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 214 == id;
}
crit_e ue_radio_cap_for_paging_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 214) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_radio_cap_for_paging_ext_ies_o::ext_c ue_radio_cap_for_paging_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 214) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_for_paging_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 214) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void ue_radio_cap_for_paging_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_for_paging_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_for_paging_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_for_paging_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "ue_radio_cap_for_paging_ext_ies_o::ext_c::types");
}

// EUTRA-PagingeDRXInformation ::= SEQUENCE
SRSASN_CODE eutra_paginge_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(eutra_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_paging_e_drx_cycle.pack(bref));
  if (eutra_paging_time_win_present) {
    HANDLE_CODE(eutra_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_paginge_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(eutra_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_paging_e_drx_cycle.unpack(bref));
  if (eutra_paging_time_win_present) {
    HANDLE_CODE(eutra_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_paginge_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eUTRA-paging-eDRX-Cycle", eutra_paging_e_drx_cycle.to_string());
  if (eutra_paging_time_win_present) {
    j.write_str("eUTRA-paging-Time-Window", eutra_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MicoAllPLMN ::= ENUMERATED
const char* mico_all_plmn_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "mico_all_plmn_e");
}

// NR-PagingeDRXInformation ::= SEQUENCE
SRSASN_CODE nr_paginge_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nr_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle.pack(bref));
  if (nr_paging_time_win_present) {
    HANDLE_CODE(nr_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_paginge_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nr_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle.unpack(bref));
  if (nr_paging_time_win_present) {
    HANDLE_CODE(nr_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_paginge_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nR-paging-eDRX-Cycle", nr_paging_e_drx_cycle.to_string());
  if (nr_paging_time_win_present) {
    j.write_str("nR-paging-Time-Window", nr_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PEIPSassistanceInformation ::= SEQUENCE
SRSASN_CODE pe_ip_sassist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, cnsubgroup_id, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pe_ip_sassist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(cnsubgroup_id, bref, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pe_ip_sassist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("cNsubgroupID", cnsubgroup_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingCauseIndicationForVoiceService ::= ENUMERATED
const char* paging_cause_ind_for_voice_service_opts::to_string() const
{
  static const char* names[] = {"supported"};
  return convert_enum_idx(names, 1, value, "paging_cause_ind_for_voice_service_e");
}

// TAIListForInactiveItem ::= SEQUENCE
SRSASN_CODE tai_list_for_inactive_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_list_for_inactive_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_list_for_inactive_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UERadioCapabilityForPaging ::= SEQUENCE
SRSASN_CODE ue_radio_cap_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_radio_cap_for_paging_of_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(ue_radio_cap_for_paging_of_eutra.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ue_radio_cap_for_paging_of_nr.size() > 0) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_nr.pack(bref));
  }
  if (ue_radio_cap_for_paging_of_eutra.size() > 0) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_eutra.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ue_radio_cap_for_paging_of_nr_present;
  HANDLE_CODE(bref.unpack(ue_radio_cap_for_paging_of_nr_present, 1));
  bool ue_radio_cap_for_paging_of_eutra_present;
  HANDLE_CODE(bref.unpack(ue_radio_cap_for_paging_of_eutra_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ue_radio_cap_for_paging_of_nr_present) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_nr.unpack(bref));
  }
  if (ue_radio_cap_for_paging_of_eutra_present) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_eutra.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void ue_radio_cap_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_radio_cap_for_paging_of_nr.size() > 0) {
    j.write_str("uERadioCapabilityForPagingOfNR", ue_radio_cap_for_paging_of_nr.to_string());
  }
  if (ue_radio_cap_for_paging_of_eutra.size() > 0) {
    j.write_str("uERadioCapabilityForPagingOfEUTRA", ue_radio_cap_for_paging_of_eutra.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// CoreNetworkAssistanceInformationForInactive-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t core_network_assist_info_for_inactive_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {223, 280, 118, 282, 332, 343, 344};
  return map_enum_number(names, 7, idx, "id");
}
bool core_network_assist_info_for_inactive_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {223, 280, 118, 282, 332, 343, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e core_network_assist_info_for_inactive_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 223:
      return crit_e::ignore;
    case 280:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 282:
      return crit_e::ignore;
    case 332:
      return crit_e::ignore;
    case 343:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
core_network_assist_info_for_inactive_ext_ies_o::ext_c
core_network_assist_info_for_inactive_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 223:
      ret.set(ext_c::types::eutra_paginge_drx_info);
      break;
    case 280:
      ret.set(ext_c::types::extended_ue_id_idx_value);
      break;
    case 118:
      ret.set(ext_c::types::ue_radio_cap_for_paging);
      break;
    case 282:
      ret.set(ext_c::types::mico_all_plmn);
      break;
    case 332:
      ret.set(ext_c::types::nr_paginge_drx_info);
      break;
    case 343:
      ret.set(ext_c::types::paging_cause_ind_for_voice_service);
      break;
    case 344:
      ret.set(ext_c::types::pe_ip_sassist_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e core_network_assist_info_for_inactive_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 223:
      return presence_e::optional;
    case 280:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 282:
      return presence_e::optional;
    case 332:
      return presence_e::optional;
    case 343:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void core_network_assist_info_for_inactive_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::eutra_paginge_drx_info:
      c = eutra_paginge_drx_info_s{};
      break;
    case types::extended_ue_id_idx_value:
      c = fixed_bitstring<16, false, true>{};
      break;
    case types::ue_radio_cap_for_paging:
      c = ue_radio_cap_for_paging_s{};
      break;
    case types::mico_all_plmn:
      c = mico_all_plmn_e{};
      break;
    case types::nr_paginge_drx_info:
      c = nr_paginge_drx_info_s{};
      break;
    case types::paging_cause_ind_for_voice_service:
      c = paging_cause_ind_for_voice_service_e{};
      break;
    case types::pe_ip_sassist_info:
      c = pe_ip_sassist_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
  }
}
eutra_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::eutra_paginge_drx_info()
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Extension");
  return c.get<eutra_paginge_drx_info_s>();
}
fixed_bitstring<16, false, true>& core_network_assist_info_for_inactive_ext_ies_o::ext_c::extended_ue_id_idx_value()
{
  assert_choice_type(types::extended_ue_id_idx_value, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
ue_radio_cap_for_paging_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Extension");
  return c.get<ue_radio_cap_for_paging_s>();
}
mico_all_plmn_e& core_network_assist_info_for_inactive_ext_ies_o::ext_c::mico_all_plmn()
{
  assert_choice_type(types::mico_all_plmn, type_, "Extension");
  return c.get<mico_all_plmn_e>();
}
nr_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::nr_paginge_drx_info()
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Extension");
  return c.get<nr_paginge_drx_info_s>();
}
paging_cause_ind_for_voice_service_e&
core_network_assist_info_for_inactive_ext_ies_o::ext_c::paging_cause_ind_for_voice_service()
{
  assert_choice_type(types::paging_cause_ind_for_voice_service, type_, "Extension");
  return c.get<paging_cause_ind_for_voice_service_e>();
}
pe_ip_sassist_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::pe_ip_sassist_info()
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Extension");
  return c.get<pe_ip_sassist_info_s>();
}
const eutra_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::eutra_paginge_drx_info() const
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Extension");
  return c.get<eutra_paginge_drx_info_s>();
}
const fixed_bitstring<16, false, true>&
core_network_assist_info_for_inactive_ext_ies_o::ext_c::extended_ue_id_idx_value() const
{
  assert_choice_type(types::extended_ue_id_idx_value, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
const ue_radio_cap_for_paging_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Extension");
  return c.get<ue_radio_cap_for_paging_s>();
}
const mico_all_plmn_e& core_network_assist_info_for_inactive_ext_ies_o::ext_c::mico_all_plmn() const
{
  assert_choice_type(types::mico_all_plmn, type_, "Extension");
  return c.get<mico_all_plmn_e>();
}
const nr_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::nr_paginge_drx_info() const
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Extension");
  return c.get<nr_paginge_drx_info_s>();
}
const paging_cause_ind_for_voice_service_e&
core_network_assist_info_for_inactive_ext_ies_o::ext_c::paging_cause_ind_for_voice_service() const
{
  assert_choice_type(types::paging_cause_ind_for_voice_service, type_, "Extension");
  return c.get<paging_cause_ind_for_voice_service_e>();
}
const pe_ip_sassist_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::pe_ip_sassist_info() const
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Extension");
  return c.get<pe_ip_sassist_info_s>();
}
void core_network_assist_info_for_inactive_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_paginge_drx_info:
      j.write_fieldname("EUTRA-PagingeDRXInformation");
      c.get<eutra_paginge_drx_info_s>().to_json(j);
      break;
    case types::extended_ue_id_idx_value:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::mico_all_plmn:
      j.write_str("MicoAllPLMN", "true");
      break;
    case types::nr_paginge_drx_info:
      j.write_fieldname("NR-PagingeDRXInformation");
      c.get<nr_paginge_drx_info_s>().to_json(j);
      break;
    case types::paging_cause_ind_for_voice_service:
      j.write_str("PagingCauseIndicationForVoiceService", "supported");
      break;
    case types::pe_ip_sassist_info:
      j.write_fieldname("PEIPSassistanceInformation");
      c.get<pe_ip_sassist_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().pack(bref));
      break;
    case types::extended_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::mico_all_plmn:
      HANDLE_CODE(c.get<mico_all_plmn_e>().pack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().pack(bref));
      break;
    case types::paging_cause_ind_for_voice_service:
      HANDLE_CODE(c.get<paging_cause_ind_for_voice_service_e>().pack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().unpack(bref));
      break;
    case types::extended_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::mico_all_plmn:
      HANDLE_CODE(c.get<mico_all_plmn_e>().unpack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().unpack(bref));
      break;
    case types::paging_cause_ind_for_voice_service:
      HANDLE_CODE(c.get<paging_cause_ind_for_voice_service_e>().unpack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* core_network_assist_info_for_inactive_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"EUTRA-PagingeDRXInformation",
                                "BIT STRING",
                                "UERadioCapabilityForPaging",
                                "MicoAllPLMN",
                                "NR-PagingeDRXInformation",
                                "PagingCauseIndicationForVoiceService",
                                "PEIPSassistanceInformation"};
  return convert_enum_idx(names, 7, value, "core_network_assist_info_for_inactive_ext_ies_o::ext_c::types");
}

// MICOModeIndication ::= ENUMERATED
const char* mico_mode_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "mico_mode_ind_e");
}

// PagingDRX ::= ENUMERATED
const char* paging_drx_opts::to_string() const
{
  static const char* names[] = {"v32", "v64", "v128", "v256"};
  return convert_enum_idx(names, 4, value, "paging_drx_e");
}
uint16_t paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {32, 64, 128, 256};
  return map_enum_number(numbers, 4, value, "paging_drx_e");
}

// UEIdentityIndexValue ::= CHOICE
void ue_id_idx_value_c::destroy_()
{
  switch (type_) {
    case types::idx_len10:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_id_idx_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::idx_len10:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c::ue_id_idx_value_c(const ue_id_idx_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::idx_len10:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c& ue_id_idx_value_c::operator=(const ue_id_idx_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::idx_len10:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }

  return *this;
}
fixed_bitstring<10, false, true>& ue_id_idx_value_c::set_idx_len10()
{
  set(types::idx_len10);
  return c.get<fixed_bitstring<10, false, true>>();
}
protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>& ue_id_idx_value_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
}
void ue_id_idx_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::idx_len10:
      j.write_str("indexLength10", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_id_idx_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_id_idx_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_id_idx_value_c::types_opts::to_string() const
{
  static const char* names[] = {"indexLength10", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "ue_id_idx_value_c::types");
}
uint8_t ue_id_idx_value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {10};
  return map_enum_number(numbers, 1, value, "ue_id_idx_value_c::types");
}

template struct asn1::protocol_ext_field_s<core_network_assist_info_for_inactive_ext_ies_o>;

SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += eutra_paginge_drx_info_present ? 1 : 0;
  nof_ies += extended_ue_id_idx_value_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += mico_all_plmn_present ? 1 : 0;
  nof_ies += nr_paginge_drx_info_present ? 1 : 0;
  nof_ies += paging_cause_ind_for_voice_service_present ? 1 : 0;
  nof_ies += pe_ip_sassist_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (eutra_paginge_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)223, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(eutra_paginge_drx_info.pack(bref));
  }
  if (extended_ue_id_idx_value_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)280, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_ue_id_idx_value.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (mico_all_plmn_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)282, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mico_all_plmn.pack(bref));
  }
  if (nr_paginge_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)332, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_paginge_drx_info.pack(bref));
  }
  if (paging_cause_ind_for_voice_service_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)343, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_cause_ind_for_voice_service.pack(bref));
  }
  if (pe_ip_sassist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)344, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pe_ip_sassist_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 223: {
        eutra_paginge_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_paginge_drx_info.unpack(bref));
        break;
      }
      case 280: {
        extended_ue_id_idx_value_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ue_id_idx_value.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.unpack(bref));
        break;
      }
      case 282: {
        mico_all_plmn_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mico_all_plmn.unpack(bref));
        break;
      }
      case 332: {
        nr_paginge_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_paginge_drx_info.unpack(bref));
        break;
      }
      case 343: {
        paging_cause_ind_for_voice_service_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_cause_ind_for_voice_service.unpack(bref));
        break;
      }
      case 344: {
        pe_ip_sassist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pe_ip_sassist_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void core_network_assist_info_for_inactive_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (eutra_paginge_drx_info_present) {
    j.write_int("id", 223);
    j.write_str("criticality", "ignore");
    eutra_paginge_drx_info.to_json(j);
  }
  if (extended_ue_id_idx_value_present) {
    j.write_int("id", 280);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", extended_ue_id_idx_value.to_string());
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "ignore");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (mico_all_plmn_present) {
    j.write_int("id", 282);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (nr_paginge_drx_info_present) {
    j.write_int("id", 332);
    j.write_str("criticality", "ignore");
    nr_paginge_drx_info.to_json(j);
  }
  if (paging_cause_ind_for_voice_service_present) {
    j.write_int("id", 343);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "supported");
  }
  if (pe_ip_sassist_info_present) {
    j.write_int("id", 344);
    j.write_str("criticality", "ignore");
    pe_ip_sassist_info.to_json(j);
  }
  j.end_obj();
}

// CoreNetworkAssistanceInformationForInactive ::= SEQUENCE
SRSASN_CODE core_network_assist_info_for_inactive_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_specific_drx_present, 1));
  HANDLE_CODE(bref.pack(mico_mode_ind_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.pack(bref));
  if (ue_specific_drx_present) {
    HANDLE_CODE(ue_specific_drx.pack(bref));
  }
  HANDLE_CODE(periodic_regist_upd_timer.pack(bref));
  if (mico_mode_ind_present) {
    HANDLE_CODE(mico_mode_ind.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, tai_list_for_inactive, 1, 16, true));
  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE core_network_assist_info_for_inactive_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_specific_drx_present, 1));
  HANDLE_CODE(bref.unpack(mico_mode_ind_present, 1));
  HANDLE_CODE(bref.unpack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.unpack(bref));
  if (ue_specific_drx_present) {
    HANDLE_CODE(ue_specific_drx.unpack(bref));
  }
  HANDLE_CODE(periodic_regist_upd_timer.unpack(bref));
  if (mico_mode_ind_present) {
    HANDLE_CODE(mico_mode_ind.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(tai_list_for_inactive, bref, 1, 16, true));
  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void core_network_assist_info_for_inactive_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEIdentityIndexValue");
  ue_id_idx_value.to_json(j);
  if (ue_specific_drx_present) {
    j.write_str("uESpecificDRX", ue_specific_drx.to_string());
  }
  j.write_str("periodicRegistrationUpdateTimer", periodic_regist_upd_timer.to_string());
  if (mico_mode_ind_present) {
    j.write_str("mICOModeIndication", "true");
  }
  j.start_array("tAIListForInactive");
  for (const auto& e1 : tai_list_for_inactive) {
    e1.to_json(j);
  }
  j.end_array();
  if (expected_ue_behaviour_present) {
    j.write_fieldname("expectedUEBehaviour");
    expected_ue_behaviour.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DAPSRequestInfo ::= SEQUENCE
SRSASN_CODE daps_request_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(da_psi_ndicator.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_request_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(da_psi_ndicator.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_request_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dAPSIndicator", "daps-ho-required");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* daps_request_info_s::da_psi_ndicator_opts::to_string() const
{
  static const char* names[] = {"daps-ho-required"};
  return convert_enum_idx(names, 1, value, "daps_request_info_s::da_psi_ndicator_e_");
}

// DAPSResponseInfo ::= SEQUENCE
SRSASN_CODE daps_resp_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dapsrespind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_resp_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dapsrespind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_resp_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dapsresponseindicator", dapsrespind.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* daps_resp_info_s::dapsrespind_opts::to_string() const
{
  static const char* names[] = {"daps-ho-accepted", "daps-ho-not-accepted"};
  return convert_enum_idx(names, 2, value, "daps_resp_info_s::dapsrespind_e_");
}

// DAPSResponseInfoItem ::= SEQUENCE
SRSASN_CODE daps_resp_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(daps_resp_info.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_resp_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(daps_resp_info.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_resp_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.write_fieldname("dAPSResponseInfo");
  daps_resp_info.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusDL12 ::= SEQUENCE
SRSASN_CODE drb_status_dl12_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_dl12_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_dl12_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-COUNTValue");
  dl_count_value.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusDL18 ::= SEQUENCE
SRSASN_CODE drb_status_dl18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_dl18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_dl18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-COUNTValue");
  dl_count_value.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusDL ::= CHOICE
void drb_status_dl_c::destroy_()
{
  switch (type_) {
    case types::drb_status_dl12:
      c.destroy<drb_status_dl12_s>();
      break;
    case types::drb_status_dl18:
      c.destroy<drb_status_dl18_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void drb_status_dl_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::drb_status_dl12:
      c.init<drb_status_dl12_s>();
      break;
    case types::drb_status_dl18:
      c.init<drb_status_dl18_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }
}
drb_status_dl_c::drb_status_dl_c(const drb_status_dl_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::drb_status_dl12:
      c.init(other.c.get<drb_status_dl12_s>());
      break;
    case types::drb_status_dl18:
      c.init(other.c.get<drb_status_dl18_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }
}
drb_status_dl_c& drb_status_dl_c::operator=(const drb_status_dl_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::drb_status_dl12:
      c.set(other.c.get<drb_status_dl12_s>());
      break;
    case types::drb_status_dl18:
      c.set(other.c.get<drb_status_dl18_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }

  return *this;
}
drb_status_dl12_s& drb_status_dl_c::set_drb_status_dl12()
{
  set(types::drb_status_dl12);
  return c.get<drb_status_dl12_s>();
}
drb_status_dl18_s& drb_status_dl_c::set_drb_status_dl18()
{
  set(types::drb_status_dl18);
  return c.get<drb_status_dl18_s>();
}
protocol_ie_single_container_s<drb_status_dl_ext_ies_o>& drb_status_dl_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>();
}
void drb_status_dl_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::drb_status_dl12:
      j.write_fieldname("dRBStatusDL12");
      c.get<drb_status_dl12_s>().to_json(j);
      break;
    case types::drb_status_dl18:
      j.write_fieldname("dRBStatusDL18");
      c.get<drb_status_dl18_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }
  j.end_obj();
}
SRSASN_CODE drb_status_dl_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::drb_status_dl12:
      HANDLE_CODE(c.get<drb_status_dl12_s>().pack(bref));
      break;
    case types::drb_status_dl18:
      HANDLE_CODE(c.get<drb_status_dl18_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_dl_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::drb_status_dl12:
      HANDLE_CODE(c.get<drb_status_dl12_s>().unpack(bref));
      break;
    case types::drb_status_dl18:
      HANDLE_CODE(c.get<drb_status_dl18_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drb_status_dl_c::types_opts::to_string() const
{
  static const char* names[] = {"dRBStatusDL12", "dRBStatusDL18", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "drb_status_dl_c::types");
}
uint8_t drb_status_dl_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "drb_status_dl_c::types");
}

// DRBStatusUL12 ::= SEQUENCE
SRSASN_CODE drb_status_ul12_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.pack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_ul12_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.unpack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_ul12_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-COUNTValue");
  ul_count_value.to_json(j);
  if (receive_status_of_ul_pdcp_sdus_present) {
    j.write_str("receiveStatusOfUL-PDCP-SDUs", receive_status_of_ul_pdcp_sdus.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusUL18 ::= SEQUENCE
SRSASN_CODE drb_status_ul18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.pack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_ul18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.unpack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_ul18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-COUNTValue");
  ul_count_value.to_json(j);
  if (receive_status_of_ul_pdcp_sdus_present) {
    j.write_str("receiveStatusOfUL-PDCP-SDUs", receive_status_of_ul_pdcp_sdus.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusUL ::= CHOICE
void drb_status_ul_c::destroy_()
{
  switch (type_) {
    case types::drb_status_ul12:
      c.destroy<drb_status_ul12_s>();
      break;
    case types::drb_status_ul18:
      c.destroy<drb_status_ul18_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void drb_status_ul_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::drb_status_ul12:
      c.init<drb_status_ul12_s>();
      break;
    case types::drb_status_ul18:
      c.init<drb_status_ul18_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }
}
drb_status_ul_c::drb_status_ul_c(const drb_status_ul_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::drb_status_ul12:
      c.init(other.c.get<drb_status_ul12_s>());
      break;
    case types::drb_status_ul18:
      c.init(other.c.get<drb_status_ul18_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }
}
drb_status_ul_c& drb_status_ul_c::operator=(const drb_status_ul_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::drb_status_ul12:
      c.set(other.c.get<drb_status_ul12_s>());
      break;
    case types::drb_status_ul18:
      c.set(other.c.get<drb_status_ul18_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }

  return *this;
}
drb_status_ul12_s& drb_status_ul_c::set_drb_status_ul12()
{
  set(types::drb_status_ul12);
  return c.get<drb_status_ul12_s>();
}
drb_status_ul18_s& drb_status_ul_c::set_drb_status_ul18()
{
  set(types::drb_status_ul18);
  return c.get<drb_status_ul18_s>();
}
protocol_ie_single_container_s<drb_status_ul_ext_ies_o>& drb_status_ul_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>();
}
void drb_status_ul_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::drb_status_ul12:
      j.write_fieldname("dRBStatusUL12");
      c.get<drb_status_ul12_s>().to_json(j);
      break;
    case types::drb_status_ul18:
      j.write_fieldname("dRBStatusUL18");
      c.get<drb_status_ul18_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }
  j.end_obj();
}
SRSASN_CODE drb_status_ul_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::drb_status_ul12:
      HANDLE_CODE(c.get<drb_status_ul12_s>().pack(bref));
      break;
    case types::drb_status_ul18:
      HANDLE_CODE(c.get<drb_status_ul18_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_ul_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::drb_status_ul12:
      HANDLE_CODE(c.get<drb_status_ul12_s>().unpack(bref));
      break;
    case types::drb_status_ul18:
      HANDLE_CODE(c.get<drb_status_ul18_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drb_status_ul_c::types_opts::to_string() const
{
  static const char* names[] = {"dRBStatusUL12", "dRBStatusUL18", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "drb_status_ul_c::types");
}
uint8_t drb_status_ul_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "drb_status_ul_c::types");
}

// DRBsSubjectToEarlyStatusTransfer-Item ::= SEQUENCE
SRSASN_CODE drbs_subject_to_early_status_transfer_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(first_dl_count.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_early_status_transfer_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(first_dl_count.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_subject_to_early_status_transfer_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.write_fieldname("firstDLCOUNT");
  first_dl_count.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBsSubjectToStatusTransferItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t drbs_subject_to_status_transfer_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {159};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_subject_to_status_transfer_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 159 == id;
}
crit_e drbs_subject_to_status_transfer_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 159) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_subject_to_status_transfer_item_ext_ies_o::ext_c
drbs_subject_to_status_transfer_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 159) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_subject_to_status_transfer_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 159) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("AssociatedQosFlowList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 64, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 64, true));
  return SRSASN_SUCCESS;
}

const char* drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AssociatedQosFlowList"};
  return convert_enum_idx(names, 1, value, "drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::types");
}

// DRBsSubjectToStatusTransferItem ::= SEQUENCE
SRSASN_CODE drbs_subject_to_status_transfer_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(drb_status_ul.pack(bref));
  HANDLE_CODE(drb_status_dl.pack(bref));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_status_transfer_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(drb_status_ul.unpack(bref));
  HANDLE_CODE(drb_status_dl.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_subject_to_status_transfer_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.write_fieldname("dRBStatusUL");
  drb_status_ul.to_json(j);
  j.write_fieldname("dRBStatusDL");
  drb_status_dl.to_json(j);
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// DRBsToQosFlowsMappingItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t drbs_to_qos_flows_map_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {266};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_to_qos_flows_map_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 266 == id;
}
crit_e drbs_to_qos_flows_map_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 266) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_to_qos_flows_map_item_ext_ies_o::ext_c drbs_to_qos_flows_map_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 266) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_qos_flows_map_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 266) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_qos_flows_map_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("DAPSRequestInfo");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE drbs_to_qos_flows_map_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_qos_flows_map_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* drbs_to_qos_flows_map_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DAPSRequestInfo"};
  return convert_enum_idx(names, 1, value, "drbs_to_qos_flows_map_item_ext_ies_o::ext_c::types");
}

// DRBsToQosFlowsMappingItem ::= SEQUENCE
SRSASN_CODE drbs_to_qos_flows_map_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, associated_qos_flow_list, 1, 64, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_qos_flows_map_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(associated_qos_flow_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_qos_flows_map_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.start_array("associatedQosFlowList");
  for (const auto& e1 : associated_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// DataForwardingResponseDRBItem ::= SEQUENCE
SRSASN_CODE data_forwarding_resp_drb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ul_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(ul_forwarding_up_tnl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_resp_drb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(ul_forwarding_up_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_resp_drb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  if (dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("dLForwardingUP-TNLInformation");
    dl_forwarding_up_tnl_info.to_json(j);
  }
  if (ul_forwarding_up_tnl_info_present) {
    j.write_fieldname("uLForwardingUP-TNLInformation");
    ul_forwarding_up_tnl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DataForwardingResponseERABListItem ::= SEQUENCE
SRSASN_CODE data_forwarding_resp_erab_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_resp_erab_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_resp_erab_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("dLForwardingUP-TNLInformation");
  dl_forwarding_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExtendedRATRestrictionInformation ::= SEQUENCE
SRSASN_CODE extended_rat_restrict_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(primary_rat_restrict.pack(bref));
  HANDLE_CODE(secondary_rat_restrict.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_rat_restrict_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(primary_rat_restrict.unpack(bref));
  HANDLE_CODE(secondary_rat_restrict.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_rat_restrict_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("primaryRATRestriction", primary_rat_restrict.to_string());
  j.write_str("secondaryRATRestriction", secondary_rat_restrict.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PNI-NPN-MobilityInformation ::= SEQUENCE
SRSASN_CODE pni_npn_mob_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, allowed_pni_npi_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pni_npn_mob_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(allowed_pni_npi_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pni_npn_mob_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("allowed-PNI-NPI-List");
  for (const auto& e1 : allowed_pni_npi_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RATRestrictions-Item-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t rat_restricts_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {180};
  return map_enum_number(names, 1, idx, "id");
}
bool rat_restricts_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 180 == id;
}
crit_e rat_restricts_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 180) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
rat_restricts_item_ext_ies_o::ext_c rat_restricts_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 180) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rat_restricts_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 180) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void rat_restricts_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExtendedRATRestrictionInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE rat_restricts_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE rat_restricts_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* rat_restricts_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExtendedRATRestrictionInformation"};
  return convert_enum_idx(names, 1, value, "rat_restricts_item_ext_ies_o::ext_c::types");
}

// SNPN-MobilityInformation ::= SEQUENCE
SRSASN_CODE sn_pn_mob_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_n_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sn_pn_mob_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_n_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sn_pn_mob_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("serving-NID", serving_n_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNTypeRestrictionsForServing ::= ENUMERATED
const char* cn_type_restricts_for_serving_opts::to_string() const
{
  static const char* names[] = {"epc-forbidden"};
  return convert_enum_idx(names, 1, value, "cn_type_restricts_for_serving_e");
}

// ForbiddenAreaInformation-Item ::= SEQUENCE
SRSASN_CODE forbidden_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_tacs, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE forbidden_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(forbidden_tacs, bref, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void forbidden_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("forbiddenTACs");
  for (const auto& e1 : forbidden_tacs) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-MobilityInformation ::= CHOICE
void npn_mob_info_c::destroy_()
{
  switch (type_) {
    case types::sn_pn_mob_info:
      c.destroy<sn_pn_mob_info_s>();
      break;
    case types::pni_npn_mob_info:
      c.destroy<pni_npn_mob_info_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_mob_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sn_pn_mob_info:
      c.init<sn_pn_mob_info_s>();
      break;
    case types::pni_npn_mob_info:
      c.init<pni_npn_mob_info_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
}
npn_mob_info_c::npn_mob_info_c(const npn_mob_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sn_pn_mob_info:
      c.init(other.c.get<sn_pn_mob_info_s>());
      break;
    case types::pni_npn_mob_info:
      c.init(other.c.get<pni_npn_mob_info_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
}
npn_mob_info_c& npn_mob_info_c::operator=(const npn_mob_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sn_pn_mob_info:
      c.set(other.c.get<sn_pn_mob_info_s>());
      break;
    case types::pni_npn_mob_info:
      c.set(other.c.get<pni_npn_mob_info_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }

  return *this;
}
sn_pn_mob_info_s& npn_mob_info_c::set_sn_pn_mob_info()
{
  set(types::sn_pn_mob_info);
  return c.get<sn_pn_mob_info_s>();
}
pni_npn_mob_info_s& npn_mob_info_c::set_pni_npn_mob_info()
{
  set(types::pni_npn_mob_info);
  return c.get<pni_npn_mob_info_s>();
}
protocol_ie_single_container_s<npn_mob_info_ext_ies_o>& npn_mob_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
}
void npn_mob_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sn_pn_mob_info:
      j.write_fieldname("sNPN-MobilityInformation");
      c.get<sn_pn_mob_info_s>().to_json(j);
      break;
    case types::pni_npn_mob_info:
      j.write_fieldname("pNI-NPN-MobilityInformation");
      c.get<pni_npn_mob_info_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_mob_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sn_pn_mob_info:
      HANDLE_CODE(c.get<sn_pn_mob_info_s>().pack(bref));
      break;
    case types::pni_npn_mob_info:
      HANDLE_CODE(c.get<pni_npn_mob_info_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_mob_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sn_pn_mob_info:
      HANDLE_CODE(c.get<sn_pn_mob_info_s>().unpack(bref));
      break;
    case types::pni_npn_mob_info:
      HANDLE_CODE(c.get<pni_npn_mob_info_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_mob_info_c::types_opts::to_string() const
{
  static const char* names[] = {"sNPN-MobilityInformation", "pNI-NPN-MobilityInformation", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "npn_mob_info_c::types");
}

// RATRestrictions-Item ::= SEQUENCE
SRSASN_CODE rat_restricts_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(rat_restrict_info.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rat_restricts_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(rat_restrict_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void rat_restricts_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("rATRestrictionInformation", rat_restrict_info.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// ServiceAreaInformation-Item ::= SEQUENCE
SRSASN_CODE service_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(allowed_tacs.size() > 0, 1));
  HANDLE_CODE(bref.pack(not_allowed_tacs.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (allowed_tacs.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_tacs, 1, 16, true));
  }
  if (not_allowed_tacs.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, not_allowed_tacs, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE service_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool allowed_tacs_present;
  HANDLE_CODE(bref.unpack(allowed_tacs_present, 1));
  bool not_allowed_tacs_present;
  HANDLE_CODE(bref.unpack(not_allowed_tacs_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (allowed_tacs_present) {
    HANDLE_CODE(unpack_dyn_seq_of(allowed_tacs, bref, 1, 16, true));
  }
  if (not_allowed_tacs_present) {
    HANDLE_CODE(unpack_dyn_seq_of(not_allowed_tacs, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void service_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  if (allowed_tacs.size() > 0) {
    j.start_array("allowedTACs");
    for (const auto& e1 : allowed_tacs) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (not_allowed_tacs.size() > 0) {
    j.start_array("notAllowedTACs");
    for (const auto& e1 : not_allowed_tacs) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetNSSAI-Item ::= SEQUENCE
SRSASN_CODE target_nssai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_nssai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_nssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MobilityRestrictionList-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t mob_restrict_list_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {150, 161, 160, 261};
  return map_enum_number(names, 4, idx, "id");
}
bool mob_restrict_list_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {150, 161, 160, 261};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mob_restrict_list_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 150:
      return crit_e::ignore;
    case 161:
      return crit_e::ignore;
    case 160:
      return crit_e::ignore;
    case 261:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
mob_restrict_list_ext_ies_o::ext_c mob_restrict_list_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 150:
      ret.set(ext_c::types::last_eutran_plmn_id);
      break;
    case 161:
      ret.set(ext_c::types::cn_type_restricts_for_serving);
      break;
    case 160:
      ret.set(ext_c::types::cn_type_restricts_for_equivalent);
      break;
    case 261:
      ret.set(ext_c::types::npn_mob_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e mob_restrict_list_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 150:
      return presence_e::optional;
    case 161:
      return presence_e::optional;
    case 160:
      return presence_e::optional;
    case 261:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void mob_restrict_list_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::last_eutran_plmn_id:
      c = fixed_octstring<3, true>{};
      break;
    case types::cn_type_restricts_for_serving:
      c = cn_type_restricts_for_serving_e{};
      break;
    case types::cn_type_restricts_for_equivalent:
      c = cn_type_restricts_for_equivalent_l{};
      break;
    case types::npn_mob_info:
      c = npn_mob_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }
}
fixed_octstring<3, true>& mob_restrict_list_ext_ies_o::ext_c::last_eutran_plmn_id()
{
  assert_choice_type(types::last_eutran_plmn_id, type_, "Extension");
  return c.get<fixed_octstring<3, true>>();
}
cn_type_restricts_for_serving_e& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_serving()
{
  assert_choice_type(types::cn_type_restricts_for_serving, type_, "Extension");
  return c.get<cn_type_restricts_for_serving_e>();
}
cn_type_restricts_for_equivalent_l& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_equivalent()
{
  assert_choice_type(types::cn_type_restricts_for_equivalent, type_, "Extension");
  return c.get<cn_type_restricts_for_equivalent_l>();
}
npn_mob_info_c& mob_restrict_list_ext_ies_o::ext_c::npn_mob_info()
{
  assert_choice_type(types::npn_mob_info, type_, "Extension");
  return c.get<npn_mob_info_c>();
}
const fixed_octstring<3, true>& mob_restrict_list_ext_ies_o::ext_c::last_eutran_plmn_id() const
{
  assert_choice_type(types::last_eutran_plmn_id, type_, "Extension");
  return c.get<fixed_octstring<3, true>>();
}
const cn_type_restricts_for_serving_e& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_serving() const
{
  assert_choice_type(types::cn_type_restricts_for_serving, type_, "Extension");
  return c.get<cn_type_restricts_for_serving_e>();
}
const cn_type_restricts_for_equivalent_l& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_equivalent() const
{
  assert_choice_type(types::cn_type_restricts_for_equivalent, type_, "Extension");
  return c.get<cn_type_restricts_for_equivalent_l>();
}
const npn_mob_info_c& mob_restrict_list_ext_ies_o::ext_c::npn_mob_info() const
{
  assert_choice_type(types::npn_mob_info, type_, "Extension");
  return c.get<npn_mob_info_c>();
}
void mob_restrict_list_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::last_eutran_plmn_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<3, true>>().to_string());
      break;
    case types::cn_type_restricts_for_serving:
      j.write_str("CNTypeRestrictionsForServing", "epc-forbidden");
      break;
    case types::cn_type_restricts_for_equivalent:
      j.start_array("CNTypeRestrictionsForEquivalent");
      for (const auto& e1 : c.get<cn_type_restricts_for_equivalent_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::npn_mob_info:
      j.write_fieldname("NPN-MobilityInformation");
      c.get<npn_mob_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE mob_restrict_list_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_eutran_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().pack(bref)));
      break;
    case types::cn_type_restricts_for_serving:
      HANDLE_CODE(c.get<cn_type_restricts_for_serving_e>().pack(bref));
      break;
    case types::cn_type_restricts_for_equivalent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cn_type_restricts_for_equivalent_l>(), 1, 15, true));
      break;
    case types::npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_eutran_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().unpack(bref)));
      break;
    case types::cn_type_restricts_for_serving:
      HANDLE_CODE(c.get<cn_type_restricts_for_serving_e>().unpack(bref));
      break;
    case types::cn_type_restricts_for_equivalent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cn_type_restricts_for_equivalent_l>(), bref, 1, 15, true));
      break;
    case types::npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mob_restrict_list_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {
      "OCTET STRING", "CNTypeRestrictionsForServing", "CNTypeRestrictionsForEquivalent", "NPN-MobilityInformation"};
  return convert_enum_idx(names, 4, value, "mob_restrict_list_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<mob_restrict_list_ext_ies_o>;

SRSASN_CODE mob_restrict_list_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += last_eutran_plmn_id_present ? 1 : 0;
  nof_ies += cn_type_restricts_for_serving_present ? 1 : 0;
  nof_ies += cn_type_restricts_for_equivalent_present ? 1 : 0;
  nof_ies += npn_mob_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (last_eutran_plmn_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)150, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(last_eutran_plmn_id.pack(bref));
  }
  if (cn_type_restricts_for_serving_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)161, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_type_restricts_for_serving.pack(bref));
  }
  if (cn_type_restricts_for_equivalent_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)160, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, cn_type_restricts_for_equivalent, 1, 15, true));
  }
  if (npn_mob_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)261, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_mob_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 150: {
        last_eutran_plmn_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(last_eutran_plmn_id.unpack(bref));
        break;
      }
      case 161: {
        cn_type_restricts_for_serving_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_type_restricts_for_serving.unpack(bref));
        break;
      }
      case 160: {
        cn_type_restricts_for_equivalent_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(cn_type_restricts_for_equivalent, bref, 1, 15, true));
        break;
      }
      case 261: {
        npn_mob_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_mob_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void mob_restrict_list_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (last_eutran_plmn_id_present) {
    j.write_int("id", 150);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", last_eutran_plmn_id.to_string());
  }
  if (cn_type_restricts_for_serving_present) {
    j.write_int("id", 161);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "epc-forbidden");
  }
  if (cn_type_restricts_for_equivalent_present) {
    j.write_int("id", 160);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : cn_type_restricts_for_equivalent) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (npn_mob_info_present) {
    j.write_int("id", 261);
    j.write_str("criticality", "reject");
    npn_mob_info.to_json(j);
  }
  j.end_obj();
}

// MobilityRestrictionList ::= SEQUENCE
SRSASN_CODE mob_restrict_list_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(equivalent_plmns.size() > 0, 1));
  HANDLE_CODE(bref.pack(rat_restricts.size() > 0, 1));
  HANDLE_CODE(bref.pack(forbidden_area_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(service_area_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.pack(bref));
  if (equivalent_plmns.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, equivalent_plmns, 1, 15, true));
  }
  if (rat_restricts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, rat_restricts, 1, 16, true));
  }
  if (forbidden_area_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_area_info, 1, 16, true));
  }
  if (service_area_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, service_area_info, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool equivalent_plmns_present;
  HANDLE_CODE(bref.unpack(equivalent_plmns_present, 1));
  bool rat_restricts_present;
  HANDLE_CODE(bref.unpack(rat_restricts_present, 1));
  bool forbidden_area_info_present;
  HANDLE_CODE(bref.unpack(forbidden_area_info_present, 1));
  bool service_area_info_present;
  HANDLE_CODE(bref.unpack(service_area_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.unpack(bref));
  if (equivalent_plmns_present) {
    HANDLE_CODE(unpack_dyn_seq_of(equivalent_plmns, bref, 1, 15, true));
  }
  if (rat_restricts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(rat_restricts, bref, 1, 16, true));
  }
  if (forbidden_area_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(forbidden_area_info, bref, 1, 16, true));
  }
  if (service_area_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(service_area_info, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mob_restrict_list_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("servingPLMN", serving_plmn.to_string());
  if (equivalent_plmns.size() > 0) {
    j.start_array("equivalentPLMNs");
    for (const auto& e1 : equivalent_plmns) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (rat_restricts.size() > 0) {
    j.start_array("rATRestrictions");
    for (const auto& e1 : rat_restricts) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (forbidden_area_info.size() > 0) {
    j.start_array("forbiddenAreaInformation");
    for (const auto& e1 : forbidden_area_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (service_area_info.size() > 0) {
    j.start_array("serviceAreaInformation");
    for (const auto& e1 : service_area_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRVCCOperationPossible ::= ENUMERATED
const char* srvcc_operation_possible_opts::to_string() const
{
  static const char* names[] = {"possible", "notPossible"};
  return convert_enum_idx(names, 2, value, "srvcc_operation_possible_e");
}

// TargetNSSAIInformation ::= SEQUENCE
SRSASN_CODE target_nssai_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, target_nssai, 1, 8, true));
  HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_nssai_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(target_nssai, bref, 1, 8, true));
  HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_nssai_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("targetNSSAI");
  for (const auto& e1 : target_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("indexToRFSP", idx_to_rfsp);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE ue_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_aggr_max_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, ue_aggr_max_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_aggr_max_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(ue_aggr_max_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uEAggregateMaximumBitRateDL", ue_aggr_max_bit_rate_dl);
  j.write_int("uEAggregateMaximumBitRateUL", ue_aggr_max_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UECapabilityInfoRequest ::= ENUMERATED
const char* ue_cap_info_request_opts::to_string() const
{
  static const char* names[] = {"requested"};
  return convert_enum_idx(names, 1, value, "ue_cap_info_request_e");
}

// EUTRAN-CompositeAvailableCapacityGroup ::= SEQUENCE
SRSASN_CODE eutran_composite_available_capacity_group_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_composite_available_capacity.pack(bref));
  HANDLE_CODE(ul_composite_available_capacity.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_composite_available_capacity_group_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_composite_available_capacity.unpack(bref));
  HANDLE_CODE(ul_composite_available_capacity.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_composite_available_capacity_group_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-CompositeAvailableCapacity");
  dl_composite_available_capacity.to_json(j);
  j.write_fieldname("uL-CompositeAvailableCapacity");
  ul_composite_available_capacity.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-RadioResourceStatus ::= SEQUENCE
SRSASN_CODE eutran_rr_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.pack(ul_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  if (dl_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, dl_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, ul_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_rr_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.unpack(ul_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (dl_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(unpack_integer(dl_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(unpack_integer(ul_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dL-GBR-PRB-usage", dl_gbr_prb_usage);
  j.write_int("uL-GBR-PRB-usage", ul_gbr_prb_usage);
  j.write_int("dL-non-GBR-PRB-usage", dl_non_gbr_prb_usage);
  j.write_int("uL-non-GBR-PRB-usage", ul_non_gbr_prb_usage);
  j.write_int("dL-Total-PRB-usage", dl_total_prb_usage);
  j.write_int("uL-Total-PRB-usage", ul_total_prb_usage);
  if (dl_sched_pdcch_cce_usage_present) {
    j.write_int("dL-scheduling-PDCCH-CCE-usage", dl_sched_pdcch_cce_usage);
  }
  if (ul_sched_pdcch_cce_usage_present) {
    j.write_int("uL-scheduling-PDCCH-CCE-usage", ul_sched_pdcch_cce_usage);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-RadioResourceStatus ::= SEQUENCE
SRSASN_CODE ngran_rr_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_rr_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dL-GBR-PRB-usage-for-MIMO", dl_gbr_prb_usage_for_mimo);
  j.write_int("uL-GBR-PRB-usage-for-MIMO", ul_gbr_prb_usage_for_mimo);
  j.write_int("dL-non-GBR-PRB-usage-for-MIMO", dl_non_gbr_prb_usage_for_mimo);
  j.write_int("uL-non-GBR-PRB-usage-for-MIMO", ul_non_gbr_prb_usage_for_mimo);
  j.write_int("dL-Total-PRB-usage-for-MIMO", dl_total_prb_usage_for_mimo);
  j.write_int("uL-Total-PRB-usage-for-MIMO", ul_total_prb_usage_for_mimo);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-CellReportItem ::= SEQUENCE
SRSASN_CODE eutran_cell_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(eutran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.pack(eutran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.pack(eutran_rr_status_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  HANDLE_CODE(eutran_composite_available_capacity_group.pack(bref));
  if (eutran_nof_active_ues_present) {
    HANDLE_CODE(pack_integer(bref, eutran_nof_active_ues, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (eutran_noof_rrc_conns_present) {
    HANDLE_CODE(pack_integer(bref, eutran_noof_rrc_conns, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (eutran_rr_status_present) {
    HANDLE_CODE(eutran_rr_status.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_cell_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(eutran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.unpack(eutran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.unpack(eutran_rr_status_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  HANDLE_CODE(eutran_composite_available_capacity_group.unpack(bref));
  if (eutran_nof_active_ues_present) {
    HANDLE_CODE(unpack_integer(eutran_nof_active_ues, bref, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (eutran_noof_rrc_conns_present) {
    HANDLE_CODE(unpack_integer(eutran_noof_rrc_conns, bref, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (eutran_rr_status_present) {
    HANDLE_CODE(eutran_rr_status.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_cell_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  j.write_fieldname("eUTRAN-CompositeAvailableCapacityGroup");
  eutran_composite_available_capacity_group.to_json(j);
  if (eutran_nof_active_ues_present) {
    j.write_int("eUTRAN-NumberOfActiveUEs", eutran_nof_active_ues);
  }
  if (eutran_noof_rrc_conns_present) {
    j.write_int("eUTRAN-NoofRRCConnections", eutran_noof_rrc_conns);
  }
  if (eutran_rr_status_present) {
    j.write_fieldname("eUTRAN-RadioResourceStatus");
    eutran_rr_status.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-CellToReportItem ::= SEQUENCE
SRSASN_CODE eutran_cell_to_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_cell_to_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_cell_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-CellReportItem ::= SEQUENCE
SRSASN_CODE ngran_cell_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ngran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.pack(ngran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.pack(ngran_rr_status_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(ngran_composite_available_capacity_group.pack(bref));
  if (ngran_nof_active_ues_present) {
    HANDLE_CODE(pack_integer(bref, ngran_nof_active_ues, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (ngran_noof_rrc_conns_present) {
    HANDLE_CODE(pack_integer(bref, ngran_noof_rrc_conns, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (ngran_rr_status_present) {
    HANDLE_CODE(ngran_rr_status.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_cell_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ngran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.unpack(ngran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.unpack(ngran_rr_status_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  HANDLE_CODE(ngran_composite_available_capacity_group.unpack(bref));
  if (ngran_nof_active_ues_present) {
    HANDLE_CODE(unpack_integer(ngran_nof_active_ues, bref, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (ngran_noof_rrc_conns_present) {
    HANDLE_CODE(unpack_integer(ngran_noof_rrc_conns, bref, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (ngran_rr_status_present) {
    HANDLE_CODE(ngran_rr_status.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_cell_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  j.write_fieldname("nGRAN-CompositeAvailableCapacityGroup");
  ngran_composite_available_capacity_group.to_json(j);
  if (ngran_nof_active_ues_present) {
    j.write_int("nGRAN-NumberOfActiveUEs", ngran_nof_active_ues);
  }
  if (ngran_noof_rrc_conns_present) {
    j.write_int("nGRAN-NoofRRCConnections", ngran_noof_rrc_conns);
  }
  if (ngran_rr_status_present) {
    j.write_fieldname("nGRAN-RadioResourceStatus");
    ngran_rr_status.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-CellToReportItem ::= SEQUENCE
SRSASN_CODE ngran_cell_to_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_cell_to_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_cell_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NumberOfMeasurementReportingLevels ::= ENUMERATED
const char* nof_meas_report_levels_opts::to_string() const
{
  static const char* names[] = {"n2", "n3", "n4", "n5", "n10"};
  return convert_enum_idx(names, 5, value, "nof_meas_report_levels_e");
}
uint8_t nof_meas_report_levels_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 3, 4, 5, 10};
  return map_enum_number(numbers, 5, value, "nof_meas_report_levels_e");
}

// ReportingPeriodicity ::= ENUMERATED
const char* report_periodicity_opts::to_string() const
{
  static const char* names[] = {"stop", "single", "ms1000", "ms2000", "ms5000", "ms10000"};
  return convert_enum_idx(names, 6, value, "report_periodicity_e");
}
uint16_t report_periodicity_opts::to_number() const
{
  switch (value) {
    case ms1000:
      return 1000;
    case ms2000:
      return 2000;
    case ms5000:
      return 5000;
    case ms10000:
      return 10000;
    default:
      invalid_enum_number(value, "report_periodicity_e");
  }
  return 0;
}

// EUTRAN-ReportingStatusIEs ::= SEQUENCE
SRSASN_CODE eutran_report_status_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, eutran_cell_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_report_status_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(eutran_cell_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_report_status_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("eUTRAN-CellReportList");
  for (const auto& e1 : eutran_cell_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-ReportingSystemIEs ::= SEQUENCE
SRSASN_CODE eutran_report_sys_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, eutran_cell_to_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_report_sys_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(eutran_cell_to_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_report_sys_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("eUTRAN-CellToReportList");
  for (const auto& e1 : eutran_cell_to_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EventBasedReportingIEs ::= SEQUENCE
SRSASN_CODE event_based_report_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, intersys_res_thres_low, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, intersys_res_thres_high, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(nof_meas_report_levels.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_based_report_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(intersys_res_thres_low, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(intersys_res_thres_high, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(nof_meas_report_levels.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void event_based_report_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("intersystemResourceThresholdLow", intersys_res_thres_low);
  j.write_int("intersystemResourceThresholdHigh", intersys_res_thres_high);
  j.write_str("numberOfMeasurementReportingLevels", nof_meas_report_levels.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-ReportingStatusIEs ::= SEQUENCE
SRSASN_CODE ngran_report_status_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ngran_cell_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_report_status_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ngran_cell_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_report_status_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("nGRAN-CellReportList");
  for (const auto& e1 : ngran_cell_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-ReportingSystemIEs ::= SEQUENCE
SRSASN_CODE ngran_report_sys_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ngran_cell_to_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_report_sys_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ngran_cell_to_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_report_sys_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("nGRAN-CellToReportList");
  for (const auto& e1 : ngran_cell_to_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NotificationCell-Item ::= SEQUENCE
SRSASN_CODE notif_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(notify_flag.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE notif_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  HANDLE_CODE(notify_flag.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void notif_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  j.write_str("notifyFlag", notify_flag.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* notif_cell_item_s::notify_flag_opts::to_string() const
{
  static const char* names[] = {"activated", "deactivated"};
  return convert_enum_idx(names, 2, value, "notif_cell_item_s::notify_flag_e_");
}

// PeriodicReportingIEs ::= SEQUENCE
SRSASN_CODE periodic_report_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_periodicity.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE periodic_report_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_periodicity.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void periodic_report_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reportingPeriodicity", report_periodicity.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SuccessfulHandoverReport-Item ::= SEQUENCE
SRSASN_CODE successful_ho_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE successful_ho_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void successful_ho_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("successfulHOReportContainer", successful_ho_report_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UERLFReportContainer ::= CHOICE
void ue_rlf_report_container_c::destroy_()
{
  switch (type_) {
    case types::nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::lte:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_rlf_report_container_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::lte:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
}
ue_rlf_report_container_c::ue_rlf_report_container_c(const ue_rlf_report_container_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::lte:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
}
ue_rlf_report_container_c& ue_rlf_report_container_c::operator=(const ue_rlf_report_container_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::lte:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_rlf_report_container_c::set_nr()
{
  set(types::nr);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_rlf_report_container_c::set_lte()
{
  set(types::lte);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>& ue_rlf_report_container_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
}
void ue_rlf_report_container_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_str("nR", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::lte:
      j.write_str("lTE", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_rlf_report_container_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::lte:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_rlf_report_container_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::lte:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_rlf_report_container_c::types_opts::to_string() const
{
  static const char* names[] = {"nR", "lTE", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "ue_rlf_report_container_c::types");
}

// XnExtTLA-Item-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t xn_ext_tla_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {173};
  return map_enum_number(names, 1, idx, "id");
}
bool xn_ext_tla_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 173 == id;
}
crit_e xn_ext_tla_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 173) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
xn_ext_tla_item_ext_ies_o::ext_c xn_ext_tla_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 173) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e xn_ext_tla_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 173) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void xn_ext_tla_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("SCTP-TLAs");
  for (const auto& e1 : c) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE xn_ext_tla_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 2, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_ext_tla_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 2, true));
  return SRSASN_SUCCESS;
}

const char* xn_ext_tla_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SCTP-TLAs"};
  return convert_enum_idx(names, 1, value, "xn_ext_tla_item_ext_ies_o::ext_c::types");
}

// ENB-ID ::= CHOICE
void enb_id_c::destroy_()
{
  switch (type_) {
    case types::macro_enb_id:
      c.destroy<fixed_bitstring<20, false, true>>();
      break;
    case types::home_enb_id:
      c.destroy<fixed_bitstring<28, false, true>>();
      break;
    case types::short_macro_enb_id:
      c.destroy<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_enb_id:
      c.destroy<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<enb_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void enb_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::macro_enb_id:
      c.init<fixed_bitstring<20, false, true>>();
      break;
    case types::home_enb_id:
      c.init<fixed_bitstring<28, false, true>>();
      break;
    case types::short_macro_enb_id:
      c.init<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_enb_id:
      c.init<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<enb_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
}
enb_id_c::enb_id_c(const enb_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::macro_enb_id:
      c.init(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::home_enb_id:
      c.init(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::short_macro_enb_id:
      c.init(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_enb_id:
      c.init(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
}
enb_id_c& enb_id_c::operator=(const enb_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::macro_enb_id:
      c.set(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::home_enb_id:
      c.set(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::short_macro_enb_id:
      c.set(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_enb_id:
      c.set(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }

  return *this;
}
fixed_bitstring<20, false, true>& enb_id_c::set_macro_enb_id()
{
  set(types::macro_enb_id);
  return c.get<fixed_bitstring<20, false, true>>();
}
fixed_bitstring<28, false, true>& enb_id_c::set_home_enb_id()
{
  set(types::home_enb_id);
  return c.get<fixed_bitstring<28, false, true>>();
}
fixed_bitstring<18, false, true>& enb_id_c::set_short_macro_enb_id()
{
  set(types::short_macro_enb_id);
  return c.get<fixed_bitstring<18, false, true>>();
}
fixed_bitstring<21, false, true>& enb_id_c::set_long_macro_enb_id()
{
  set(types::long_macro_enb_id);
  return c.get<fixed_bitstring<21, false, true>>();
}
protocol_ie_single_container_s<enb_id_ext_ies_o>& enb_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>();
}
void enb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::macro_enb_id:
      j.write_str("macroENB-ID", c.get<fixed_bitstring<20, false, true>>().to_string());
      break;
    case types::home_enb_id:
      j.write_str("homeENB-ID", c.get<fixed_bitstring<28, false, true>>().to_string());
      break;
    case types::short_macro_enb_id:
      j.write_str("short-macroENB-ID", c.get<fixed_bitstring<18, false, true>>().to_string());
      break;
    case types::long_macro_enb_id:
      j.write_str("long-macroENB-ID", c.get<fixed_bitstring<21, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().pack(bref)));
      break;
    case types::home_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().pack(bref)));
      break;
    case types::short_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().pack(bref)));
      break;
    case types::long_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().unpack(bref)));
      break;
    case types::home_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().unpack(bref)));
      break;
    case types::short_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().unpack(bref)));
      break;
    case types::long_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_id_c::types_opts::to_string() const
{
  static const char* names[] = {
      "macroENB-ID", "homeENB-ID", "short-macroENB-ID", "long-macroENB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "enb_id_c::types");
}

// IntersystemUnnecessaryHO ::= SEQUENCE
SRSASN_CODE intersys_unnecessary_ho_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.pack(bref));
  HANDLE_CODE(targetcell_id.pack(bref));
  HANDLE_CODE(early_iratho.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_cell_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_unnecessary_ho_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.unpack(bref));
  HANDLE_CODE(targetcell_id.unpack(bref));
  HANDLE_CODE(early_iratho.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(candidate_cell_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_unnecessary_ho_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourcecellID");
  sourcecell_id.to_json(j);
  j.write_fieldname("targetcellID");
  targetcell_id.to_json(j);
  j.write_str("earlyIRATHO", early_iratho.to_string());
  j.start_array("candidateCellList");
  for (const auto& e1 : candidate_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* intersys_unnecessary_ho_s::early_iratho_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "intersys_unnecessary_ho_s::early_iratho_e_");
}

// ReportType ::= CHOICE
void report_type_c::destroy_()
{
  switch (type_) {
    case types::event_based_report:
      c.destroy<event_based_report_ies_s>();
      break;
    case types::periodic_report:
      c.destroy<periodic_report_ies_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<report_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void report_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::event_based_report:
      c.init<event_based_report_ies_s>();
      break;
    case types::periodic_report:
      c.init<periodic_report_ies_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<report_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
}
report_type_c::report_type_c(const report_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::event_based_report:
      c.init(other.c.get<event_based_report_ies_s>());
      break;
    case types::periodic_report:
      c.init(other.c.get<periodic_report_ies_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
}
report_type_c& report_type_c::operator=(const report_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::event_based_report:
      c.set(other.c.get<event_based_report_ies_s>());
      break;
    case types::periodic_report:
      c.set(other.c.get<periodic_report_ies_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }

  return *this;
}
event_based_report_ies_s& report_type_c::set_event_based_report()
{
  set(types::event_based_report);
  return c.get<event_based_report_ies_s>();
}
periodic_report_ies_s& report_type_c::set_periodic_report()
{
  set(types::periodic_report);
  return c.get<periodic_report_ies_s>();
}
protocol_ie_single_container_s<report_type_ext_ies_o>& report_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>();
}
void report_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::event_based_report:
      j.write_fieldname("eventBasedReporting");
      c.get<event_based_report_ies_s>().to_json(j);
      break;
    case types::periodic_report:
      j.write_fieldname("periodicReporting");
      c.get<periodic_report_ies_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
  j.end_obj();
}
SRSASN_CODE report_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::event_based_report:
      HANDLE_CODE(c.get<event_based_report_ies_s>().pack(bref));
      break;
    case types::periodic_report:
      HANDLE_CODE(c.get<periodic_report_ies_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE report_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::event_based_report:
      HANDLE_CODE(c.get<event_based_report_ies_s>().unpack(bref));
      break;
    case types::periodic_report:
      HANDLE_CODE(c.get<periodic_report_ies_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* report_type_c::types_opts::to_string() const
{
  static const char* names[] = {"eventBasedReporting", "periodicReporting", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "report_type_c::types");
}

// ReportingSystem ::= CHOICE
void report_sys_c::destroy_()
{
  switch (type_) {
    case types::eutran:
      c.destroy<eutran_report_sys_ies_s>();
      break;
    case types::ngran:
      c.destroy<ngran_report_sys_ies_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<report_sys_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void report_sys_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran:
      c.init<eutran_report_sys_ies_s>();
      break;
    case types::ngran:
      c.init<ngran_report_sys_ies_s>();
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<report_sys_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }
}
report_sys_c::report_sys_c(const report_sys_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran:
      c.init(other.c.get<eutran_report_sys_ies_s>());
      break;
    case types::ngran:
      c.init(other.c.get<ngran_report_sys_ies_s>());
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }
}
report_sys_c& report_sys_c::operator=(const report_sys_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran:
      c.set(other.c.get<eutran_report_sys_ies_s>());
      break;
    case types::ngran:
      c.set(other.c.get<ngran_report_sys_ies_s>());
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }

  return *this;
}
eutran_report_sys_ies_s& report_sys_c::set_eutran()
{
  set(types::eutran);
  return c.get<eutran_report_sys_ies_s>();
}
ngran_report_sys_ies_s& report_sys_c::set_ngran()
{
  set(types::ngran);
  return c.get<ngran_report_sys_ies_s>();
}
void report_sys_c::set_no_report()
{
  set(types::no_report);
}
protocol_ie_single_container_s<report_sys_ext_ies_o>& report_sys_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>();
}
void report_sys_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran:
      j.write_fieldname("eUTRAN");
      c.get<eutran_report_sys_ies_s>().to_json(j);
      break;
    case types::ngran:
      j.write_fieldname("nGRAN");
      c.get<ngran_report_sys_ies_s>().to_json(j);
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }
  j.end_obj();
}
SRSASN_CODE report_sys_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<eutran_report_sys_ies_s>().pack(bref));
      break;
    case types::ngran:
      HANDLE_CODE(c.get<ngran_report_sys_ies_s>().pack(bref));
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE report_sys_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<eutran_report_sys_ies_s>().unpack(bref));
      break;
    case types::ngran:
      HANDLE_CODE(c.get<ngran_report_sys_ies_s>().unpack(bref));
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* report_sys_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRAN", "nGRAN", "noReporting", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "report_sys_c::types");
}

// ResourceStatusReportingSystem ::= CHOICE
void res_status_report_sys_c::destroy_()
{
  switch (type_) {
    case types::eutran_report_status:
      c.destroy<eutran_report_status_ies_s>();
      break;
    case types::ngran_report_status:
      c.destroy<ngran_report_status_ies_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void res_status_report_sys_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran_report_status:
      c.init<eutran_report_status_ies_s>();
      break;
    case types::ngran_report_status:
      c.init<ngran_report_status_ies_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }
}
res_status_report_sys_c::res_status_report_sys_c(const res_status_report_sys_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran_report_status:
      c.init(other.c.get<eutran_report_status_ies_s>());
      break;
    case types::ngran_report_status:
      c.init(other.c.get<ngran_report_status_ies_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }
}
res_status_report_sys_c& res_status_report_sys_c::operator=(const res_status_report_sys_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran_report_status:
      c.set(other.c.get<eutran_report_status_ies_s>());
      break;
    case types::ngran_report_status:
      c.set(other.c.get<ngran_report_status_ies_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }

  return *this;
}
eutran_report_status_ies_s& res_status_report_sys_c::set_eutran_report_status()
{
  set(types::eutran_report_status);
  return c.get<eutran_report_status_ies_s>();
}
ngran_report_status_ies_s& res_status_report_sys_c::set_ngran_report_status()
{
  set(types::ngran_report_status);
  return c.get<ngran_report_status_ies_s>();
}
protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>& res_status_report_sys_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>();
}
void res_status_report_sys_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran_report_status:
      j.write_fieldname("eUTRAN-ReportingStatus");
      c.get<eutran_report_status_ies_s>().to_json(j);
      break;
    case types::ngran_report_status:
      j.write_fieldname("nGRAN-ReportingStatus");
      c.get<ngran_report_status_ies_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }
  j.end_obj();
}
SRSASN_CODE res_status_report_sys_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran_report_status:
      HANDLE_CODE(c.get<eutran_report_status_ies_s>().pack(bref));
      break;
    case types::ngran_report_status:
      HANDLE_CODE(c.get<ngran_report_status_ies_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE res_status_report_sys_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran_report_status:
      HANDLE_CODE(c.get<eutran_report_status_ies_s>().unpack(bref));
      break;
    case types::ngran_report_status:
      HANDLE_CODE(c.get<ngran_report_status_ies_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* res_status_report_sys_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRAN-ReportingStatus", "nGRAN-ReportingStatus", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "res_status_report_sys_c::types");
}

// TooearlyIntersystemHO ::= SEQUENCE
SRSASN_CODE tooearly_intersys_ho_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.pack(bref));
  HANDLE_CODE(failcell_id.pack(bref));
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tooearly_intersys_ho_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.unpack(bref));
  HANDLE_CODE(failcell_id.unpack(bref));
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tooearly_intersys_ho_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourcecellID");
  sourcecell_id.to_json(j);
  j.write_fieldname("failurecellID");
  failcell_id.to_json(j);
  if (ue_rlf_report_container_present) {
    j.write_fieldname("uERLFReportContainer");
    ue_rlf_report_container.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// XnExtTLA-Item ::= SEQUENCE
SRSASN_CODE xn_ext_tla_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ip_sec_tla_present, 1));
  HANDLE_CODE(bref.pack(gtp_tlas.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ip_sec_tla_present) {
    HANDLE_CODE(ip_sec_tla.pack(bref));
  }
  if (gtp_tlas.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, gtp_tlas, 1, 16, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_ext_tla_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ip_sec_tla_present, 1));
  bool gtp_tlas_present;
  HANDLE_CODE(bref.unpack(gtp_tlas_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ip_sec_tla_present) {
    HANDLE_CODE(ip_sec_tla.unpack(bref));
  }
  if (gtp_tlas_present) {
    HANDLE_CODE(unpack_dyn_seq_of(gtp_tlas, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void xn_ext_tla_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ip_sec_tla_present) {
    j.write_str("iPsecTLA", ip_sec_tla.to_string());
  }
  if (gtp_tlas.size() > 0) {
    j.start_array("gTP-TLAs");
    for (const auto& e1 : gtp_tlas) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// EPS-TAI ::= SEQUENCE
SRSASN_CODE eps_tai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(eps_tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eps_tai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(eps_tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eps_tai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("ePS-TAC", eps_tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FailureIndication ::= SEQUENCE
SRSASN_CODE fail_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE fail_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uERLFReportContainer");
  ue_rlf_report_container.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalENB-ID ::= SEQUENCE
SRSASN_CODE global_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plmn_id.to_string());
  j.write_fieldname("eNB-ID");
  enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HOReport ::= SEQUENCE
SRSASN_CODE ho_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(reestcell_cgi_present, 1));
  HANDLE_CODE(bref.pack(sourcecell_c_rnti_present, 1));
  HANDLE_CODE(bref.pack(targetcellin_e_utran_present, 1));
  HANDLE_CODE(bref.pack(mob_info_present, 1));
  HANDLE_CODE(bref.pack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.pack(bref));
  HANDLE_CODE(ho_cause.pack(bref));
  HANDLE_CODE(sourcecell_cgi.pack(bref));
  HANDLE_CODE(targetcell_cgi.pack(bref));
  if (reestcell_cgi_present) {
    HANDLE_CODE(reestcell_cgi.pack(bref));
  }
  if (sourcecell_c_rnti_present) {
    HANDLE_CODE(sourcecell_c_rnti.pack(bref));
  }
  if (targetcellin_e_utran_present) {
    HANDLE_CODE(targetcellin_e_utran.pack(bref));
  }
  if (mob_info_present) {
    HANDLE_CODE(mob_info.pack(bref));
  }
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(reestcell_cgi_present, 1));
  HANDLE_CODE(bref.unpack(sourcecell_c_rnti_present, 1));
  HANDLE_CODE(bref.unpack(targetcellin_e_utran_present, 1));
  HANDLE_CODE(bref.unpack(mob_info_present, 1));
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.unpack(bref));
  HANDLE_CODE(ho_cause.unpack(bref));
  HANDLE_CODE(sourcecell_cgi.unpack(bref));
  HANDLE_CODE(targetcell_cgi.unpack(bref));
  if (reestcell_cgi_present) {
    HANDLE_CODE(reestcell_cgi.unpack(bref));
  }
  if (sourcecell_c_rnti_present) {
    HANDLE_CODE(sourcecell_c_rnti.unpack(bref));
  }
  if (targetcellin_e_utran_present) {
    HANDLE_CODE(targetcellin_e_utran.unpack(bref));
  }
  if (mob_info_present) {
    HANDLE_CODE(mob_info.unpack(bref));
  }
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("handoverReportType", ho_report_type.to_string());
  j.write_fieldname("handoverCause");
  ho_cause.to_json(j);
  j.write_fieldname("sourcecellCGI");
  sourcecell_cgi.to_json(j);
  j.write_fieldname("targetcellCGI");
  targetcell_cgi.to_json(j);
  if (reestcell_cgi_present) {
    j.write_fieldname("reestablishmentcellCGI");
    reestcell_cgi.to_json(j);
  }
  if (sourcecell_c_rnti_present) {
    j.write_str("sourcecellC-RNTI", sourcecell_c_rnti.to_string());
  }
  if (targetcellin_e_utran_present) {
    j.write_fieldname("targetcellinE-UTRAN");
    targetcellin_e_utran.to_json(j);
  }
  if (mob_info_present) {
    j.write_str("mobilityInformation", mob_info.to_string());
  }
  if (ue_rlf_report_container_present) {
    j.write_fieldname("uERLFReportContainer");
    ue_rlf_report_container.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ho_report_s::ho_report_type_opts::to_string() const
{
  static const char* names[] = {"ho-too-early", "ho-to-wrong-cell", "intersystem-ping-pong"};
  return convert_enum_idx(names, 3, value, "ho_report_s::ho_report_type_e_");
}

// InterSystemHandoverReportType ::= CHOICE
void inter_sys_ho_report_type_c::destroy_()
{
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.destroy<tooearly_intersys_ho_s>();
      break;
    case types::intersys_unnecessary_ho:
      c.destroy<intersys_unnecessary_ho_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void inter_sys_ho_report_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.init<tooearly_intersys_ho_s>();
      break;
    case types::intersys_unnecessary_ho:
      c.init<intersys_unnecessary_ho_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }
}
inter_sys_ho_report_type_c::inter_sys_ho_report_type_c(const inter_sys_ho_report_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.init(other.c.get<tooearly_intersys_ho_s>());
      break;
    case types::intersys_unnecessary_ho:
      c.init(other.c.get<intersys_unnecessary_ho_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }
}
inter_sys_ho_report_type_c& inter_sys_ho_report_type_c::operator=(const inter_sys_ho_report_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.set(other.c.get<tooearly_intersys_ho_s>());
      break;
    case types::intersys_unnecessary_ho:
      c.set(other.c.get<intersys_unnecessary_ho_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }

  return *this;
}
tooearly_intersys_ho_s& inter_sys_ho_report_type_c::set_tooearly_intersys_ho()
{
  set(types::tooearly_intersys_ho);
  return c.get<tooearly_intersys_ho_s>();
}
intersys_unnecessary_ho_s& inter_sys_ho_report_type_c::set_intersys_unnecessary_ho()
{
  set(types::intersys_unnecessary_ho);
  return c.get<intersys_unnecessary_ho_s>();
}
protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>& inter_sys_ho_report_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>();
}
void inter_sys_ho_report_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tooearly_intersys_ho:
      j.write_fieldname("tooearlyIntersystemHO");
      c.get<tooearly_intersys_ho_s>().to_json(j);
      break;
    case types::intersys_unnecessary_ho:
      j.write_fieldname("intersystemUnnecessaryHO");
      c.get<intersys_unnecessary_ho_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }
  j.end_obj();
}
SRSASN_CODE inter_sys_ho_report_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::tooearly_intersys_ho:
      HANDLE_CODE(c.get<tooearly_intersys_ho_s>().pack(bref));
      break;
    case types::intersys_unnecessary_ho:
      HANDLE_CODE(c.get<intersys_unnecessary_ho_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE inter_sys_ho_report_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::tooearly_intersys_ho:
      HANDLE_CODE(c.get<tooearly_intersys_ho_s>().unpack(bref));
      break;
    case types::intersys_unnecessary_ho:
      HANDLE_CODE(c.get<intersys_unnecessary_ho_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* inter_sys_ho_report_type_c::types_opts::to_string() const
{
  static const char* names[] = {"tooearlyIntersystemHO", "intersystemUnnecessaryHO", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "inter_sys_ho_report_type_c::types");
}

// IntersystemCellActivationReply ::= SEQUENCE
SRSASN_CODE intersys_cell_activation_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, activ_cell_list, 1, 16384, true));
  HANDLE_CODE(pack_integer(bref, activation_id, (uint16_t)0u, (uint16_t)16384u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_cell_activation_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(activ_cell_list, bref, 1, 16384, true));
  HANDLE_CODE(unpack_integer(activation_id, bref, (uint16_t)0u, (uint16_t)16384u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_cell_activation_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("activatedCellList");
  for (const auto& e1 : activ_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("activation-ID", activation_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemCellActivationRequest ::= SEQUENCE
SRSASN_CODE intersys_cell_activation_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, activation_id, (uint16_t)0u, (uint16_t)16384u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, cells_to_activ_list, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_cell_activation_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(activation_id, bref, (uint16_t)0u, (uint16_t)16384u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(cells_to_activ_list, bref, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_cell_activation_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("activationID", activation_id);
  j.start_array("cellsToActivateList");
  for (const auto& e1 : cells_to_activ_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemCellStateIndication ::= SEQUENCE
SRSASN_CODE intersys_cell_state_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, notif_cell_list, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_cell_state_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(notif_cell_list, bref, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_cell_state_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("notificationCellList");
  for (const auto& e1 : notif_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemResourceStatusReply ::= SEQUENCE
SRSASN_CODE intersys_res_status_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(reportsys.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_res_status_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(reportsys.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_res_status_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("reportingsystem");
  reportsys.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemResourceStatusReport ::= SEQUENCE
SRSASN_CODE intersys_res_status_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_res_status_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_res_status_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("reportingSystem");
  report_sys.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemResourceStatusRequest ::= SEQUENCE
SRSASN_CODE intersys_res_status_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.pack(bref));
  HANDLE_CODE(report_characteristics.pack(bref));
  HANDLE_CODE(report_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_res_status_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.unpack(bref));
  HANDLE_CODE(report_characteristics.unpack(bref));
  HANDLE_CODE(report_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_res_status_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("reportingSystem");
  report_sys.to_json(j);
  j.write_str("reportCharacteristics", report_characteristics.to_string());
  j.write_fieldname("reportType");
  report_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONInformationReport-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t son_info_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {294};
  return map_enum_number(names, 1, idx, "id");
}
bool son_info_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 294 == id;
}
crit_e son_info_report_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 294) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
son_info_report_ext_ies_o::value_c son_info_report_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 294) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e son_info_report_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 294) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void son_info_report_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("SuccessfulHandoverReportList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE son_info_report_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 64, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_report_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 64, true));
  return SRSASN_SUCCESS;
}

const char* son_info_report_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SuccessfulHandoverReportList"};
  return convert_enum_idx(names, 1, value, "son_info_report_ext_ies_o::value_c::types");
}

// InterSystemFailureIndication ::= SEQUENCE
SRSASN_CODE inter_sys_fail_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE inter_sys_fail_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void inter_sys_fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_rlf_report_container_present) {
    j.write_fieldname("uERLFReportContainer");
    ue_rlf_report_container.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InterSystemHOReport ::= SEQUENCE
SRSASN_CODE inter_sys_ho_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE inter_sys_ho_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void inter_sys_ho_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("handoverReportType");
  ho_report_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemSONInformationReply ::= CHOICE
void intersys_son_info_reply_c::destroy_()
{
  switch (type_) {
    case types::ngran_cell_activation:
      c.destroy<intersys_cell_activation_reply_s>();
      break;
    case types::res_status:
      c.destroy<intersys_res_status_reply_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_reply_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ngran_cell_activation:
      c.init<intersys_cell_activation_reply_s>();
      break;
    case types::res_status:
      c.init<intersys_res_status_reply_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }
}
intersys_son_info_reply_c::intersys_son_info_reply_c(const intersys_son_info_reply_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ngran_cell_activation:
      c.init(other.c.get<intersys_cell_activation_reply_s>());
      break;
    case types::res_status:
      c.init(other.c.get<intersys_res_status_reply_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }
}
intersys_son_info_reply_c& intersys_son_info_reply_c::operator=(const intersys_son_info_reply_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ngran_cell_activation:
      c.set(other.c.get<intersys_cell_activation_reply_s>());
      break;
    case types::res_status:
      c.set(other.c.get<intersys_res_status_reply_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }

  return *this;
}
intersys_cell_activation_reply_s& intersys_son_info_reply_c::set_ngran_cell_activation()
{
  set(types::ngran_cell_activation);
  return c.get<intersys_cell_activation_reply_s>();
}
intersys_res_status_reply_s& intersys_son_info_reply_c::set_res_status()
{
  set(types::res_status);
  return c.get<intersys_res_status_reply_s>();
}
protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>& intersys_son_info_reply_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>();
}
void intersys_son_info_reply_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ngran_cell_activation:
      j.write_fieldname("nGRAN-CellActivation");
      c.get<intersys_cell_activation_reply_s>().to_json(j);
      break;
    case types::res_status:
      j.write_fieldname("resourceStatus");
      c.get<intersys_res_status_reply_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_reply_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_reply_s>().pack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_reply_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_reply_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_reply_s>().unpack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_reply_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_reply_c::types_opts::to_string() const
{
  static const char* names[] = {"nGRAN-CellActivation", "resourceStatus", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_info_reply_c::types");
}

// IntersystemSONInformationReport-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t intersys_son_info_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {292, 293};
  return map_enum_number(names, 2, idx, "id");
}
bool intersys_son_info_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {292, 293};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e intersys_son_info_report_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 292:
      return crit_e::ignore;
    case 293:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
intersys_son_info_report_ext_ies_o::value_c intersys_son_info_report_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 292:
      ret.set(value_c::types::energy_saving_ind);
      break;
    case 293:
      ret.set(value_c::types::intersys_res_status_upd);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e intersys_son_info_report_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 292:
      return presence_e::mandatory;
    case 293:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void intersys_son_info_report_ext_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::energy_saving_ind:
      c = intersys_cell_state_ind_s{};
      break;
    case types::intersys_res_status_upd:
      c = intersys_res_status_report_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
  }
}
intersys_cell_state_ind_s& intersys_son_info_report_ext_ies_o::value_c::energy_saving_ind()
{
  assert_choice_type(types::energy_saving_ind, type_, "Value");
  return c.get<intersys_cell_state_ind_s>();
}
intersys_res_status_report_s& intersys_son_info_report_ext_ies_o::value_c::intersys_res_status_upd()
{
  assert_choice_type(types::intersys_res_status_upd, type_, "Value");
  return c.get<intersys_res_status_report_s>();
}
const intersys_cell_state_ind_s& intersys_son_info_report_ext_ies_o::value_c::energy_saving_ind() const
{
  assert_choice_type(types::energy_saving_ind, type_, "Value");
  return c.get<intersys_cell_state_ind_s>();
}
const intersys_res_status_report_s& intersys_son_info_report_ext_ies_o::value_c::intersys_res_status_upd() const
{
  assert_choice_type(types::intersys_res_status_upd, type_, "Value");
  return c.get<intersys_res_status_report_s>();
}
void intersys_son_info_report_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::energy_saving_ind:
      j.write_fieldname("IntersystemCellStateIndication");
      c.get<intersys_cell_state_ind_s>().to_json(j);
      break;
    case types::intersys_res_status_upd:
      j.write_fieldname("IntersystemResourceStatusReport");
      c.get<intersys_res_status_report_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_report_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::energy_saving_ind:
      HANDLE_CODE(c.get<intersys_cell_state_ind_s>().pack(bref));
      break;
    case types::intersys_res_status_upd:
      HANDLE_CODE(c.get<intersys_res_status_report_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_report_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::energy_saving_ind:
      HANDLE_CODE(c.get<intersys_cell_state_ind_s>().unpack(bref));
      break;
    case types::intersys_res_status_upd:
      HANDLE_CODE(c.get<intersys_res_status_report_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_report_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"IntersystemCellStateIndication", "IntersystemResourceStatusReport"};
  return convert_enum_idx(names, 2, value, "intersys_son_info_report_ext_ies_o::value_c::types");
}

// IntersystemSONInformationRequest ::= CHOICE
void intersys_son_info_request_c::destroy_()
{
  switch (type_) {
    case types::ngran_cell_activation:
      c.destroy<intersys_cell_activation_request_s>();
      break;
    case types::res_status:
      c.destroy<intersys_res_status_request_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_request_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ngran_cell_activation:
      c.init<intersys_cell_activation_request_s>();
      break;
    case types::res_status:
      c.init<intersys_res_status_request_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }
}
intersys_son_info_request_c::intersys_son_info_request_c(const intersys_son_info_request_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ngran_cell_activation:
      c.init(other.c.get<intersys_cell_activation_request_s>());
      break;
    case types::res_status:
      c.init(other.c.get<intersys_res_status_request_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }
}
intersys_son_info_request_c& intersys_son_info_request_c::operator=(const intersys_son_info_request_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ngran_cell_activation:
      c.set(other.c.get<intersys_cell_activation_request_s>());
      break;
    case types::res_status:
      c.set(other.c.get<intersys_res_status_request_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }

  return *this;
}
intersys_cell_activation_request_s& intersys_son_info_request_c::set_ngran_cell_activation()
{
  set(types::ngran_cell_activation);
  return c.get<intersys_cell_activation_request_s>();
}
intersys_res_status_request_s& intersys_son_info_request_c::set_res_status()
{
  set(types::res_status);
  return c.get<intersys_res_status_request_s>();
}
protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>& intersys_son_info_request_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>();
}
void intersys_son_info_request_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ngran_cell_activation:
      j.write_fieldname("nGRAN-CellActivation");
      c.get<intersys_cell_activation_request_s>().to_json(j);
      break;
    case types::res_status:
      j.write_fieldname("resourceStatus");
      c.get<intersys_res_status_request_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_request_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_request_s>().pack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_request_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_request_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_request_s>().unpack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_request_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_request_c::types_opts::to_string() const
{
  static const char* names[] = {"nGRAN-CellActivation", "resourceStatus", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_info_request_c::types");
}

// IntersystemSONNGRANnodeID ::= SEQUENCE
SRSASN_CODE intersys_son_ngran_node_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_ngran_node_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_son_ngran_node_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemSONeNBID ::= SEQUENCE
SRSASN_CODE intersys_son_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.pack(bref));
  HANDLE_CODE(sel_eps_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.unpack(bref));
  HANDLE_CODE(sel_eps_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_son_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globaleNBID");
  global_enb_id.to_json(j);
  j.write_fieldname("selectedEPSTAI");
  sel_eps_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_single_container_s<son_info_report_ext_ies_o>;

// SONInformationReport ::= CHOICE
void son_info_report_c::destroy_()
{
  switch (type_) {
    case types::fail_ind_info:
      c.destroy<fail_ind_s>();
      break;
    case types::ho_report_info:
      c.destroy<ho_report_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<son_info_report_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void son_info_report_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fail_ind_info:
      c.init<fail_ind_s>();
      break;
    case types::ho_report_info:
      c.init<ho_report_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<son_info_report_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }
}
son_info_report_c::son_info_report_c(const son_info_report_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fail_ind_info:
      c.init(other.c.get<fail_ind_s>());
      break;
    case types::ho_report_info:
      c.init(other.c.get<ho_report_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }
}
son_info_report_c& son_info_report_c::operator=(const son_info_report_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fail_ind_info:
      c.set(other.c.get<fail_ind_s>());
      break;
    case types::ho_report_info:
      c.set(other.c.get<ho_report_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }

  return *this;
}
fail_ind_s& son_info_report_c::set_fail_ind_info()
{
  set(types::fail_ind_info);
  return c.get<fail_ind_s>();
}
ho_report_s& son_info_report_c::set_ho_report_info()
{
  set(types::ho_report_info);
  return c.get<ho_report_s>();
}
protocol_ie_single_container_s<son_info_report_ext_ies_o>& son_info_report_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>();
}
void son_info_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fail_ind_info:
      j.write_fieldname("failureIndicationInformation");
      c.get<fail_ind_s>().to_json(j);
      break;
    case types::ho_report_info:
      j.write_fieldname("hOReportInformation");
      c.get<ho_report_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }
  j.end_obj();
}
SRSASN_CODE son_info_report_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fail_ind_info:
      HANDLE_CODE(c.get<fail_ind_s>().pack(bref));
      break;
    case types::ho_report_info:
      HANDLE_CODE(c.get<ho_report_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_report_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fail_ind_info:
      HANDLE_CODE(c.get<fail_ind_s>().unpack(bref));
      break;
    case types::ho_report_info:
      HANDLE_CODE(c.get<ho_report_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* son_info_report_c::types_opts::to_string() const
{
  static const char* names[] = {"failureIndicationInformation", "hOReportInformation", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "son_info_report_c::types");
}

// XnTNLConfigurationInfo ::= SEQUENCE
SRSASN_CODE xn_tnl_cfg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(xn_extended_transport_layer_addresses.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, xn_transport_layer_addresses, 1, 2, true));
  if (xn_extended_transport_layer_addresses.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, xn_extended_transport_layer_addresses, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_tnl_cfg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool xn_extended_transport_layer_addresses_present;
  HANDLE_CODE(bref.unpack(xn_extended_transport_layer_addresses_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(xn_transport_layer_addresses, bref, 1, 2, true));
  if (xn_extended_transport_layer_addresses_present) {
    HANDLE_CODE(unpack_dyn_seq_of(xn_extended_transport_layer_addresses, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void xn_tnl_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("xnTransportLayerAddresses");
  for (const auto& e1 : xn_transport_layer_addresses) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (xn_extended_transport_layer_addresses.size() > 0) {
    j.start_array("xnExtendedTransportLayerAddresses");
    for (const auto& e1 : xn_extended_transport_layer_addresses) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FromEUTRANtoNGRAN ::= SEQUENCE
SRSASN_CODE from_eutran_to_ngran_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(source_enb_id.pack(bref));
  HANDLE_CODE(target_ngran_node_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE from_eutran_to_ngran_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(source_enb_id.unpack(bref));
  HANDLE_CODE(target_ngran_node_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void from_eutran_to_ngran_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourceeNBID");
  source_enb_id.to_json(j);
  j.write_fieldname("targetNGRANnodeID");
  target_ngran_node_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FromNGRANtoEUTRAN ::= SEQUENCE
SRSASN_CODE from_ngran_to_eutran_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(source_ngran_node_id.pack(bref));
  HANDLE_CODE(target_enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE from_ngran_to_eutran_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(source_ngran_node_id.unpack(bref));
  HANDLE_CODE(target_enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void from_ngran_to_eutran_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourceNGRANnodeID");
  source_ngran_node_id.to_json(j);
  j.write_fieldname("targeteNBID");
  target_enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemSONInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t intersys_son_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {290, 291};
  return map_enum_number(names, 2, idx, "id");
}
bool intersys_son_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {290, 291};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e intersys_son_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 290:
      return crit_e::ignore;
    case 291:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
intersys_son_info_ext_ies_o::value_c intersys_son_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 290:
      ret.set(value_c::types::intersys_son_info_request);
      break;
    case 291:
      ret.set(value_c::types::intersys_son_info_reply);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e intersys_son_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 290:
      return presence_e::mandatory;
    case 291:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void intersys_son_info_ext_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::intersys_son_info_request:
      c = intersys_son_info_request_c{};
      break;
    case types::intersys_son_info_reply:
      c = intersys_son_info_reply_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
  }
}
intersys_son_info_request_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_request()
{
  assert_choice_type(types::intersys_son_info_request, type_, "Value");
  return c.get<intersys_son_info_request_c>();
}
intersys_son_info_reply_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_reply()
{
  assert_choice_type(types::intersys_son_info_reply, type_, "Value");
  return c.get<intersys_son_info_reply_c>();
}
const intersys_son_info_request_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_request() const
{
  assert_choice_type(types::intersys_son_info_request, type_, "Value");
  return c.get<intersys_son_info_request_c>();
}
const intersys_son_info_reply_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_reply() const
{
  assert_choice_type(types::intersys_son_info_reply, type_, "Value");
  return c.get<intersys_son_info_reply_c>();
}
void intersys_son_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::intersys_son_info_request:
      j.write_fieldname("IntersystemSONInformationRequest");
      c.get<intersys_son_info_request_c>().to_json(j);
      break;
    case types::intersys_son_info_reply:
      j.write_fieldname("IntersystemSONInformationReply");
      c.get<intersys_son_info_reply_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intersys_son_info_request:
      HANDLE_CODE(c.get<intersys_son_info_request_c>().pack(bref));
      break;
    case types::intersys_son_info_reply:
      HANDLE_CODE(c.get<intersys_son_info_reply_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intersys_son_info_request:
      HANDLE_CODE(c.get<intersys_son_info_request_c>().unpack(bref));
      break;
    case types::intersys_son_info_reply:
      HANDLE_CODE(c.get<intersys_son_info_reply_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"IntersystemSONInformationRequest", "IntersystemSONInformationReply"};
  return convert_enum_idx(names, 2, value, "intersys_son_info_ext_ies_o::value_c::types");
}

template struct asn1::protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>;

// IntersystemSONInformationReport ::= CHOICE
void intersys_son_info_report_c::destroy_()
{
  switch (type_) {
    case types::ho_report_info:
      c.destroy<inter_sys_ho_report_s>();
      break;
    case types::fail_ind_info:
      c.destroy<inter_sys_fail_ind_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_report_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ho_report_info:
      c.init<inter_sys_ho_report_s>();
      break;
    case types::fail_ind_info:
      c.init<inter_sys_fail_ind_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }
}
intersys_son_info_report_c::intersys_son_info_report_c(const intersys_son_info_report_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ho_report_info:
      c.init(other.c.get<inter_sys_ho_report_s>());
      break;
    case types::fail_ind_info:
      c.init(other.c.get<inter_sys_fail_ind_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }
}
intersys_son_info_report_c& intersys_son_info_report_c::operator=(const intersys_son_info_report_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ho_report_info:
      c.set(other.c.get<inter_sys_ho_report_s>());
      break;
    case types::fail_ind_info:
      c.set(other.c.get<inter_sys_fail_ind_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }

  return *this;
}
inter_sys_ho_report_s& intersys_son_info_report_c::set_ho_report_info()
{
  set(types::ho_report_info);
  return c.get<inter_sys_ho_report_s>();
}
inter_sys_fail_ind_s& intersys_son_info_report_c::set_fail_ind_info()
{
  set(types::fail_ind_info);
  return c.get<inter_sys_fail_ind_s>();
}
protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>& intersys_son_info_report_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>();
}
void intersys_son_info_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ho_report_info:
      j.write_fieldname("hOReportInformation");
      c.get<inter_sys_ho_report_s>().to_json(j);
      break;
    case types::fail_ind_info:
      j.write_fieldname("failureIndicationInformation");
      c.get<inter_sys_fail_ind_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_report_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ho_report_info:
      HANDLE_CODE(c.get<inter_sys_ho_report_s>().pack(bref));
      break;
    case types::fail_ind_info:
      HANDLE_CODE(c.get<inter_sys_fail_ind_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_report_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ho_report_info:
      HANDLE_CODE(c.get<inter_sys_ho_report_s>().unpack(bref));
      break;
    case types::fail_ind_info:
      HANDLE_CODE(c.get<inter_sys_fail_ind_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_report_c::types_opts::to_string() const
{
  static const char* names[] = {"hOReportInformation", "failureIndicationInformation", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_info_report_c::types");
}

// SONInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t son_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {252};
  return map_enum_number(names, 1, idx, "id");
}
bool son_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 252 == id;
}
crit_e son_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 252) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
son_info_ext_ies_o::value_c son_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 252) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e son_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 252) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void son_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SONInformationReport");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE son_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* son_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SONInformationReport"};
  return convert_enum_idx(names, 1, value, "son_info_ext_ies_o::value_c::types");
}

// SONInformationReply ::= SEQUENCE
SRSASN_CODE son_info_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void son_info_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (xn_tnl_cfg_info_present) {
    j.write_fieldname("xnTNLConfigurationInfo");
    xn_tnl_cfg_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONInformationRequest ::= ENUMERATED
const char* son_info_request_opts::to_string() const
{
  static const char* names[] = {"xn-TNL-configuration-info"};
  return convert_enum_idx(names, 1, value, "son_info_request_e");
}

// TargetRANNodeID-SON-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t target_ran_node_id_son_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {45};
  return map_enum_number(names, 1, idx, "id");
}
bool target_ran_node_id_son_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 45 == id;
}
crit_e target_ran_node_id_son_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 45) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
target_ran_node_id_son_ext_ies_o::ext_c target_ran_node_id_son_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 45) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_ran_node_id_son_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 45) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void target_ran_node_id_son_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("NR-CGI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE target_ran_node_id_son_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_son_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* target_ran_node_id_son_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NR-CGI"};
  return convert_enum_idx(names, 1, value, "target_ran_node_id_son_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ie_single_container_s<intersys_son_info_ext_ies_o>;

// IntersystemSONInformation ::= CHOICE
void intersys_son_info_c::destroy_()
{
  switch (type_) {
    case types::intersys_son_info_report:
      c.destroy<intersys_son_info_report_c>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::intersys_son_info_report:
      c.init<intersys_son_info_report_c>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }
}
intersys_son_info_c::intersys_son_info_c(const intersys_son_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::intersys_son_info_report:
      c.init(other.c.get<intersys_son_info_report_c>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }
}
intersys_son_info_c& intersys_son_info_c::operator=(const intersys_son_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::intersys_son_info_report:
      c.set(other.c.get<intersys_son_info_report_c>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }

  return *this;
}
intersys_son_info_report_c& intersys_son_info_c::set_intersys_son_info_report()
{
  set(types::intersys_son_info_report);
  return c.get<intersys_son_info_report_c>();
}
protocol_ie_single_container_s<intersys_son_info_ext_ies_o>& intersys_son_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>();
}
void intersys_son_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::intersys_son_info_report:
      j.write_fieldname("intersystemSONInformationReport");
      c.get<intersys_son_info_report_c>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::intersys_son_info_report:
      HANDLE_CODE(c.get<intersys_son_info_report_c>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::intersys_son_info_report:
      HANDLE_CODE(c.get<intersys_son_info_report_c>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_c::types_opts::to_string() const
{
  static const char* names[] = {"intersystemSONInformationReport", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "intersys_son_info_c::types");
}

// IntersystemSONTransferType ::= CHOICE
void intersys_son_transfer_type_c::destroy_()
{
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.destroy<from_eutran_to_ngran_s>();
      break;
    case types::from_ngran_to_eutran:
      c.destroy<from_ngran_to_eutran_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_transfer_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.init<from_eutran_to_ngran_s>();
      break;
    case types::from_ngran_to_eutran:
      c.init<from_ngran_to_eutran_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }
}
intersys_son_transfer_type_c::intersys_son_transfer_type_c(const intersys_son_transfer_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.init(other.c.get<from_eutran_to_ngran_s>());
      break;
    case types::from_ngran_to_eutran:
      c.init(other.c.get<from_ngran_to_eutran_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }
}
intersys_son_transfer_type_c& intersys_son_transfer_type_c::operator=(const intersys_son_transfer_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.set(other.c.get<from_eutran_to_ngran_s>());
      break;
    case types::from_ngran_to_eutran:
      c.set(other.c.get<from_ngran_to_eutran_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }

  return *this;
}
from_eutran_to_ngran_s& intersys_son_transfer_type_c::set_from_eutran_to_ngran()
{
  set(types::from_eutran_to_ngran);
  return c.get<from_eutran_to_ngran_s>();
}
from_ngran_to_eutran_s& intersys_son_transfer_type_c::set_from_ngran_to_eutran()
{
  set(types::from_ngran_to_eutran);
  return c.get<from_ngran_to_eutran_s>();
}
protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>& intersys_son_transfer_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>();
}
void intersys_son_transfer_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::from_eutran_to_ngran:
      j.write_fieldname("fromEUTRANtoNGRAN");
      c.get<from_eutran_to_ngran_s>().to_json(j);
      break;
    case types::from_ngran_to_eutran:
      j.write_fieldname("fromNGRANtoEUTRAN");
      c.get<from_ngran_to_eutran_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_transfer_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::from_eutran_to_ngran:
      HANDLE_CODE(c.get<from_eutran_to_ngran_s>().pack(bref));
      break;
    case types::from_ngran_to_eutran:
      HANDLE_CODE(c.get<from_ngran_to_eutran_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_transfer_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::from_eutran_to_ngran:
      HANDLE_CODE(c.get<from_eutran_to_ngran_s>().unpack(bref));
      break;
    case types::from_ngran_to_eutran:
      HANDLE_CODE(c.get<from_ngran_to_eutran_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_transfer_type_c::types_opts::to_string() const
{
  static const char* names[] = {"fromEUTRANtoNGRAN", "fromNGRANtoEUTRAN", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_transfer_type_c::types");
}

template struct asn1::protocol_ie_single_container_s<son_info_ext_ies_o>;

// SONInformation ::= CHOICE
void son_info_c::destroy_()
{
  switch (type_) {
    case types::son_info_reply:
      c.destroy<son_info_reply_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<son_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void son_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_info_request:
      break;
    case types::son_info_reply:
      c.init<son_info_reply_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<son_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
}
son_info_c::son_info_c(const son_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_info_request:
      c.init(other.c.get<son_info_request_e>());
      break;
    case types::son_info_reply:
      c.init(other.c.get<son_info_reply_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
}
son_info_c& son_info_c::operator=(const son_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_info_request:
      c.set(other.c.get<son_info_request_e>());
      break;
    case types::son_info_reply:
      c.set(other.c.get<son_info_reply_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }

  return *this;
}
son_info_request_e& son_info_c::set_son_info_request()
{
  set(types::son_info_request);
  return c.get<son_info_request_e>();
}
son_info_reply_s& son_info_c::set_son_info_reply()
{
  set(types::son_info_reply);
  return c.get<son_info_reply_s>();
}
protocol_ie_single_container_s<son_info_ext_ies_o>& son_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>();
}
void son_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_info_request:
      j.write_str("sONInformationRequest", "xn-TNL-configuration-info");
      break;
    case types::son_info_reply:
      j.write_fieldname("sONInformationReply");
      c.get<son_info_reply_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
  j.end_obj();
}
SRSASN_CODE son_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::son_info_request:
      HANDLE_CODE(c.get<son_info_request_e>().pack(bref));
      break;
    case types::son_info_reply:
      HANDLE_CODE(c.get<son_info_reply_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::son_info_request:
      HANDLE_CODE(c.get<son_info_request_e>().unpack(bref));
      break;
    case types::son_info_reply:
      HANDLE_CODE(c.get<son_info_reply_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* son_info_c::types_opts::to_string() const
{
  static const char* names[] = {"sONInformationRequest", "sONInformationReply", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "son_info_c::types");
}

// SourceRANNodeID ::= SEQUENCE
SRSASN_CODE source_ran_node_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ran_node_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void source_ran_node_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetRANNodeID-SON ::= SEQUENCE
SRSASN_CODE target_ran_node_id_son_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_son_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void target_ran_node_id_son_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// IntersystemSONConfigurationTransfer ::= SEQUENCE
SRSASN_CODE intersys_son_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(transfer_type.pack(bref));
  HANDLE_CODE(intersys_son_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(transfer_type.unpack(bref));
  HANDLE_CODE(intersys_son_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_son_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("transferType");
  transfer_type.to_json(j);
  j.write_fieldname("intersystemSONInformation");
  intersys_son_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONConfigurationTransfer ::= SEQUENCE
SRSASN_CODE son_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_son.pack(bref));
  HANDLE_CODE(source_ran_node_id.pack(bref));
  HANDLE_CODE(son_info.pack(bref));
  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE son_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_son.unpack(bref));
  HANDLE_CODE(source_ran_node_id.unpack(bref));
  HANDLE_CODE(son_info.unpack(bref));
  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void son_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("targetRANNodeID-SON");
  target_ran_node_id_son.to_json(j);
  j.write_fieldname("sourceRANNodeID");
  source_ran_node_id.to_json(j);
  j.write_fieldname("sONInformation");
  son_info.to_json(j);
  if (xn_tnl_cfg_info_present) {
    j.write_fieldname("xnTNLConfigurationInfo");
    xn_tnl_cfg_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FirstDLCount ::= SEQUENCE
SRSASN_CODE first_dl_count_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_subject_to_early_status_transfer, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE first_dl_count_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(drbs_subject_to_early_status_transfer, bref, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void first_dl_count_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dRBsSubjectToEarlyStatusTransfer");
  for (const auto& e1 : drbs_subject_to_early_status_transfer) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ProcedureStageChoice ::= CHOICE
void proc_stage_choice_c::destroy_()
{
  switch (type_) {
    case types::first_dl_count:
      c.destroy<first_dl_count_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void proc_stage_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::first_dl_count:
      c.init<first_dl_count_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }
}
proc_stage_choice_c::proc_stage_choice_c(const proc_stage_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::first_dl_count:
      c.init(other.c.get<first_dl_count_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }
}
proc_stage_choice_c& proc_stage_choice_c::operator=(const proc_stage_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::first_dl_count:
      c.set(other.c.get<first_dl_count_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }

  return *this;
}
first_dl_count_s& proc_stage_choice_c::set_first_dl_count()
{
  set(types::first_dl_count);
  return c.get<first_dl_count_s>();
}
protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>& proc_stage_choice_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>();
}
void proc_stage_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::first_dl_count:
      j.write_fieldname("first-dl-count");
      c.get<first_dl_count_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE proc_stage_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::first_dl_count:
      HANDLE_CODE(c.get<first_dl_count_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE proc_stage_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::first_dl_count:
      HANDLE_CODE(c.get<first_dl_count_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* proc_stage_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"first-dl-count", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "proc_stage_choice_c::types");
}

// EarlyStatusTransfer-TransparentContainer ::= SEQUENCE
SRSASN_CODE early_status_transfer_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(proc_stage.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE early_status_transfer_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(proc_stage.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void early_status_transfer_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("procedureStage");
  proc_stage.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RANStatusTransfer-TransparentContainer ::= SEQUENCE
SRSASN_CODE ran_status_transfer_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_subject_to_status_transfer_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_status_transfer_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(drbs_subject_to_status_transfer_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ran_status_transfer_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dRBsSubjectToStatusTransferList");
  for (const auto& e1 : drbs_subject_to_status_transfer_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RIMInformation ::= SEQUENCE
SRSASN_CODE rim_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_gnb_set_id.pack(bref));
  HANDLE_CODE(rim_rs_detection.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rim_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_gnb_set_id.unpack(bref));
  HANDLE_CODE(rim_rs_detection.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rim_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("targetgNBSetID", target_gnb_set_id.to_string());
  j.write_str("rIM-RSDetection", rim_rs_detection.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* rim_info_s::rim_rs_detection_opts::to_string() const
{
  static const char* names[] = {"rs-detected", "rs-disappeared"};
  return convert_enum_idx(names, 2, value, "rim_info_s::rim_rs_detection_e_");
}

// TargetRANNodeID-RIM ::= SEQUENCE
SRSASN_CODE target_ran_node_id_rim_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_rim_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_ran_node_id_rim_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RIMInformationTransfer ::= SEQUENCE
SRSASN_CODE rim_info_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_rim.pack(bref));
  HANDLE_CODE(source_ran_node_id.pack(bref));
  HANDLE_CODE(rim_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rim_info_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_rim.unpack(bref));
  HANDLE_CODE(source_ran_node_id.unpack(bref));
  HANDLE_CODE(rim_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rim_info_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("targetRANNodeID-RIM");
  target_ran_node_id_rim.to_json(j);
  j.write_fieldname("sourceRANNodeID");
  source_ran_node_id.to_json(j);
  j.write_fieldname("rIMInformation");
  rim_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DelayCritical ::= ENUMERATED
const char* delay_crit_opts::to_string() const
{
  static const char* names[] = {"delay-critical", "non-delay-critical"};
  return convert_enum_idx(names, 2, value, "delay_crit_e");
}

// Dynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {189, 187, 188};
  return map_enum_number(names, 3, idx, "id");
}
bool dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {189, 187, 188};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 189:
      return crit_e::ignore;
    case 187:
      return crit_e::ignore;
    case 188:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dyn_5qi_descriptor_ext_ies_o::ext_c dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 189:
      ret.set(ext_c::types::extended_packet_delay_budget);
      break;
    case 187:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 188:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 189:
      return presence_e::optional;
    case 187:
      return presence_e::optional;
    case 188:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::extended_packet_delay_budget:
      c = uint32_t{};
      break;
    case types::cn_packet_delay_budget_dl:
      c = uint32_t{};
      break;
    case types::cn_packet_delay_budget_ul:
      c = uint32_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget()
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget() const
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_packet_delay_budget:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dyn_5qi_descriptor_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..65535,...)", "INTEGER (1..65535,...)", "INTEGER (1..65535,...)"};
  return convert_enum_idx(names, 3, value, "dyn_5qi_descriptor_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<dyn_5qi_descriptor_ext_ies_o>;

SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_packet_delay_budget_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_packet_delay_budget_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)189, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_packet_delay_budget, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)187, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_dl, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)188, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_ul, (uint32_t)1u, (uint32_t)65535u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 189: {
        extended_packet_delay_budget_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_packet_delay_budget, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 187: {
        cn_packet_delay_budget_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_dl, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 188: {
        cn_packet_delay_budget_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_ul, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_packet_delay_budget_present) {
    j.write_int("id", 189);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", extended_packet_delay_budget);
  }
  if (cn_packet_delay_budget_dl_present) {
    j.write_int("id", 187);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_dl);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_int("id", 188);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_ul);
  }
  j.end_obj();
}

// Dynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_qi_present, 1));
  HANDLE_CODE(bref.pack(delay_crit_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level_qos, (uint8_t)1u, (uint8_t)127u, true, true));
  HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.pack(bref));
  if (five_qi_present) {
    HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.pack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_qi_present, 1));
  HANDLE_CODE(bref.unpack(delay_crit_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level_qos, bref, (uint8_t)1u, (uint8_t)127u, true, true));
  HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.unpack(bref));
  if (five_qi_present) {
    HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.unpack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevelQos", prio_level_qos);
  j.write_int("packetDelayBudget", packet_delay_budget);
  j.write_fieldname("packetErrorRate");
  packet_error_rate.to_json(j);
  if (five_qi_present) {
    j.write_int("fiveQI", five_qi);
  }
  if (delay_crit_present) {
    j.write_str("delayCritical", delay_crit.to_string());
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maximumDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DLForwarding ::= ENUMERATED
const char* dl_forwarding_opts::to_string() const
{
  static const char* names[] = {"dl-forwarding-proposed"};
  return convert_enum_idx(names, 1, value, "dl_forwarding_e");
}

// E-RABInformationItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t erab_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {284, 354};
  return map_enum_number(names, 2, idx, "id");
}
bool erab_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {284, 354};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 284:
      return crit_e::ignore;
    case 354:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
erab_info_item_ext_ies_o::ext_c erab_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 284:
      ret.set(ext_c::types::source_tnla_ddr_info);
      break;
    case 354:
      ret.set(ext_c::types::source_node_tnla_ddr_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e erab_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 284:
      return presence_e::optional;
    case 354:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void erab_info_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::source_tnla_ddr_info:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::source_node_tnla_ddr_info:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
  }
}
bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_tnla_ddr_info()
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info()
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_tnla_ddr_info() const
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info() const
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
void erab_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::source_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::source_node_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_info_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING"};
  return convert_enum_idx(names, 2, value, "erab_info_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<erab_info_item_ext_ies_o>;

SRSASN_CODE erab_info_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += source_tnla_ddr_info_present ? 1 : 0;
  nof_ies += source_node_tnla_ddr_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (source_tnla_ddr_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)284, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_tnla_ddr_info.pack(bref));
  }
  if (source_node_tnla_ddr_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)354, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_node_tnla_ddr_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 284: {
        source_tnla_ddr_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_tnla_ddr_info.unpack(bref));
        break;
      }
      case 354: {
        source_node_tnla_ddr_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_node_tnla_ddr_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void erab_info_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (source_tnla_ddr_info_present) {
    j.write_int("id", 284);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", source_tnla_ddr_info.to_string());
  }
  if (source_node_tnla_ddr_info_present) {
    j.write_int("id", 354);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", source_node_tnla_ddr_info.to_string());
  }
  j.end_obj();
}

// E-RABInformationItem ::= SEQUENCE
SRSASN_CODE erab_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  if (dl_forwarding_present) {
    j.write_str("dLForwarding", "dl-forwarding-proposed");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyFallbackRequestIndicator ::= ENUMERATED
const char* emergency_fallback_request_ind_opts::to_string() const
{
  static const char* names[] = {"emergency-fallback-requested"};
  return convert_enum_idx(names, 1, value, "emergency_fallback_request_ind_e");
}

// EmergencyServiceTargetCN ::= ENUMERATED
const char* emergency_service_target_cn_opts::to_string() const
{
  static const char* names[] = {"fiveGC", "epc"};
  return convert_enum_idx(names, 2, value, "emergency_service_target_cn_e");
}
uint8_t emergency_service_target_cn_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "emergency_service_target_cn_e");
}

// EmergencyFallbackIndicator ::= SEQUENCE
SRSASN_CODE emergency_fallback_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(emergency_service_target_cn_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_fallback_request_ind.pack(bref));
  if (emergency_service_target_cn_present) {
    HANDLE_CODE(emergency_service_target_cn.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_fallback_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(emergency_service_target_cn_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_fallback_request_ind.unpack(bref));
  if (emergency_service_target_cn_present) {
    HANDLE_CODE(emergency_service_target_cn.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_fallback_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyFallbackRequestIndicator", "emergency-fallback-requested");
  if (emergency_service_target_cn_present) {
    j.write_str("emergencyServiceTargetCN", emergency_service_target_cn.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveG-S-TMSI ::= SEQUENCE
SRSASN_CODE five_g_s_tmsi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_set_id.pack(bref));
  HANDLE_CODE(amf_pointer.pack(bref));
  HANDLE_CODE(five_g_tmsi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_s_tmsi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_set_id.unpack(bref));
  HANDLE_CODE(amf_pointer.unpack(bref));
  HANDLE_CODE(five_g_tmsi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_s_tmsi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("aMFSetID", amf_set_id.to_string());
  j.write_str("aMFPointer", amf_pointer.to_string());
  j.write_str("fiveG-TMSI", five_g_tmsi.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MeasurementThresholdL1LoggedMDT ::= CHOICE
void meas_thres_l1_logged_mdt_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void meas_thres_l1_logged_mdt_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::thres_rsrp:
      break;
    case types::thres_rsrq:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
}
meas_thres_l1_logged_mdt_c::meas_thres_l1_logged_mdt_c(const meas_thres_l1_logged_mdt_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::thres_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
}
meas_thres_l1_logged_mdt_c& meas_thres_l1_logged_mdt_c::operator=(const meas_thres_l1_logged_mdt_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::thres_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }

  return *this;
}
uint8_t& meas_thres_l1_logged_mdt_c::set_thres_rsrp()
{
  set(types::thres_rsrp);
  return c.get<uint8_t>();
}
uint8_t& meas_thres_l1_logged_mdt_c::set_thres_rsrq()
{
  set(types::thres_rsrq);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>& meas_thres_l1_logged_mdt_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>();
}
void meas_thres_l1_logged_mdt_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::thres_rsrp:
      j.write_int("threshold-RSRP", c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      j.write_int("threshold-RSRQ", c.get<uint8_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
  j.end_obj();
}
SRSASN_CODE meas_thres_l1_logged_mdt_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE meas_thres_l1_logged_mdt_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* meas_thres_l1_logged_mdt_c::types_opts::to_string() const
{
  static const char* names[] = {"threshold-RSRP", "threshold-RSRQ", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "meas_thres_l1_logged_mdt_c::types");
}

// TimeToTrigger ::= ENUMERATED
const char* time_to_trigger_opts::to_string() const
{
  static const char* names[] = {"ms0",
                                "ms40",
                                "ms64",
                                "ms80",
                                "ms100",
                                "ms128",
                                "ms160",
                                "ms256",
                                "ms320",
                                "ms480",
                                "ms512",
                                "ms640",
                                "ms1024",
                                "ms1280",
                                "ms2560",
                                "ms5120"};
  return convert_enum_idx(names, 16, value, "time_to_trigger_e");
}
uint16_t time_to_trigger_opts::to_number() const
{
  static const uint16_t numbers[] = {0, 40, 64, 80, 100, 128, 160, 256, 320, 480, 512, 640, 1024, 1280, 2560, 5120};
  return map_enum_number(numbers, 16, value, "time_to_trigger_e");
}

// EventL1LoggedMDTConfig ::= SEQUENCE
SRSASN_CODE event_l1_logged_mdt_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(l1_thres.pack(bref));
  HANDLE_CODE(pack_integer(bref, hysteresis, (uint8_t)0u, (uint8_t)30u, false, true));
  HANDLE_CODE(time_to_trigger.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_l1_logged_mdt_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(l1_thres.unpack(bref));
  HANDLE_CODE(unpack_integer(hysteresis, bref, (uint8_t)0u, (uint8_t)30u, false, true));
  HANDLE_CODE(time_to_trigger.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void event_l1_logged_mdt_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("l1Threshold");
  l1_thres.to_json(j);
  j.write_int("hysteresis", hysteresis);
  j.write_str("timeToTrigger", time_to_trigger.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EventTrigger ::= CHOICE
void event_trigger_c::destroy_()
{
  switch (type_) {
    case types::event_l1_logged_mdt_cfg:
      c.destroy<event_l1_logged_mdt_cfg_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<event_trigger_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void event_trigger_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::out_of_coverage:
      break;
    case types::event_l1_logged_mdt_cfg:
      c.init<event_l1_logged_mdt_cfg_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<event_trigger_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }
}
event_trigger_c::event_trigger_c(const event_trigger_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::out_of_coverage:
      c.init(other.c.get<out_of_coverage_e_>());
      break;
    case types::event_l1_logged_mdt_cfg:
      c.init(other.c.get<event_l1_logged_mdt_cfg_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }
}
event_trigger_c& event_trigger_c::operator=(const event_trigger_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::out_of_coverage:
      c.set(other.c.get<out_of_coverage_e_>());
      break;
    case types::event_l1_logged_mdt_cfg:
      c.set(other.c.get<event_l1_logged_mdt_cfg_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }

  return *this;
}
event_trigger_c::out_of_coverage_e_& event_trigger_c::set_out_of_coverage()
{
  set(types::out_of_coverage);
  return c.get<out_of_coverage_e_>();
}
event_l1_logged_mdt_cfg_s& event_trigger_c::set_event_l1_logged_mdt_cfg()
{
  set(types::event_l1_logged_mdt_cfg);
  return c.get<event_l1_logged_mdt_cfg_s>();
}
protocol_ie_single_container_s<event_trigger_ext_ies_o>& event_trigger_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>();
}
void event_trigger_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::out_of_coverage:
      j.write_str("outOfCoverage", "true");
      break;
    case types::event_l1_logged_mdt_cfg:
      j.write_fieldname("eventL1LoggedMDTConfig");
      c.get<event_l1_logged_mdt_cfg_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }
  j.end_obj();
}
SRSASN_CODE event_trigger_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::out_of_coverage:
      HANDLE_CODE(c.get<out_of_coverage_e_>().pack(bref));
      break;
    case types::event_l1_logged_mdt_cfg:
      HANDLE_CODE(c.get<event_l1_logged_mdt_cfg_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE event_trigger_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::out_of_coverage:
      HANDLE_CODE(c.get<out_of_coverage_e_>().unpack(bref));
      break;
    case types::event_l1_logged_mdt_cfg:
      HANDLE_CODE(c.get<event_l1_logged_mdt_cfg_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* event_trigger_c::out_of_coverage_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "event_trigger_c::out_of_coverage_e_");
}

const char* event_trigger_c::types_opts::to_string() const
{
  static const char* names[] = {"outOfCoverage", "eventL1LoggedMDTConfig", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "event_trigger_c::types");
}
uint8_t event_trigger_c::types_opts::to_number() const
{
  if (value == event_l1_logged_mdt_cfg) {
    return 1;
  }
  invalid_enum_number(value, "event_trigger_c::types");
  return 0;
}

// ExcessPacketDelayThresholdValue ::= ENUMERATED
const char* excess_packet_delay_thres_value_opts::to_string() const
{
  static const char* names[] = {"ms0dot25",
                                "ms0dot5",
                                "ms1",
                                "ms2",
                                "ms4",
                                "ms5",
                                "ms10",
                                "ms20",
                                "ms30",
                                "ms40",
                                "ms50",
                                "ms60",
                                "ms70",
                                "ms80",
                                "ms90",
                                "ms100",
                                "ms150",
                                "ms300",
                                "ms500"};
  return convert_enum_idx(names, 19, value, "excess_packet_delay_thres_value_e");
}
float excess_packet_delay_thres_value_opts::to_number() const
{
  static const float numbers[] = {
      0.25, 0.5, 1.0, 2.0, 4.0, 5.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 150.0, 300.0, 500.0};
  return map_enum_number(numbers, 19, value, "excess_packet_delay_thres_value_e");
}
const char* excess_packet_delay_thres_value_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25",
                                      "0.5",
                                      "1",
                                      "2",
                                      "4",
                                      "5",
                                      "10",
                                      "20",
                                      "30",
                                      "40",
                                      "50",
                                      "60",
                                      "70",
                                      "80",
                                      "90",
                                      "100",
                                      "150",
                                      "300",
                                      "500"};
  return convert_enum_idx(number_strs, 19, value, "excess_packet_delay_thres_value_e");
}

// ExcessPacketDelayThresholdItem ::= SEQUENCE
SRSASN_CODE excess_packet_delay_thres_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(excess_packet_delay_thres_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE excess_packet_delay_thres_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(excess_packet_delay_thres_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void excess_packet_delay_thres_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQi", five_qi);
  j.write_str("excessPacketDelayThresholdValue", excess_packet_delay_thres_value.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Extended-RANNodeName ::= SEQUENCE
SRSASN_CODE extended_ran_node_name_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ran_node_name_visible_string_present, 1));
  HANDLE_CODE(bref.pack(ran_node_name_utf8_string_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ran_node_name_visible_string_present) {
    HANDLE_CODE(ran_node_name_visible_string.pack(bref));
  }
  if (ran_node_name_utf8_string_present) {
    HANDLE_CODE(ran_node_name_utf8_string.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_ran_node_name_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ran_node_name_visible_string_present, 1));
  HANDLE_CODE(bref.unpack(ran_node_name_utf8_string_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ran_node_name_visible_string_present) {
    HANDLE_CODE(ran_node_name_visible_string.unpack(bref));
  }
  if (ran_node_name_utf8_string_present) {
    HANDLE_CODE(ran_node_name_utf8_string.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_ran_node_name_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ran_node_name_visible_string_present) {
    j.write_str("rANNodeNameVisibleString", ran_node_name_visible_string.to_string());
  }
  if (ran_node_name_utf8_string_present) {
    j.write_str("rANNodeNameUTF8String", ran_node_name_utf8_string.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveGProSeDirectCommunication ::= ENUMERATED
const char* five_g_pro_se_direct_communication_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_communication_e");
}

// FiveGProSeDirectDiscovery ::= ENUMERATED
const char* five_g_pro_se_direct_discovery_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_discovery_e");
}

// FiveGProSeLayer2RemoteUE ::= ENUMERATED
const char* five_g_pro_se_layer2_remote_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_remote_ue_e");
}

// FiveGProSeLayer2UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer2_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_ue_to_network_relay_e");
}

// FiveGProSeLayer3UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer3_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer3_ue_to_network_relay_e");
}

// FiveG-ProSeAuthorized ::= SEQUENCE
SRSASN_CODE five_g_pro_se_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_g_pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (five_g_pro_se_direct_discovery_present) {
    HANDLE_CODE(five_g_pro_se_direct_discovery.pack(bref));
  }
  if (five_g_pro_se_direct_communication_present) {
    HANDLE_CODE(five_g_pro_se_direct_communication.pack(bref));
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer2_ue_to_network_relay.pack(bref));
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer3_ue_to_network_relay.pack(bref));
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_g_pro_se_layer2_remote_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_g_pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (five_g_pro_se_direct_discovery_present) {
    HANDLE_CODE(five_g_pro_se_direct_discovery.unpack(bref));
  }
  if (five_g_pro_se_direct_communication_present) {
    HANDLE_CODE(five_g_pro_se_direct_communication.unpack(bref));
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer2_ue_to_network_relay.unpack(bref));
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer3_ue_to_network_relay.unpack(bref));
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_g_pro_se_layer2_remote_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (five_g_pro_se_direct_discovery_present) {
    j.write_str("fiveGProSeDirectDiscovery", five_g_pro_se_direct_discovery.to_string());
  }
  if (five_g_pro_se_direct_communication_present) {
    j.write_str("fiveGProSeDirectCommunication", five_g_pro_se_direct_communication.to_string());
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    j.write_str("fiveGProSeLayer2UEtoNetworkRelay", five_g_pro_se_layer2_ue_to_network_relay.to_string());
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    j.write_str("fiveGProSeLayer3UEtoNetworkRelay", five_g_pro_se_layer3_ue_to_network_relay.to_string());
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    j.write_str("fiveGProSeLayer2RemoteUE", five_g_pro_se_layer2_remote_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveGProSePC5FlowBitRates ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_flow_bit_rates_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(
      pack_integer(bref, five_gpro_seguaranteed_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, five_gpro_semax_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_flow_bit_rates_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(five_gpro_seguaranteed_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(five_gpro_semax_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_flow_bit_rates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveGproSeguaranteedFlowBitRate", five_gpro_seguaranteed_flow_bit_rate);
  j.write_int("fiveGproSemaximumFlowBitRate", five_gpro_semax_flow_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Range ::= ENUMERATED
const char* range_opts::to_string() const
{
  static const char* names[] = {"m50", "m80", "m180", "m200", "m350", "m400", "m500", "m700", "m1000"};
  return convert_enum_idx(names, 9, value, "range_e");
}
uint16_t range_opts::to_number() const
{
  static const uint16_t numbers[] = {50, 80, 180, 200, 350, 400, 500, 700, 1000};
  return map_enum_number(numbers, 9, value, "range_e");
}

// FiveGProSePC5QoSFlowItem ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_gpro_sepc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(five_gpro_serange_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_gpro_sep_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (five_gpro_sepc5_flow_bit_rates_present) {
    HANDLE_CODE(five_gpro_sepc5_flow_bit_rates.pack(bref));
  }
  if (five_gpro_serange_present) {
    HANDLE_CODE(five_gpro_serange.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_gpro_sepc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(five_gpro_serange_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_gpro_sep_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (five_gpro_sepc5_flow_bit_rates_present) {
    HANDLE_CODE(five_gpro_sepc5_flow_bit_rates.unpack(bref));
  }
  if (five_gpro_serange_present) {
    HANDLE_CODE(five_gpro_serange.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveGproSepQI", five_gpro_sep_qi);
  if (five_gpro_sepc5_flow_bit_rates_present) {
    j.write_fieldname("fiveGproSepc5FlowBitRates");
    five_gpro_sepc5_flow_bit_rates.to_json(j);
  }
  if (five_gpro_serange_present) {
    j.write_str("fiveGproSerange", five_gpro_serange.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveG-ProSePC5QoSParameters ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_g_pro_sepc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, five_g_pro_sepc5_qos_flow_list, 1, 2048, true));
  if (five_g_pro_sepc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(
        pack_integer(bref, five_g_pro_sepc5_link_aggr_bit_rates, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_g_pro_sepc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(five_g_pro_sepc5_qos_flow_list, bref, 1, 2048, true));
  if (five_g_pro_sepc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(
        unpack_integer(five_g_pro_sepc5_link_aggr_bit_rates, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("fiveGProSepc5QoSFlowList");
  for (const auto& e1 : five_g_pro_sepc5_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (five_g_pro_sepc5_link_aggr_bit_rates_present) {
    j.write_int("fiveGProSepc5LinkAggregateBitRates", five_g_pro_sepc5_link_aggr_bit_rates);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GBR-QosInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t gbr_qos_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {220};
  return map_enum_number(names, 1, idx, "id");
}
bool gbr_qos_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 220 == id;
}
crit_e gbr_qos_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 220) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
gbr_qos_info_ext_ies_o::ext_c gbr_qos_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 220) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gbr_qos_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 220) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void gbr_qos_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("AlternativeQoSParaSetList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE gbr_qos_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 8, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 8, true));
  return SRSASN_SUCCESS;
}

const char* gbr_qos_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AlternativeQoSParaSetList"};
  return convert_enum_idx(names, 1, value, "gbr_qos_info_ext_ies_o::ext_c::types");
}

// NotificationControl ::= ENUMERATED
const char* notif_ctrl_opts::to_string() const
{
  static const char* names[] = {"notification-requested"};
  return convert_enum_idx(names, 1, value, "notif_ctrl_e");
}

// GBR-QosInformation ::= SEQUENCE
SRSASN_CODE gbr_qos_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.pack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(max_packet_loss_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.pack(bref));
  }
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_dl, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_ul, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_ul_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(max_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.unpack(bref));
  }
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_dl, bref, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_ul, bref, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void gbr_qos_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("maximumFlowBitRateDL", max_flow_bit_rate_dl);
  j.write_int("maximumFlowBitRateUL", max_flow_bit_rate_ul);
  j.write_int("guaranteedFlowBitRateDL", guaranteed_flow_bit_rate_dl);
  j.write_int("guaranteedFlowBitRateUL", guaranteed_flow_bit_rate_ul);
  if (notif_ctrl_present) {
    j.write_str("notificationControl", "notification-requested");
  }
  if (max_packet_loss_rate_dl_present) {
    j.write_int("maximumPacketLossRateDL", max_packet_loss_rate_dl);
  }
  if (max_packet_loss_rate_ul_present) {
    j.write_int("maximumPacketLossRateUL", max_packet_loss_rate_ul);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// GlobalCable-ID-new ::= SEQUENCE
SRSASN_CODE global_cable_id_new_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_cable_id.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_cable_id_new_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_cable_id.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_cable_id_new_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("globalCable-ID", global_cable_id.to_string());
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalLine-ID-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t global_line_id_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool global_line_id_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e global_line_id_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
global_line_id_ext_ies_o::ext_c global_line_id_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e global_line_id_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void global_line_id_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE global_line_id_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_line_id_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* global_line_id_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "global_line_id_ext_ies_o::ext_c::types");
}

// LineType ::= ENUMERATED
const char* line_type_opts::to_string() const
{
  static const char* names[] = {"dsl", "pon"};
  return convert_enum_idx(names, 2, value, "line_type_e");
}

// GlobalLine-ID ::= SEQUENCE
SRSASN_CODE global_line_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(line_type_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(global_line_id.pack(bref));
  if (line_type_present) {
    HANDLE_CODE(line_type.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_line_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(line_type_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_line_id.unpack(bref));
  if (line_type_present) {
    HANDLE_CODE(line_type.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void global_line_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("globalLineIdentity", global_line_id.to_string());
  if (line_type_present) {
    j.write_str("lineType", line_type.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// HFCNode-ID-new ::= SEQUENCE
SRSASN_CODE hfc_node_id_new_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(hfc_node_id.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE hfc_node_id_new_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(hfc_node_id.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void hfc_node_id_new_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("hFCNode-ID", hfc_node_id.to_string());
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceHandoverItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_ho_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_cmd_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_ho_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_cmd_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_ho_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverCommandTransfer", ho_cmd_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceToReleaseItemHOCmd ::= SEQUENCE
SRSASN_CODE pdu_session_res_to_release_item_ho_cmd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_prep_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_release_item_ho_cmd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_prep_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_release_item_ho_cmd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverPreparationUnsuccessfulTransfer", ho_prep_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverType ::= ENUMERATED
const char* handov_type_opts::to_string() const
{
  static const char* names[] = {"intra5gs", "fivegs-to-eps", "eps-to-5gs", "fivegs-to-utran"};
  return convert_enum_idx(names, 4, value, "handov_type_e");
}

// QosFlowPerTNLInformation ::= SEQUENCE
SRSASN_CODE qos_flow_per_tnl_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(up_transport_layer_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, associated_qos_flow_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_per_tnl_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(up_transport_layer_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(associated_qos_flow_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_per_tnl_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uPTransportLayerInformation");
  up_transport_layer_info.to_json(j);
  j.start_array("associatedQosFlowList");
  for (const auto& e1 : associated_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportLayerInformationItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t up_transport_layer_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {166};
  return map_enum_number(names, 1, idx, "id");
}
bool up_transport_layer_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 166 == id;
}
crit_e up_transport_layer_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 166) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
up_transport_layer_info_item_ext_ies_o::ext_c up_transport_layer_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 166) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e up_transport_layer_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 166) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void up_transport_layer_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE up_transport_layer_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* up_transport_layer_info_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "up_transport_layer_info_item_ext_ies_o::ext_c::types");
}

// QosFlowPerTNLInformationItem ::= SEQUENCE
SRSASN_CODE qos_flow_per_tnl_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qos_flow_per_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_per_tnl_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qos_flow_per_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_per_tnl_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("qosFlowPerTNLInformation");
  qos_flow_per_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowWithCauseItem ::= SEQUENCE
SRSASN_CODE qos_flow_with_cause_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_with_cause_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_with_cause_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportLayerInformationItem ::= SEQUENCE
SRSASN_CODE up_transport_layer_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(ngu_up_tnl_info.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngu_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void up_transport_layer_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGU-UP-TNLInformation");
  ngu_up_tnl_info.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QosFlowToBeForwardedItem ::= SEQUENCE
SRSASN_CODE qos_flow_to_be_forwarded_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_to_be_forwarded_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_to_be_forwarded_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverCommandTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ho_cmd_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {152, 164, 172, 249, 283};
  return map_enum_number(names, 5, idx, "id");
}
bool ho_cmd_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {152, 164, 172, 249, 283};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cmd_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 152:
      return crit_e::ignore;
    case 164:
      return crit_e::reject;
    case 172:
      return crit_e::reject;
    case 249:
      return crit_e::ignore;
    case 283:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cmd_transfer_ext_ies_o::ext_c ho_cmd_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 152:
      ret.set(ext_c::types::add_dl_forwarding_up_tnl_info);
      break;
    case 164:
      ret.set(ext_c::types::ul_forwarding_up_tnl_info);
      break;
    case 172:
      ret.set(ext_c::types::add_ul_forwarding_up_tnl_info);
      break;
    case 249:
      ret.set(ext_c::types::data_forwarding_resp_erab_list);
      break;
    case 283:
      ret.set(ext_c::types::qos_flow_failed_to_setup_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cmd_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 152:
      return presence_e::optional;
    case 164:
      return presence_e::optional;
    case 172:
      return presence_e::optional;
    case 249:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ho_cmd_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      c = qos_flow_per_tnl_info_list_l{};
      break;
    case types::ul_forwarding_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c = up_transport_layer_info_list_l{};
      break;
    case types::data_forwarding_resp_erab_list:
      c = data_forwarding_resp_erab_list_l{};
      break;
    case types::qos_flow_failed_to_setup_list:
      c = qos_flow_list_with_cause_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
  }
}
qos_flow_per_tnl_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_dl_forwarding_up_tnl_info()
{
  assert_choice_type(types::add_dl_forwarding_up_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
up_transport_layer_info_c& ho_cmd_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
data_forwarding_resp_erab_list_l& ho_cmd_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list()
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
qos_flow_list_with_cause_l& ho_cmd_transfer_ext_ies_o::ext_c::qos_flow_failed_to_setup_list()
{
  assert_choice_type(types::qos_flow_failed_to_setup_list, type_, "Extension");
  return c.get<qos_flow_list_with_cause_l>();
}
const qos_flow_per_tnl_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_dl_forwarding_up_tnl_info() const
{
  assert_choice_type(types::add_dl_forwarding_up_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const up_transport_layer_info_c& ho_cmd_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
const data_forwarding_resp_erab_list_l& ho_cmd_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list() const
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
const qos_flow_list_with_cause_l& ho_cmd_transfer_ext_ies_o::ext_c::qos_flow_failed_to_setup_list() const
{
  assert_choice_type(types::qos_flow_failed_to_setup_list, type_, "Extension");
  return c.get<qos_flow_list_with_cause_l>();
}
void ho_cmd_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ul_forwarding_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_ul_forwarding_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::data_forwarding_resp_erab_list:
      j.start_array("DataForwardingResponseERABList");
      for (const auto& e1 : c.get<data_forwarding_resp_erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flow_failed_to_setup_list:
      j.start_array("QosFlowListWithCause");
      for (const auto& e1 : c.get<qos_flow_list_with_cause_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cmd_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<data_forwarding_resp_erab_list_l>(), 1, 256, true));
      break;
    case types::qos_flow_failed_to_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_list_with_cause_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<data_forwarding_resp_erab_list_l>(), bref, 1, 256, true));
      break;
    case types::qos_flow_failed_to_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_list_with_cause_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cmd_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosFlowPerTNLInformationList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "DataForwardingResponseERABList",
                                "QosFlowListWithCause"};
  return convert_enum_idx(names, 5, value, "ho_cmd_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<ho_cmd_transfer_ext_ies_o>;

SRSASN_CODE ho_cmd_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dl_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += add_ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += data_forwarding_resp_erab_list_present ? 1 : 0;
  nof_ies += qos_flow_failed_to_setup_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)152, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_forwarding_up_tnl_info, 1, 3, true));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)164, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_forwarding_up_tnl_info.pack(bref));
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)172, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ul_forwarding_up_tnl_info, 1, 3, true));
  }
  if (data_forwarding_resp_erab_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)249, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_resp_erab_list, 1, 256, true));
  }
  if (qos_flow_failed_to_setup_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)283, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_setup_list, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 152: {
        add_dl_forwarding_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_dl_forwarding_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 164: {
        ul_forwarding_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_forwarding_up_tnl_info.unpack(bref));
        break;
      }
      case 172: {
        add_ul_forwarding_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_ul_forwarding_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 249: {
        data_forwarding_resp_erab_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_resp_erab_list, bref, 1, 256, true));
        break;
      }
      case 283: {
        qos_flow_failed_to_setup_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_setup_list, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ho_cmd_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dl_forwarding_up_tnl_info_present) {
    j.write_int("id", 152);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_dl_forwarding_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ul_forwarding_up_tnl_info_present) {
    j.write_int("id", 164);
    j.write_str("criticality", "reject");
    ul_forwarding_up_tnl_info.to_json(j);
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    j.write_int("id", 172);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : add_ul_forwarding_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_resp_erab_list_present) {
    j.write_int("id", 249);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : data_forwarding_resp_erab_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_failed_to_setup_list_present) {
    j.write_int("id", 283);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : qos_flow_failed_to_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// HandoverCommandTransfer ::= SEQUENCE
SRSASN_CODE ho_cmd_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_to_be_forwarded_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(data_forwarding_resp_drb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  }
  if (qos_flow_to_be_forwarded_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_to_be_forwarded_list, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_resp_drb_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_up_tnl_info_present, 1));
  bool qos_flow_to_be_forwarded_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_to_be_forwarded_list_present, 1));
  bool data_forwarding_resp_drb_list_present;
  HANDLE_CODE(bref.unpack(data_forwarding_resp_drb_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (qos_flow_to_be_forwarded_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_to_be_forwarded_list, bref, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_resp_drb_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_cmd_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("dLForwardingUP-TNLInformation");
    dl_forwarding_up_tnl_info.to_json(j);
  }
  if (qos_flow_to_be_forwarded_list.size() > 0) {
    j.start_array("qosFlowToBeForwardedList");
    for (const auto& e1 : qos_flow_to_be_forwarded_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    j.start_array("dataForwardingResponseDRBList");
    for (const auto& e1 : data_forwarding_resp_drb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRNTNTAIInformation ::= SEQUENCE
SRSASN_CODE nr_ntn_tai_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_location_derived_tac_in_nr_ntn_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, tac_list_in_nr_ntn, 1, 12, true));
  if (ue_location_derived_tac_in_nr_ntn_present) {
    HANDLE_CODE(ue_location_derived_tac_in_nr_ntn.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_ntn_tai_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_location_derived_tac_in_nr_ntn_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(tac_list_in_nr_ntn, bref, 1, 12, true));
  if (ue_location_derived_tac_in_nr_ntn_present) {
    HANDLE_CODE(ue_location_derived_tac_in_nr_ntn.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_ntn_tai_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("servingPLMN", serving_plmn.to_string());
  j.start_array("tACListInNRNTN");
  for (const auto& e1 : tac_list_in_nr_ntn) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ue_location_derived_tac_in_nr_ntn_present) {
    j.write_str("uELocationDerivedTACInNRNTN", ue_location_derived_tac_in_nr_ntn.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UserLocationInformationTNGF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_tngf_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_tngf_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e user_location_info_tngf_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_tngf_ext_ies_o::ext_c user_location_info_tngf_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_tngf_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_tngf_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_tngf_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_tngf_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_tngf_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "user_location_info_tngf_ext_ies_o::ext_c::types");
}

// UserLocationInformationTWIF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_twif_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_twif_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e user_location_info_twif_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_twif_ext_ies_o::ext_c user_location_info_twif_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_twif_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_twif_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_twif_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_twif_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_twif_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "user_location_info_twif_ext_ies_o::ext_c::types");
}

// UserLocationInformationW-AGF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t user_location_info_w_agf_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {275, 362, 363};
  return map_enum_number(names, 3, idx, "id");
}
bool user_location_info_w_agf_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {275, 362, 363};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e user_location_info_w_agf_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 275:
      return crit_e::ignore;
    case 362:
      return crit_e::ignore;
    case 363:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
user_location_info_w_agf_ext_ies_o::value_c user_location_info_w_agf_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 275:
      ret.set(value_c::types::global_cable_id);
      break;
    case 362:
      ret.set(value_c::types::hfc_node_id_new);
      break;
    case 363:
      ret.set(value_c::types::global_cable_id_new);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_w_agf_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 275:
      return presence_e::mandatory;
    case 362:
      return presence_e::mandatory;
    case 363:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void user_location_info_w_agf_ext_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::global_cable_id:
      c = unbounded_octstring<true>{};
      break;
    case types::hfc_node_id_new:
      c = hfc_node_id_new_s{};
      break;
    case types::global_cable_id_new:
      c = global_cable_id_new_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
  }
}
unbounded_octstring<true>& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id()
{
  assert_choice_type(types::global_cable_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
hfc_node_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::hfc_node_id_new()
{
  assert_choice_type(types::hfc_node_id_new, type_, "Value");
  return c.get<hfc_node_id_new_s>();
}
global_cable_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id_new()
{
  assert_choice_type(types::global_cable_id_new, type_, "Value");
  return c.get<global_cable_id_new_s>();
}
const unbounded_octstring<true>& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id() const
{
  assert_choice_type(types::global_cable_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const hfc_node_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::hfc_node_id_new() const
{
  assert_choice_type(types::hfc_node_id_new, type_, "Value");
  return c.get<hfc_node_id_new_s>();
}
const global_cable_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id_new() const
{
  assert_choice_type(types::global_cable_id_new, type_, "Value");
  return c.get<global_cable_id_new_s>();
}
void user_location_info_w_agf_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_cable_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::hfc_node_id_new:
      j.write_fieldname("HFCNode-ID-new");
      c.get<hfc_node_id_new_s>().to_json(j);
      break;
    case types::global_cable_id_new:
      j.write_fieldname("GlobalCable-ID-new");
      c.get<global_cable_id_new_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_w_agf_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_cable_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::hfc_node_id_new:
      HANDLE_CODE(c.get<hfc_node_id_new_s>().pack(bref));
      break;
    case types::global_cable_id_new:
      HANDLE_CODE(c.get<global_cable_id_new_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_w_agf_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_cable_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::hfc_node_id_new:
      HANDLE_CODE(c.get<hfc_node_id_new_s>().unpack(bref));
      break;
    case types::global_cable_id_new:
      HANDLE_CODE(c.get<global_cable_id_new_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_w_agf_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "HFCNode-ID-new", "GlobalCable-ID-new"};
  return convert_enum_idx(names, 3, value, "user_location_info_w_agf_ext_ies_o::value_c::types");
}

// UserLocationInformationEUTRA-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_eutra_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {149};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_eutra_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 149 == id;
}
crit_e user_location_info_eutra_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 149) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_eutra_ext_ies_o::ext_c user_location_info_eutra_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 149) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_eutra_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 149) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_eutra_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("NGRAN-CGI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_eutra_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_eutra_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_eutra_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NGRAN-CGI"};
  return convert_enum_idx(names, 1, value, "user_location_info_eutra_ext_ies_o::ext_c::types");
}

// UserLocationInformationN3IWF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_n3_iwf_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_n3_iwf_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e user_location_info_n3_iwf_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_n3_iwf_ext_ies_o::ext_c user_location_info_n3_iwf_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_n3_iwf_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_n3_iwf_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_n3_iwf_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_n3_iwf_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_n3_iwf_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "user_location_info_n3_iwf_ext_ies_o::ext_c::types");
}

// UserLocationInformationNR-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_nr_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {149, 263, 287};
  return map_enum_number(names, 3, idx, "id");
}
bool user_location_info_nr_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {149, 263, 287};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e user_location_info_nr_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 149:
      return crit_e::ignore;
    case 263:
      return crit_e::reject;
    case 287:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
user_location_info_nr_ext_ies_o::ext_c user_location_info_nr_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 149:
      ret.set(ext_c::types::pscell_info);
      break;
    case 263:
      ret.set(ext_c::types::n_id);
      break;
    case 287:
      ret.set(ext_c::types::nr_ntn_tai_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_nr_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 149:
      return presence_e::optional;
    case 263:
      return presence_e::optional;
    case 287:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_nr_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::pscell_info:
      c = ngran_cgi_c{};
      break;
    case types::n_id:
      c = fixed_bitstring<44, false, true>{};
      break;
    case types::nr_ntn_tai_info:
      c = nr_ntn_tai_info_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
  }
}
ngran_cgi_c& user_location_info_nr_ext_ies_o::ext_c::pscell_info()
{
  assert_choice_type(types::pscell_info, type_, "Extension");
  return c.get<ngran_cgi_c>();
}
fixed_bitstring<44, false, true>& user_location_info_nr_ext_ies_o::ext_c::n_id()
{
  assert_choice_type(types::n_id, type_, "Extension");
  return c.get<fixed_bitstring<44, false, true>>();
}
nr_ntn_tai_info_s& user_location_info_nr_ext_ies_o::ext_c::nr_ntn_tai_info()
{
  assert_choice_type(types::nr_ntn_tai_info, type_, "Extension");
  return c.get<nr_ntn_tai_info_s>();
}
const ngran_cgi_c& user_location_info_nr_ext_ies_o::ext_c::pscell_info() const
{
  assert_choice_type(types::pscell_info, type_, "Extension");
  return c.get<ngran_cgi_c>();
}
const fixed_bitstring<44, false, true>& user_location_info_nr_ext_ies_o::ext_c::n_id() const
{
  assert_choice_type(types::n_id, type_, "Extension");
  return c.get<fixed_bitstring<44, false, true>>();
}
const nr_ntn_tai_info_s& user_location_info_nr_ext_ies_o::ext_c::nr_ntn_tai_info() const
{
  assert_choice_type(types::nr_ntn_tai_info, type_, "Extension");
  return c.get<nr_ntn_tai_info_s>();
}
void user_location_info_nr_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pscell_info:
      j.write_fieldname("NGRAN-CGI");
      c.get<ngran_cgi_c>().to_json(j);
      break;
    case types::n_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<44, false, true>>().to_string());
      break;
    case types::nr_ntn_tai_info:
      j.write_fieldname("NRNTNTAIInformation");
      c.get<nr_ntn_tai_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_nr_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pscell_info:
      HANDLE_CODE(c.get<ngran_cgi_c>().pack(bref));
      break;
    case types::n_id:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().pack(bref)));
      break;
    case types::nr_ntn_tai_info:
      HANDLE_CODE(c.get<nr_ntn_tai_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_nr_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pscell_info:
      HANDLE_CODE(c.get<ngran_cgi_c>().unpack(bref));
      break;
    case types::n_id:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().unpack(bref)));
      break;
    case types::nr_ntn_tai_info:
      HANDLE_CODE(c.get<nr_ntn_tai_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_nr_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NGRAN-CGI", "BIT STRING", "NRNTNTAIInformation"};
  return convert_enum_idx(names, 3, value, "user_location_info_nr_ext_ies_o::ext_c::types");
}

// UserLocationInformationTNGF ::= SEQUENCE
SRSASN_CODE user_location_info_tngf_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(port_num_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(tnap_id.pack(bref));
  HANDLE_CODE(ip_address.pack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_tngf_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(port_num_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnap_id.unpack(bref));
  HANDLE_CODE(ip_address.unpack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_tngf_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tNAP-ID", tnap_id.to_string());
  j.write_str("iPAddress", ip_address.to_string());
  if (port_num_present) {
    j.write_str("portNumber", port_num.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UserLocationInformationTWIF ::= SEQUENCE
SRSASN_CODE user_location_info_twif_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(port_num_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(twap_id.pack(bref));
  HANDLE_CODE(ip_address.pack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_twif_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(port_num_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(twap_id.unpack(bref));
  HANDLE_CODE(ip_address.unpack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_twif_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tWAP-ID", twap_id.to_string());
  j.write_str("iPAddress", ip_address.to_string());
  if (port_num_present) {
    j.write_str("portNumber", port_num.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>;

// UserLocationInformationW-AGF ::= CHOICE
void user_location_info_w_agf_c::destroy_()
{
  switch (type_) {
    case types::global_line_id:
      c.destroy<global_line_id_s>();
      break;
    case types::hfc_node_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void user_location_info_w_agf_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_line_id:
      c.init<global_line_id_s>();
      break;
    case types::hfc_node_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }
}
user_location_info_w_agf_c::user_location_info_w_agf_c(const user_location_info_w_agf_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_line_id:
      c.init(other.c.get<global_line_id_s>());
      break;
    case types::hfc_node_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }
}
user_location_info_w_agf_c& user_location_info_w_agf_c::operator=(const user_location_info_w_agf_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_line_id:
      c.set(other.c.get<global_line_id_s>());
      break;
    case types::hfc_node_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }

  return *this;
}
global_line_id_s& user_location_info_w_agf_c::set_global_line_id()
{
  set(types::global_line_id);
  return c.get<global_line_id_s>();
}
unbounded_octstring<true>& user_location_info_w_agf_c::set_hfc_node_id()
{
  set(types::hfc_node_id);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>& user_location_info_w_agf_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>();
}
void user_location_info_w_agf_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_line_id:
      j.write_fieldname("globalLine-ID");
      c.get<global_line_id_s>().to_json(j);
      break;
    case types::hfc_node_id:
      j.write_str("hFCNode-ID", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_w_agf_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::global_line_id:
      HANDLE_CODE(c.get<global_line_id_s>().pack(bref));
      break;
    case types::hfc_node_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_w_agf_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::global_line_id:
      HANDLE_CODE(c.get<global_line_id_s>().unpack(bref));
      break;
    case types::hfc_node_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_w_agf_c::types_opts::to_string() const
{
  static const char* names[] = {"globalLine-ID", "hFCNode-ID", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "user_location_info_w_agf_c::types");
}

// UserLocationInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t user_location_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {244, 248, 243};
  return map_enum_number(names, 3, idx, "id");
}
bool user_location_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {244, 248, 243};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e user_location_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 244:
      return crit_e::ignore;
    case 248:
      return crit_e::ignore;
    case 243:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
user_location_info_ext_ies_o::value_c user_location_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 244:
      ret.set(value_c::types::user_location_info_tngf);
      break;
    case 248:
      ret.set(value_c::types::user_location_info_twif);
      break;
    case 243:
      ret.set(value_c::types::user_location_info_w_agf);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 244:
      return presence_e::mandatory;
    case 248:
      return presence_e::mandatory;
    case 243:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void user_location_info_ext_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::user_location_info_tngf:
      c = user_location_info_tngf_s{};
      break;
    case types::user_location_info_twif:
      c = user_location_info_twif_s{};
      break;
    case types::user_location_info_w_agf:
      c = user_location_info_w_agf_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
  }
}
user_location_info_tngf_s& user_location_info_ext_ies_o::value_c::user_location_info_tngf()
{
  assert_choice_type(types::user_location_info_tngf, type_, "Value");
  return c.get<user_location_info_tngf_s>();
}
user_location_info_twif_s& user_location_info_ext_ies_o::value_c::user_location_info_twif()
{
  assert_choice_type(types::user_location_info_twif, type_, "Value");
  return c.get<user_location_info_twif_s>();
}
user_location_info_w_agf_c& user_location_info_ext_ies_o::value_c::user_location_info_w_agf()
{
  assert_choice_type(types::user_location_info_w_agf, type_, "Value");
  return c.get<user_location_info_w_agf_c>();
}
const user_location_info_tngf_s& user_location_info_ext_ies_o::value_c::user_location_info_tngf() const
{
  assert_choice_type(types::user_location_info_tngf, type_, "Value");
  return c.get<user_location_info_tngf_s>();
}
const user_location_info_twif_s& user_location_info_ext_ies_o::value_c::user_location_info_twif() const
{
  assert_choice_type(types::user_location_info_twif, type_, "Value");
  return c.get<user_location_info_twif_s>();
}
const user_location_info_w_agf_c& user_location_info_ext_ies_o::value_c::user_location_info_w_agf() const
{
  assert_choice_type(types::user_location_info_w_agf, type_, "Value");
  return c.get<user_location_info_w_agf_c>();
}
void user_location_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::user_location_info_tngf:
      j.write_fieldname("UserLocationInformationTNGF");
      c.get<user_location_info_tngf_s>().to_json(j);
      break;
    case types::user_location_info_twif:
      j.write_fieldname("UserLocationInformationTWIF");
      c.get<user_location_info_twif_s>().to_json(j);
      break;
    case types::user_location_info_w_agf:
      j.write_fieldname("UserLocationInformationW-AGF");
      c.get<user_location_info_w_agf_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::user_location_info_tngf:
      HANDLE_CODE(c.get<user_location_info_tngf_s>().pack(bref));
      break;
    case types::user_location_info_twif:
      HANDLE_CODE(c.get<user_location_info_twif_s>().pack(bref));
      break;
    case types::user_location_info_w_agf:
      HANDLE_CODE(c.get<user_location_info_w_agf_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::user_location_info_tngf:
      HANDLE_CODE(c.get<user_location_info_tngf_s>().unpack(bref));
      break;
    case types::user_location_info_twif:
      HANDLE_CODE(c.get<user_location_info_twif_s>().unpack(bref));
      break;
    case types::user_location_info_w_agf:
      HANDLE_CODE(c.get<user_location_info_w_agf_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "UserLocationInformationTNGF", "UserLocationInformationTWIF", "UserLocationInformationW-AGF"};
  return convert_enum_idx(names, 3, value, "user_location_info_ext_ies_o::value_c::types");
}

// UserLocationInformationEUTRA ::= SEQUENCE
SRSASN_CODE user_location_info_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stamp_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stamp_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (time_stamp_present) {
    j.write_str("timeStamp", time_stamp.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UserLocationInformationN3IWF ::= SEQUENCE
SRSASN_CODE user_location_info_n3_iwf_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(ip_address.pack(bref));
  HANDLE_CODE(port_num.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_n3_iwf_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ip_address.unpack(bref));
  HANDLE_CODE(port_num.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_n3_iwf_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iPAddress", ip_address.to_string());
  j.write_str("portNumber", port_num.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<user_location_info_nr_ext_ies_o>;

SRSASN_CODE user_location_info_nr_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += pscell_info_present ? 1 : 0;
  nof_ies += n_id_present ? 1 : 0;
  nof_ies += nr_ntn_tai_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (pscell_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)149, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pscell_info.pack(bref));
  }
  if (n_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)263, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(n_id.pack(bref));
  }
  if (nr_ntn_tai_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)287, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ntn_tai_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_nr_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 149: {
        pscell_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pscell_info.unpack(bref));
        break;
      }
      case 263: {
        n_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(n_id.unpack(bref));
        break;
      }
      case 287: {
        nr_ntn_tai_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ntn_tai_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void user_location_info_nr_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pscell_info_present) {
    j.write_int("id", 149);
    j.write_str("criticality", "ignore");
    pscell_info.to_json(j);
  }
  if (n_id_present) {
    j.write_int("id", 263);
    j.write_str("criticality", "reject");
    j.write_str("Extension", n_id.to_string());
  }
  if (nr_ntn_tai_info_present) {
    j.write_int("id", 287);
    j.write_str("criticality", "ignore");
    nr_ntn_tai_info.to_json(j);
  }
  j.end_obj();
}

// UserLocationInformationNR ::= SEQUENCE
SRSASN_CODE user_location_info_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stamp_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stamp_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (time_stamp_present) {
    j.write_str("timeStamp", time_stamp.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NotifySourceNGRANNode ::= ENUMERATED
const char* notify_source_ngran_node_opts::to_string() const
{
  static const char* names[] = {"notifySource"};
  return convert_enum_idx(names, 1, value, "notify_source_ngran_node_e");
}

template struct asn1::protocol_ie_single_container_s<user_location_info_ext_ies_o>;

// UserLocationInformation ::= CHOICE
void user_location_info_c::destroy_()
{
  switch (type_) {
    case types::user_location_info_eutra:
      c.destroy<user_location_info_eutra_s>();
      break;
    case types::user_location_info_nr:
      c.destroy<user_location_info_nr_s>();
      break;
    case types::user_location_info_n3_iwf:
      c.destroy<user_location_info_n3_iwf_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<user_location_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void user_location_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::user_location_info_eutra:
      c.init<user_location_info_eutra_s>();
      break;
    case types::user_location_info_nr:
      c.init<user_location_info_nr_s>();
      break;
    case types::user_location_info_n3_iwf:
      c.init<user_location_info_n3_iwf_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<user_location_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }
}
user_location_info_c::user_location_info_c(const user_location_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::user_location_info_eutra:
      c.init(other.c.get<user_location_info_eutra_s>());
      break;
    case types::user_location_info_nr:
      c.init(other.c.get<user_location_info_nr_s>());
      break;
    case types::user_location_info_n3_iwf:
      c.init(other.c.get<user_location_info_n3_iwf_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }
}
user_location_info_c& user_location_info_c::operator=(const user_location_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::user_location_info_eutra:
      c.set(other.c.get<user_location_info_eutra_s>());
      break;
    case types::user_location_info_nr:
      c.set(other.c.get<user_location_info_nr_s>());
      break;
    case types::user_location_info_n3_iwf:
      c.set(other.c.get<user_location_info_n3_iwf_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }

  return *this;
}
user_location_info_eutra_s& user_location_info_c::set_user_location_info_eutra()
{
  set(types::user_location_info_eutra);
  return c.get<user_location_info_eutra_s>();
}
user_location_info_nr_s& user_location_info_c::set_user_location_info_nr()
{
  set(types::user_location_info_nr);
  return c.get<user_location_info_nr_s>();
}
user_location_info_n3_iwf_s& user_location_info_c::set_user_location_info_n3_iwf()
{
  set(types::user_location_info_n3_iwf);
  return c.get<user_location_info_n3_iwf_s>();
}
protocol_ie_single_container_s<user_location_info_ext_ies_o>& user_location_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>();
}
void user_location_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::user_location_info_eutra:
      j.write_fieldname("userLocationInformationEUTRA");
      c.get<user_location_info_eutra_s>().to_json(j);
      break;
    case types::user_location_info_nr:
      j.write_fieldname("userLocationInformationNR");
      c.get<user_location_info_nr_s>().to_json(j);
      break;
    case types::user_location_info_n3_iwf:
      j.write_fieldname("userLocationInformationN3IWF");
      c.get<user_location_info_n3_iwf_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::user_location_info_eutra:
      HANDLE_CODE(c.get<user_location_info_eutra_s>().pack(bref));
      break;
    case types::user_location_info_nr:
      HANDLE_CODE(c.get<user_location_info_nr_s>().pack(bref));
      break;
    case types::user_location_info_n3_iwf:
      HANDLE_CODE(c.get<user_location_info_n3_iwf_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::user_location_info_eutra:
      HANDLE_CODE(c.get<user_location_info_eutra_s>().unpack(bref));
      break;
    case types::user_location_info_nr:
      HANDLE_CODE(c.get<user_location_info_nr_s>().unpack(bref));
      break;
    case types::user_location_info_n3_iwf:
      HANDLE_CODE(c.get<user_location_info_n3_iwf_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_c::types_opts::to_string() const
{
  static const char* names[] = {
      "userLocationInformationEUTRA", "userLocationInformationNR", "userLocationInformationN3IWF", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "user_location_info_c::types");
}
uint8_t user_location_info_c::types_opts::to_number() const
{
  if (value == user_location_info_n3_iwf) {
    return 3;
  }
  invalid_enum_number(value, "user_location_info_c::types");
  return 0;
}

// HandoverPreparationUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE ho_prep_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_prep_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExtendedReportIntervalMDT ::= ENUMERATED
const char* extended_report_interv_mdt_opts::to_string() const
{
  static const char* names[] = {"ms20480", "ms40960"};
  return convert_enum_idx(names, 2, value, "extended_report_interv_mdt_e");
}
uint16_t extended_report_interv_mdt_opts::to_number() const
{
  static const uint16_t numbers[] = {20480, 40960};
  return map_enum_number(numbers, 2, value, "extended_report_interv_mdt_e");
}

// SensorNameConfig ::= CHOICE
void sensor_name_cfg_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void sensor_name_cfg_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      break;
    case types::ue_speed_cfg:
      break;
    case types::ue_orientation_cfg:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }
}
sensor_name_cfg_c::sensor_name_cfg_c(const sensor_name_cfg_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      c.init(other.c.get<uncompensated_barometric_cfg_e_>());
      break;
    case types::ue_speed_cfg:
      c.init(other.c.get<ue_speed_cfg_e_>());
      break;
    case types::ue_orientation_cfg:
      c.init(other.c.get<ue_orientation_cfg_e_>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }
}
sensor_name_cfg_c& sensor_name_cfg_c::operator=(const sensor_name_cfg_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      c.set(other.c.get<uncompensated_barometric_cfg_e_>());
      break;
    case types::ue_speed_cfg:
      c.set(other.c.get<ue_speed_cfg_e_>());
      break;
    case types::ue_orientation_cfg:
      c.set(other.c.get<ue_orientation_cfg_e_>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }

  return *this;
}
sensor_name_cfg_c::uncompensated_barometric_cfg_e_& sensor_name_cfg_c::set_uncompensated_barometric_cfg()
{
  set(types::uncompensated_barometric_cfg);
  return c.get<uncompensated_barometric_cfg_e_>();
}
sensor_name_cfg_c::ue_speed_cfg_e_& sensor_name_cfg_c::set_ue_speed_cfg()
{
  set(types::ue_speed_cfg);
  return c.get<ue_speed_cfg_e_>();
}
sensor_name_cfg_c::ue_orientation_cfg_e_& sensor_name_cfg_c::set_ue_orientation_cfg()
{
  set(types::ue_orientation_cfg);
  return c.get<ue_orientation_cfg_e_>();
}
protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>& sensor_name_cfg_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>();
}
void sensor_name_cfg_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      j.write_str("uncompensatedBarometricConfig", "true");
      break;
    case types::ue_speed_cfg:
      j.write_str("ueSpeedConfig", "true");
      break;
    case types::ue_orientation_cfg:
      j.write_str("ueOrientationConfig", "true");
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }
  j.end_obj();
}
SRSASN_CODE sensor_name_cfg_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      HANDLE_CODE(c.get<uncompensated_barometric_cfg_e_>().pack(bref));
      break;
    case types::ue_speed_cfg:
      HANDLE_CODE(c.get<ue_speed_cfg_e_>().pack(bref));
      break;
    case types::ue_orientation_cfg:
      HANDLE_CODE(c.get<ue_orientation_cfg_e_>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_name_cfg_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      HANDLE_CODE(c.get<uncompensated_barometric_cfg_e_>().unpack(bref));
      break;
    case types::ue_speed_cfg:
      HANDLE_CODE(c.get<ue_speed_cfg_e_>().unpack(bref));
      break;
    case types::ue_orientation_cfg:
      HANDLE_CODE(c.get<ue_orientation_cfg_e_>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* sensor_name_cfg_c::uncompensated_barometric_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_cfg_c::uncompensated_barometric_cfg_e_");
}

const char* sensor_name_cfg_c::ue_speed_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_cfg_c::ue_speed_cfg_e_");
}

const char* sensor_name_cfg_c::ue_orientation_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_cfg_c::ue_orientation_cfg_e_");
}

const char* sensor_name_cfg_c::types_opts::to_string() const
{
  static const char* names[] = {
      "uncompensatedBarometricConfig", "ueSpeedConfig", "ueOrientationConfig", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "sensor_name_cfg_c::types");
}

// IncludeBeamMeasurementsIndication ::= ENUMERATED
const char* include_beam_meass_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "include_beam_meass_ind_e");
}

// M1PeriodicReporting-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m1_periodic_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {285};
  return map_enum_number(names, 1, idx, "id");
}
bool m1_periodic_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 285 == id;
}
crit_e m1_periodic_report_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 285) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m1_periodic_report_ext_ies_o::ext_c m1_periodic_report_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 285) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m1_periodic_report_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 285) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m1_periodic_report_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ExtendedReportIntervalMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m1_periodic_report_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_periodic_report_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m1_periodic_report_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExtendedReportIntervalMDT"};
  return convert_enum_idx(names, 1, value, "m1_periodic_report_ext_ies_o::ext_c::types");
}

// M1ThresholdType ::= CHOICE
void m1_thres_type_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void m1_thres_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::thres_rsrp:
      break;
    case types::thres_rsrq:
      break;
    case types::thres_sinr:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }
}
m1_thres_type_c::m1_thres_type_c(const m1_thres_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::thres_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_sinr:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }
}
m1_thres_type_c& m1_thres_type_c::operator=(const m1_thres_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::thres_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_sinr:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }

  return *this;
}
uint8_t& m1_thres_type_c::set_thres_rsrp()
{
  set(types::thres_rsrp);
  return c.get<uint8_t>();
}
uint8_t& m1_thres_type_c::set_thres_rsrq()
{
  set(types::thres_rsrq);
  return c.get<uint8_t>();
}
uint8_t& m1_thres_type_c::set_thres_sinr()
{
  set(types::thres_sinr);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<m1_thres_type_ext_ies_o>& m1_thres_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>();
}
void m1_thres_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::thres_rsrp:
      j.write_int("threshold-RSRP", c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      j.write_int("threshold-RSRQ", c.get<uint8_t>());
      break;
    case types::thres_sinr:
      j.write_int("threshold-SINR", c.get<uint8_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }
  j.end_obj();
}
SRSASN_CODE m1_thres_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_sinr:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_thres_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_sinr:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m1_thres_type_c::types_opts::to_string() const
{
  static const char* names[] = {"threshold-RSRP", "threshold-RSRQ", "threshold-SINR", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "m1_thres_type_c::types");
}

// M4ReportAmountMDT ::= ENUMERATED
const char* m4_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m4_report_amount_mdt_e");
}
int8_t m4_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m4_report_amount_mdt_e");
}

// M5ReportAmountMDT ::= ENUMERATED
const char* m5_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m5_report_amount_mdt_e");
}
int8_t m5_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m5_report_amount_mdt_e");
}

// M6ReportAmountMDT ::= ENUMERATED
const char* m6_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m6_report_amount_mdt_e");
}
int8_t m6_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m6_report_amount_mdt_e");
}

// M7ReportAmountMDT ::= ENUMERATED
const char* m7_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m7_report_amount_mdt_e");
}
int8_t m7_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m7_report_amount_mdt_e");
}

// ReportAmountMDT ::= ENUMERATED
const char* report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "rinfinity"};
  return convert_enum_idx(names, 8, value, "report_amount_mdt_e");
}
int8_t report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "report_amount_mdt_e");
}

// ReportIntervalMDT ::= ENUMERATED
const char* report_interv_mdt_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms480",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "min1",
                                "min6",
                                "min12",
                                "min30",
                                "min60"};
  return convert_enum_idx(names, 13, value, "report_interv_mdt_e");
}
uint16_t report_interv_mdt_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 1, 6, 12, 30, 60};
  return map_enum_number(numbers, 13, value, "report_interv_mdt_e");
}

// SensorMeasConfigNameItem ::= SEQUENCE
SRSASN_CODE sensor_meas_cfg_name_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sensor_name_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_meas_cfg_name_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sensor_name_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sensor_meas_cfg_name_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sensorNameConfig");
  sensor_name_cfg.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WLANMeasConfigNameItem ::= SEQUENCE
SRSASN_CODE wlan_meas_cfg_name_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(wlan_name.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wlan_meas_cfg_name_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(wlan_name.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wlan_meas_cfg_name_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("wLANName", wlan_name.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EarlyMeasurement ::= ENUMERATED
const char* early_meas_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "early_meas_e");
}

// Links-to-log ::= ENUMERATED
const char* links_to_log_opts::to_string() const
{
  static const char* names[] = {"uplink", "downlink", "both-uplink-and-downlink"};
  return convert_enum_idx(names, 3, value, "links_to_log_e");
}

// M1Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m1_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {340, 361};
  return map_enum_number(names, 2, idx, "id");
}
bool m1_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {340, 361};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e m1_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 340:
      return crit_e::ignore;
    case 361:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
m1_cfg_ext_ies_o::ext_c m1_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 340:
      ret.set(ext_c::types::include_beam_meass_ind);
      break;
    case 361:
      ret.set(ext_c::types::beam_meass_report_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m1_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 340:
      return presence_e::optional;
    case 361:
      return presence_e::conditional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void m1_cfg_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::include_beam_meass_ind:
      c = include_beam_meass_ind_e{};
      break;
    case types::beam_meass_report_cfg:
      c = beam_meass_report_cfg_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }
}
include_beam_meass_ind_e& m1_cfg_ext_ies_o::ext_c::include_beam_meass_ind()
{
  assert_choice_type(types::include_beam_meass_ind, type_, "Extension");
  return c.get<include_beam_meass_ind_e>();
}
beam_meass_report_cfg_s& m1_cfg_ext_ies_o::ext_c::beam_meass_report_cfg()
{
  assert_choice_type(types::beam_meass_report_cfg, type_, "Extension");
  return c.get<beam_meass_report_cfg_s>();
}
const include_beam_meass_ind_e& m1_cfg_ext_ies_o::ext_c::include_beam_meass_ind() const
{
  assert_choice_type(types::include_beam_meass_ind, type_, "Extension");
  return c.get<include_beam_meass_ind_e>();
}
const beam_meass_report_cfg_s& m1_cfg_ext_ies_o::ext_c::beam_meass_report_cfg() const
{
  assert_choice_type(types::beam_meass_report_cfg, type_, "Extension");
  return c.get<beam_meass_report_cfg_s>();
}
void m1_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::include_beam_meass_ind:
      j.write_str("IncludeBeamMeasurementsIndication", "true");
      break;
    case types::beam_meass_report_cfg:
      j.write_fieldname("BeamMeasurementsReportConfiguration");
      c.get<beam_meass_report_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE m1_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::include_beam_meass_ind:
      HANDLE_CODE(c.get<include_beam_meass_ind_e>().pack(bref));
      break;
    case types::beam_meass_report_cfg:
      HANDLE_CODE(c.get<beam_meass_report_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::include_beam_meass_ind:
      HANDLE_CODE(c.get<include_beam_meass_ind_e>().unpack(bref));
      break;
    case types::beam_meass_report_cfg:
      HANDLE_CODE(c.get<beam_meass_report_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m1_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"IncludeBeamMeasurementsIndication", "BeamMeasurementsReportConfiguration"};
  return convert_enum_idx(names, 2, value, "m1_cfg_ext_ies_o::ext_c::types");
}

// M1PeriodicReporting ::= SEQUENCE
SRSASN_CODE m1_periodic_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(report_interv.pack(bref));
  HANDLE_CODE(report_amount.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_periodic_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_interv.unpack(bref));
  HANDLE_CODE(report_amount.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m1_periodic_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reportInterval", report_interv.to_string());
  j.write_str("reportAmount", report_amount.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M1ReportingTrigger ::= ENUMERATED
const char* m1_report_trigger_opts::to_string() const
{
  static const char* names[] = {"periodic", "a2eventtriggered", "a2eventtriggered-periodic"};
  return convert_enum_idx(names, 3, value, "m1_report_trigger_e");
}

// M1ThresholdEventA2 ::= SEQUENCE
SRSASN_CODE m1_thres_event_a2_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m1_thres_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_thres_event_a2_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m1_thres_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_thres_event_a2_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("m1ThresholdType");
  m1_thres_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M4Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m4_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {336};
  return map_enum_number(names, 1, idx, "id");
}
bool m4_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 336 == id;
}
crit_e m4_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 336) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m4_cfg_ext_ies_o::ext_c m4_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 336) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m4_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 336) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m4_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M4ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m4_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m4_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m4_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M4ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m4_cfg_ext_ies_o::ext_c::types");
}
uint8_t m4_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {4};
  return map_enum_number(numbers, 1, value, "m4_cfg_ext_ies_o::ext_c::types");
}

// M4period ::= ENUMERATED
const char* m4period_opts::to_string() const
{
  static const char* names[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(names, 5, value, "m4period_e");
}
uint16_t m4period_opts::to_number() const
{
  static const uint16_t numbers[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(numbers, 5, value, "m4period_e");
}

// M5Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m5_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {337};
  return map_enum_number(names, 1, idx, "id");
}
bool m5_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 337 == id;
}
crit_e m5_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 337) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m5_cfg_ext_ies_o::ext_c m5_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 337) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m5_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 337) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m5_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M5ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m5_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M5ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m5_cfg_ext_ies_o::ext_c::types");
}
uint8_t m5_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "m5_cfg_ext_ies_o::ext_c::types");
}

// M5period ::= ENUMERATED
const char* m5period_opts::to_string() const
{
  static const char* names[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(names, 5, value, "m5period_e");
}
uint16_t m5period_opts::to_number() const
{
  static const uint16_t numbers[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(numbers, 5, value, "m5period_e");
}

// M6Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m6_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {338, 341};
  return map_enum_number(names, 2, idx, "id");
}
bool m6_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {338, 341};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e m6_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 338:
      return crit_e::ignore;
    case 341:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
m6_cfg_ext_ies_o::ext_c m6_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 338:
      ret.set(ext_c::types::m6_report_amount);
      break;
    case 341:
      ret.set(ext_c::types::excess_packet_delay_thres_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m6_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 338:
      return presence_e::optional;
    case 341:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void m6_cfg_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::m6_report_amount:
      c = m6_report_amount_mdt_e{};
      break;
    case types::excess_packet_delay_thres_cfg:
      c = excess_packet_delay_thres_cfg_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }
}
m6_report_amount_mdt_e& m6_cfg_ext_ies_o::ext_c::m6_report_amount()
{
  assert_choice_type(types::m6_report_amount, type_, "Extension");
  return c.get<m6_report_amount_mdt_e>();
}
excess_packet_delay_thres_cfg_l& m6_cfg_ext_ies_o::ext_c::excess_packet_delay_thres_cfg()
{
  assert_choice_type(types::excess_packet_delay_thres_cfg, type_, "Extension");
  return c.get<excess_packet_delay_thres_cfg_l>();
}
const m6_report_amount_mdt_e& m6_cfg_ext_ies_o::ext_c::m6_report_amount() const
{
  assert_choice_type(types::m6_report_amount, type_, "Extension");
  return c.get<m6_report_amount_mdt_e>();
}
const excess_packet_delay_thres_cfg_l& m6_cfg_ext_ies_o::ext_c::excess_packet_delay_thres_cfg() const
{
  assert_choice_type(types::excess_packet_delay_thres_cfg, type_, "Extension");
  return c.get<excess_packet_delay_thres_cfg_l>();
}
void m6_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::m6_report_amount:
      j.write_str("M6ReportAmountMDT", c.get<m6_report_amount_mdt_e>().to_string());
      break;
    case types::excess_packet_delay_thres_cfg:
      j.start_array("ExcessPacketDelayThresholdConfiguration");
      for (const auto& e1 : c.get<excess_packet_delay_thres_cfg_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m6_report_amount:
      HANDLE_CODE(c.get<m6_report_amount_mdt_e>().pack(bref));
      break;
    case types::excess_packet_delay_thres_cfg:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<excess_packet_delay_thres_cfg_l>(), 1, 255, true));
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m6_report_amount:
      HANDLE_CODE(c.get<m6_report_amount_mdt_e>().unpack(bref));
      break;
    case types::excess_packet_delay_thres_cfg:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<excess_packet_delay_thres_cfg_l>(), bref, 1, 255, true));
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m6_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M6ReportAmountMDT", "ExcessPacketDelayThresholdConfiguration"};
  return convert_enum_idx(names, 2, value, "m6_cfg_ext_ies_o::ext_c::types");
}
uint8_t m6_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {6};
  return map_enum_number(numbers, 1, value, "m6_cfg_ext_ies_o::ext_c::types");
}

// M6report-Interval ::= ENUMERATED
const char* m6report_interv_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms480",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms40960",
                                "min1",
                                "min6",
                                "min12",
                                "min30"};
  return convert_enum_idx(names, 14, value, "m6report_interv_e");
}
uint16_t m6report_interv_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 20480, 40960, 1, 6, 12, 30};
  return map_enum_number(numbers, 14, value, "m6report_interv_e");
}

// M7Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m7_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {339};
  return map_enum_number(names, 1, idx, "id");
}
bool m7_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 339 == id;
}
crit_e m7_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 339) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m7_cfg_ext_ies_o::ext_c m7_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 339) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m7_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 339) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m7_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M7ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m7_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M7ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m7_cfg_ext_ies_o::ext_c::types");
}
uint8_t m7_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {7};
  return map_enum_number(numbers, 1, value, "m7_cfg_ext_ies_o::ext_c::types");
}

// SensorMeasConfig ::= ENUMERATED
const char* sensor_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "sensor_meas_cfg_e");
}

// WLANMeasConfig ::= ENUMERATED
const char* wlan_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_e");
}

// LoggedMDTNr-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t logged_mdt_nr_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {360};
  return map_enum_number(names, 1, idx, "id");
}
bool logged_mdt_nr_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 360 == id;
}
crit_e logged_mdt_nr_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 360) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
logged_mdt_nr_ext_ies_o::ext_c logged_mdt_nr_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 360) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e logged_mdt_nr_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 360) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void logged_mdt_nr_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("EarlyMeasurement", "true");
  j.end_obj();
}
SRSASN_CODE logged_mdt_nr_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_nr_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* logged_mdt_nr_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"EarlyMeasurement"};
  return convert_enum_idx(names, 1, value, "logged_mdt_nr_ext_ies_o::ext_c::types");
}

// LoggedMDTTrigger ::= CHOICE
void logged_mdt_trigger_c::destroy_()
{
  switch (type_) {
    case types::event_trigger:
      c.destroy<event_trigger_c>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void logged_mdt_trigger_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      c.init<event_trigger_c>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }
}
logged_mdt_trigger_c::logged_mdt_trigger_c(const logged_mdt_trigger_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      c.init(other.c.get<event_trigger_c>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }
}
logged_mdt_trigger_c& logged_mdt_trigger_c::operator=(const logged_mdt_trigger_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      c.set(other.c.get<event_trigger_c>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }

  return *this;
}
void logged_mdt_trigger_c::set_periodical()
{
  set(types::periodical);
}
event_trigger_c& logged_mdt_trigger_c::set_event_trigger()
{
  set(types::event_trigger);
  return c.get<event_trigger_c>();
}
protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>& logged_mdt_trigger_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>();
}
void logged_mdt_trigger_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      j.write_fieldname("eventTrigger");
      c.get<event_trigger_c>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }
  j.end_obj();
}
SRSASN_CODE logged_mdt_trigger_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      HANDLE_CODE(c.get<event_trigger_c>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_trigger_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      HANDLE_CODE(c.get<event_trigger_c>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* logged_mdt_trigger_c::types_opts::to_string() const
{
  static const char* names[] = {"periodical", "eventTrigger", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "logged_mdt_trigger_c::types");
}

// LoggingDuration ::= ENUMERATED
const char* logging_dur_opts::to_string() const
{
  static const char* names[] = {"m10", "m20", "m40", "m60", "m90", "m120"};
  return convert_enum_idx(names, 6, value, "logging_dur_e");
}
uint8_t logging_dur_opts::to_number() const
{
  static const uint8_t numbers[] = {10, 20, 40, 60, 90, 120};
  return map_enum_number(numbers, 6, value, "logging_dur_e");
}

// LoggingInterval ::= ENUMERATED
const char* logging_interv_opts::to_string() const
{
  static const char* names[] = {"ms320",
                                "ms640",
                                "ms1280",
                                "ms2560",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms30720",
                                "ms40960",
                                "ms61440",
                                "infinity"};
  return convert_enum_idx(names, 11, value, "logging_interv_e");
}
int32_t logging_interv_opts::to_number() const
{
  static const int32_t numbers[] = {320, 640, 1280, 2560, 5120, 10240, 20480, 30720, 40960, 61440, -1};
  return map_enum_number(numbers, 11, value, "logging_interv_e");
}

template struct asn1::protocol_ext_field_s<m1_cfg_ext_ies_o>;

SRSASN_CODE m1_cfg_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += include_beam_meass_ind_present ? 1 : 0;
  nof_ies += beam_meass_report_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (include_beam_meass_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)340, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(include_beam_meass_ind.pack(bref));
  }
  if (beam_meass_report_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)361, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(beam_meass_report_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 340: {
        include_beam_meass_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(include_beam_meass_ind.unpack(bref));
        break;
      }
      case 361: {
        beam_meass_report_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(beam_meass_report_cfg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void m1_cfg_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (include_beam_meass_ind_present) {
    j.write_int("id", 340);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (beam_meass_report_cfg_present) {
    j.write_int("id", 361);
    j.write_str("criticality", "ignore");
    beam_meass_report_cfg.to_json(j);
  }
  j.end_obj();
}

// M1Configuration ::= SEQUENCE
SRSASN_CODE m1_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m1thres_event_a2_present, 1));
  HANDLE_CODE(bref.pack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m1report_trigger.pack(bref));
  if (m1thres_event_a2_present) {
    HANDLE_CODE(m1thres_event_a2.pack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m1thres_event_a2_present, 1));
  HANDLE_CODE(bref.unpack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m1report_trigger.unpack(bref));
  if (m1thres_event_a2_present) {
    HANDLE_CODE(m1thres_event_a2.unpack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m1reportingTrigger", m1report_trigger.to_string());
  if (m1thres_event_a2_present) {
    j.write_fieldname("m1thresholdEventA2");
    m1thres_event_a2.to_json(j);
  }
  if (m1periodic_report_present) {
    j.write_fieldname("m1periodicReporting");
    m1periodic_report.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M4Configuration ::= SEQUENCE
SRSASN_CODE m4_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m4period.pack(bref));
  HANDLE_CODE(m4_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m4_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m4period.unpack(bref));
  HANDLE_CODE(m4_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m4_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m4period", m4period.to_string());
  j.write_str("m4-links-to-log", m4_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M5Configuration ::= SEQUENCE
SRSASN_CODE m5_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m5period.pack(bref));
  HANDLE_CODE(m5_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m5period.unpack(bref));
  HANDLE_CODE(m5_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m5_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m5period", m5period.to_string());
  j.write_str("m5-links-to-log", m5_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<m6_cfg_ext_ies_o>;

SRSASN_CODE m6_cfg_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += m6_report_amount_present ? 1 : 0;
  nof_ies += excess_packet_delay_thres_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (m6_report_amount_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)338, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(m6_report_amount.pack(bref));
  }
  if (excess_packet_delay_thres_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)341, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, excess_packet_delay_thres_cfg, 1, 255, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 338: {
        m6_report_amount_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(m6_report_amount.unpack(bref));
        break;
      }
      case 341: {
        excess_packet_delay_thres_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(excess_packet_delay_thres_cfg, bref, 1, 255, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (m6_report_amount_present) {
    j.write_int("id", 338);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", m6_report_amount.to_string());
  }
  if (excess_packet_delay_thres_cfg_present) {
    j.write_int("id", 341);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : excess_packet_delay_thres_cfg) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// M6Configuration ::= SEQUENCE
SRSASN_CODE m6_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.pack(bref));
  HANDLE_CODE(m6_links_to_log.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.unpack(bref));
  HANDLE_CODE(m6_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m6report-Interval", m6report_interv.to_string());
  j.write_str("m6-links-to-log", m6_links_to_log.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M7Configuration ::= SEQUENCE
SRSASN_CODE m7_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, m7period, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(m7period, bref, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m7_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("m7period", m7period);
  j.write_str("m7-links-to-log", m7_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// MDT-Location-Info ::= SEQUENCE
SRSASN_CODE mdt_location_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_location_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_location_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_location_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_location_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mDT-Location-Information", mdt_location_info.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SensorMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE sensor_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sensor_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sensor_meas_cfg.pack(bref));
  if (sensor_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sensor_meas_cfg_name_list, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sensor_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  if (sensor_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sensor_meas_cfg_name_list, bref, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sensor_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sensorMeasConfig", "setup");
  if (sensor_meas_cfg_name_list.size() > 0) {
    j.start_array("sensorMeasConfigNameList");
    for (const auto& e1 : sensor_meas_cfg_name_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WLANMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE wlan_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(wlan_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.pack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.pack(bref));
  if (wlan_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, wlan_meas_cfg_name_list, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.pack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wlan_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool wlan_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  if (wlan_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(wlan_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.unpack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wlan_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("wlanMeasConfig", "setup");
  if (wlan_meas_cfg_name_list.size() > 0) {
    j.start_array("wlanMeasConfigNameList");
    for (const auto& e1 : wlan_meas_cfg_name_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (wlan_rssi_present) {
    j.write_str("wlan-rssi", "true");
  }
  if (wlan_rtt_present) {
    j.write_str("wlan-rtt", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* wlan_meas_cfg_s::wlan_rssi_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_s::wlan_rssi_e_");
}

const char* wlan_meas_cfg_s::wlan_rtt_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_s::wlan_rtt_e_");
}

// ImmediateMDTNr ::= SEQUENCE
SRSASN_CODE immediate_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m1_cfg_present, 1));
  HANDLE_CODE(bref.pack(m4_cfg_present, 1));
  HANDLE_CODE(bref.pack(m5_cfg_present, 1));
  HANDLE_CODE(bref.pack(m6_cfg_present, 1));
  HANDLE_CODE(bref.pack(m7_cfg_present, 1));
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(mdt_location_info_present, 1));
  HANDLE_CODE(bref.pack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.pack(bref));
  if (m1_cfg_present) {
    HANDLE_CODE(m1_cfg.pack(bref));
  }
  if (m4_cfg_present) {
    HANDLE_CODE(m4_cfg.pack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.pack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.pack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.pack(bref));
  }
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }
  if (mdt_location_info_present) {
    HANDLE_CODE(mdt_location_info.pack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE immediate_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m1_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m4_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m5_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m6_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m7_cfg_present, 1));
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(mdt_location_info_present, 1));
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.unpack(bref));
  if (m1_cfg_present) {
    HANDLE_CODE(m1_cfg.unpack(bref));
  }
  if (m4_cfg_present) {
    HANDLE_CODE(m4_cfg.unpack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.unpack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.unpack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.unpack(bref));
  }
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  }
  if (mdt_location_info_present) {
    HANDLE_CODE(mdt_location_info.unpack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void immediate_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("measurementsToActivate", meass_to_activ.to_string());
  if (m1_cfg_present) {
    j.write_fieldname("m1Configuration");
    m1_cfg.to_json(j);
  }
  if (m4_cfg_present) {
    j.write_fieldname("m4Configuration");
    m4_cfg.to_json(j);
  }
  if (m5_cfg_present) {
    j.write_fieldname("m5Configuration");
    m5_cfg.to_json(j);
  }
  if (m6_cfg_present) {
    j.write_fieldname("m6Configuration");
    m6_cfg.to_json(j);
  }
  if (m7_cfg_present) {
    j.write_fieldname("m7Configuration");
    m7_cfg.to_json(j);
  }
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("bluetoothMeasurementConfiguration");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("wLANMeasurementConfiguration");
    wlan_meas_cfg.to_json(j);
  }
  if (mdt_location_info_present) {
    j.write_fieldname("mDT-Location-Info");
    mdt_location_info.to_json(j);
  }
  if (sensor_meas_cfg_present) {
    j.write_fieldname("sensorMeasurementConfiguration");
    sensor_meas_cfg.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LoggedMDTNr ::= SEQUENCE
SRSASN_CODE logged_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(area_scope_of_neigh_cells_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(logging_interv.pack(bref));
  HANDLE_CODE(logging_dur.pack(bref));
  HANDLE_CODE(logged_mdt_trigger.pack(bref));
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.pack(bref));
  }
  if (area_scope_of_neigh_cells_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_scope_of_neigh_cells_list, 1, 8, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_present, 1));
  bool area_scope_of_neigh_cells_list_present;
  HANDLE_CODE(bref.unpack(area_scope_of_neigh_cells_list_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(logging_interv.unpack(bref));
  HANDLE_CODE(logging_dur.unpack(bref));
  HANDLE_CODE(logged_mdt_trigger.unpack(bref));
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  }
  if (area_scope_of_neigh_cells_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_scope_of_neigh_cells_list, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void logged_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("loggingInterval", logging_interv.to_string());
  j.write_str("loggingDuration", logging_dur.to_string());
  j.write_fieldname("loggedMDTTrigger");
  logged_mdt_trigger.to_json(j);
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("bluetoothMeasurementConfiguration");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("wLANMeasurementConfiguration");
    wlan_meas_cfg.to_json(j);
  }
  if (sensor_meas_cfg_present) {
    j.write_fieldname("sensorMeasurementConfiguration");
    sensor_meas_cfg.to_json(j);
  }
  if (area_scope_of_neigh_cells_list.size() > 0) {
    j.start_array("areaScopeOfNeighCellsList");
    for (const auto& e1 : area_scope_of_neigh_cells_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// MDT-Activation ::= ENUMERATED
const char* mdt_activation_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT-only", "logged-MDT-only", "immediate-MDT-and-Trace"};
  return convert_enum_idx(names, 3, value, "mdt_activation_e");
}

// MDTModeNr ::= CHOICE
void mdt_mode_nr_c::destroy_()
{
  switch (type_) {
    case types::immediate_mdt_nr:
      c.destroy<immediate_mdt_nr_s>();
      break;
    case types::logged_mdt_nr:
      c.destroy<logged_mdt_nr_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mdt_mode_nr_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::immediate_mdt_nr:
      c.init<immediate_mdt_nr_s>();
      break;
    case types::logged_mdt_nr:
      c.init<logged_mdt_nr_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
}
mdt_mode_nr_c::mdt_mode_nr_c(const mdt_mode_nr_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::immediate_mdt_nr:
      c.init(other.c.get<immediate_mdt_nr_s>());
      break;
    case types::logged_mdt_nr:
      c.init(other.c.get<logged_mdt_nr_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
}
mdt_mode_nr_c& mdt_mode_nr_c::operator=(const mdt_mode_nr_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::immediate_mdt_nr:
      c.set(other.c.get<immediate_mdt_nr_s>());
      break;
    case types::logged_mdt_nr:
      c.set(other.c.get<logged_mdt_nr_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }

  return *this;
}
immediate_mdt_nr_s& mdt_mode_nr_c::set_immediate_mdt_nr()
{
  set(types::immediate_mdt_nr);
  return c.get<immediate_mdt_nr_s>();
}
logged_mdt_nr_s& mdt_mode_nr_c::set_logged_mdt_nr()
{
  set(types::logged_mdt_nr);
  return c.get<logged_mdt_nr_s>();
}
protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>& mdt_mode_nr_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>();
}
void mdt_mode_nr_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::immediate_mdt_nr:
      j.write_fieldname("immediateMDTNr");
      c.get<immediate_mdt_nr_s>().to_json(j);
      break;
    case types::logged_mdt_nr:
      j.write_fieldname("loggedMDTNr");
      c.get<logged_mdt_nr_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
  j.end_obj();
}
SRSASN_CODE mdt_mode_nr_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::immediate_mdt_nr:
      HANDLE_CODE(c.get<immediate_mdt_nr_s>().pack(bref));
      break;
    case types::logged_mdt_nr:
      HANDLE_CODE(c.get<logged_mdt_nr_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_mode_nr_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::immediate_mdt_nr:
      HANDLE_CODE(c.get<immediate_mdt_nr_s>().unpack(bref));
      break;
    case types::logged_mdt_nr:
      HANDLE_CODE(c.get<logged_mdt_nr_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mdt_mode_nr_c::types_opts::to_string() const
{
  static const char* names[] = {"immediateMDTNr", "loggedMDTNr", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mdt_mode_nr_c::types");
}

// MDT-Configuration-EUTRA ::= SEQUENCE
SRSASN_CODE mdt_cfg_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sig_based_mdt_plmn_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  HANDLE_CODE(area_scope_of_mdt.pack(bref));
  HANDLE_CODE(mdt_mode.pack(bref));
  if (sig_based_mdt_plmn_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sig_based_mdt_plmn_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sig_based_mdt_plmn_list_present;
  HANDLE_CODE(bref.unpack(sig_based_mdt_plmn_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  HANDLE_CODE(area_scope_of_mdt.unpack(bref));
  HANDLE_CODE(mdt_mode.unpack(bref));
  if (sig_based_mdt_plmn_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sig_based_mdt_plmn_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  j.write_fieldname("areaScopeOfMDT");
  area_scope_of_mdt.to_json(j);
  j.write_str("mDTMode", mdt_mode.to_string());
  if (sig_based_mdt_plmn_list.size() > 0) {
    j.start_array("signallingBasedMDTPLMNList");
    for (const auto& e1 : sig_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDT-Configuration-NR ::= SEQUENCE
SRSASN_CODE mdt_cfg_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sig_based_mdt_plmn_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  HANDLE_CODE(area_scope_of_mdt.pack(bref));
  HANDLE_CODE(mdt_mode_nr.pack(bref));
  if (sig_based_mdt_plmn_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sig_based_mdt_plmn_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sig_based_mdt_plmn_list_present;
  HANDLE_CODE(bref.unpack(sig_based_mdt_plmn_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  HANDLE_CODE(area_scope_of_mdt.unpack(bref));
  HANDLE_CODE(mdt_mode_nr.unpack(bref));
  if (sig_based_mdt_plmn_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sig_based_mdt_plmn_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  j.write_fieldname("areaScopeOfMDT");
  area_scope_of_mdt.to_json(j);
  j.write_fieldname("mDTModeNr");
  mdt_mode_nr.to_json(j);
  if (sig_based_mdt_plmn_list.size() > 0) {
    j.start_array("signallingBasedMDTPLMNList");
    for (const auto& e1 : sig_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5FlowBitRates ::= SEQUENCE
SRSASN_CODE pc5_flow_bit_rates_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_flow_bit_rates_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_flow_bit_rates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("guaranteedFlowBitRate", guaranteed_flow_bit_rate);
  j.write_int("maximumFlowBitRate", max_flow_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LocationReportingAdditionalInfo ::= ENUMERATED
const char* location_report_add_info_opts::to_string() const
{
  static const char* names[] = {"includePSCell"};
  return convert_enum_idx(names, 1, value, "location_report_add_info_e");
}

// MDT-Configuration ::= SEQUENCE
SRSASN_CODE mdt_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mdt_cfg_nr_present, 1));
  HANDLE_CODE(bref.pack(mdt_cfg_eutra_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mdt_cfg_nr_present) {
    HANDLE_CODE(mdt_cfg_nr.pack(bref));
  }
  if (mdt_cfg_eutra_present) {
    HANDLE_CODE(mdt_cfg_eutra.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mdt_cfg_nr_present, 1));
  HANDLE_CODE(bref.unpack(mdt_cfg_eutra_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mdt_cfg_nr_present) {
    HANDLE_CODE(mdt_cfg_nr.unpack(bref));
  }
  if (mdt_cfg_eutra_present) {
    HANDLE_CODE(mdt_cfg_eutra.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mdt_cfg_nr_present) {
    j.write_fieldname("mdt-Config-NR");
    mdt_cfg_nr.to_json(j);
  }
  if (mdt_cfg_eutra_present) {
    j.write_fieldname("mdt-Config-EUTRA");
    mdt_cfg_eutra.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5QoSFlowItem ::= SEQUENCE
SRSASN_CODE pc5_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(range_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pqi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (pc5_flow_bit_rates_present) {
    HANDLE_CODE(pc5_flow_bit_rates.pack(bref));
  }
  if (range_present) {
    HANDLE_CODE(range.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(range_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pqi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (pc5_flow_bit_rates_present) {
    HANDLE_CODE(pc5_flow_bit_rates.unpack(bref));
  }
  if (range_present) {
    HANDLE_CODE(range.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pQI", pqi);
  if (pc5_flow_bit_rates_present) {
    j.write_fieldname("pc5FlowBitRates");
    pc5_flow_bit_rates.to_json(j);
  }
  if (range_present) {
    j.write_str("range", range.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemHOReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_item_ho_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_setup_item_ho_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_setup_item_ho_req_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c
pdu_session_res_setup_item_ho_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_item_ho_req_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::types");
}

// EventType ::= ENUMERATED
const char* event_type_opts::to_string() const
{
  static const char* names[] = {"direct",
                                "change-of-serve-cell",
                                "ue-presence-in-area-of-interest",
                                "stop-change-of-serve-cell",
                                "stop-ue-presence-in-area-of-interest",
                                "cancel-location-reporting-for-the-ue"};
  return convert_enum_idx(names, 6, value, "event_type_e");
}

// LocationReportingRequestType-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t location_report_request_type_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {170};
  return map_enum_number(names, 1, idx, "id");
}
bool location_report_request_type_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 170 == id;
}
crit_e location_report_request_type_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 170) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
location_report_request_type_ext_ies_o::ext_c location_report_request_type_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 170) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_request_type_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 170) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void location_report_request_type_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("LocationReportingAdditionalInfo", "includePSCell");
  j.end_obj();
}
SRSASN_CODE location_report_request_type_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_request_type_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* location_report_request_type_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"LocationReportingAdditionalInfo"};
  return convert_enum_idx(names, 1, value, "location_report_request_type_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSetupItemHOReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_ho_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(ho_request_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_ho_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(ho_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_ho_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_str("handoverRequestTransfer", ho_request_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PedestrianUE ::= ENUMERATED
const char* pedestrian_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "pedestrian_ue_e");
}

// ReportArea ::= ENUMERATED
const char* report_area_opts::to_string() const
{
  static const char* names[] = {"cell"};
  return convert_enum_idx(names, 1, value, "report_area_e");
}

// TraceActivation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t trace_activation_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {255, 257};
  return map_enum_number(names, 2, idx, "id");
}
bool trace_activation_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {255, 257};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_activation_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 255:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_activation_ext_ies_o::ext_c trace_activation_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 255:
      ret.set(ext_c::types::mdt_cfg);
      break;
    case 257:
      ret.set(ext_c::types::trace_collection_entity_uri);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_activation_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 255:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void trace_activation_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mdt_cfg:
      c = mdt_cfg_s{};
      break;
    case types::trace_collection_entity_uri:
      c = visible_string<0, MAX_ASN_STRING_LENGTH, false, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg()
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg() const
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
void trace_activation_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mdt_cfg:
      j.write_fieldname("MDT-Configuration");
      c.get<mdt_cfg_s>().to_json(j);
      break;
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().pack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().unpack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_activation_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"MDT-Configuration", "VisibleString"};
  return convert_enum_idx(names, 2, value, "trace_activation_ext_ies_o::ext_c::types");
}

// TraceDepth ::= ENUMERATED
const char* trace_depth_opts::to_string() const
{
  static const char* names[] = {"minimum",
                                "medium",
                                "maximum",
                                "minimumWithoutVendorSpecificExtension",
                                "mediumWithoutVendorSpecificExtension",
                                "maximumWithoutVendorSpecificExtension"};
  return convert_enum_idx(names, 6, value, "trace_depth_e");
}

// UESliceMaximumBitRateItem ::= SEQUENCE
SRSASN_CODE ue_slice_max_bit_rate_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pack_integer(bref, ue_slice_max_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, ue_slice_max_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_slice_max_bit_rate_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(unpack_integer(ue_slice_max_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(ue_slice_max_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_slice_max_bit_rate_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_int("uESliceMaximumBitRateDL", ue_slice_max_bit_rate_dl);
  j.write_int("uESliceMaximumBitRateUL", ue_slice_max_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// VehicleUE ::= ENUMERATED
const char* vehicle_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "vehicle_ue_e");
}

// IAB-Authorized ::= ENUMERATED
const char* iab_authorized_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "iab_authorized_e");
}

// LTEUESidelinkAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE lte_ue_sidelink_aggr_max_bitrate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_sidelink_aggr_max_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lte_ue_sidelink_aggr_max_bitrate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_sidelink_aggr_max_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lte_ue_sidelink_aggr_max_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uESidelinkAggregateMaximumBitRate", ue_sidelink_aggr_max_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LTEV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE ltev2x_services_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ltev2x_services_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ltev2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LocationReportingRequestType ::= SEQUENCE
SRSASN_CODE location_report_request_type_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(area_of_interest_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(location_report_ref_id_to_be_cancelled_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(event_type.pack(bref));
  HANDLE_CODE(report_area.pack(bref));
  if (area_of_interest_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_list, 1, 64, true));
  }
  if (location_report_ref_id_to_be_cancelled_present) {
    HANDLE_CODE(pack_integer(bref, location_report_ref_id_to_be_cancelled, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_request_type_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool area_of_interest_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_list_present, 1));
  HANDLE_CODE(bref.unpack(location_report_ref_id_to_be_cancelled_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(event_type.unpack(bref));
  HANDLE_CODE(report_area.unpack(bref));
  if (area_of_interest_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_list, bref, 1, 64, true));
  }
  if (location_report_ref_id_to_be_cancelled_present) {
    HANDLE_CODE(unpack_integer(location_report_ref_id_to_be_cancelled, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void location_report_request_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eventType", event_type.to_string());
  j.write_str("reportArea", "cell");
  if (area_of_interest_list.size() > 0) {
    j.start_array("areaOfInterestList");
    for (const auto& e1 : area_of_interest_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (location_report_ref_id_to_be_cancelled_present) {
    j.write_int("locationReportingReferenceIDToBeCancelled", location_report_ref_id_to_be_cancelled);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// NRUESidelinkAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE nr_ue_sidelink_aggr_max_bitrate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_sidelink_aggr_max_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_ue_sidelink_aggr_max_bitrate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_sidelink_aggr_max_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_ue_sidelink_aggr_max_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uESidelinkAggregateMaximumBitRate", ue_sidelink_aggr_max_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE nr_v2x_services_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_v2x_services_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_v2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NewSecurityContextInd ::= ENUMERATED
const char* new_security_context_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "new_security_context_ind_e");
}

// PC5QoSParameters ::= SEQUENCE
SRSASN_CODE pc5_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, pc5_qos_flow_list, 1, 2048, true));
  if (pc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(pack_integer(bref, pc5_link_aggr_bit_rates, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(pc5_qos_flow_list, bref, 1, 2048, true));
  if (pc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(unpack_integer(pc5_link_aggr_bit_rates, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("pc5QoSFlowList");
  for (const auto& e1 : pc5_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pc5_link_aggr_bit_rates_present) {
    j.write_int("pc5LinkAggregateBitRates", pc5_link_aggr_bit_rates);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCInactiveTransitionReportRequest ::= ENUMERATED
const char* rrc_inactive_transition_report_request_opts::to_string() const
{
  static const char* names[] = {
      "subsequent-state-transition-report", "single-rrc-connected-state-report", "cancel-report"};
  return convert_enum_idx(names, 3, value, "rrc_inactive_transition_report_request_e");
}

// RedirectionVoiceFallback ::= ENUMERATED
const char* redirection_voice_fallback_opts::to_string() const
{
  static const char* names[] = {"possible", "not-possible"};
  return convert_enum_idx(names, 2, value, "redirection_voice_fallback_e");
}

// SecurityContext ::= SEQUENCE
SRSASN_CODE security_context_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, next_hop_chaining_count, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(next_hop_nh.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_context_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(next_hop_chaining_count, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(next_hop_nh.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void security_context_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nextHopChainingCount", next_hop_chaining_count);
  j.write_str("nextHopNH", next_hop_nh.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TimeSyncAssistanceInfo ::= SEQUENCE
SRSASN_CODE time_sync_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(uu_time_sync_error_budget_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(time_distribution_ind.pack(bref));
  if (uu_time_sync_error_budget_present) {
    HANDLE_CODE(pack_integer(bref, uu_time_sync_error_budget, (uint32_t)1u, (uint32_t)1000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE time_sync_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(uu_time_sync_error_budget_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(time_distribution_ind.unpack(bref));
  if (uu_time_sync_error_budget_present) {
    HANDLE_CODE(unpack_integer(uu_time_sync_error_budget, bref, (uint32_t)1u, (uint32_t)1000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void time_sync_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("timeDistributionIndication", time_distribution_ind.to_string());
  if (uu_time_sync_error_budget_present) {
    j.write_int("uUTimeSyncErrorBudget", uu_time_sync_error_budget);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* time_sync_assist_info_s::time_distribution_ind_opts::to_string() const
{
  static const char* names[] = {"enabled", "disabled"};
  return convert_enum_idx(names, 2, value, "time_sync_assist_info_s::time_distribution_ind_e_");
}

template struct asn1::protocol_ext_field_s<trace_activation_ext_ies_o>;

SRSASN_CODE trace_activation_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += mdt_cfg_present ? 1 : 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (mdt_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)255, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mdt_cfg.pack(bref));
  }
  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)257, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 255: {
        mdt_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mdt_cfg.unpack(bref));
        break;
      }
      case 257: {
        trace_collection_entity_uri_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void trace_activation_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mdt_cfg_present) {
    j.write_int("id", 255);
    j.write_str("criticality", "ignore");
    mdt_cfg.to_json(j);
  }
  if (trace_collection_entity_uri_present) {
    j.write_int("id", 257);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", trace_collection_entity_uri.to_string());
  }
  j.end_obj();
}

// TraceActivation ::= SEQUENCE
SRSASN_CODE trace_activation_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_trace_id.pack(bref));
  HANDLE_CODE(interfaces_to_trace.pack(bref));
  HANDLE_CODE(trace_depth.pack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_trace_id.unpack(bref));
  HANDLE_CODE(interfaces_to_trace.unpack(bref));
  HANDLE_CODE(trace_depth.unpack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trace_activation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nGRANTraceID", ngran_trace_id.to_string());
  j.write_str("interfacesToTrace", interfaces_to_trace.to_string());
  j.write_str("traceDepth", trace_depth.to_string());
  j.write_str("traceCollectionEntityIPAddress", trace_collection_entity_ip_address.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-UP-CIoT-Support ::= ENUMERATED
const char* ue_up_c_iot_support_opts::to_string() const
{
  static const char* names[] = {"supported"};
  return convert_enum_idx(names, 1, value, "ue_up_c_iot_support_e");
}

// UESecurityCapabilities ::= SEQUENCE
SRSASN_CODE ue_security_cap_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_encryption_algorithms.pack(bref));
  HANDLE_CODE(nr_integrity_protection_algorithms.pack(bref));
  HANDLE_CODE(eutr_aencryption_algorithms.pack(bref));
  HANDLE_CODE(eutr_aintegrity_protection_algorithms.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_security_cap_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_encryption_algorithms.unpack(bref));
  HANDLE_CODE(nr_integrity_protection_algorithms.unpack(bref));
  HANDLE_CODE(eutr_aencryption_algorithms.unpack(bref));
  HANDLE_CODE(eutr_aintegrity_protection_algorithms.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_security_cap_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRencryptionAlgorithms", nr_encryption_algorithms.to_string());
  j.write_str("nRintegrityProtectionAlgorithms", nr_integrity_protection_algorithms.to_string());
  j.write_str("eUTRAencryptionAlgorithms", eutr_aencryption_algorithms.to_string());
  j.write_str("eUTRAintegrityProtectionAlgorithms", eutr_aintegrity_protection_algorithms.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceAdmittedItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_admitted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_request_ack_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_admitted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_request_ack_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_admitted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverRequestAcknowledgeTransfer", ho_request_ack_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemHOAck ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_ho_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_res_alloc_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_ho_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_res_alloc_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_ho_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverResourceAllocationUnsuccessfulTransfer", ho_res_alloc_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-AccessInformation ::= CHOICE
void npn_access_info_c::destroy_()
{
  switch (type_) {
    case types::pni_npn_access_info:
      c.destroy<cell_cag_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_access_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pni_npn_access_info:
      c.init<cell_cag_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }
}
npn_access_info_c::npn_access_info_c(const npn_access_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pni_npn_access_info:
      c.init(other.c.get<cell_cag_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }
}
npn_access_info_c& npn_access_info_c::operator=(const npn_access_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pni_npn_access_info:
      c.set(other.c.get<cell_cag_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }

  return *this;
}
cell_cag_list_l& npn_access_info_c::set_pni_npn_access_info()
{
  set(types::pni_npn_access_info);
  return c.get<cell_cag_list_l>();
}
protocol_ie_single_container_s<npn_access_info_ext_ies_o>& npn_access_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>();
}
void npn_access_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pni_npn_access_info:
      j.start_array("pNI-NPN-Access-Information");
      for (const auto& e1 : c.get<cell_cag_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_access_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pni_npn_access_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_cag_list_l>(), 1, 64, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_access_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pni_npn_access_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_cag_list_l>(), bref, 1, 64, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_access_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pNI-NPN-Access-Information", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "npn_access_info_c::types");
}

// RedCapIndication ::= ENUMERATED
const char* red_cap_ind_opts::to_string() const
{
  static const char* names[] = {"redcap"};
  return convert_enum_idx(names, 1, value, "red_cap_ind_e");
}

// RSN ::= ENUMERATED
const char* r_sn_opts::to_string() const
{
  static const char* names[] = {"v1", "v2"};
  return convert_enum_idx(names, 2, value, "r_sn_e");
}
uint8_t r_sn_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2};
  return map_enum_number(numbers, 2, value, "r_sn_e");
}

// RedundantPDUSessionInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t redundant_pdu_session_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {331};
  return map_enum_number(names, 1, idx, "id");
}
bool redundant_pdu_session_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 331 == id;
}
crit_e redundant_pdu_session_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 331) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
redundant_pdu_session_info_ext_ies_o::ext_c redundant_pdu_session_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 331) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e redundant_pdu_session_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 331) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void redundant_pdu_session_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..255,...)", c);
  j.end_obj();
}
SRSASN_CODE redundant_pdu_session_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint16_t)0u, (uint16_t)255u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE redundant_pdu_session_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  return SRSASN_SUCCESS;
}

const char* redundant_pdu_session_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..255,...)"};
  return convert_enum_idx(names, 1, value, "redundant_pdu_session_info_ext_ies_o::ext_c::types");
}
uint8_t redundant_pdu_session_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "redundant_pdu_session_info_ext_ies_o::ext_c::types");
}

// ConfidentialityProtectionResult ::= ENUMERATED
const char* confidentiality_protection_result_opts::to_string() const
{
  static const char* names[] = {"performed", "not-performed"};
  return convert_enum_idx(names, 2, value, "confidentiality_protection_result_e");
}

// IntegrityProtectionResult ::= ENUMERATED
const char* integrity_protection_result_opts::to_string() const
{
  static const char* names[] = {"performed", "not-performed"};
  return convert_enum_idx(names, 2, value, "integrity_protection_result_e");
}

// MBS-SupportIndicator ::= ENUMERATED
const char* mbs_support_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "mbs_support_ind_e");
}

// RedundantPDUSessionInformation ::= SEQUENCE
SRSASN_CODE redundant_pdu_session_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(rsn.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE redundant_pdu_session_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rsn.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void redundant_pdu_session_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rSN", rsn.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// HandoverRequestAcknowledgeTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ho_request_ack_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {153, 164, 172, 249, 192, 198, 27, 309};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_request_ack_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {153, 164, 172, 249, 192, 198, 27, 309};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ack_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 153:
      return crit_e::ignore;
    case 164:
      return crit_e::reject;
    case 172:
      return crit_e::reject;
    case 249:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ack_transfer_ext_ies_o::ext_c ho_request_ack_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 153:
      ret.set(ext_c::types::add_dl_up_tnl_info_for_ho_list);
      break;
    case 164:
      ret.set(ext_c::types::ul_forwarding_up_tnl_info);
      break;
    case 172:
      ret.set(ext_c::types::add_ul_forwarding_up_tnl_info);
      break;
    case 249:
      ret.set(ext_c::types::data_forwarding_resp_erab_list);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    case 198:
      ret.set(ext_c::types::used_r_sn_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ack_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 153:
      return presence_e::optional;
    case 164:
      return presence_e::optional;
    case 172:
      return presence_e::optional;
    case 249:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 198:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ho_request_ack_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      c = add_dl_up_tnl_info_for_ho_list_l{};
      break;
    case types::ul_forwarding_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c = up_transport_layer_info_list_l{};
      break;
    case types::data_forwarding_resp_erab_list:
      c = data_forwarding_resp_erab_list_l{};
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::used_r_sn_info:
      c = redundant_pdu_session_info_s{};
      break;
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::mbs_support_ind:
      c = mbs_support_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
  }
}
add_dl_up_tnl_info_for_ho_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_dl_up_tnl_info_for_ho_list()
{
  assert_choice_type(types::add_dl_up_tnl_info_for_ho_list, type_, "Extension");
  return c.get<add_dl_up_tnl_info_for_ho_list_l>();
}
up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
data_forwarding_resp_erab_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list()
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
redundant_pdu_session_info_s& ho_request_ack_transfer_ext_ies_o::ext_c::used_r_sn_info()
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
global_ran_node_id_c& ho_request_ack_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
mbs_support_ind_e& ho_request_ack_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const add_dl_up_tnl_info_for_ho_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_dl_up_tnl_info_for_ho_list() const
{
  assert_choice_type(types::add_dl_up_tnl_info_for_ho_list, type_, "Extension");
  return c.get<add_dl_up_tnl_info_for_ho_list_l>();
}
const up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
const data_forwarding_resp_erab_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list() const
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
const up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const redundant_pdu_session_info_s& ho_request_ack_transfer_ext_ies_o::ext_c::used_r_sn_info() const
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const global_ran_node_id_c& ho_request_ack_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const mbs_support_ind_e& ho_request_ack_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
void ho_request_ack_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      j.start_array("AdditionalDLUPTNLInformationForHOList");
      for (const auto& e1 : c.get<add_dl_up_tnl_info_for_ho_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ul_forwarding_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_ul_forwarding_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::data_forwarding_resp_erab_list:
      j.start_array("DataForwardingResponseERABList");
      for (const auto& e1 : c.get<data_forwarding_resp_erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::used_r_sn_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ack_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_dl_up_tnl_info_for_ho_list_l>(), 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<data_forwarding_resp_erab_list_l>(), 1, 256, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_dl_up_tnl_info_for_ho_list_l>(), bref, 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<data_forwarding_resp_erab_list_l>(), bref, 1, 256, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ack_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AdditionalDLUPTNLInformationForHOList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "DataForwardingResponseERABList",
                                "UPTransportLayerInformation",
                                "RedundantPDUSessionInformation",
                                "GlobalRANNodeID",
                                "MBS-SupportIndicator"};
  return convert_enum_idx(names, 8, value, "ho_request_ack_transfer_ext_ies_o::ext_c::types");
}

// SecurityResult ::= SEQUENCE
SRSASN_CODE security_result_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_result.pack(bref));
  HANDLE_CODE(confidentiality_protection_result.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_result_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_result.unpack(bref));
  HANDLE_CODE(confidentiality_protection_result.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void security_result_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("integrityProtectionResult", integrity_protection_result.to_string());
  j.write_str("confidentialityProtectionResult", confidentiality_protection_result.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<ho_request_ack_transfer_ext_ies_o>;

SRSASN_CODE ho_request_ack_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dl_up_tnl_info_for_ho_list_present ? 1 : 0;
  nof_ies += ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += add_ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += data_forwarding_resp_erab_list_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += used_r_sn_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dl_up_tnl_info_for_ho_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)153, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_up_tnl_info_for_ho_list, 1, 3, true));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)164, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_forwarding_up_tnl_info.pack(bref));
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)172, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ul_forwarding_up_tnl_info, 1, 3, true));
  }
  if (data_forwarding_resp_erab_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)249, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_resp_erab_list, 1, 256, true));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)192, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }
  if (used_r_sn_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)198, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(used_r_sn_info.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)309, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 153: {
        add_dl_up_tnl_info_for_ho_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_dl_up_tnl_info_for_ho_list, bref, 1, 3, true));
        break;
      }
      case 164: {
        ul_forwarding_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_forwarding_up_tnl_info.unpack(bref));
        break;
      }
      case 172: {
        add_ul_forwarding_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_ul_forwarding_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 249: {
        data_forwarding_resp_erab_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_resp_erab_list, bref, 1, 256, true));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 198: {
        used_r_sn_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(used_r_sn_info.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ho_request_ack_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dl_up_tnl_info_for_ho_list_present) {
    j.write_int("id", 153);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_dl_up_tnl_info_for_ho_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ul_forwarding_up_tnl_info_present) {
    j.write_int("id", 164);
    j.write_str("criticality", "reject");
    ul_forwarding_up_tnl_info.to_json(j);
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    j.write_int("id", 172);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : add_ul_forwarding_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_resp_erab_list_present) {
    j.write_int("id", 249);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : data_forwarding_resp_erab_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_int("id", 192);
    j.write_str("criticality", "ignore");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  if (used_r_sn_info_present) {
    j.write_int("id", 198);
    j.write_str("criticality", "ignore");
    used_r_sn_info.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_int("id", 27);
    j.write_str("criticality", "ignore");
    global_ran_node_id.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_int("id", 309);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// HandoverRequestAcknowledgeTransfer ::= SEQUENCE
SRSASN_CODE ho_request_ack_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(security_result_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_setup_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(data_forwarding_resp_drb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_setup_resp_list, 1, 64, true));
  if (qos_flow_failed_to_setup_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_setup_list, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_resp_drb_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(security_result_present, 1));
  bool qos_flow_failed_to_setup_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_setup_list_present, 1));
  bool data_forwarding_resp_drb_list_present;
  HANDLE_CODE(bref.unpack(data_forwarding_resp_drb_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_setup_resp_list, bref, 1, 64, true));
  if (qos_flow_failed_to_setup_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_setup_list, bref, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_resp_drb_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_request_ack_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("dLForwardingUP-TNLInformation");
    dl_forwarding_up_tnl_info.to_json(j);
  }
  if (security_result_present) {
    j.write_fieldname("securityResult");
    security_result.to_json(j);
  }
  j.start_array("qosFlowSetupResponseList");
  for (const auto& e1 : qos_flow_setup_resp_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (qos_flow_failed_to_setup_list.size() > 0) {
    j.start_array("qosFlowFailedToSetupList");
    for (const auto& e1 : qos_flow_failed_to_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    j.start_array("dataForwardingResponseDRBList");
    for (const auto& e1 : data_forwarding_resp_drb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LAI ::= SEQUENCE
SRSASN_CODE lai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(lac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(lac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plmn_id.to_string());
  j.write_str("lAC", lac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetHomeENB-ID ::= SEQUENCE
SRSASN_CODE target_home_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(home_enb_id.pack(bref));
  HANDLE_CODE(sel_eps_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_home_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(home_enb_id.unpack(bref));
  HANDLE_CODE(sel_eps_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_home_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plmn_id.to_string());
  j.write_str("homeENB-ID", home_enb_id.to_string());
  j.write_fieldname("selected-EPS-TAI");
  sel_eps_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetRNC-ID ::= SEQUENCE
SRSASN_CODE target_rnc_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(extended_rnc_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(lai.pack(bref));
  HANDLE_CODE(pack_integer(bref, rnc_id, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (extended_rnc_id_present) {
    HANDLE_CODE(pack_integer(bref, extended_rnc_id, (uint32_t)4096u, (uint32_t)65535u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_rnc_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(extended_rnc_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(lai.unpack(bref));
  HANDLE_CODE(unpack_integer(rnc_id, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (extended_rnc_id_present) {
    HANDLE_CODE(unpack_integer(extended_rnc_id, bref, (uint32_t)4096u, (uint32_t)65535u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_rnc_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("lAI");
  lai.to_json(j);
  j.write_int("rNC-ID", rnc_id);
  if (extended_rnc_id_present) {
    j.write_int("extendedRNC-ID", extended_rnc_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceItemHORqd ::= SEQUENCE
SRSASN_CODE pdu_session_res_item_ho_rqd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_required_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_ho_rqd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_required_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_item_ho_rqd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverRequiredTransfer", ho_required_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetID-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t target_id_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {178, 364};
  return map_enum_number(names, 2, idx, "id");
}
bool target_id_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {178, 364};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e target_id_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 178:
      return crit_e::reject;
    case 364:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
target_id_ext_ies_o::value_c target_id_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 178:
      ret.set(value_c::types::target_rnc_id);
      break;
    case 364:
      ret.set(value_c::types::target_home_enb_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_id_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 178:
      return presence_e::mandatory;
    case 364:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void target_id_ext_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::target_rnc_id:
      c = target_rnc_id_s{};
      break;
    case types::target_home_enb_id:
      c = target_home_enb_id_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
  }
}
target_rnc_id_s& target_id_ext_ies_o::value_c::target_rnc_id()
{
  assert_choice_type(types::target_rnc_id, type_, "Value");
  return c.get<target_rnc_id_s>();
}
target_home_enb_id_s& target_id_ext_ies_o::value_c::target_home_enb_id()
{
  assert_choice_type(types::target_home_enb_id, type_, "Value");
  return c.get<target_home_enb_id_s>();
}
const target_rnc_id_s& target_id_ext_ies_o::value_c::target_rnc_id() const
{
  assert_choice_type(types::target_rnc_id, type_, "Value");
  return c.get<target_rnc_id_s>();
}
const target_home_enb_id_s& target_id_ext_ies_o::value_c::target_home_enb_id() const
{
  assert_choice_type(types::target_home_enb_id, type_, "Value");
  return c.get<target_home_enb_id_s>();
}
void target_id_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::target_rnc_id:
      j.write_fieldname("TargetRNC-ID");
      c.get<target_rnc_id_s>().to_json(j);
      break;
    case types::target_home_enb_id:
      j.write_fieldname("TargetHomeENB-ID");
      c.get<target_home_enb_id_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE target_id_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::target_rnc_id:
      HANDLE_CODE(c.get<target_rnc_id_s>().pack(bref));
      break;
    case types::target_home_enb_id:
      HANDLE_CODE(c.get<target_home_enb_id_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_id_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::target_rnc_id:
      HANDLE_CODE(c.get<target_rnc_id_s>().unpack(bref));
      break;
    case types::target_home_enb_id:
      HANDLE_CODE(c.get<target_home_enb_id_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_id_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"TargetRNC-ID", "TargetHomeENB-ID"};
  return convert_enum_idx(names, 2, value, "target_id_ext_ies_o::value_c::types");
}

// TargetRANNodeID ::= SEQUENCE
SRSASN_CODE target_ran_node_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_ran_node_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargeteNB-ID ::= SEQUENCE
SRSASN_CODE target_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.pack(bref));
  HANDLE_CODE(sel_eps_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.unpack(bref));
  HANDLE_CODE(sel_eps_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalENB-ID");
  global_enb_id.to_json(j);
  j.write_fieldname("selected-EPS-TAI");
  sel_eps_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DirectForwardingPathAvailability ::= ENUMERATED
const char* direct_forwarding_path_availability_opts::to_string() const
{
  static const char* names[] = {"direct-path-available"};
  return convert_enum_idx(names, 1, value, "direct_forwarding_path_availability_e");
}

template struct asn1::protocol_ie_single_container_s<target_id_ext_ies_o>;

// TargetID ::= CHOICE
void target_id_c::destroy_()
{
  switch (type_) {
    case types::target_ran_node_id:
      c.destroy<target_ran_node_id_s>();
      break;
    case types::target_enb_id:
      c.destroy<target_enb_id_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<target_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void target_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::target_ran_node_id:
      c.init<target_ran_node_id_s>();
      break;
    case types::target_enb_id:
      c.init<target_enb_id_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<target_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
}
target_id_c::target_id_c(const target_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::target_ran_node_id:
      c.init(other.c.get<target_ran_node_id_s>());
      break;
    case types::target_enb_id:
      c.init(other.c.get<target_enb_id_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
}
target_id_c& target_id_c::operator=(const target_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::target_ran_node_id:
      c.set(other.c.get<target_ran_node_id_s>());
      break;
    case types::target_enb_id:
      c.set(other.c.get<target_enb_id_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }

  return *this;
}
target_ran_node_id_s& target_id_c::set_target_ran_node_id()
{
  set(types::target_ran_node_id);
  return c.get<target_ran_node_id_s>();
}
target_enb_id_s& target_id_c::set_target_enb_id()
{
  set(types::target_enb_id);
  return c.get<target_enb_id_s>();
}
protocol_ie_single_container_s<target_id_ext_ies_o>& target_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>();
}
void target_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::target_ran_node_id:
      j.write_fieldname("targetRANNodeID");
      c.get<target_ran_node_id_s>().to_json(j);
      break;
    case types::target_enb_id:
      j.write_fieldname("targeteNB-ID");
      c.get<target_enb_id_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
  j.end_obj();
}
SRSASN_CODE target_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::target_ran_node_id:
      HANDLE_CODE(c.get<target_ran_node_id_s>().pack(bref));
      break;
    case types::target_enb_id:
      HANDLE_CODE(c.get<target_enb_id_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::target_ran_node_id:
      HANDLE_CODE(c.get<target_ran_node_id_s>().unpack(bref));
      break;
    case types::target_enb_id:
      HANDLE_CODE(c.get<target_enb_id_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_id_c::types_opts::to_string() const
{
  static const char* names[] = {"targetRANNodeID", "targeteNB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "target_id_c::types");
}

// HandoverRequiredTransfer ::= SEQUENCE
SRSASN_CODE ho_required_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(direct_forwarding_path_availability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(direct_forwarding_path_availability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_required_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (direct_forwarding_path_availability_present) {
    j.write_str("directForwardingPathAvailability", "direct-path-available");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverResourceAllocationUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE ho_res_alloc_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_res_alloc_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_res_alloc_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedRANNodeItem ::= SEQUENCE
SRSASN_CODE recommended_ran_node_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_paging_target.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_ran_node_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_paging_target.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_ran_node_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMFPagingTarget");
  amf_paging_target.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedRANNodesForPaging ::= SEQUENCE
SRSASN_CODE recommended_ran_nodes_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, recommended_ran_node_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_ran_nodes_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(recommended_ran_node_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_ran_nodes_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("recommendedRANNodeList");
  for (const auto& e1 : recommended_ran_node_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InfoOnRecommendedCellsAndRANNodesForPaging ::= SEQUENCE
SRSASN_CODE info_on_recommended_cells_and_ran_nodes_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.pack(bref));
  HANDLE_CODE(recommend_ran_nodes_for_paging.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE info_on_recommended_cells_and_ran_nodes_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.unpack(bref));
  HANDLE_CODE(recommend_ran_nodes_for_paging.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void info_on_recommended_cells_and_ran_nodes_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("recommendedCellsForPaging");
  recommended_cells_for_paging.to_json(j);
  j.write_fieldname("recommendRANNodesForPaging");
  recommend_ran_nodes_for_paging.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemCxtFail ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_cxt_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupUnsuccessfulTransfer", pdu_session_res_setup_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceSupportQMC-Item ::= SEQUENCE
SRSASN_CODE slice_support_qmc_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_support_qmc_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_support_qmc_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDT-AlignmentInfo ::= CHOICE
void mdt_align_info_c::destroy_()
{
  switch (type_) {
    case types::s_based_mdt:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mdt_align_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s_based_mdt:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
}
mdt_align_info_c::mdt_align_info_c(const mdt_align_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s_based_mdt:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
}
mdt_align_info_c& mdt_align_info_c::operator=(const mdt_align_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s_based_mdt:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }

  return *this;
}
fixed_octstring<8, true>& mdt_align_info_c::set_s_based_mdt()
{
  set(types::s_based_mdt);
  return c.get<fixed_octstring<8, true>>();
}
protocol_ie_single_container_s<mdt_align_info_ext_ies_o>& mdt_align_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
}
void mdt_align_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_based_mdt:
      j.write_str("s-basedMDT", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
  j.end_obj();
}
SRSASN_CODE mdt_align_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::s_based_mdt:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_align_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::s_based_mdt:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mdt_align_info_c::types_opts::to_string() const
{
  static const char* names[] = {"s-basedMDT", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "mdt_align_info_c::types");
}

// ServiceType ::= ENUMERATED
const char* service_type_opts::to_string() const
{
  static const char* names[] = {"streaming", "mTSI", "vR"};
  return convert_enum_idx(names, 3, value, "service_type_e");
}

// UEAppLayerMeasConfigInfo ::= SEQUENCE
SRSASN_CODE ue_app_layer_meas_cfg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qo_e_meas_status_present, 1));
  HANDLE_CODE(bref.pack(container_for_app_layer_meas_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(meas_cfg_app_layer_id_present, 1));
  HANDLE_CODE(bref.pack(slice_support_list_qmc.size() > 0, 1));
  HANDLE_CODE(bref.pack(mdt_align_info_present, 1));
  HANDLE_CODE(bref.pack(available_ran_visible_qo_e_metrics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qo_e_ref.pack(bref));
  HANDLE_CODE(service_type.pack(bref));
  HANDLE_CODE(area_scope_of_qmc.pack(bref));
  HANDLE_CODE(meas_coll_entity_ip_address.pack(bref));
  if (qo_e_meas_status_present) {
    HANDLE_CODE(qo_e_meas_status.pack(bref));
  }
  if (container_for_app_layer_meas_cfg.size() > 0) {
    HANDLE_CODE(container_for_app_layer_meas_cfg.pack(bref));
  }
  if (meas_cfg_app_layer_id_present) {
    HANDLE_CODE(pack_integer(bref, meas_cfg_app_layer_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (slice_support_list_qmc.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, slice_support_list_qmc, 1, 16, true));
  }
  if (mdt_align_info_present) {
    HANDLE_CODE(mdt_align_info.pack(bref));
  }
  if (available_ran_visible_qo_e_metrics_present) {
    HANDLE_CODE(available_ran_visible_qo_e_metrics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_cfg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qo_e_meas_status_present, 1));
  bool container_for_app_layer_meas_cfg_present;
  HANDLE_CODE(bref.unpack(container_for_app_layer_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(meas_cfg_app_layer_id_present, 1));
  bool slice_support_list_qmc_present;
  HANDLE_CODE(bref.unpack(slice_support_list_qmc_present, 1));
  HANDLE_CODE(bref.unpack(mdt_align_info_present, 1));
  HANDLE_CODE(bref.unpack(available_ran_visible_qo_e_metrics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qo_e_ref.unpack(bref));
  HANDLE_CODE(service_type.unpack(bref));
  HANDLE_CODE(area_scope_of_qmc.unpack(bref));
  HANDLE_CODE(meas_coll_entity_ip_address.unpack(bref));
  if (qo_e_meas_status_present) {
    HANDLE_CODE(qo_e_meas_status.unpack(bref));
  }
  if (container_for_app_layer_meas_cfg_present) {
    HANDLE_CODE(container_for_app_layer_meas_cfg.unpack(bref));
  }
  if (meas_cfg_app_layer_id_present) {
    HANDLE_CODE(unpack_integer(meas_cfg_app_layer_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (slice_support_list_qmc_present) {
    HANDLE_CODE(unpack_dyn_seq_of(slice_support_list_qmc, bref, 1, 16, true));
  }
  if (mdt_align_info_present) {
    HANDLE_CODE(mdt_align_info.unpack(bref));
  }
  if (available_ran_visible_qo_e_metrics_present) {
    HANDLE_CODE(available_ran_visible_qo_e_metrics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_app_layer_meas_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("qoEReference", qo_e_ref.to_string());
  j.write_str("serviceType", service_type.to_string());
  j.write_fieldname("areaScopeOfQMC");
  area_scope_of_qmc.to_json(j);
  j.write_str("measCollEntityIPAddress", meas_coll_entity_ip_address.to_string());
  if (qo_e_meas_status_present) {
    j.write_str("qoEMeasurementStatus", "ongoing");
  }
  if (container_for_app_layer_meas_cfg.size() > 0) {
    j.write_str("containerForAppLayerMeasConfig", container_for_app_layer_meas_cfg.to_string());
  }
  if (meas_cfg_app_layer_id_present) {
    j.write_int("measConfigAppLayerID", meas_cfg_app_layer_id);
  }
  if (slice_support_list_qmc.size() > 0) {
    j.start_array("sliceSupportListQMC");
    for (const auto& e1 : slice_support_list_qmc) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mdt_align_info_present) {
    j.write_fieldname("mDT-AlignmentInfo");
    mdt_align_info.to_json(j);
  }
  if (available_ran_visible_qo_e_metrics_present) {
    j.write_fieldname("availableRANVisibleQoEMetrics");
    available_ran_visible_qo_e_metrics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ue_app_layer_meas_cfg_info_s::qo_e_meas_status_opts::to_string() const
{
  static const char* names[] = {"ongoing"};
  return convert_enum_idx(names, 1, value, "ue_app_layer_meas_cfg_info_s::qo_e_meas_status_e_");
}

// PDUSessionResourceSetupItemCxtReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_item_cxt_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_setup_item_cxt_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_setup_item_cxt_req_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c
pdu_session_res_setup_item_cxt_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_item_cxt_req_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::types");
}

// UEAppLayerMeasInfoItem ::= SEQUENCE
SRSASN_CODE ue_app_layer_meas_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_app_layer_meas_cfg_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_app_layer_meas_cfg_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_app_layer_meas_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEAppLayerMeasConfigInfo");
  ue_app_layer_meas_cfg_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemCxtReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_cxt_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nas_pdu.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu.size() > 0) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_cxt_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool nas_pdu_present;
  HANDLE_CODE(bref.unpack(nas_pdu_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.unpack(bref));
  }
  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_cxt_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (nas_pdu.size() > 0) {
    j.write_str("nAS-PDU", nas_pdu.to_string());
  }
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_str("pDUSessionResourceSetupRequestTransfer", pdu_session_res_setup_request_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QMCConfigInfo ::= SEQUENCE
SRSASN_CODE q_mcc_onfig_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ue_app_layer_meas_info_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE q_mcc_onfig_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ue_app_layer_meas_info_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void q_mcc_onfig_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("uEAppLayerMeasInfoList");
  for (const auto& e1 : ue_app_layer_meas_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemCxtRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_cxt_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupUnsuccessfulTransfer", pdu_session_res_setup_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemCxtRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_cxt_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_cxt_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_cxt_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupResponseTransfer", pdu_session_res_setup_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AuthenticatedIndication ::= ENUMERATED
const char* authenticated_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "authenticated_ind_e");
}

// CEmodeBSupport-Indicator ::= ENUMERATED
const char* ce_mode_b_support_ind_opts::to_string() const
{
  static const char* names[] = {"supported"};
  return convert_enum_idx(names, 1, value, "ce_mode_b_support_ind_e");
}

// EDT-Session ::= ENUMERATED
const char* edt_session_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "edt_session_e");
}

// IABNodeIndication ::= ENUMERATED
const char* iab_node_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "iab_node_ind_e");
}

// LTEM-Indication ::= ENUMERATED
const char* ltem_ind_opts::to_string() const
{
  static const char* names[] = {"lte-m"};
  return convert_enum_idx(names, 1, value, "ltem_ind_e");
}

// RRCEstablishmentCause ::= ENUMERATED
const char* rrc_establishment_cause_opts::to_string() const
{
  static const char* names[] = {"emergency",
                                "highPriorityAccess",
                                "mt-Access",
                                "mo-Signalling",
                                "mo-Data",
                                "mo-VoiceCall",
                                "mo-VideoCall",
                                "mo-SMS",
                                "mps-PriorityAccess",
                                "mcs-PriorityAccess",
                                "notAvailable",
                                "mo-ExceptionData"};
  return convert_enum_idx(names, 12, value, "rrc_establishment_cause_e");
}

// SourceToTarget-AMFInformationReroute ::= SEQUENCE
SRSASN_CODE source_to_target_amf_info_reroute_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cfg_nssai_present, 1));
  HANDLE_CODE(bref.pack(rejected_nssai_in_plmn_present, 1));
  HANDLE_CODE(bref.pack(rejected_nssai_in_ta_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cfg_nssai_present) {
    HANDLE_CODE(cfg_nssai.pack(bref));
  }
  if (rejected_nssai_in_plmn_present) {
    HANDLE_CODE(rejected_nssai_in_plmn.pack(bref));
  }
  if (rejected_nssai_in_ta_present) {
    HANDLE_CODE(rejected_nssai_in_ta.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_to_target_amf_info_reroute_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cfg_nssai_present, 1));
  HANDLE_CODE(bref.unpack(rejected_nssai_in_plmn_present, 1));
  HANDLE_CODE(bref.unpack(rejected_nssai_in_ta_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cfg_nssai_present) {
    HANDLE_CODE(cfg_nssai.unpack(bref));
  }
  if (rejected_nssai_in_plmn_present) {
    HANDLE_CODE(rejected_nssai_in_plmn.unpack(bref));
  }
  if (rejected_nssai_in_ta_present) {
    HANDLE_CODE(rejected_nssai_in_ta.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void source_to_target_amf_info_reroute_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cfg_nssai_present) {
    j.write_str("configuredNSSAI", cfg_nssai.to_string());
  }
  if (rejected_nssai_in_plmn_present) {
    j.write_str("rejectedNSSAIinPLMN", rejected_nssai_in_plmn.to_string());
  }
  if (rejected_nssai_in_ta_present) {
    j.write_str("rejectedNSSAIinTA", rejected_nssai_in_ta.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEContextRequest ::= ENUMERATED
const char* ue_context_request_opts::to_string() const
{
  static const char* names[] = {"requested"};
  return convert_enum_idx(names, 1, value, "ue_context_request_e");
}

// ConfiguredTACIndication ::= ENUMERATED
const char* cfg_tac_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cfg_tac_ind_e");
}

// OverloadAction ::= ENUMERATED
const char* overload_action_opts::to_string() const
{
  static const char* names[] = {"reject-non-emergency-mo-dt",
                                "reject-rrc-cr-signalling",
                                "permit-emergency-sessions-and-mobile-terminated-services-only",
                                "permit-high-priority-sessions-and-mobile-terminated-services-only"};
  return convert_enum_idx(names, 4, value, "overload_action_e");
}

// RAT-Information ::= ENUMERATED
const char* rat_info_opts::to_string() const
{
  static const char* names[] = {"unlicensed", "nb-IoT", "nR-LEO", "nR-MEO", "nR-GEO", "nR-OTHERSAT"};
  return convert_enum_idx(names, 6, value, "rat_info_e");
}

// SliceOverloadItem ::= SEQUENCE
SRSASN_CODE slice_overload_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_overload_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_overload_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-PagingItem ::= SEQUENCE
SRSASN_CODE ue_paging_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(paging_drx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.pack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_paging_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(paging_drx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.unpack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_paging_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEIdentityIndexValue");
  ue_id_idx_value.to_json(j);
  if (paging_drx_present) {
    j.write_str("pagingDRX", paging_drx.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastGroupPagingArea ::= SEQUENCE
SRSASN_CODE multicast_group_paging_area_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_area_tai_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_area_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(mbs_area_tai_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_group_paging_area_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("mBS-AreaTAIList");
  for (const auto& e1 : mbs_area_tai_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// OverloadResponse ::= CHOICE
void overload_resp_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<overload_resp_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void overload_resp_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::overload_action:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<overload_resp_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }
}
overload_resp_c::overload_resp_c(const overload_resp_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::overload_action:
      c.init(other.c.get<overload_action_e>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }
}
overload_resp_c& overload_resp_c::operator=(const overload_resp_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::overload_action:
      c.set(other.c.get<overload_action_e>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }

  return *this;
}
overload_action_e& overload_resp_c::set_overload_action()
{
  set(types::overload_action);
  return c.get<overload_action_e>();
}
protocol_ie_single_container_s<overload_resp_ext_ies_o>& overload_resp_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>();
}
void overload_resp_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::overload_action:
      j.write_str("overloadAction", c.get<overload_action_e>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }
  j.end_obj();
}
SRSASN_CODE overload_resp_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::overload_action:
      HANDLE_CODE(c.get<overload_action_e>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_resp_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::overload_action:
      HANDLE_CODE(c.get<overload_action_e>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* overload_resp_c::types_opts::to_string() const
{
  static const char* names[] = {"overloadAction", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "overload_resp_c::types");
}

// PDUSessionResourceItemCxtRelCpl-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_item_cxt_rel_cpl_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {145};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_item_cxt_rel_cpl_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 145 == id;
}
crit_e pdu_session_res_item_cxt_rel_cpl_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 145) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c
pdu_session_res_item_cxt_rel_cpl_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 145) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_item_cxt_rel_cpl_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 145) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::types");
}

// PDUSessionResourceModifyItemModReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_item_mod_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {148, 281};
  return map_enum_number(names, 2, idx, "id");
}
bool pdu_session_res_modify_item_mod_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {148, 281};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_item_mod_req_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 148:
      return crit_e::reject;
    case 281:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c
pdu_session_res_modify_item_mod_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 148:
      ret.set(ext_c::types::s_nssai);
      break;
    case 281:
      ret.set(ext_c::types::pdu_session_expected_ue_activity_behaviour);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_item_mod_req_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 148:
      return presence_e::optional;
    case 281:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::s_nssai:
      c = s_nssai_s{};
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      c = expected_ue_activity_behaviour_s{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
  }
}
s_nssai_s& pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Extension");
  return c.get<s_nssai_s>();
}
expected_ue_activity_behaviour_s&
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::pdu_session_expected_ue_activity_behaviour()
{
  assert_choice_type(types::pdu_session_expected_ue_activity_behaviour, type_, "Extension");
  return c.get<expected_ue_activity_behaviour_s>();
}
const s_nssai_s& pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Extension");
  return c.get<s_nssai_s>();
}
const expected_ue_activity_behaviour_s&
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::pdu_session_expected_ue_activity_behaviour() const
{
  assert_choice_type(types::pdu_session_expected_ue_activity_behaviour, type_, "Extension");
  return c.get<expected_ue_activity_behaviour_s>();
}
void pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      j.write_fieldname("ExpectedUEActivityBehaviour");
      c.get<expected_ue_activity_behaviour_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      HANDLE_CODE(c.get<expected_ue_activity_behaviour_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      HANDLE_CODE(c.get<expected_ue_activity_behaviour_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"S-NSSAI", "ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 2, value, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSetupItemSUReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_item_su_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_setup_item_su_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_setup_item_su_req_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_setup_item_su_req_ext_ies_o::ext_c
pdu_session_res_setup_item_su_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_item_su_req_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSwitchedItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_switched_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_switched_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_switched_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_switched_item_ext_ies_o::ext_c pdu_session_res_switched_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_switched_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_switched_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_switched_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_switched_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_switched_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_switched_item_ext_ies_o::ext_c::types");
}

// SupportedTAItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t supported_ta_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {272, 179};
  return map_enum_number(names, 2, idx, "id");
}
bool supported_ta_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {272, 179};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e supported_ta_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 272:
      return crit_e::ignore;
    case 179:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
supported_ta_item_ext_ies_o::ext_c supported_ta_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 272:
      ret.set(ext_c::types::cfg_tac_ind);
      break;
    case 179:
      ret.set(ext_c::types::rat_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e supported_ta_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 272:
      return presence_e::optional;
    case 179:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void supported_ta_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cfg_tac_ind:
      c = cfg_tac_ind_e{};
      break;
    case types::rat_info:
      c = rat_info_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
  }
}
cfg_tac_ind_e& supported_ta_item_ext_ies_o::ext_c::cfg_tac_ind()
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
rat_info_e& supported_ta_item_ext_ies_o::ext_c::rat_info()
{
  assert_choice_type(types::rat_info, type_, "Extension");
  return c.get<rat_info_e>();
}
const cfg_tac_ind_e& supported_ta_item_ext_ies_o::ext_c::cfg_tac_ind() const
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
const rat_info_e& supported_ta_item_ext_ies_o::ext_c::rat_info() const
{
  assert_choice_type(types::rat_info, type_, "Extension");
  return c.get<rat_info_e>();
}
void supported_ta_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cfg_tac_ind:
      j.write_str("ConfiguredTACIndication", "true");
      break;
    case types::rat_info:
      j.write_str("RAT-Information", c.get<rat_info_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE supported_ta_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().pack(bref));
      break;
    case types::rat_info:
      HANDLE_CODE(c.get<rat_info_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_ta_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().unpack(bref));
      break;
    case types::rat_info:
      HANDLE_CODE(c.get<rat_info_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* supported_ta_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ConfiguredTACIndication", "RAT-Information"};
  return convert_enum_idx(names, 2, value, "supported_ta_item_ext_ies_o::ext_c::types");
}

// UE-associatedLogicalNG-connectionItem ::= SEQUENCE
SRSASN_CODE ue_associated_lc_ng_conn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(amf_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.pack(ran_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_associated_lc_ng_conn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(amf_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.unpack(ran_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_associated_lc_ng_conn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_ue_ngap_id_present) {
    j.write_int("aMF-UE-NGAP-ID", amf_ue_ngap_id);
  }
  if (ran_ue_ngap_id_present) {
    j.write_int("rAN-UE-NGAP-ID", ran_ue_ngap_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEPresence ::= ENUMERATED
const char* ue_presence_opts::to_string() const
{
  static const char* names[] = {"in", "out", "unknown"};
  return convert_enum_idx(names, 3, value, "ue_presence_e");
}

// MulticastGroupPagingAreaItem ::= SEQUENCE
SRSASN_CODE multicast_group_paging_area_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_paging_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(multicast_group_paging_area.pack(bref));
  if (ue_paging_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_paging_list, 1, 4096, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_area_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ue_paging_list_present;
  HANDLE_CODE(bref.unpack(ue_paging_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(multicast_group_paging_area.unpack(bref));
  if (ue_paging_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ue_paging_list, bref, 1, 4096, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_group_paging_area_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("multicastGroupPagingArea");
  multicast_group_paging_area.to_json(j);
  if (ue_paging_list.size() > 0) {
    j.start_array("uE-PagingList");
    for (const auto& e1 : ue_paging_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NB-IoT-Paging-TimeWindow ::= ENUMERATED
const char* nb_iot_paging_time_win_opts::to_string() const
{
  static const char* names[] = {
      "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"};
  return convert_enum_idx(names, 16, value, "nb_iot_paging_time_win_e");
}
uint8_t nb_iot_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
  return map_enum_number(numbers, 16, value, "nb_iot_paging_time_win_e");
}

// NB-IoT-Paging-eDRXCycle ::= ENUMERATED
const char* nb_iot_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hf2", "hf4", "hf6", "hf8", "hf10", "hf12", "hf14", "hf16", "hf32", "hf64", "hf128", "hf256", "hf512", "hf1024"};
  return convert_enum_idx(names, 14, value, "nb_iot_paging_e_drx_cycle_e");
}
uint16_t nb_iot_paging_e_drx_cycle_opts::to_number() const
{
  static const uint16_t numbers[] = {2, 4, 6, 8, 10, 12, 14, 16, 32, 64, 128, 256, 512, 1024};
  return map_enum_number(numbers, 14, value, "nb_iot_paging_e_drx_cycle_e");
}

// NGRAN-TNLAssociationToRemoveItem ::= SEQUENCE
SRSASN_CODE ngran_tnl_assoc_to_rem_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(tnl_assoc_transport_layer_address_amf_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (tnl_assoc_transport_layer_address_amf_present) {
    HANDLE_CODE(tnl_assoc_transport_layer_address_amf.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_tnl_assoc_to_rem_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(tnl_assoc_transport_layer_address_amf_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (tnl_assoc_transport_layer_address_amf_present) {
    HANDLE_CODE(tnl_assoc_transport_layer_address_amf.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_tnl_assoc_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (tnl_assoc_transport_layer_address_amf_present) {
    j.write_fieldname("tNLAssociationTransportLayerAddressAMF");
    tnl_assoc_transport_layer_address_amf.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// OverloadStartNSSAIItem ::= SEQUENCE
SRSASN_CODE overload_start_nssai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(slice_overload_resp_present, 1));
  HANDLE_CODE(bref.pack(slice_traffic_load_reduction_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, slice_overload_list, 1, 1024, true));
  if (slice_overload_resp_present) {
    HANDLE_CODE(slice_overload_resp.pack(bref));
  }
  if (slice_traffic_load_reduction_ind_present) {
    HANDLE_CODE(pack_integer(bref, slice_traffic_load_reduction_ind, (uint8_t)1u, (uint8_t)99u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_nssai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(slice_overload_resp_present, 1));
  HANDLE_CODE(bref.unpack(slice_traffic_load_reduction_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(slice_overload_list, bref, 1, 1024, true));
  if (slice_overload_resp_present) {
    HANDLE_CODE(slice_overload_resp.unpack(bref));
  }
  if (slice_traffic_load_reduction_ind_present) {
    HANDLE_CODE(unpack_integer(slice_traffic_load_reduction_ind, bref, (uint8_t)1u, (uint8_t)99u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void overload_start_nssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sliceOverloadList");
  for (const auto& e1 : slice_overload_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (slice_overload_resp_present) {
    j.write_fieldname("sliceOverloadResponse");
    slice_overload_resp.to_json(j);
  }
  if (slice_traffic_load_reduction_ind_present) {
    j.write_int("sliceTrafficLoadReductionIndication", slice_traffic_load_reduction_ind);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToModifyItemModCfm ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_cfm_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_cfm_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_modify_item_mod_cfm_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyIndicationUnsuccessfulTransfer",
              pdu_session_res_modify_ind_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToModifyItemModRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_modify_item_mod_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyUnsuccessfulTransfer", pdu_session_res_modify_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToResumeItemRESReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_resume_item_res_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToResumeItemRESRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_resume_item_res_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemPSReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_ps_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_setup_failed_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_ps_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_setup_failed_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_ps_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestSetupFailedTransfer", path_switch_request_setup_failed_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemSURes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_su_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_su_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_su_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupUnsuccessfulTransfer", pdu_session_res_setup_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceItemCxtRelCpl ::= SEQUENCE
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_item_cxt_rel_cpl_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceItemCxtRelReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_item_cxt_rel_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_cxt_rel_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_item_cxt_rel_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModCfm ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_cfm_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_confirm_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_cfm_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_confirm_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_cfm_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyConfirmTransfer", pdu_session_res_modify_confirm_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModInd ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyIndicationTransfer", pdu_session_res_modify_ind_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_item_mod_req_ext_ies_o>;

SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += pdu_session_expected_ue_activity_behaviour_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (s_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (pdu_session_expected_ue_activity_behaviour_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)281, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdu_session_expected_ue_activity_behaviour.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 148: {
        s_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 281: {
        pdu_session_expected_ue_activity_behaviour_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_expected_ue_activity_behaviour.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_req_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (s_nssai_present) {
    j.write_int("id", 148);
    j.write_str("criticality", "reject");
    s_nssai.to_json(j);
  }
  if (pdu_session_expected_ue_activity_behaviour_present) {
    j.write_int("id", 281);
    j.write_str("criticality", "ignore");
    pdu_session_expected_ue_activity_behaviour.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nas_pdu.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu.size() > 0) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_modify_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool nas_pdu_present;
  HANDLE_CODE(bref.unpack(nas_pdu_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.unpack(bref));
  }
  HANDLE_CODE(pdu_session_res_modify_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (nas_pdu.size() > 0) {
    j.write_str("nAS-PDU", nas_pdu.to_string());
  }
  j.write_str("pDUSessionResourceModifyRequestTransfer", pdu_session_res_modify_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyResponseTransfer", pdu_session_res_modify_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceNotifyItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_notify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceNotifyTransfer", pdu_session_res_notify_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemNot ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_not_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_released_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_not_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_released_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_not_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceNotifyReleasedTransfer", pdu_session_res_notify_released_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemPSAck ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_ps_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_ps_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_ps_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestUnsuccessfulTransfer", path_switch_request_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemPSFail ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_ps_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_ps_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_ps_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestUnsuccessfulTransfer", path_switch_request_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemRelRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_rel_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_rel_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_rel_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceReleaseResponseTransfer", pdu_session_res_release_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceResumeItemRESReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_resume_item_res_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_resume_item_res_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_resume_item_res_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("uEContextResumeRequestTransfer", ue_context_resume_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceResumeItemRESRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_resume_item_res_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_resume_item_res_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_resume_item_res_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("uEContextResumeResponseTransfer", ue_context_resume_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSecondaryRATUsageItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_secondary_rat_usage_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(secondary_rat_data_usage_report_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_secondary_rat_usage_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(secondary_rat_data_usage_report_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_secondary_rat_usage_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("secondaryRATDataUsageReportTransfer", secondary_rat_data_usage_report_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemSUReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_su_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_nas_pdu.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (pdu_session_nas_pdu.size() > 0) {
    HANDLE_CODE(pdu_session_nas_pdu.pack(bref));
  }
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_su_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool pdu_session_nas_pdu_present;
  HANDLE_CODE(bref.unpack(pdu_session_nas_pdu_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (pdu_session_nas_pdu_present) {
    HANDLE_CODE(pdu_session_nas_pdu.unpack(bref));
  }
  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_su_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (pdu_session_nas_pdu.size() > 0) {
    j.write_str("pDUSessionNAS-PDU", pdu_session_nas_pdu.to_string());
  }
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_str("pDUSessionResourceSetupRequestTransfer", pdu_session_res_setup_request_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemSURes ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_su_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_su_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_su_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupResponseTransfer", pdu_session_res_setup_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSuspendItemSUSReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_suspend_item_sus_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_suspend_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_suspend_item_sus_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_suspend_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_suspend_item_sus_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("uEContextSuspendRequestTransfer", ue_context_suspend_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSwitchedItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_switched_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_ack_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_switched_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_ack_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_switched_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestAcknowledgeTransfer", path_switch_request_ack_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceToBeSwitchedDLItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_to_be_switched_dl_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_be_switched_dl_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_be_switched_dl_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestTransfer", path_switch_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceToReleaseItemRelCmd ::= SEQUENCE
SRSASN_CODE pdu_session_res_to_release_item_rel_cmd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_cmd_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_release_item_rel_cmd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_cmd_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_release_item_rel_cmd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceReleaseCommandTransfer", pdu_session_res_release_cmd_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingProbabilityInformation ::= ENUMERATED
const char* paging_probability_info_opts::to_string() const
{
  static const char* names[] = {"p00", "p05", "p10", "p15", "p20", "p25", "p30", "p35", "p40", "p45", "p50",
                                "p55", "p60", "p65", "p70", "p75", "p80", "p85", "p90", "p95", "p100"};
  return convert_enum_idx(names, 21, value, "paging_probability_info_e");
}
float paging_probability_info_opts::to_number() const
{
  static const float numbers[] = {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0,
                                  5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5, 1.0};
  return map_enum_number(numbers, 21, value, "paging_probability_info_e");
}
const char* paging_probability_info_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.0", "0.5", "1.0", "1.5", "2.0", "2.5", "3.0", "3.5", "4.0", "4.5", "5.0",
                                      "5.5", "6.0", "6.5", "7.0", "7.5", "8.0", "8.5", "9.0", "9.5", "1.00"};
  return convert_enum_idx(number_strs, 21, value, "paging_probability_info_e");
}

// ResetAll ::= ENUMERATED
const char* reset_all_opts::to_string() const
{
  static const char* names[] = {"reset-all"};
  return convert_enum_idx(names, 1, value, "reset_all_e");
}

template struct asn1::protocol_ext_field_s<supported_ta_item_ext_ies_o>;

SRSASN_CODE supported_ta_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cfg_tac_ind_present ? 1 : 0;
  nof_ies += rat_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cfg_tac_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)272, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cfg_tac_ind.pack(bref));
  }
  if (rat_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)179, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rat_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_ta_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 272: {
        cfg_tac_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cfg_tac_ind.unpack(bref));
        break;
      }
      case 179: {
        rat_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rat_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void supported_ta_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cfg_tac_ind_present) {
    j.write_int("id", 272);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (rat_info_present) {
    j.write_int("id", 179);
    j.write_str("criticality", "reject");
    j.write_str("Extension", rat_info.to_string());
  }
  j.end_obj();
}

// SupportedTAItem ::= SEQUENCE
SRSASN_CODE supported_ta_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tac.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmn_list, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_ta_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tac.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmn_list, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void supported_ta_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tAC", tac.to_string());
  j.start_array("broadcastPLMNList");
  for (const auto& e1 : broadcast_plmn_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIListForPagingItem ::= SEQUENCE
SRSASN_CODE tai_list_for_paging_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_list_for_paging_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_list_for_paging_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-NGAP-ID-pair ::= SEQUENCE
SRSASN_CODE ue_ngap_id_pair_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_ngap_id_pair_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_ngap_id_pair_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("aMF-UE-NGAP-ID", amf_ue_ngap_id);
  j.write_int("rAN-UE-NGAP-ID", ran_ue_ngap_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEPresenceInAreaOfInterestItem ::= SEQUENCE
SRSASN_CODE ue_presence_in_area_of_interest_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, location_report_ref_id, (uint8_t)1u, (uint8_t)64u, true, true));
  HANDLE_CODE(ue_presence.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_presence_in_area_of_interest_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(location_report_ref_id, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  HANDLE_CODE(ue_presence.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_presence_in_area_of_interest_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("locationReportingReferenceID", location_report_ref_id);
  j.write_str("uEPresence", ue_presence.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelAllWarningMessages ::= ENUMERATED
const char* cancel_all_warning_msgs_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cancel_all_warning_msgs_e");
}

// ConcurrentWarningMessageInd ::= ENUMERATED
const char* concurrent_warning_msg_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "concurrent_warning_msg_ind_e");
}

// HandoverFlag ::= ENUMERATED
const char* ho_flag_opts::to_string() const
{
  static const char* names[] = {"handover-preparation"};
  return convert_enum_idx(names, 1, value, "ho_flag_e");
}

// IAB-Supported ::= ENUMERATED
const char* iab_supported_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "iab_supported_e");
}

// IMSVoiceSupportIndicator ::= ENUMERATED
const char* ims_voice_support_ind_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "ims_voice_support_ind_e");
}

// NB-IoT-DefaultPagingDRX ::= ENUMERATED
const char* nb_iot_default_paging_drx_opts::to_string() const
{
  static const char* names[] = {"rf128", "rf256", "rf512", "rf1024"};
  return convert_enum_idx(names, 4, value, "nb_iot_default_paging_drx_e");
}
uint16_t nb_iot_default_paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {128, 256, 512, 1024};
  return map_enum_number(numbers, 4, value, "nb_iot_default_paging_drx_e");
}

// NB-IoT-Paging-eDRXInfo ::= SEQUENCE
SRSASN_CODE nb_iot_paging_e_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nb_iot_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nb_iot_paging_e_drx_cycle.pack(bref));
  if (nb_iot_paging_time_win_present) {
    HANDLE_CODE(nb_iot_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nb_iot_paging_e_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nb_iot_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nb_iot_paging_e_drx_cycle.unpack(bref));
  if (nb_iot_paging_time_win_present) {
    HANDLE_CODE(nb_iot_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nb_iot_paging_e_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nB-IoT-Paging-eDRXCycle", nb_iot_paging_e_drx_cycle.to_string());
  if (nb_iot_paging_time_win_present) {
    j.write_str("nB-IoT-Paging-TimeWindow", nb_iot_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NB-IoT-PagingDRX ::= ENUMERATED
const char* nb_iot_paging_drx_opts::to_string() const
{
  static const char* names[] = {"rf32", "rf64", "rf128", "rf256", "rf512", "rf1024"};
  return convert_enum_idx(names, 6, value, "nb_iot_paging_drx_e");
}
uint16_t nb_iot_paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {32, 64, 128, 256, 512, 1024};
  return map_enum_number(numbers, 6, value, "nb_iot_paging_drx_e");
}

// PWSFailedCellIDList ::= CHOICE
void pws_failed_cell_id_list_c::destroy_()
{
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.destroy<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_pws_failed_list:
      c.destroy<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pws_failed_cell_id_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.init<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_pws_failed_list:
      c.init<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }
}
pws_failed_cell_id_list_c::pws_failed_cell_id_list_c(const pws_failed_cell_id_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.init(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_pws_failed_list:
      c.init(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }
}
pws_failed_cell_id_list_c& pws_failed_cell_id_list_c::operator=(const pws_failed_cell_id_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.set(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_pws_failed_list:
      c.set(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }

  return *this;
}
eutra_cgi_list_l& pws_failed_cell_id_list_c::set_eutra_cgi_pws_failed_list()
{
  set(types::eutra_cgi_pws_failed_list);
  return c.get<eutra_cgi_list_l>();
}
nr_cgi_list_l& pws_failed_cell_id_list_c::set_nr_cgi_pws_failed_list()
{
  set(types::nr_cgi_pws_failed_list);
  return c.get<nr_cgi_list_l>();
}
protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>& pws_failed_cell_id_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>();
}
void pws_failed_cell_id_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      j.start_array("eUTRA-CGI-PWSFailedList");
      for (const auto& e1 : c.get<eutra_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nr_cgi_pws_failed_list:
      j.start_array("nR-CGI-PWSFailedList");
      for (const auto& e1 : c.get<nr_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_failed_cell_id_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<eutra_cgi_list_l>(), 1, 256, true));
      break;
    case types::nr_cgi_pws_failed_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_cgi_list_l>(), 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_failed_cell_id_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<eutra_cgi_list_l>(), bref, 1, 256, true));
      break;
    case types::nr_cgi_pws_failed_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_cgi_list_l>(), bref, 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_failed_cell_id_list_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRA-CGI-PWSFailedList", "nR-CGI-PWSFailedList", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "pws_failed_cell_id_list_c::types");
}

// PagingCause ::= ENUMERATED
const char* paging_cause_opts::to_string() const
{
  static const char* names[] = {"voice"};
  return convert_enum_idx(names, 1, value, "paging_cause_e");
}

// PagingOrigin ::= ENUMERATED
const char* paging_origin_opts::to_string() const
{
  static const char* names[] = {"non-3gpp"};
  return convert_enum_idx(names, 1, value, "paging_origin_e");
}
int8_t paging_origin_opts::to_number() const
{
  static const int8_t numbers[] = {-3};
  return map_enum_number(numbers, 1, value, "paging_origin_e");
}

// PagingPriority ::= ENUMERATED
const char* paging_prio_opts::to_string() const
{
  static const char* names[] = {
      "priolevel1", "priolevel2", "priolevel3", "priolevel4", "priolevel5", "priolevel6", "priolevel7", "priolevel8"};
  return convert_enum_idx(names, 8, value, "paging_prio_e");
}
uint8_t paging_prio_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8};
  return map_enum_number(numbers, 8, value, "paging_prio_e");
}

// QMCDeactivation ::= SEQUENCE
SRSASN_CODE qmc_deactivation_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, qo_e_ref_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qmc_deactivation_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(qo_e_ref_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qmc_deactivation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("qoEReferenceList");
  for (const auto& e1 : qo_e_ref_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCState ::= ENUMERATED
const char* rrc_state_opts::to_string() const
{
  static const char* names[] = {"inactive", "connected"};
  return convert_enum_idx(names, 2, value, "rrc_state_e");
}

// ResetType ::= CHOICE
void reset_type_c::destroy_()
{
  switch (type_) {
    case types::part_of_ng_interface:
      c.destroy<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void reset_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ng_interface:
      break;
    case types::part_of_ng_interface:
      c.init<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
}
reset_type_c::reset_type_c(const reset_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ng_interface:
      c.init(other.c.get<reset_all_e>());
      break;
    case types::part_of_ng_interface:
      c.init(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
}
reset_type_c& reset_type_c::operator=(const reset_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ng_interface:
      c.set(other.c.get<reset_all_e>());
      break;
    case types::part_of_ng_interface:
      c.set(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }

  return *this;
}
reset_all_e& reset_type_c::set_ng_interface()
{
  set(types::ng_interface);
  return c.get<reset_all_e>();
}
ue_associated_lc_ng_conn_list_l& reset_type_c::set_part_of_ng_interface()
{
  set(types::part_of_ng_interface);
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
protocol_ie_single_container_s<reset_type_ext_ies_o>& reset_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
}
void reset_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ng_interface:
      j.write_str("nG-Interface", "reset-all");
      break;
    case types::part_of_ng_interface:
      j.start_array("partOfNG-Interface");
      for (const auto& e1 : c.get<ue_associated_lc_ng_conn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
  j.end_obj();
}
SRSASN_CODE reset_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ng_interface:
      HANDLE_CODE(c.get<reset_all_e>().pack(bref));
      break;
    case types::part_of_ng_interface:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_ng_conn_list_l>(), 1, 65536, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ng_interface:
      HANDLE_CODE(c.get<reset_all_e>().unpack(bref));
      break;
    case types::part_of_ng_interface:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_ng_conn_list_l>(), bref, 1, 65536, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reset_type_c::types_opts::to_string() const
{
  static const char* names[] = {"nG-Interface", "partOfNG-Interface", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "reset_type_c::types");
}

// Suspend-Request-Indication ::= ENUMERATED
const char* suspend_request_ind_opts::to_string() const
{
  static const char* names[] = {"suspend-requested"};
  return convert_enum_idx(names, 1, value, "suspend_request_ind_e");
}

// Suspend-Response-Indication ::= ENUMERATED
const char* suspend_resp_ind_opts::to_string() const
{
  static const char* names[] = {"suspend-indicated"};
  return convert_enum_idx(names, 1, value, "suspend_resp_ind_e");
}

// UE-NGAP-IDs ::= CHOICE
void ue_ngap_ids_c::destroy_()
{
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.destroy<ue_ngap_id_pair_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_ngap_ids_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.init<ue_ngap_id_pair_s>();
      break;
    case types::amf_ue_ngap_id:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }
}
ue_ngap_ids_c::ue_ngap_ids_c(const ue_ngap_ids_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.init(other.c.get<ue_ngap_id_pair_s>());
      break;
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }
}
ue_ngap_ids_c& ue_ngap_ids_c::operator=(const ue_ngap_ids_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.set(other.c.get<ue_ngap_id_pair_s>());
      break;
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }

  return *this;
}
ue_ngap_id_pair_s& ue_ngap_ids_c::set_ue_ngap_id_pair()
{
  set(types::ue_ngap_id_pair);
  return c.get<ue_ngap_id_pair_s>();
}
uint64_t& ue_ngap_ids_c::set_amf_ue_ngap_id()
{
  set(types::amf_ue_ngap_id);
  return c.get<uint64_t>();
}
protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>& ue_ngap_ids_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>();
}
void ue_ngap_ids_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_ngap_id_pair:
      j.write_fieldname("uE-NGAP-ID-pair");
      c.get<ue_ngap_id_pair_s>().to_json(j);
      break;
    case types::amf_ue_ngap_id:
      j.write_int("aMF-UE-NGAP-ID", c.get<uint64_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_ngap_ids_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ue_ngap_id_pair:
      HANDLE_CODE(c.get<ue_ngap_id_pair_s>().pack(bref));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_ngap_ids_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ue_ngap_id_pair:
      HANDLE_CODE(c.get<ue_ngap_id_pair_s>().unpack(bref));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_ngap_ids_c::types_opts::to_string() const
{
  static const char* names[] = {"uE-NGAP-ID-pair", "aMF-UE-NGAP-ID", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "ue_ngap_ids_c::types");
}

// UEPagingIdentity ::= CHOICE
void ue_paging_id_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_paging_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
}
ue_paging_id_c::ue_paging_id_c(const ue_paging_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
}
ue_paging_id_c& ue_paging_id_c::operator=(const ue_paging_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }

  return *this;
}
five_g_s_tmsi_s& ue_paging_id_c::set_five_g_s_tmsi()
{
  set(types::five_g_s_tmsi);
  return c.get<five_g_s_tmsi_s>();
}
protocol_ie_single_container_s<ue_paging_id_ext_ies_o>& ue_paging_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>();
}
void ue_paging_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_g_s_tmsi:
      j.write_fieldname("fiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_paging_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_paging_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_paging_id_c::types_opts::to_string() const
{
  static const char* names[] = {"fiveG-S-TMSI", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "ue_paging_id_c::types");
}
uint8_t ue_paging_id_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "ue_paging_id_c::types");
}

// UERetentionInformation ::= ENUMERATED
const char* ue_retention_info_opts::to_string() const
{
  static const char* names[] = {"ues-retained"};
  return convert_enum_idx(names, 1, value, "ue_retention_info_e");
}

// UL-CP-SecurityInformation ::= SEQUENCE
SRSASN_CODE ul_cp_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_nas_mac.pack(bref));
  HANDLE_CODE(ul_nas_count.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_cp_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_nas_mac.unpack(bref));
  HANDLE_CODE(ul_nas_count.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_cp_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ul-NAS-MAC", ul_nas_mac.to_string());
  j.write_str("ul-NAS-Count", ul_nas_count.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WUS-Assistance-Information ::= SEQUENCE
SRSASN_CODE wus_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(paging_probability_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wus_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(paging_probability_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wus_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pagingProbabilityInformation", paging_probability_info.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WarningAreaList ::= CHOICE
void warning_area_list_c::destroy_()
{
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.destroy<eutra_cgi_list_for_warning_l>();
      break;
    case types::nr_cgi_list_for_warning:
      c.destroy<nr_cgi_list_for_warning_l>();
      break;
    case types::tai_list_for_warning:
      c.destroy<tai_list_for_warning_l>();
      break;
    case types::emergency_area_id_list:
      c.destroy<emergency_area_id_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void warning_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.init<eutra_cgi_list_for_warning_l>();
      break;
    case types::nr_cgi_list_for_warning:
      c.init<nr_cgi_list_for_warning_l>();
      break;
    case types::tai_list_for_warning:
      c.init<tai_list_for_warning_l>();
      break;
    case types::emergency_area_id_list:
      c.init<emergency_area_id_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
}
warning_area_list_c::warning_area_list_c(const warning_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.init(other.c.get<eutra_cgi_list_for_warning_l>());
      break;
    case types::nr_cgi_list_for_warning:
      c.init(other.c.get<nr_cgi_list_for_warning_l>());
      break;
    case types::tai_list_for_warning:
      c.init(other.c.get<tai_list_for_warning_l>());
      break;
    case types::emergency_area_id_list:
      c.init(other.c.get<emergency_area_id_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
}
warning_area_list_c& warning_area_list_c::operator=(const warning_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.set(other.c.get<eutra_cgi_list_for_warning_l>());
      break;
    case types::nr_cgi_list_for_warning:
      c.set(other.c.get<nr_cgi_list_for_warning_l>());
      break;
    case types::tai_list_for_warning:
      c.set(other.c.get<tai_list_for_warning_l>());
      break;
    case types::emergency_area_id_list:
      c.set(other.c.get<emergency_area_id_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }

  return *this;
}
eutra_cgi_list_for_warning_l& warning_area_list_c::set_eutra_cgi_list_for_warning()
{
  set(types::eutra_cgi_list_for_warning);
  return c.get<eutra_cgi_list_for_warning_l>();
}
nr_cgi_list_for_warning_l& warning_area_list_c::set_nr_cgi_list_for_warning()
{
  set(types::nr_cgi_list_for_warning);
  return c.get<nr_cgi_list_for_warning_l>();
}
tai_list_for_warning_l& warning_area_list_c::set_tai_list_for_warning()
{
  set(types::tai_list_for_warning);
  return c.get<tai_list_for_warning_l>();
}
emergency_area_id_list_l& warning_area_list_c::set_emergency_area_id_list()
{
  set(types::emergency_area_id_list);
  return c.get<emergency_area_id_list_l>();
}
protocol_ie_single_container_s<warning_area_list_ext_ies_o>& warning_area_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>();
}
void warning_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      j.start_array("eUTRA-CGIListForWarning");
      for (const auto& e1 : c.get<eutra_cgi_list_for_warning_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nr_cgi_list_for_warning:
      j.start_array("nR-CGIListForWarning");
      for (const auto& e1 : c.get<nr_cgi_list_for_warning_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_list_for_warning:
      j.start_array("tAIListForWarning");
      for (const auto& e1 : c.get<tai_list_for_warning_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list:
      j.start_array("emergencyAreaIDList");
      for (const auto& e1 : c.get<emergency_area_id_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE warning_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<eutra_cgi_list_for_warning_l>(), 1, 65535, true));
      break;
    case types::nr_cgi_list_for_warning:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_cgi_list_for_warning_l>(), 1, 65535, true));
      break;
    case types::tai_list_for_warning:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_warning_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_l>(), 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE warning_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<eutra_cgi_list_for_warning_l>(), bref, 1, 65535, true));
      break;
    case types::nr_cgi_list_for_warning:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_cgi_list_for_warning_l>(), bref, 1, 65535, true));
      break;
    case types::tai_list_for_warning:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_warning_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_l>(), bref, 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* warning_area_list_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRA-CGIListForWarning",
                                "nR-CGIListForWarning",
                                "tAIListForWarning",
                                "emergencyAreaIDList",
                                "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "warning_area_list_c::types");
}

// LastVisitedPSCellInformation ::= SEQUENCE
SRSASN_CODE last_visited_pscell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pscell_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (pscell_id_present) {
    HANDLE_CODE(pscell_id.pack(bref));
  }
  HANDLE_CODE(pack_integer(bref, time_stay, (uint16_t)0u, (uint16_t)40950u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_pscell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pscell_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (pscell_id_present) {
    HANDLE_CODE(pscell_id.unpack(bref));
  }
  HANDLE_CODE(unpack_integer(time_stay, bref, (uint16_t)0u, (uint16_t)40950u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void last_visited_pscell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (pscell_id_present) {
    j.write_fieldname("pSCellID");
    pscell_id.to_json(j);
  }
  j.write_int("timeStay", time_stay);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LastVisitedNGRANCellInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t last_visited_ngran_cell_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {289};
  return map_enum_number(names, 1, idx, "id");
}
bool last_visited_ngran_cell_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 289 == id;
}
crit_e last_visited_ngran_cell_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 289) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
last_visited_ngran_cell_info_ext_ies_o::ext_c last_visited_ngran_cell_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 289) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e last_visited_ngran_cell_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 289) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void last_visited_ngran_cell_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("LastVisitedPSCellList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE last_visited_ngran_cell_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 8, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_ngran_cell_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 8, true));
  return SRSASN_SUCCESS;
}

const char* last_visited_ngran_cell_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"LastVisitedPSCellList"};
  return convert_enum_idx(names, 1, value, "last_visited_ngran_cell_info_ext_ies_o::ext_c::types");
}

// LastVisitedNGRANCellInformation ::= SEQUENCE
SRSASN_CODE last_visited_ngran_cell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_ue_stayed_in_cell_enhanced_granularity_present, 1));
  HANDLE_CODE(bref.pack(ho_cause_value_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(global_cell_id.pack(bref));
  HANDLE_CODE(cell_type.pack(bref));
  HANDLE_CODE(pack_integer(bref, time_ue_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    HANDLE_CODE(
        pack_integer(bref, time_ue_stayed_in_cell_enhanced_granularity, (uint16_t)0u, (uint16_t)40950u, false, true));
  }
  if (ho_cause_value_present) {
    HANDLE_CODE(ho_cause_value.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_ngran_cell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_ue_stayed_in_cell_enhanced_granularity_present, 1));
  HANDLE_CODE(bref.unpack(ho_cause_value_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_cell_id.unpack(bref));
  HANDLE_CODE(cell_type.unpack(bref));
  HANDLE_CODE(unpack_integer(time_ue_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    HANDLE_CODE(
        unpack_integer(time_ue_stayed_in_cell_enhanced_granularity, bref, (uint16_t)0u, (uint16_t)40950u, false, true));
  }
  if (ho_cause_value_present) {
    HANDLE_CODE(ho_cause_value.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void last_visited_ngran_cell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalCellID");
  global_cell_id.to_json(j);
  j.write_fieldname("cellType");
  cell_type.to_json(j);
  j.write_int("timeUEStayedInCell", time_ue_stayed_in_cell);
  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    j.write_int("timeUEStayedInCellEnhancedGranularity", time_ue_stayed_in_cell_enhanced_granularity);
  }
  if (ho_cause_value_present) {
    j.write_fieldname("hOCauseValue");
    ho_cause_value.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// LastVisitedCellInformation ::= CHOICE
void last_visited_cell_info_c::destroy_()
{
  switch (type_) {
    case types::ngran_cell:
      c.destroy<last_visited_ngran_cell_info_s>();
      break;
    case types::eutran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::utran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::geran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void last_visited_cell_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ngran_cell:
      c.init<last_visited_ngran_cell_info_s>();
      break;
    case types::eutran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::utran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::geran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }
}
last_visited_cell_info_c::last_visited_cell_info_c(const last_visited_cell_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ngran_cell:
      c.init(other.c.get<last_visited_ngran_cell_info_s>());
      break;
    case types::eutran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::utran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::geran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }
}
last_visited_cell_info_c& last_visited_cell_info_c::operator=(const last_visited_cell_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ngran_cell:
      c.set(other.c.get<last_visited_ngran_cell_info_s>());
      break;
    case types::eutran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::utran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::geran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }

  return *this;
}
last_visited_ngran_cell_info_s& last_visited_cell_info_c::set_ngran_cell()
{
  set(types::ngran_cell);
  return c.get<last_visited_ngran_cell_info_s>();
}
unbounded_octstring<true>& last_visited_cell_info_c::set_eutran_cell()
{
  set(types::eutran_cell);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& last_visited_cell_info_c::set_utran_cell()
{
  set(types::utran_cell);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& last_visited_cell_info_c::set_geran_cell()
{
  set(types::geran_cell);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>& last_visited_cell_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>();
}
void last_visited_cell_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ngran_cell:
      j.write_fieldname("nGRANCell");
      c.get<last_visited_ngran_cell_info_s>().to_json(j);
      break;
    case types::eutran_cell:
      j.write_str("eUTRANCell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::utran_cell:
      j.write_str("uTRANCell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::geran_cell:
      j.write_str("gERANCell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }
  j.end_obj();
}
SRSASN_CODE last_visited_cell_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ngran_cell:
      HANDLE_CODE(c.get<last_visited_ngran_cell_info_s>().pack(bref));
      break;
    case types::eutran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_cell_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ngran_cell:
      HANDLE_CODE(c.get<last_visited_ngran_cell_info_s>().unpack(bref));
      break;
    case types::eutran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* last_visited_cell_info_c::types_opts::to_string() const
{
  static const char* names[] = {"nGRANCell", "eUTRANCell", "uTRANCell", "gERANCell", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "last_visited_cell_info_c::types");
}

// LastVisitedCellItem ::= SEQUENCE
SRSASN_CODE last_visited_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(last_visited_cell_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(last_visited_cell_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void last_visited_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("lastVisitedCellInformation");
  last_visited_cell_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NonDynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t non_dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {187, 188};
  return map_enum_number(names, 2, idx, "id");
}
bool non_dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {187, 188};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e non_dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 187:
      return crit_e::ignore;
    case 188:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c non_dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 187:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 188:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e non_dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 187:
      return presence_e::optional;
    case 188:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c = uint32_t{};
      break;
    case types::cn_packet_delay_budget_ul:
      c = uint32_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* non_dyn_5qi_descriptor_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..65535,...)", "INTEGER (1..65535,...)"};
  return convert_enum_idx(names, 2, value, "non_dyn_5qi_descriptor_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<non_dyn_5qi_descriptor_ext_ies_o>;

SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)187, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_dl, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)188, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_ul, (uint32_t)1u, (uint32_t)65535u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 187: {
        cn_packet_delay_budget_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_dl, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 188: {
        cn_packet_delay_budget_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_ul, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cn_packet_delay_budget_dl_present) {
    j.write_int("id", 187);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_dl);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_int("id", 188);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_ul);
  }
  j.end_obj();
}

// NonDynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE non_dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(prio_level_qos_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (prio_level_qos_present) {
    HANDLE_CODE(pack_integer(bref, prio_level_qos, (uint8_t)1u, (uint8_t)127u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(prio_level_qos_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (prio_level_qos_present) {
    HANDLE_CODE(unpack_integer(prio_level_qos, bref, (uint8_t)1u, (uint8_t)127u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQI", five_qi);
  if (prio_level_qos_present) {
    j.write_int("priorityLevelQos", prio_level_qos);
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maximumDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosMonitoringRequest ::= ENUMERATED
const char* qos_monitoring_request_opts::to_string() const
{
  static const char* names[] = {"ul", "dl", "both", "stop"};
  return convert_enum_idx(names, 4, value, "qos_monitoring_request_e");
}

// AdditionalQosFlowInformation ::= ENUMERATED
const char* add_qos_flow_info_opts::to_string() const
{
  static const char* names[] = {"more-likely"};
  return convert_enum_idx(names, 1, value, "add_qos_flow_info_e");
}

// QosCharacteristics ::= CHOICE
void qos_characteristics_c::destroy_()
{
  switch (type_) {
    case types::non_dyn5qi:
      c.destroy<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn5qi:
      c.destroy<dyn_5qi_descriptor_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void qos_characteristics_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::non_dyn5qi:
      c.init<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn5qi:
      c.init<dyn_5qi_descriptor_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c::qos_characteristics_c(const qos_characteristics_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::non_dyn5qi:
      c.init(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn5qi:
      c.init(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c& qos_characteristics_c::operator=(const qos_characteristics_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::non_dyn5qi:
      c.set(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn5qi:
      c.set(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }

  return *this;
}
non_dyn_5qi_descriptor_s& qos_characteristics_c::set_non_dyn5qi()
{
  set(types::non_dyn5qi);
  return c.get<non_dyn_5qi_descriptor_s>();
}
dyn_5qi_descriptor_s& qos_characteristics_c::set_dyn5qi()
{
  set(types::dyn5qi);
  return c.get<dyn_5qi_descriptor_s>();
}
protocol_ie_single_container_s<qos_characteristics_ext_ies_o>& qos_characteristics_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
}
void qos_characteristics_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::non_dyn5qi:
      j.write_fieldname("nonDynamic5QI");
      c.get<non_dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::dyn5qi:
      j.write_fieldname("dynamic5QI");
      c.get<dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_characteristics_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::non_dyn5qi:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::dyn5qi:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_characteristics_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::non_dyn5qi:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::dyn5qi:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_characteristics_c::types_opts::to_string() const
{
  static const char* names[] = {"nonDynamic5QI", "dynamic5QI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "qos_characteristics_c::types");
}

// QosFlowLevelQosParameters-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_level_qos_params_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {181, 276};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flow_level_qos_params_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {181, 276};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_level_qos_params_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 181:
      return crit_e::ignore;
    case 276:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_level_qos_params_ext_ies_o::ext_c qos_flow_level_qos_params_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 181:
      ret.set(ext_c::types::qos_monitoring_request);
      break;
    case 276:
      ret.set(ext_c::types::qos_monitoring_report_freq);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_level_qos_params_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 181:
      return presence_e::optional;
    case 276:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_level_qos_params_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::qos_monitoring_request:
      c = qos_monitoring_request_e{};
      break;
    case types::qos_monitoring_report_freq:
      c = uint16_t{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
}
qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request()
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_report_freq()
{
  assert_choice_type(types::qos_monitoring_report_freq, type_, "Extension");
  return c.get<uint16_t>();
}
const qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request() const
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
const uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_report_freq() const
{
  assert_choice_type(types::qos_monitoring_report_freq, type_, "Extension");
  return c.get<uint16_t>();
}
void qos_flow_level_qos_params_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::qos_monitoring_request:
      j.write_str("QosMonitoringRequest", c.get<qos_monitoring_request_e>().to_string());
      break;
    case types::qos_monitoring_report_freq:
      j.write_int("INTEGER (1..1800,...)", c.get<uint16_t>());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().pack(bref));
      break;
    case types::qos_monitoring_report_freq:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)1800u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().unpack(bref));
      break;
    case types::qos_monitoring_report_freq:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)1800u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_level_qos_params_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosMonitoringRequest", "INTEGER (1..1800,...)"};
  return convert_enum_idx(names, 2, value, "qos_flow_level_qos_params_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_level_qos_params_ext_ies_o::ext_c::types_opts::to_number() const
{
  if (value == qos_monitoring_report_freq) {
    return 1;
  }
  invalid_enum_number(value, "qos_flow_level_qos_params_ext_ies_o::ext_c::types");
  return 0;
}

// ReflectiveQosAttribute ::= ENUMERATED
const char* reflective_qos_attribute_opts::to_string() const
{
  static const char* names[] = {"subject-to"};
  return convert_enum_idx(names, 1, value, "reflective_qos_attribute_e");
}

// MRB-ProgressInformation ::= CHOICE
void mrb_progress_info_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mrb_progress_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdcp_sn_len12:
      break;
    case types::pdcp_sn_len18:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c::mrb_progress_info_c(const mrb_progress_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdcp_sn_len12:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn_len18:
      c.init(other.c.get<uint32_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c& mrb_progress_info_c::operator=(const mrb_progress_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdcp_sn_len12:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn_len18:
      c.set(other.c.get<uint32_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }

  return *this;
}
uint16_t& mrb_progress_info_c::set_pdcp_sn_len12()
{
  set(types::pdcp_sn_len12);
  return c.get<uint16_t>();
}
uint32_t& mrb_progress_info_c::set_pdcp_sn_len18()
{
  set(types::pdcp_sn_len18);
  return c.get<uint32_t>();
}
protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>& mrb_progress_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
}
void mrb_progress_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdcp_sn_len12:
      j.write_int("pDCP-SN-Length12", c.get<uint16_t>());
      break;
    case types::pdcp_sn_len18:
      j.write_int("pDCP-SN-Length18", c.get<uint32_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
  j.end_obj();
}
SRSASN_CODE mrb_progress_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pdcp_sn_len12:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn_len18:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mrb_progress_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pdcp_sn_len12:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn_len18:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mrb_progress_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pDCP-SN-Length12", "pDCP-SN-Length18", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mrb_progress_info_c::types");
}
uint8_t mrb_progress_info_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "mrb_progress_info_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_level_qos_params_ext_ies_o>;

SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += qos_monitoring_request_present ? 1 : 0;
  nof_ies += qos_monitoring_report_freq_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (qos_monitoring_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)181, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(qos_monitoring_request.pack(bref));
  }
  if (qos_monitoring_report_freq_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)276, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, qos_monitoring_report_freq, (uint16_t)1u, (uint16_t)1800u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 181: {
        qos_monitoring_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_monitoring_request.unpack(bref));
        break;
      }
      case 276: {
        qos_monitoring_report_freq_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(qos_monitoring_report_freq, bref, (uint16_t)1u, (uint16_t)1800u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_monitoring_request_present) {
    j.write_int("id", 181);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", qos_monitoring_request.to_string());
  }
  if (qos_monitoring_report_freq_present) {
    j.write_int("id", 276);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", qos_monitoring_report_freq);
  }
  j.end_obj();
}

// QosFlowLevelQosParameters ::= SEQUENCE
SRSASN_CODE qos_flow_level_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gbr_qos_info_present, 1));
  HANDLE_CODE(bref.pack(reflective_qos_attribute_present, 1));
  HANDLE_CODE(bref.pack(add_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.pack(bref));
  HANDLE_CODE(alloc_and_retention_prio.pack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.pack(bref));
  }
  if (reflective_qos_attribute_present) {
    HANDLE_CODE(reflective_qos_attribute.pack(bref));
  }
  if (add_qos_flow_info_present) {
    HANDLE_CODE(add_qos_flow_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gbr_qos_info_present, 1));
  HANDLE_CODE(bref.unpack(reflective_qos_attribute_present, 1));
  HANDLE_CODE(bref.unpack(add_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.unpack(bref));
  HANDLE_CODE(alloc_and_retention_prio.unpack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.unpack(bref));
  }
  if (reflective_qos_attribute_present) {
    HANDLE_CODE(reflective_qos_attribute.unpack(bref));
  }
  if (add_qos_flow_info_present) {
    HANDLE_CODE(add_qos_flow_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("qosCharacteristics");
  qos_characteristics.to_json(j);
  j.write_fieldname("allocationAndRetentionPriority");
  alloc_and_retention_prio.to_json(j);
  if (gbr_qos_info_present) {
    j.write_fieldname("gBR-QosInformation");
    gbr_qos_info.to_json(j);
  }
  if (reflective_qos_attribute_present) {
    j.write_str("reflectiveQosAttribute", "subject-to");
  }
  if (add_qos_flow_info_present) {
    j.write_str("additionalQosFlowInformation", "more-likely");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-MappingandDataForwardingRequestItem ::= SEQUENCE
SRSASN_CODE mbs_mapand_data_forwarding_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flow_list, 1, 64, integer_packer<uint8_t>(0, 63, true, true)));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_mapand_data_forwarding_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flow_list, bref, 1, 64, integer_packer<uint8_t>(0, 63, true, true)));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_mapand_data_forwarding_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.start_array("mBS-QoSFlowList");
  for (const auto& e1 : mbs_qos_flow_list) {
    j.write_int(e1);
  }
  j.end_array();
  if (mrb_progress_info_present) {
    j.write_fieldname("mRB-ProgressInformation");
    mrb_progress_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-QoSFlowsToBeSetupItem ::= SEQUENCE
SRSASN_CODE mbs_qos_flows_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mb_sqos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(mb_sqos_flow_level_qos_params.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_qos_flows_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mb_sqos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(mb_sqos_flow_level_qos_params.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_qos_flows_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBSqosFlowIdentifier", mb_sqos_flow_id);
  j.write_fieldname("mBSqosFlowLevelQosParameters");
  mb_sqos_flow_level_qos_params.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ActiveSessionInformation-SourcetoTargetItem ::= SEQUENCE
SRSASN_CODE mbs_active_session_info_sourceto_target_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_present, 1));
  HANDLE_CODE(bref.pack(mbs_mapand_data_forwarding_request_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flows_to_be_setup_list, 1, 64, true));
  if (mbs_mapand_data_forwarding_request_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_mapand_data_forwarding_request_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_active_session_info_sourceto_target_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(mbs_service_area_present, 1));
  bool mbs_mapand_data_forwarding_request_list_present;
  HANDLE_CODE(bref.unpack(mbs_mapand_data_forwarding_request_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flows_to_be_setup_list, bref, 1, 64, true));
  if (mbs_mapand_data_forwarding_request_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_mapand_data_forwarding_request_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_active_session_info_sourceto_target_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (mbs_service_area_present) {
    j.write_fieldname("mBS-ServiceArea");
    mbs_service_area.to_json(j);
  }
  j.start_array("mBS-QoSFlowsToBeSetupList");
  for (const auto& e1 : mbs_qos_flows_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (mbs_mapand_data_forwarding_request_list.size() > 0) {
    j.start_array("mBS-MappingandDataForwardingRequestList");
    for (const auto& e1 : mbs_mapand_data_forwarding_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DataForwardingResponseMRBItem ::= SEQUENCE
SRSASN_CODE mbs_data_forwarding_resp_mrb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_data_forwarding_resp_mrb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_data_forwarding_resp_mrb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("dL-Forwarding-UPTNLInformation");
  dl_forwarding_up_tnl_info.to_json(j);
  if (mrb_progress_info_present) {
    j.write_fieldname("mRB-ProgressInformation");
    mrb_progress_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ActiveSessionInformation-TargettoSourceItem ::= SEQUENCE
SRSASN_CODE mbs_active_session_info_targetto_source_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_data_forwarding_resp_mrb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_data_forwarding_resp_mrb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_data_forwarding_resp_mrb_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_active_session_info_targetto_source_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mbs_data_forwarding_resp_mrb_list_present;
  HANDLE_CODE(bref.unpack(mbs_data_forwarding_resp_mrb_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_data_forwarding_resp_mrb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_data_forwarding_resp_mrb_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_active_session_info_targetto_source_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_data_forwarding_resp_mrb_list.size() > 0) {
    j.start_array("mBS-DataForwardingResponseMRBList");
    for (const auto& e1 : mbs_data_forwarding_resp_mrb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DistributionReleaseRequestTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_release_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_release_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.unpack(bref));
  }
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_release_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (shared_ngu_unicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-UnicastTNLInformation");
    shared_ngu_unicast_tnl_info.to_json(j);
  }
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DistributionSetupRequestTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_setup_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_setup_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_setup_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (shared_ngu_unicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-UnicastTNLInformation");
    shared_ngu_unicast_tnl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SharedNGU-MulticastTNLInformation ::= SEQUENCE
SRSASN_CODE shared_ngu_multicast_tnl_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ip_multicast_address.pack(bref));
  HANDLE_CODE(ip_source_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_ngu_multicast_tnl_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ip_multicast_address.unpack(bref));
  HANDLE_CODE(ip_source_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void shared_ngu_multicast_tnl_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iP-MulticastAddress", ip_multicast_address.to_string());
  j.write_str("iP-SourceAddress", ip_source_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionTNLInfo5GCItem ::= SEQUENCE
SRSASN_CODE mbs_session_tnl_info5_gc_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(shared_ngu_multicast_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info5_gc_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(shared_ngu_multicast_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_tnl_info5_gc_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  j.write_fieldname("sharedNGU-MulticastTNLInformation");
  shared_ngu_multicast_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionStatus ::= ENUMERATED
const char* mbs_session_status_opts::to_string() const
{
  static const char* names[] = {"activated", "deactivated"};
  return convert_enum_idx(names, 2, value, "mbs_session_status_e");
}

// MBS-DistributionSetupResponseTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_setup_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(shared_ngu_multicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_multicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_multicast_tnl_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flows_to_be_setup_list, 1, 64, true));
  HANDLE_CODE(mbs_session_status.pack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_setup_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(shared_ngu_multicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(mbs_service_area_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_multicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_multicast_tnl_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flows_to_be_setup_list, bref, 1, 64, true));
  HANDLE_CODE(mbs_session_status.unpack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_setup_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (shared_ngu_multicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-MulticastTNLInformation");
    shared_ngu_multicast_tnl_info.to_json(j);
  }
  j.start_array("mBS-QoSFlowsToBeSetupList");
  for (const auto& e1 : mbs_qos_flows_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("mBSSessionStatus", mbs_session_status.to_string());
  if (mbs_service_area_present) {
    j.write_fieldname("mBS-ServiceArea");
    mbs_service_area.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DistributionSetupUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_setup_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_setup_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_setup_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionTNLInfo5GC ::= CHOICE
void mbs_session_tnl_info5_gc_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<shared_ngu_multicast_tnl_info_s>();
      break;
    case types::locationdependent:
      c.destroy<mbs_session_tnl_info5_gc_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_session_tnl_info5_gc_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<shared_ngu_multicast_tnl_info_s>();
      break;
    case types::locationdependent:
      c.init<mbs_session_tnl_info5_gc_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }
}
mbs_session_tnl_info5_gc_c::mbs_session_tnl_info5_gc_c(const mbs_session_tnl_info5_gc_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<shared_ngu_multicast_tnl_info_s>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_session_tnl_info5_gc_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }
}
mbs_session_tnl_info5_gc_c& mbs_session_tnl_info5_gc_c::operator=(const mbs_session_tnl_info5_gc_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<shared_ngu_multicast_tnl_info_s>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_session_tnl_info5_gc_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }

  return *this;
}
shared_ngu_multicast_tnl_info_s& mbs_session_tnl_info5_gc_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<shared_ngu_multicast_tnl_info_s>();
}
mbs_session_tnl_info5_gc_list_l& mbs_session_tnl_info5_gc_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_session_tnl_info5_gc_list_l>();
}
protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>& mbs_session_tnl_info5_gc_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>();
}
void mbs_session_tnl_info5_gc_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<shared_ngu_multicast_tnl_info_s>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_session_tnl_info5_gc_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_session_tnl_info5_gc_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<shared_ngu_multicast_tnl_info_s>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_tnl_info5_gc_list_l>(), 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info5_gc_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<shared_ngu_multicast_tnl_info_s>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_tnl_info5_gc_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_session_tnl_info5_gc_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mbs_session_tnl_info5_gc_c::types");
}

// MBS-SessionTNLInfoNGRANItem ::= SEQUENCE
SRSASN_CODE mbs_session_tnl_info_ngran_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info_ngran_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_tnl_info_ngran_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  if (shared_ngu_unicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-UnicastTNLInformation");
    shared_ngu_unicast_tnl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionTNLInfoNGRAN ::= CHOICE
void mbs_session_tnl_info_ngran_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::locationdependent:
      c.destroy<mbs_session_tnl_info_ngran_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_session_tnl_info_ngran_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<up_transport_layer_info_c>();
      break;
    case types::locationdependent:
      c.init<mbs_session_tnl_info_ngran_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }
}
mbs_session_tnl_info_ngran_c::mbs_session_tnl_info_ngran_c(const mbs_session_tnl_info_ngran_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_session_tnl_info_ngran_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }
}
mbs_session_tnl_info_ngran_c& mbs_session_tnl_info_ngran_c::operator=(const mbs_session_tnl_info_ngran_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_session_tnl_info_ngran_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }

  return *this;
}
up_transport_layer_info_c& mbs_session_tnl_info_ngran_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<up_transport_layer_info_c>();
}
mbs_session_tnl_info_ngran_list_l& mbs_session_tnl_info_ngran_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_session_tnl_info_ngran_list_l>();
}
protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>& mbs_session_tnl_info_ngran_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>();
}
void mbs_session_tnl_info_ngran_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_session_tnl_info_ngran_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_session_tnl_info_ngran_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_tnl_info_ngran_list_l>(), 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info_ngran_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_tnl_info_ngran_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_session_tnl_info_ngran_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mbs_session_tnl_info_ngran_c::types");
}

// MBSSessionFailedtoSetupItem ::= SEQUENCE
SRSASN_CODE mbs_session_failedto_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_failedto_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_failedto_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionReleaseResponseTransfer ::= SEQUENCE
SRSASN_CODE mbs_session_release_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_release_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_release_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_session_tnl_info_ngran_present) {
    j.write_fieldname("mBS-SessionTNLInfoNGRAN");
    mbs_session_tnl_info_ngran.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupOrModFailureTransfer ::= SEQUENCE
SRSASN_CODE mbs_session_setup_or_mod_fail_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_fail_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_or_mod_fail_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupOrModRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t mbs_session_setup_or_mod_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {352, 297, 357};
  return map_enum_number(names, 3, idx, "id");
}
bool mbs_session_setup_or_mod_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {352, 297, 357};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mbs_session_setup_or_mod_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 352:
      return crit_e::reject;
    case 297:
      return crit_e::reject;
    case 357:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
mbs_session_setup_or_mod_request_transfer_ies_o::value_c
mbs_session_setup_or_mod_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 352:
      ret.set(value_c::types::mbs_session_tnl_info5_gc);
      break;
    case 297:
      ret.set(value_c::types::mbs_qos_flows_to_be_setup_mod_list);
      break;
    case 357:
      ret.set(value_c::types::mbs_session_fsa_id_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e mbs_session_setup_or_mod_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 352:
      return presence_e::optional;
    case 297:
      return presence_e::mandatory;
    case 357:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void mbs_session_setup_or_mod_request_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      c = mbs_session_tnl_info5_gc_c{};
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c = mbs_qos_flows_to_be_setup_list_l{};
      break;
    case types::mbs_session_fsa_id_list:
      c = mbs_session_fsa_id_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
  }
}
mbs_session_tnl_info5_gc_c& mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc()
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
mbs_qos_flows_to_be_setup_list_l&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list()
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
mbs_session_fsa_id_list_l& mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_fsa_id_list()
{
  assert_choice_type(types::mbs_session_fsa_id_list, type_, "Value");
  return c.get<mbs_session_fsa_id_list_l>();
}
const mbs_session_tnl_info5_gc_c&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc() const
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
const mbs_qos_flows_to_be_setup_list_l&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list() const
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
const mbs_session_fsa_id_list_l&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_fsa_id_list() const
{
  assert_choice_type(types::mbs_session_fsa_id_list, type_, "Value");
  return c.get<mbs_session_fsa_id_list_l>();
}
void mbs_session_setup_or_mod_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      j.write_fieldname("MBS-SessionTNLInfo5GC");
      c.get<mbs_session_tnl_info5_gc_c>().to_json(j);
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      j.start_array("MBS-QoSFlowsToBeSetupList");
      for (const auto& e1 : c.get<mbs_qos_flows_to_be_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_fsa_id_list:
      j.start_array("MBS-SessionFSAIDList");
      for (const auto& e1 : c.get<mbs_session_fsa_id_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().pack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_qos_flows_to_be_setup_list_l>(), 1, 64, true));
      break;
    case types::mbs_session_fsa_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_fsa_id_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().unpack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_qos_flows_to_be_setup_list_l>(), bref, 1, 64, true));
      break;
    case types::mbs_session_fsa_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_fsa_id_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionTNLInfo5GC", "MBS-QoSFlowsToBeSetupList", "MBS-SessionFSAIDList"};
  return convert_enum_idx(names, 3, value, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types");
}
uint8_t mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<mbs_session_setup_or_mod_request_transfer_ies_o>;

SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_tnl_info5_gc_present ? 1 : 0;
  nof_ies += mbs_session_fsa_id_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (mbs_session_tnl_info5_gc_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)352, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_tnl_info5_gc.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)297, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flows_to_be_setup_mod_list, 1, 64, true));
  }
  if (mbs_session_fsa_id_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)357, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_fsa_id_list, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 352: {
        mbs_session_tnl_info5_gc_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_tnl_info5_gc.unpack(bref));
        break;
      }
      case 297: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flows_to_be_setup_mod_list, bref, 1, 64, true));
        break;
      }
      case 357: {
        mbs_session_fsa_id_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_fsa_id_list, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void mbs_session_setup_or_mod_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_session_tnl_info5_gc_present) {
    j.write_int("id", 352);
    j.write_str("criticality", "reject");
    mbs_session_tnl_info5_gc.to_json(j);
  }
  j.write_int("id", 297);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : mbs_qos_flows_to_be_setup_mod_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (mbs_session_fsa_id_list_present) {
    j.write_int("id", 357);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : mbs_session_fsa_id_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  j.end_obj();
}

// MBSSessionSetupOrModResponseTransfer ::= SEQUENCE
SRSASN_CODE mbs_session_setup_or_mod_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_or_mod_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_session_tnl_info_ngran_present) {
    j.write_fieldname("mBS-SessionTNLInfoNGRAN");
    mbs_session_tnl_info_ngran.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupRequestItem ::= SEQUENCE
SRSASN_CODE mbs_session_setup_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(associated_mbs_qos_flow_setup_request_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setup_request_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, associated_mbs_qos_flow_setup_request_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  bool associated_mbs_qos_flow_setup_request_list_present;
  HANDLE_CODE(bref.unpack(associated_mbs_qos_flow_setup_request_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setup_request_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(associated_mbs_qos_flow_setup_request_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (associated_mbs_qos_flow_setup_request_list.size() > 0) {
    j.start_array("associatedMBSQosFlowSetupRequestList");
    for (const auto& e1 : associated_mbs_qos_flow_setup_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupResponseItem ::= SEQUENCE
SRSASN_CODE mbs_session_setup_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetuporModifyRequestItem ::= SEQUENCE
SRSASN_CODE mbs_session_setupor_modify_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(associated_mbs_qos_flow_setupor_modify_request_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(mbs_qos_flow_to_release_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setupor_modify_request_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, associated_mbs_qos_flow_setupor_modify_request_list, 1, 64, true));
  }
  if (mbs_qos_flow_to_release_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flow_to_release_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setupor_modify_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  bool associated_mbs_qos_flow_setupor_modify_request_list_present;
  HANDLE_CODE(bref.unpack(associated_mbs_qos_flow_setupor_modify_request_list_present, 1));
  bool mbs_qos_flow_to_release_list_present;
  HANDLE_CODE(bref.unpack(mbs_qos_flow_to_release_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setupor_modify_request_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(associated_mbs_qos_flow_setupor_modify_request_list, bref, 1, 64, true));
  }
  if (mbs_qos_flow_to_release_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flow_to_release_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setupor_modify_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (associated_mbs_qos_flow_setupor_modify_request_list.size() > 0) {
    j.start_array("associatedMBSQosFlowSetuporModifyRequestList");
    for (const auto& e1 : associated_mbs_qos_flow_setupor_modify_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_qos_flow_to_release_list.size() > 0) {
    j.start_array("mBS-QosFlowToReleaseList");
    for (const auto& e1 : mbs_qos_flow_to_release_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionToReleaseItem ::= SEQUENCE
SRSASN_CODE mbs_session_to_release_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_to_release_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_to_release_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastSessionActivationRequestTransfer ::= SEQUENCE
SRSASN_CODE multicast_session_activation_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_session_activation_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastSessionDeactivationRequestTransfer ::= SEQUENCE
SRSASN_CODE multicast_session_deactivation_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastSessionUpdateRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 297, 351, 352};
  return map_enum_number(names, 5, idx, "id");
}
bool multicast_session_upd_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 297, 351, 352};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 297:
      return crit_e::reject;
    case 351:
      return crit_e::reject;
    case 352:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_request_transfer_ies_o::value_c
multicast_session_upd_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 297:
      ret.set(value_c::types::mbs_qos_flows_to_be_setup_mod_list);
      break;
    case 351:
      ret.set(value_c::types::mbs_qos_flow_to_release_list);
      break;
    case 352:
      ret.set(value_c::types::mbs_session_tnl_info5_gc);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 297:
      return presence_e::optional;
    case 351:
      return presence_e::optional;
    case 352:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_request_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c = mbs_session_id_s{};
      break;
    case types::mbs_service_area:
      c = mbs_service_area_c{};
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c = mbs_qos_flows_to_be_setup_list_l{};
      break;
    case types::mbs_qos_flow_to_release_list:
      c = qos_flow_list_with_cause_l{};
      break;
    case types::mbs_session_tnl_info5_gc:
      c = mbs_session_tnl_info5_gc_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
  }
}
mbs_session_id_s& multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& multicast_session_upd_request_transfer_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
mbs_qos_flows_to_be_setup_list_l&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list()
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
qos_flow_list_with_cause_l& multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flow_to_release_list()
{
  assert_choice_type(types::mbs_qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
mbs_session_tnl_info5_gc_c& multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc()
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
const mbs_session_id_s& multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& multicast_session_upd_request_transfer_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const mbs_qos_flows_to_be_setup_list_l&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list() const
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
const qos_flow_list_with_cause_l&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flow_to_release_list() const
{
  assert_choice_type(types::mbs_qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
const mbs_session_tnl_info5_gc_c&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc() const
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
void multicast_session_upd_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      j.start_array("MBS-QoSFlowsToBeSetupList");
      for (const auto& e1 : c.get<mbs_qos_flows_to_be_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_qos_flow_to_release_list:
      j.start_array("QosFlowListWithCause");
      for (const auto& e1 : c.get<qos_flow_list_with_cause_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_tnl_info5_gc:
      j.write_fieldname("MBS-SessionTNLInfo5GC");
      c.get<mbs_session_tnl_info5_gc_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_qos_flows_to_be_setup_list_l>(), 1, 64, true));
      break;
    case types::mbs_qos_flow_to_release_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_list_with_cause_l>(), 1, 64, true));
      break;
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_qos_flows_to_be_setup_list_l>(), bref, 1, 64, true));
      break;
    case types::mbs_qos_flow_to_release_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_list_with_cause_l>(), bref, 1, 64, true));
      break;
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "MBS-SessionID", "MBS-ServiceArea", "MBS-QoSFlowsToBeSetupList", "QosFlowListWithCause", "MBS-SessionTNLInfo5GC"};
  return convert_enum_idx(names, 5, value, "multicast_session_upd_request_transfer_ies_o::value_c::types");
}
uint8_t multicast_session_upd_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_session_tnl_info5_gc) {
    return 5;
  }
  invalid_enum_number(value, "multicast_session_upd_request_transfer_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_request_transfer_ies_o>;

SRSASN_CODE multicast_session_upd_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_service_area_present ? 1 : 0;
  nof_ies += mbs_qos_flows_to_be_setup_mod_list_present ? 1 : 0;
  nof_ies += mbs_qos_flow_to_release_list_present ? 1 : 0;
  nof_ies += mbs_session_tnl_info5_gc_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (mbs_qos_flows_to_be_setup_mod_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)297, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flows_to_be_setup_mod_list, 1, 64, true));
  }
  if (mbs_qos_flow_to_release_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)351, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flow_to_release_list, 1, 64, true));
  }
  if (mbs_session_tnl_info5_gc_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)352, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_tnl_info5_gc.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.unpack(bref));
        break;
      }
      case 297: {
        mbs_qos_flows_to_be_setup_mod_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flows_to_be_setup_mod_list, bref, 1, 64, true));
        break;
      }
      case 351: {
        mbs_qos_flow_to_release_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flow_to_release_list, bref, 1, 64, true));
        break;
      }
      case 352: {
        mbs_session_tnl_info5_gc_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_tnl_info5_gc.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_int("id", 298);
    j.write_str("criticality", "reject");
    mbs_service_area.to_json(j);
  }
  if (mbs_qos_flows_to_be_setup_mod_list_present) {
    j.write_int("id", 297);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : mbs_qos_flows_to_be_setup_mod_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_qos_flow_to_release_list_present) {
    j.write_int("id", 351);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : mbs_qos_flow_to_release_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_session_tnl_info5_gc_present) {
    j.write_int("id", 352);
    j.write_str("criticality", "reject");
    mbs_session_tnl_info5_gc.to_json(j);
  }
  j.end_obj();
}

// NGAPIESupportInformationRequestItem ::= SEQUENCE
SRSASN_CODE ngap_ie_support_info_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ngap_protocol_ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_ie_support_info_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ngap_protocol_ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngap_ie_support_info_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("ngap-ProtocolIE-Id", ngap_protocol_ie_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGAPIESupportInformationResponseItem ::= SEQUENCE
SRSASN_CODE ngap_ie_support_info_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ngap_protocol_ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(ngap_protocol_ie_support_info.pack(bref));
  HANDLE_CODE(ngap_protocol_ie_presence_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_ie_support_info_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ngap_protocol_ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(ngap_protocol_ie_support_info.unpack(bref));
  HANDLE_CODE(ngap_protocol_ie_presence_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngap_ie_support_info_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("ngap-ProtocolIE-Id", ngap_protocol_ie_id);
  j.write_str("ngap-ProtocolIESupportInfo", ngap_protocol_ie_support_info.to_string());
  j.write_str("ngap-ProtocolIEPresenceInfo", ngap_protocol_ie_presence_info.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ngap_ie_support_info_resp_item_s::ngap_protocol_ie_support_info_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "ngap_ie_support_info_resp_item_s::ngap_protocol_ie_support_info_e_");
}

const char* ngap_ie_support_info_resp_item_s::ngap_protocol_ie_presence_info_opts::to_string() const
{
  static const char* names[] = {"present", "not-present"};
  return convert_enum_idx(names, 2, value, "ngap_ie_support_info_resp_item_s::ngap_protocol_ie_presence_info_e_");
}

// PDUSessionAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE pdu_session_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_aggr_max_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, pdu_session_aggr_max_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(pdu_session_aggr_max_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(
      unpack_integer(pdu_session_aggr_max_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionAggregateMaximumBitRateDL", pdu_session_aggr_max_bit_rate_dl);
  j.write_int("pDUSessionAggregateMaximumBitRateUL", pdu_session_aggr_max_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ULForwarding ::= ENUMERATED
const char* ul_forwarding_opts::to_string() const
{
  static const char* names[] = {"ul-forwarding-proposed"};
  return convert_enum_idx(names, 1, value, "ul_forwarding_e");
}

// QosFlowInformationItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {163, 284, 354};
  return map_enum_number(names, 3, idx, "id");
}
bool qos_flow_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {163, 284, 354};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 163:
      return crit_e::ignore;
    case 284:
      return crit_e::ignore;
    case 354:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_info_item_ext_ies_o::ext_c qos_flow_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 163:
      ret.set(ext_c::types::ul_forwarding);
      break;
    case 284:
      ret.set(ext_c::types::source_tnla_ddr_info);
      break;
    case 354:
      ret.set(ext_c::types::source_node_tnla_ddr_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 163:
      return presence_e::optional;
    case 284:
      return presence_e::optional;
    case 354:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_info_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::ul_forwarding:
      c = ul_forwarding_e{};
      break;
    case types::source_tnla_ddr_info:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::source_node_tnla_ddr_info:
      c = bounded_bitstring<1, 160, true, true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
  }
}
ul_forwarding_e& qos_flow_info_item_ext_ies_o::ext_c::ul_forwarding()
{
  assert_choice_type(types::ul_forwarding, type_, "Extension");
  return c.get<ul_forwarding_e>();
}
bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_tnla_ddr_info()
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info()
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const ul_forwarding_e& qos_flow_info_item_ext_ies_o::ext_c::ul_forwarding() const
{
  assert_choice_type(types::ul_forwarding, type_, "Extension");
  return c.get<ul_forwarding_e>();
}
const bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_tnla_ddr_info() const
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info() const
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
void qos_flow_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_forwarding:
      j.write_str("ULForwarding", "ul-forwarding-proposed");
      break;
    case types::source_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::source_node_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_forwarding:
      HANDLE_CODE(c.get<ul_forwarding_e>().pack(bref));
      break;
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_forwarding:
      HANDLE_CODE(c.get<ul_forwarding_e>().unpack(bref));
      break;
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_info_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ULForwarding", "BIT STRING", "BIT STRING"};
  return convert_enum_idx(names, 3, value, "qos_flow_info_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_info_item_ext_ies_o>;

SRSASN_CODE qos_flow_info_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ul_forwarding_present ? 1 : 0;
  nof_ies += source_tnla_ddr_info_present ? 1 : 0;
  nof_ies += source_node_tnla_ddr_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ul_forwarding_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)163, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_forwarding.pack(bref));
  }
  if (source_tnla_ddr_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)284, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_tnla_ddr_info.pack(bref));
  }
  if (source_node_tnla_ddr_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)354, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_node_tnla_ddr_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_info_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 163: {
        ul_forwarding_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_forwarding.unpack(bref));
        break;
      }
      case 284: {
        source_tnla_ddr_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_tnla_ddr_info.unpack(bref));
        break;
      }
      case 354: {
        source_node_tnla_ddr_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_node_tnla_ddr_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_info_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_forwarding_present) {
    j.write_int("id", 163);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "ul-forwarding-proposed");
  }
  if (source_tnla_ddr_info_present) {
    j.write_int("id", 284);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", source_tnla_ddr_info.to_string());
  }
  if (source_node_tnla_ddr_info_present) {
    j.write_int("id", 354);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", source_node_tnla_ddr_info.to_string());
  }
  j.end_obj();
}

// QosFlowInformationItem ::= SEQUENCE
SRSASN_CODE qos_flow_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (dl_forwarding_present) {
    j.write_str("dLForwarding", "dl-forwarding-proposed");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceInformationItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drbs_to_qos_flows_map_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_info_list, 1, 64, true));
  if (drbs_to_qos_flows_map_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_qos_flows_map_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool drbs_to_qos_flows_map_list_present;
  HANDLE_CODE(bref.unpack(drbs_to_qos_flows_map_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_info_list, bref, 1, 64, true));
  if (drbs_to_qos_flows_map_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_qos_flows_map_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.start_array("qosFlowInformationList");
  for (const auto& e1 : qos_flow_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (drbs_to_qos_flows_map_list.size() > 0) {
    j.start_array("dRBsToQosFlowsMappingList");
    for (const auto& e1 : drbs_to_qos_flows_map_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportLayerInformationPairItem ::= SEQUENCE
SRSASN_CODE up_transport_layer_info_pair_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_pair_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void up_transport_layer_info_pair_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-NGU-UP-TNLInformation");
  ul_ngu_up_tnl_info.to_json(j);
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowModifyConfirmItem ::= SEQUENCE
SRSASN_CODE qos_flow_modify_confirm_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_modify_confirm_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_modify_confirm_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyConfirmTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_confirm_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {195, 185};
  return map_enum_number(names, 2, idx, "id");
}
bool pdu_session_res_modify_confirm_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {195, 185};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_confirm_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 195:
      return crit_e::ignore;
    case 185:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c
pdu_session_res_modify_confirm_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 185:
      ret.set(ext_c::types::add_redundant_ngu_up_tnl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_confirm_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 195:
      return presence_e::optional;
    case 185:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c = up_transport_layer_info_pair_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
  }
}
up_transport_layer_info_c& pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_pair_list_l&
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_pair_list_l&
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
void pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformation", "UPTransportLayerInformationPairList"};
  return convert_enum_idx(names, 2, value, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_confirm_transfer_ext_ies_o>;

SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ngu_up_tnl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)195, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)185, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_ngu_up_tnl_info, 1, 3, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 185: {
        add_redundant_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 195);
    j.write_str("criticality", "ignore");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    j.write_int("id", 185);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PDUSessionResourceModifyConfirmTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_confirm_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_ng_u_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_modify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_modify_confirm_list, 1, 64, true));
  HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  if (add_ng_u_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ng_u_up_tnl_info, 1, 3, true));
  }
  if (qos_flow_failed_to_modify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_modify_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool add_ng_u_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_ng_u_up_tnl_info_present, 1));
  bool qos_flow_failed_to_modify_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_modify_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_modify_confirm_list, bref, 1, 64, true));
  HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  if (add_ng_u_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_ng_u_up_tnl_info, bref, 1, 3, true));
  }
  if (qos_flow_failed_to_modify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_modify_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("qosFlowModifyConfirmList");
  for (const auto& e1 : qos_flow_modify_confirm_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("uLNGU-UP-TNLInformation");
  ul_ngu_up_tnl_info.to_json(j);
  if (add_ng_u_up_tnl_info.size() > 0) {
    j.start_array("additionalNG-UUPTNLInformation");
    for (const auto& e1 : add_ng_u_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_failed_to_modify_list.size() > 0) {
    j.start_array("qosFlowFailedToModifyList");
    for (const auto& e1 : qos_flow_failed_to_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// VolumeTimedReport-Item ::= SEQUENCE
SRSASN_CODE volume_timed_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(start_time_stamp.pack(bref));
  HANDLE_CODE(end_time_stamp.pack(bref));
  HANDLE_CODE(pack_integer(bref, usage_count_ul, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(pack_integer(bref, usage_count_dl, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE volume_timed_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(start_time_stamp.unpack(bref));
  HANDLE_CODE(end_time_stamp.unpack(bref));
  HANDLE_CODE(unpack_integer(usage_count_ul, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(unpack_integer(usage_count_dl, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void volume_timed_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("startTimeStamp", start_time_stamp.to_string());
  j.write_str("endTimeStamp", end_time_stamp.to_string());
  j.write_int("usageCountUL", usage_count_ul);
  j.write_int("usageCountDL", usage_count_dl);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsUsageReport-Item ::= SEQUENCE
SRSASN_CODE qos_flows_usage_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(rat_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_timed_report_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_usage_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(rat_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_timed_report_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_usage_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_str("rATType", rat_type.to_string());
  j.start_array("qoSFlowsTimedReportList");
  for (const auto& e1 : qos_flows_timed_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* qos_flows_usage_report_item_s::rat_type_opts::to_string() const
{
  static const char* names[] = {"nr", "eutra", "nr-unlicensed", "e-utra-unlicensed"};
  return convert_enum_idx(names, 4, value, "qos_flows_usage_report_item_s::rat_type_e_");
}

// PDUSessionUsageReport ::= SEQUENCE
SRSASN_CODE pdu_session_usage_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rat_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_timed_report_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_usage_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rat_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(pdu_session_timed_report_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_usage_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rATType", rat_type.to_string());
  j.start_array("pDUSessionTimedReportList");
  for (const auto& e1 : pdu_session_timed_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* pdu_session_usage_report_s::rat_type_opts::to_string() const
{
  static const char* names[] = {"nr", "eutra", "nr-unlicensed", "e-utra-unlicensed"};
  return convert_enum_idx(names, 4, value, "pdu_session_usage_report_s::rat_type_e_");
}

// SecondaryRATUsageInformation ::= SEQUENCE
SRSASN_CODE secondary_rat_usage_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_usage_report_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_usage_report_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (pdu_session_usage_report_present) {
    HANDLE_CODE(pdu_session_usage_report.pack(bref));
  }
  if (qos_flows_usage_report_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_usage_report_list, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_usage_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdu_session_usage_report_present, 1));
  bool qos_flows_usage_report_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_usage_report_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (pdu_session_usage_report_present) {
    HANDLE_CODE(pdu_session_usage_report.unpack(bref));
  }
  if (qos_flows_usage_report_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_usage_report_list, bref, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void secondary_rat_usage_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_usage_report_present) {
    j.write_fieldname("pDUSessionUsageReport");
    pdu_session_usage_report.to_json(j);
  }
  if (qos_flows_usage_report_list.size() > 0) {
    j.start_array("qosFlowsUsageReportList");
    for (const auto& e1 : qos_flows_usage_report_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyIndicationTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_ind_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144, 156, 193, 184, 27};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_modify_ind_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {144, 156, 193, 184, 27};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_ind_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 144:
      return crit_e::ignore;
    case 156:
      return crit_e::ignore;
    case 193:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c
pdu_session_res_modify_ind_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 144:
      ret.set(ext_c::types::secondary_rat_usage_info);
      break;
    case 156:
      ret.set(ext_c::types::security_result);
      break;
    case 193:
      ret.set(ext_c::types::redundant_dl_qos_flow_per_tnl_info);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_ind_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 144:
      return presence_e::optional;
    case 156:
      return presence_e::optional;
    case 193:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::secondary_rat_usage_info:
      c = secondary_rat_usage_info_s{};
      break;
    case types::security_result:
      c = security_result_s{};
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      c = qos_flow_per_tnl_info_s{};
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c = qos_flow_per_tnl_info_list_l{};
      break;
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
  }
}
secondary_rat_usage_info_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::secondary_rat_usage_info()
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
security_result_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::security_result()
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
qos_flow_per_tnl_info_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
global_ran_node_id_c& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const secondary_rat_usage_info_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::secondary_rat_usage_info() const
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
const security_result_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::security_result() const
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
const qos_flow_per_tnl_info_s&
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
const qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const global_ran_node_id_c& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
void pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::secondary_rat_usage_info:
      j.write_fieldname("SecondaryRATUsageInformation");
      c.get<secondary_rat_usage_info_s>().to_json(j);
      break;
    case types::security_result:
      j.write_fieldname("SecurityResult");
      c.get<security_result_s>().to_json(j);
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      j.write_fieldname("QosFlowPerTNLInformation");
      c.get<qos_flow_per_tnl_info_s>().to_json(j);
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().pack(bref));
      break;
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().pack(bref));
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().unpack(bref));
      break;
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().unpack(bref));
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation",
                                "SecurityResult",
                                "QosFlowPerTNLInformation",
                                "QosFlowPerTNLInformationList",
                                "GlobalRANNodeID"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_ind_transfer_ext_ies_o>;

SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += secondary_rat_usage_info_present ? 1 : 0;
  nof_ies += security_result_present ? 1 : 0;
  nof_ies += redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)144, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (security_result_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)156, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_result.pack(bref));
  }
  if (redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)193, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)184, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 144: {
        secondary_rat_usage_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(secondary_rat_usage_info.unpack(bref));
        break;
      }
      case 156: {
        security_result_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_result.unpack(bref));
        break;
      }
      case 193: {
        redundant_dl_qos_flow_per_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (secondary_rat_usage_info_present) {
    j.write_int("id", 144);
    j.write_str("criticality", "ignore");
    secondary_rat_usage_info.to_json(j);
  }
  if (security_result_present) {
    j.write_int("id", 156);
    j.write_str("criticality", "ignore");
    security_result.to_json(j);
  }
  if (redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_int("id", 193);
    j.write_str("criticality", "ignore");
    redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_int("id", 184);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (global_ran_node_id_present) {
    j.write_int("id", 27);
    j.write_str("criticality", "ignore");
    global_ran_node_id.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyIndicationTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_ind_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_dl_qos_flow_per_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.pack(bref));
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool add_dl_qos_flow_per_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_dl_qos_flow_per_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.unpack(bref));
  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dLQosFlowPerTNLInformation");
  dl_qos_flow_per_tnl_info.to_json(j);
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    j.start_array("additionalDLQosFlowPerTNLInformation");
    for (const auto& e1 : add_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyIndicationUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_ind_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TSCAssistanceInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t tsc_assist_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {327};
  return map_enum_number(names, 1, idx, "id");
}
bool tsc_assist_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 327 == id;
}
crit_e tsc_assist_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 327) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
tsc_assist_info_ext_ies_o::ext_c tsc_assist_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 327) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e tsc_assist_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 327) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void tsc_assist_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..1920000,...)", c);
  j.end_obj();
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}

const char* tsc_assist_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1920000,...)"};
  return convert_enum_idx(names, 1, value, "tsc_assist_info_ext_ies_o::ext_c::types");
}
uint8_t tsc_assist_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "tsc_assist_info_ext_ies_o::ext_c::types");
}

// TSCAssistanceInformation ::= SEQUENCE
SRSASN_CODE tsc_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(burst_arrival_time.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, periodicity, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time.size() > 0) {
    HANDLE_CODE(burst_arrival_time.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool burst_arrival_time_present;
  HANDLE_CODE(bref.unpack(burst_arrival_time_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(periodicity, bref, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time_present) {
    HANDLE_CODE(burst_arrival_time.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void tsc_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("periodicity", periodicity);
  if (burst_arrival_time.size() > 0) {
    j.write_str("burstArrivalTime", burst_arrival_time.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// RedundantQosFlowIndicator ::= ENUMERATED
const char* redundant_qos_flow_ind_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "redundant_qos_flow_ind_e");
}

// TSCTrafficCharacteristics ::= SEQUENCE
SRSASN_CODE tsc_traffic_characteristics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.pack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.pack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_traffic_characteristics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.unpack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.unpack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tsc_traffic_characteristics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_assist_info_dl_present) {
    j.write_fieldname("tSCAssistanceInformationDL");
    tsc_assist_info_dl.to_json(j);
  }
  if (tsc_assist_info_ul_present) {
    j.write_fieldname("tSCAssistanceInformationUL");
    tsc_assist_info_ul.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MaximumIntegrityProtectedDataRate ::= ENUMERATED
const char* max_integrity_protected_data_rate_opts::to_string() const
{
  static const char* names[] = {"bitrate64kbs", "maximum-UE-rate"};
  return convert_enum_idx(names, 2, value, "max_integrity_protected_data_rate_e");
}
uint8_t max_integrity_protected_data_rate_opts::to_number() const
{
  static const uint8_t numbers[] = {64};
  return map_enum_number(numbers, 1, value, "max_integrity_protected_data_rate_e");
}

// QosFlowAddOrModifyRequestItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_add_or_modify_request_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {196, 194};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flow_add_or_modify_request_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {196, 194};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_add_or_modify_request_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 196:
      return crit_e::ignore;
    case 194:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_add_or_modify_request_item_ext_ies_o::ext_c
qos_flow_add_or_modify_request_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 196:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    case 194:
      ret.set(ext_c::types::redundant_qos_flow_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_add_or_modify_request_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 196:
      return presence_e::optional;
    case 194:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c = tsc_traffic_characteristics_s{};
      break;
    case types::redundant_qos_flow_ind:
      c = redundant_qos_flow_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
  }
}
tsc_traffic_characteristics_s& qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
redundant_qos_flow_ind_e& qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind()
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
const tsc_traffic_characteristics_s&
qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const redundant_qos_flow_ind_e& qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind() const
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
void qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    case types::redundant_qos_flow_ind:
      j.write_str("RedundantQosFlowIndicator", c.get<redundant_qos_flow_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics", "RedundantQosFlowIndicator"};
  return convert_enum_idx(names, 2, value, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::types");
}

// UL-NGU-UP-TNLModifyItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ul_ngu_up_tnl_modify_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {195, 192};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_ngu_up_tnl_modify_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {195, 192};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ngu_up_tnl_modify_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 195:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c ul_ngu_up_tnl_modify_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ngu_up_tnl_modify_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 195:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
  }
}
up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
void ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformation", "UPTransportLayerInformation"};
  return convert_enum_idx(names, 2, value, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::types");
}

// ConfidentialityProtectionIndication ::= ENUMERATED
const char* confidentiality_protection_ind_opts::to_string() const
{
  static const char* names[] = {"required", "preferred", "not-needed"};
  return convert_enum_idx(names, 3, value, "confidentiality_protection_ind_e");
}

// IntegrityProtectionIndication ::= ENUMERATED
const char* integrity_protection_ind_opts::to_string() const
{
  static const char* names[] = {"required", "preferred", "not-needed"};
  return convert_enum_idx(names, 3, value, "integrity_protection_ind_e");
}

template struct asn1::protocol_ext_field_s<qos_flow_add_or_modify_request_item_ext_ies_o>;

SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  nof_ies += redundant_qos_flow_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)196, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }
  if (redundant_qos_flow_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)194, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_qos_flow_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 196: {
        tsc_traffic_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.unpack(bref));
        break;
      }
      case 194: {
        redundant_qos_flow_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_qos_flow_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_add_or_modify_request_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_traffic_characteristics_present) {
    j.write_int("id", 196);
    j.write_str("criticality", "ignore");
    tsc_traffic_characteristics.to_json(j);
  }
  if (redundant_qos_flow_ind_present) {
    j.write_int("id", 194);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_qos_flow_ind.to_string());
  }
  j.end_obj();
}

// QosFlowAddOrModifyRequestItem ::= SEQUENCE
SRSASN_CODE qos_flow_add_or_modify_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_level_qos_params_present, 1));
  HANDLE_CODE(bref.pack(erab_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_level_qos_params_present) {
    HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  }
  if (erab_id_present) {
    HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_flow_level_qos_params_present, 1));
  HANDLE_CODE(bref.unpack(erab_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_level_qos_params_present) {
    HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  }
  if (erab_id_present) {
    HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_add_or_modify_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (qos_flow_level_qos_params_present) {
    j.write_fieldname("qosFlowLevelQosParameters");
    qos_flow_level_qos_params.to_json(j);
  }
  if (erab_id_present) {
    j.write_int("e-RAB-ID", erab_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecurityIndication-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t security_ind_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {151};
  return map_enum_number(names, 1, idx, "id");
}
bool security_ind_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 151 == id;
}
crit_e security_ind_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 151) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
security_ind_ext_ies_o::ext_c security_ind_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 151) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e security_ind_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 151) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void security_ind_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("MaximumIntegrityProtectedDataRate", c.to_string());
  j.end_obj();
}
SRSASN_CODE security_ind_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE security_ind_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* security_ind_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"MaximumIntegrityProtectedDataRate"};
  return convert_enum_idx(names, 1, value, "security_ind_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<ul_ngu_up_tnl_modify_item_ext_ies_o>;

SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)195, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)192, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_ngu_up_tnl_modify_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 195);
    j.write_str("criticality", "ignore");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_int("id", 192);
    j.write_str("criticality", "ignore");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  j.end_obj();
}

// UL-NGU-UP-TNLModifyItem ::= SEQUENCE
SRSASN_CODE ul_ngu_up_tnl_modify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_ngu_up_tnl_modify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-NGU-UP-TNLInformation");
  ul_ngu_up_tnl_info.to_json(j);
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecurityIndication ::= SEQUENCE
SRSASN_CODE security_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_integrity_protected_data_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(integrity_protection_ind.pack(bref));
  HANDLE_CODE(confidentiality_protection_ind.pack(bref));
  if (max_integrity_protected_data_rate_ul_present) {
    HANDLE_CODE(max_integrity_protected_data_rate_ul.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_integrity_protected_data_rate_ul_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_ind.unpack(bref));
  HANDLE_CODE(confidentiality_protection_ind.unpack(bref));
  if (max_integrity_protected_data_rate_ul_present) {
    HANDLE_CODE(max_integrity_protected_data_rate_ul.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void security_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("integrityProtectionIndication", integrity_protection_ind.to_string());
  j.write_str("confidentialityProtectionIndication", confidentiality_protection_ind.to_string());
  if (max_integrity_protected_data_rate_ul_present) {
    j.write_str("maximumIntegrityProtectedDataRate-UL", max_integrity_protected_data_rate_ul.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceModifyRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {130, 140, 129, 135, 137, 126, 166, 186, 190, 195, 138, 319, 317};
  return map_enum_number(names, 13, idx, "id");
}
bool pdu_session_res_modify_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {130, 140, 129, 135, 137, 126, 166, 186, 190, 195, 138, 319, 317};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 130:
      return crit_e::reject;
    case 140:
      return crit_e::reject;
    case 129:
      return crit_e::reject;
    case 135:
      return crit_e::reject;
    case 137:
      return crit_e::reject;
    case 126:
      return crit_e::reject;
    case 166:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 190:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 138:
      return crit_e::ignore;
    case 319:
      return crit_e::ignore;
    case 317:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_request_transfer_ies_o::value_c
pdu_session_res_modify_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 130:
      ret.set(value_c::types::pdu_session_aggr_max_bit_rate);
      break;
    case 140:
      ret.set(value_c::types::ul_ngu_up_tnl_modify_list);
      break;
    case 129:
      ret.set(value_c::types::network_instance);
      break;
    case 135:
      ret.set(value_c::types::qos_flow_add_or_modify_request_list);
      break;
    case 137:
      ret.set(value_c::types::qos_flow_to_release_list);
      break;
    case 126:
      ret.set(value_c::types::add_ul_ngu_up_tnl_info);
      break;
    case 166:
      ret.set(value_c::types::common_network_instance);
      break;
    case 186:
      ret.set(value_c::types::add_redundant_ul_ngu_up_tnl_info);
      break;
    case 190:
      ret.set(value_c::types::redundant_common_network_instance);
      break;
    case 195:
      ret.set(value_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 138:
      ret.set(value_c::types::security_ind);
      break;
    case 319:
      ret.set(value_c::types::mbs_session_setupor_modify_request_list);
      break;
    case 317:
      ret.set(value_c::types::mbs_session_to_release_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 130:
      return presence_e::optional;
    case 140:
      return presence_e::optional;
    case 129:
      return presence_e::optional;
    case 135:
      return presence_e::optional;
    case 137:
      return presence_e::optional;
    case 126:
      return presence_e::optional;
    case 166:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 190:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 138:
      return presence_e::optional;
    case 319:
      return presence_e::optional;
    case 317:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_request_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c = pdu_session_aggr_max_bit_rate_s{};
      break;
    case types::ul_ngu_up_tnl_modify_list:
      c = ul_ngu_up_tnl_modify_list_l{};
      break;
    case types::network_instance:
      c = uint16_t{};
      break;
    case types::qos_flow_add_or_modify_request_list:
      c = qos_flow_add_or_modify_request_list_l{};
      break;
    case types::qos_flow_to_release_list:
      c = qos_flow_list_with_cause_l{};
      break;
    case types::add_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_list_l{};
      break;
    case types::common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_list_l{};
      break;
    case types::redundant_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::security_ind:
      c = security_ind_s{};
      break;
    case types::mbs_session_setupor_modify_request_list:
      c = mbs_session_setupor_modify_request_list_l{};
      break;
    case types::mbs_session_to_release_list:
      c = mbs_session_to_release_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
  }
}
pdu_session_aggr_max_bit_rate_s& pdu_session_res_modify_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate()
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
ul_ngu_up_tnl_modify_list_l& pdu_session_res_modify_request_transfer_ies_o::value_c::ul_ngu_up_tnl_modify_list()
{
  assert_choice_type(types::ul_ngu_up_tnl_modify_list, type_, "Value");
  return c.get<ul_ngu_up_tnl_modify_list_l>();
}
uint16_t& pdu_session_res_modify_request_transfer_ies_o::value_c::network_instance()
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
qos_flow_add_or_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_add_or_modify_request_list()
{
  assert_choice_type(types::qos_flow_add_or_modify_request_list, type_, "Value");
  return c.get<qos_flow_add_or_modify_request_list_l>();
}
qos_flow_list_with_cause_l& pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_to_release_list()
{
  assert_choice_type(types::qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
up_transport_layer_info_list_l& pdu_session_res_modify_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
unbounded_octstring<true>& pdu_session_res_modify_request_transfer_ies_o::value_c::common_network_instance()
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
up_transport_layer_info_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
unbounded_octstring<true>& pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_common_network_instance()
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
up_transport_layer_info_c& pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
security_ind_s& pdu_session_res_modify_request_transfer_ies_o::value_c::security_ind()
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
mbs_session_setupor_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_setupor_modify_request_list()
{
  assert_choice_type(types::mbs_session_setupor_modify_request_list, type_, "Value");
  return c.get<mbs_session_setupor_modify_request_list_l>();
}
mbs_session_to_release_list_l& pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_to_release_list()
{
  assert_choice_type(types::mbs_session_to_release_list, type_, "Value");
  return c.get<mbs_session_to_release_list_l>();
}
const pdu_session_aggr_max_bit_rate_s&
pdu_session_res_modify_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate() const
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
const ul_ngu_up_tnl_modify_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::ul_ngu_up_tnl_modify_list() const
{
  assert_choice_type(types::ul_ngu_up_tnl_modify_list, type_, "Value");
  return c.get<ul_ngu_up_tnl_modify_list_l>();
}
const uint16_t& pdu_session_res_modify_request_transfer_ies_o::value_c::network_instance() const
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
const qos_flow_add_or_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_add_or_modify_request_list() const
{
  assert_choice_type(types::qos_flow_add_or_modify_request_list, type_, "Value");
  return c.get<qos_flow_add_or_modify_request_list_l>();
}
const qos_flow_list_with_cause_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_to_release_list() const
{
  assert_choice_type(types::qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
const up_transport_layer_info_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const unbounded_octstring<true>& pdu_session_res_modify_request_transfer_ies_o::value_c::common_network_instance() const
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const up_transport_layer_info_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const unbounded_octstring<true>&
pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_common_network_instance() const
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
const security_ind_s& pdu_session_res_modify_request_transfer_ies_o::value_c::security_ind() const
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
const mbs_session_setupor_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_setupor_modify_request_list() const
{
  assert_choice_type(types::mbs_session_setupor_modify_request_list, type_, "Value");
  return c.get<mbs_session_setupor_modify_request_list_l>();
}
const mbs_session_to_release_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_to_release_list() const
{
  assert_choice_type(types::mbs_session_to_release_list, type_, "Value");
  return c.get<mbs_session_to_release_list_l>();
}
void pdu_session_res_modify_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      j.write_fieldname("PDUSessionAggregateMaximumBitRate");
      c.get<pdu_session_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ul_ngu_up_tnl_modify_list:
      j.start_array("UL-NGU-UP-TNLModifyList");
      for (const auto& e1 : c.get<ul_ngu_up_tnl_modify_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::network_instance:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::qos_flow_add_or_modify_request_list:
      j.start_array("QosFlowAddOrModifyRequestList");
      for (const auto& e1 : c.get<qos_flow_add_or_modify_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flow_to_release_list:
      j.start_array("QosFlowListWithCause");
      for (const auto& e1 : c.get<qos_flow_list_with_cause_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::add_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::security_ind:
      j.write_fieldname("SecurityIndication");
      c.get<security_ind_s>().to_json(j);
      break;
    case types::mbs_session_setupor_modify_request_list:
      j.start_array("MBSSessionSetuporModifyRequestList");
      for (const auto& e1 : c.get<mbs_session_setupor_modify_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_to_release_list:
      j.start_array("MBSSessionToReleaseList");
      for (const auto& e1 : c.get<mbs_session_to_release_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ul_ngu_up_tnl_modify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ul_ngu_up_tnl_modify_list_l>(), 1, 4, true));
      break;
    case types::network_instance:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_add_or_modify_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_add_or_modify_request_list_l>(), 1, 64, true));
      break;
    case types::qos_flow_to_release_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_list_with_cause_l>(), 1, 64, true));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().pack(bref));
      break;
    case types::mbs_session_setupor_modify_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setupor_modify_request_list_l>(), 1, 32, true));
      break;
    case types::mbs_session_to_release_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_to_release_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ul_ngu_up_tnl_modify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ul_ngu_up_tnl_modify_list_l>(), bref, 1, 4, true));
      break;
    case types::network_instance:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_add_or_modify_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_add_or_modify_request_list_l>(), bref, 1, 64, true));
      break;
    case types::qos_flow_to_release_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_list_with_cause_l>(), bref, 1, 64, true));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().unpack(bref));
      break;
    case types::mbs_session_setupor_modify_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setupor_modify_request_list_l>(), bref, 1, 32, true));
      break;
    case types::mbs_session_to_release_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_to_release_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PDUSessionAggregateMaximumBitRate",
                                "UL-NGU-UP-TNLModifyList",
                                "INTEGER (1..256,...)",
                                "QosFlowAddOrModifyRequestList",
                                "QosFlowListWithCause",
                                "UPTransportLayerInformationList",
                                "OCTET STRING",
                                "UPTransportLayerInformationList",
                                "OCTET STRING",
                                "UPTransportLayerInformation",
                                "SecurityIndication",
                                "MBSSessionSetuporModifyRequestList",
                                "MBSSessionToReleaseList"};
  return convert_enum_idx(names, 13, value, "pdu_session_res_modify_request_transfer_ies_o::value_c::types");
}
uint8_t pdu_session_res_modify_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == network_instance) {
    return 1;
  }
  invalid_enum_number(value, "pdu_session_res_modify_request_transfer_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_request_transfer_ies_o>;

SRSASN_CODE pdu_session_res_modify_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += pdu_session_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ul_ngu_up_tnl_modify_list_present ? 1 : 0;
  nof_ies += network_instance_present ? 1 : 0;
  nof_ies += qos_flow_add_or_modify_request_list_present ? 1 : 0;
  nof_ies += qos_flow_to_release_list_present ? 1 : 0;
  nof_ies += add_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += common_network_instance_present ? 1 : 0;
  nof_ies += add_redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_common_network_instance_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += security_ind_present ? 1 : 0;
  nof_ies += mbs_session_setupor_modify_request_list_present ? 1 : 0;
  nof_ies += mbs_session_to_release_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (pdu_session_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)130, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdu_session_aggr_max_bit_rate.pack(bref));
  }
  if (ul_ngu_up_tnl_modify_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)140, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ul_ngu_up_tnl_modify_list, 1, 4, true));
  }
  if (network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)129, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, network_instance, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (qos_flow_add_or_modify_request_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)135, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_add_or_modify_request_list, 1, 64, true));
  }
  if (qos_flow_to_release_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)137, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_to_release_list, 1, 64, true));
  }
  if (add_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)126, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ul_ngu_up_tnl_info, 1, 3, true));
  }
  if (common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)166, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(common_network_instance.pack(bref));
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)186, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_ul_ngu_up_tnl_info, 1, 3, true));
  }
  if (redundant_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)190, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_common_network_instance.pack(bref));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)195, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)138, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_ind.pack(bref));
  }
  if (mbs_session_setupor_modify_request_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)319, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_setupor_modify_request_list, 1, 32, true));
  }
  if (mbs_session_to_release_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)317, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_to_release_list, 1, 32, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 130: {
        pdu_session_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 140: {
        ul_ngu_up_tnl_modify_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ul_ngu_up_tnl_modify_list, bref, 1, 4, true));
        break;
      }
      case 129: {
        network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(network_instance, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 135: {
        qos_flow_add_or_modify_request_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flow_add_or_modify_request_list, bref, 1, 64, true));
        break;
      }
      case 137: {
        qos_flow_to_release_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flow_to_release_list, bref, 1, 64, true));
        break;
      }
      case 126: {
        add_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_ul_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 166: {
        common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(common_network_instance.unpack(bref));
        break;
      }
      case 186: {
        add_redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_ul_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 190: {
        redundant_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_common_network_instance.unpack(bref));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 138: {
        security_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_ind.unpack(bref));
        break;
      }
      case 319: {
        mbs_session_setupor_modify_request_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_setupor_modify_request_list, bref, 1, 32, true));
        break;
      }
      case 317: {
        mbs_session_to_release_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_to_release_list, bref, 1, 32, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_aggr_max_bit_rate_present) {
    j.write_int("id", 130);
    j.write_str("criticality", "reject");
    pdu_session_aggr_max_bit_rate.to_json(j);
  }
  if (ul_ngu_up_tnl_modify_list_present) {
    j.write_int("id", 140);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : ul_ngu_up_tnl_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (network_instance_present) {
    j.write_int("id", 129);
    j.write_str("criticality", "reject");
    j.write_int("Value", network_instance);
  }
  if (qos_flow_add_or_modify_request_list_present) {
    j.write_int("id", 135);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : qos_flow_add_or_modify_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_to_release_list_present) {
    j.write_int("id", 137);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : qos_flow_to_release_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (add_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 126);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : add_ul_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (common_network_instance_present) {
    j.write_int("id", 166);
    j.write_str("criticality", "ignore");
    j.write_str("Value", common_network_instance.to_string());
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 186);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : add_redundant_ul_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redundant_common_network_instance_present) {
    j.write_int("id", 190);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redundant_common_network_instance.to_string());
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 195);
    j.write_str("criticality", "ignore");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (security_ind_present) {
    j.write_int("id", 138);
    j.write_str("criticality", "ignore");
    security_ind.to_json(j);
  }
  if (mbs_session_setupor_modify_request_list_present) {
    j.write_int("id", 319);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : mbs_session_setupor_modify_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_session_to_release_list_present) {
    j.write_int("id", 317);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : mbs_session_to_release_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// QosFlowAddOrModifyResponseItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_add_or_modify_resp_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_add_or_modify_resp_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_add_or_modify_resp_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c
qos_flow_add_or_modify_resp_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_add_or_modify_resp_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types");
}

// QosFlowAddOrModifyResponseItem ::= SEQUENCE
SRSASN_CODE qos_flow_add_or_modify_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_add_or_modify_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceModifyResponseTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_resp_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {154, 192, 195, 184, 185, 144, 309, 313, 311};
  return map_enum_number(names, 9, idx, "id");
}
bool pdu_session_res_modify_resp_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {154, 192, 195, 184, 185, 144, 309, 313, 311};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_resp_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 154:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 185:
      return crit_e::ignore;
    case 144:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    case 313:
      return crit_e::ignore;
    case 311:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c
pdu_session_res_modify_resp_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 154:
      ret.set(ext_c::types::add_ngu_up_tnl_info);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 185:
      ret.set(ext_c::types::add_redundant_ngu_up_tnl_info);
      break;
    case 144:
      ret.set(ext_c::types::secondary_rat_usage_info);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    case 313:
      ret.set(ext_c::types::mbs_session_setupor_modify_resp_list);
      break;
    case 311:
      ret.set(ext_c::types::mbs_session_failedto_setupor_modify_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_resp_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 154:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 185:
      return presence_e::optional;
    case 144:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    case 313:
      return presence_e::optional;
    case 311:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c = up_transport_layer_info_pair_list_l{};
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c = qos_flow_per_tnl_info_list_l{};
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c = up_transport_layer_info_pair_list_l{};
      break;
    case types::secondary_rat_usage_info:
      c = secondary_rat_usage_info_s{};
      break;
    case types::mbs_support_ind:
      c = mbs_support_ind_e{};
      break;
    case types::mbs_session_setupor_modify_resp_list:
      c = mbs_session_setup_resp_list_l{};
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      c = mbs_session_failedto_setup_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
  }
}
up_transport_layer_info_pair_list_l& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
up_transport_layer_info_c& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_c& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
up_transport_layer_info_pair_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
secondary_rat_usage_info_s& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::secondary_rat_usage_info()
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
mbs_support_ind_e& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
mbs_session_setup_resp_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_setupor_modify_resp_list()
{
  assert_choice_type(types::mbs_session_setupor_modify_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
mbs_session_failedto_setup_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setupor_modify_list()
{
  assert_choice_type(types::mbs_session_failedto_setupor_modify_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
const up_transport_layer_info_pair_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const up_transport_layer_info_pair_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const secondary_rat_usage_info_s&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::secondary_rat_usage_info() const
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
const mbs_support_ind_e& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const mbs_session_setup_resp_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_setupor_modify_resp_list() const
{
  assert_choice_type(types::mbs_session_setupor_modify_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
const mbs_session_failedto_setup_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setupor_modify_list() const
{
  assert_choice_type(types::mbs_session_failedto_setupor_modify_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
void pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::secondary_rat_usage_info:
      j.write_fieldname("SecondaryRATUsageInformation");
      c.get<secondary_rat_usage_info_s>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    case types::mbs_session_setupor_modify_resp_list:
      j.start_array("MBSSessionSetupResponseList");
      for (const auto& e1 : c.get<mbs_session_setup_resp_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      j.start_array("MBSSessionFailedtoSetupList");
      for (const auto& e1 : c.get<mbs_session_failedto_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    case types::mbs_session_setupor_modify_resp_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setup_resp_list_l>(), 1, 32, true));
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_failedto_setup_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    case types::mbs_session_setupor_modify_resp_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setup_resp_list_l>(), bref, 1, 32, true));
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_failedto_setup_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformationPairList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformation",
                                "QosFlowPerTNLInformationList",
                                "UPTransportLayerInformationPairList",
                                "SecondaryRATUsageInformation",
                                "MBS-SupportIndicator",
                                "MBSSessionSetupResponseList",
                                "MBSSessionFailedtoSetupList"};
  return convert_enum_idx(names, 9, value, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_resp_transfer_ext_ies_o>;

SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += secondary_rat_usage_info_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  nof_ies += mbs_session_setupor_modify_resp_list_present ? 1 : 0;
  nof_ies += mbs_session_failedto_setupor_modify_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)154, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ngu_up_tnl_info, 1, 3, true));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)192, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)195, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)184, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)185, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_ngu_up_tnl_info, 1, 3, true));
  }
  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)144, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)309, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }
  if (mbs_session_setupor_modify_resp_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)313, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_setupor_modify_resp_list, 1, 32, true));
  }
  if (mbs_session_failedto_setupor_modify_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)311, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_failedto_setupor_modify_list, 1, 32, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 154: {
        add_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
        break;
      }
      case 185: {
        add_redundant_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 144: {
        secondary_rat_usage_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(secondary_rat_usage_info.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.unpack(bref));
        break;
      }
      case 313: {
        mbs_session_setupor_modify_resp_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_setupor_modify_resp_list, bref, 1, 32, true));
        break;
      }
      case 311: {
        mbs_session_failedto_setupor_modify_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_failedto_setupor_modify_list, bref, 1, 32, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_ngu_up_tnl_info_present) {
    j.write_int("id", 154);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_int("id", 192);
    j.write_str("criticality", "ignore");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 195);
    j.write_str("criticality", "ignore");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_int("id", 184);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    j.write_int("id", 185);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (secondary_rat_usage_info_present) {
    j.write_int("id", 144);
    j.write_str("criticality", "ignore");
    secondary_rat_usage_info.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_int("id", 309);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (mbs_session_setupor_modify_resp_list_present) {
    j.write_int("id", 313);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_session_setupor_modify_resp_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_session_failedto_setupor_modify_list_present) {
    j.write_int("id", 311);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_session_failedto_setupor_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PDUSessionResourceModifyResponseTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ul_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_add_or_modify_resp_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(add_dl_qos_flow_per_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_add_or_modify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  }
  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  }
  if (qos_flow_add_or_modify_resp_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_add_or_modify_resp_list, 1, 64, true));
  }
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (qos_flow_failed_to_add_or_modify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_add_or_modify_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_ngu_up_tnl_info_present, 1));
  bool qos_flow_add_or_modify_resp_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_add_or_modify_resp_list_present, 1));
  bool add_dl_qos_flow_per_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_dl_qos_flow_per_tnl_info_present, 1));
  bool qos_flow_failed_to_add_or_modify_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_add_or_modify_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  }
  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  }
  if (qos_flow_add_or_modify_resp_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_add_or_modify_resp_list, bref, 1, 64, true));
  }
  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
  }
  if (qos_flow_failed_to_add_or_modify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_add_or_modify_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_ngu_up_tnl_info_present) {
    j.write_fieldname("dL-NGU-UP-TNLInformation");
    dl_ngu_up_tnl_info.to_json(j);
  }
  if (ul_ngu_up_tnl_info_present) {
    j.write_fieldname("uL-NGU-UP-TNLInformation");
    ul_ngu_up_tnl_info.to_json(j);
  }
  if (qos_flow_add_or_modify_resp_list.size() > 0) {
    j.start_array("qosFlowAddOrModifyResponseList");
    for (const auto& e1 : qos_flow_add_or_modify_resp_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    j.start_array("additionalDLQosFlowPerTNLInformation");
    for (const auto& e1 : add_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_failed_to_add_or_modify_list.size() > 0) {
    j.start_array("qosFlowFailedToAddOrModifyList");
    for (const auto& e1 : qos_flow_failed_to_add_or_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceNotifyReleasedTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_notify_released_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_notify_released_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 144 == id;
}
crit_e pdu_session_res_notify_released_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 144) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_notify_released_transfer_ext_ies_o::ext_c
pdu_session_res_notify_released_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 144) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_released_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 144) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SecondaryRATUsageInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::types");
}

// PDUSessionResourceNotifyReleasedTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_notify_released_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_released_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_released_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// NotificationCause ::= ENUMERATED
const char* notif_cause_opts::to_string() const
{
  static const char* names[] = {"fulfilled", "not-fulfilled"};
  return convert_enum_idx(names, 2, value, "notif_cause_e");
}

// QosFlowFeedbackItem ::= SEQUENCE
SRSASN_CODE qos_flow_feedback_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(upd_feedback_present, 1));
  HANDLE_CODE(bref.pack(cnpacket_delay_budget_dl_present, 1));
  HANDLE_CODE(bref.pack(cnpacket_delay_budget_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (upd_feedback_present) {
    HANDLE_CODE(upd_feedback.pack(bref));
  }
  if (cnpacket_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, cnpacket_delay_budget_dl, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cnpacket_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, cnpacket_delay_budget_ul, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_feedback_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(upd_feedback_present, 1));
  HANDLE_CODE(bref.unpack(cnpacket_delay_budget_dl_present, 1));
  HANDLE_CODE(bref.unpack(cnpacket_delay_budget_ul_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (upd_feedback_present) {
    HANDLE_CODE(upd_feedback.unpack(bref));
  }
  if (cnpacket_delay_budget_dl_present) {
    HANDLE_CODE(unpack_integer(cnpacket_delay_budget_dl, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cnpacket_delay_budget_ul_present) {
    HANDLE_CODE(unpack_integer(cnpacket_delay_budget_ul, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_feedback_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (upd_feedback_present) {
    j.write_str("updateFeedback", upd_feedback.to_string());
  }
  if (cnpacket_delay_budget_dl_present) {
    j.write_int("cNpacketDelayBudgetDL", cnpacket_delay_budget_dl);
  }
  if (cnpacket_delay_budget_ul_present) {
    j.write_int("cNpacketDelayBudgetUL", cnpacket_delay_budget_ul);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowNotifyItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_notify_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_notify_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_notify_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_notify_item_ext_ies_o::ext_c qos_flow_notify_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_notify_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_notify_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_notify_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_notify_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_notify_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_notify_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_notify_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "qos_flow_notify_item_ext_ies_o::ext_c::types");
}

// QosFlowNotifyItem ::= SEQUENCE
SRSASN_CODE qos_flow_notify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(notif_cause.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_notify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(notif_cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_notify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_str("notificationCause", notif_cause.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceNotifyTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_notify_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144, 278};
  return map_enum_number(names, 2, idx, "id");
}
bool pdu_session_res_notify_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {144, 278};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_notify_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 144:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_notify_transfer_ext_ies_o::ext_c pdu_session_res_notify_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 144:
      ret.set(ext_c::types::secondary_rat_usage_info);
      break;
    case 278:
      ret.set(ext_c::types::qos_flow_feedback_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 144:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_notify_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::secondary_rat_usage_info:
      c = secondary_rat_usage_info_s{};
      break;
    case types::qos_flow_feedback_list:
      c = qos_flow_feedback_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
  }
}
secondary_rat_usage_info_s& pdu_session_res_notify_transfer_ext_ies_o::ext_c::secondary_rat_usage_info()
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
qos_flow_feedback_list_l& pdu_session_res_notify_transfer_ext_ies_o::ext_c::qos_flow_feedback_list()
{
  assert_choice_type(types::qos_flow_feedback_list, type_, "Extension");
  return c.get<qos_flow_feedback_list_l>();
}
const secondary_rat_usage_info_s& pdu_session_res_notify_transfer_ext_ies_o::ext_c::secondary_rat_usage_info() const
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
const qos_flow_feedback_list_l& pdu_session_res_notify_transfer_ext_ies_o::ext_c::qos_flow_feedback_list() const
{
  assert_choice_type(types::qos_flow_feedback_list, type_, "Extension");
  return c.get<qos_flow_feedback_list_l>();
}
void pdu_session_res_notify_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::secondary_rat_usage_info:
      j.write_fieldname("SecondaryRATUsageInformation");
      c.get<secondary_rat_usage_info_s>().to_json(j);
      break;
    case types::qos_flow_feedback_list:
      j.start_array("QosFlowFeedbackList");
      for (const auto& e1 : c.get<qos_flow_feedback_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().pack(bref));
      break;
    case types::qos_flow_feedback_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_feedback_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().unpack(bref));
      break;
    case types::qos_flow_feedback_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_feedback_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_notify_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation", "QosFlowFeedbackList"};
  return convert_enum_idx(names, 2, value, "pdu_session_res_notify_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_notify_transfer_ext_ies_o>;

SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += secondary_rat_usage_info_present ? 1 : 0;
  nof_ies += qos_flow_feedback_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)144, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (qos_flow_feedback_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)278, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_feedback_list, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 144: {
        secondary_rat_usage_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(secondary_rat_usage_info.unpack(bref));
        break;
      }
      case 278: {
        qos_flow_feedback_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flow_feedback_list, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (secondary_rat_usage_info_present) {
    j.write_int("id", 144);
    j.write_str("criticality", "ignore");
    secondary_rat_usage_info.to_json(j);
  }
  if (qos_flow_feedback_list_present) {
    j.write_int("id", 278);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : qos_flow_feedback_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PDUSessionResourceNotifyTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_notify_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_notify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flow_released_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qos_flow_notify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_notify_list, 1, 64, true));
  }
  if (qos_flow_released_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_released_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool qos_flow_notify_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_notify_list_present, 1));
  bool qos_flow_released_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_released_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qos_flow_notify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_notify_list, bref, 1, 64, true));
  }
  if (qos_flow_released_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_released_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_flow_notify_list.size() > 0) {
    j.start_array("qosFlowNotifyList");
    for (const auto& e1 : qos_flow_notify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_released_list.size() > 0) {
    j.start_array("qosFlowReleasedList");
    for (const auto& e1 : qos_flow_released_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleaseCommandTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_release_cmd_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_release_cmd_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleaseResponseTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_release_resp_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_release_resp_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 144 == id;
}
crit_e pdu_session_res_release_resp_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 144) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_release_resp_transfer_ext_ies_o::ext_c
pdu_session_res_release_resp_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 144) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_resp_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 144) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SecondaryRATUsageInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::types");
}

// PDUSessionResourceReleaseResponseTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_release_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_release_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QosFlowSetupRequestItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_setup_request_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {196, 194};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flow_setup_request_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {196, 194};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_setup_request_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 196:
      return crit_e::ignore;
    case 194:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_setup_request_item_ext_ies_o::ext_c qos_flow_setup_request_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 196:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    case 194:
      ret.set(ext_c::types::redundant_qos_flow_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_setup_request_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 196:
      return presence_e::optional;
    case 194:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_setup_request_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c = tsc_traffic_characteristics_s{};
      break;
    case types::redundant_qos_flow_ind:
      c = redundant_qos_flow_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
  }
}
tsc_traffic_characteristics_s& qos_flow_setup_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
redundant_qos_flow_ind_e& qos_flow_setup_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind()
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
const tsc_traffic_characteristics_s& qos_flow_setup_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const redundant_qos_flow_ind_e& qos_flow_setup_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind() const
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
void qos_flow_setup_request_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    case types::redundant_qos_flow_ind:
      j.write_str("RedundantQosFlowIndicator", c.get<redundant_qos_flow_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_setup_request_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_setup_request_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_setup_request_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics", "RedundantQosFlowIndicator"};
  return convert_enum_idx(names, 2, value, "qos_flow_setup_request_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_setup_request_item_ext_ies_o>;

SRSASN_CODE qos_flow_setup_request_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  nof_ies += redundant_qos_flow_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)196, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }
  if (redundant_qos_flow_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)194, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_qos_flow_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_setup_request_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 196: {
        tsc_traffic_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.unpack(bref));
        break;
      }
      case 194: {
        redundant_qos_flow_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_qos_flow_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_setup_request_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_traffic_characteristics_present) {
    j.write_int("id", 196);
    j.write_str("criticality", "ignore");
    tsc_traffic_characteristics.to_json(j);
  }
  if (redundant_qos_flow_ind_present) {
    j.write_int("id", 194);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redundant_qos_flow_ind.to_string());
  }
  j.end_obj();
}

// QosFlowSetupRequestItem ::= SEQUENCE
SRSASN_CODE qos_flow_setup_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(erab_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  if (erab_id_present) {
    HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_setup_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(erab_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  if (erab_id_present) {
    HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_setup_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_fieldname("qosFlowLevelQosParameters");
  qos_flow_level_qos_params.to_json(j);
  if (erab_id_present) {
    j.write_int("e-RAB-ID", erab_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DataForwardingNotPossible ::= ENUMERATED
const char* data_forwarding_not_possible_opts::to_string() const
{
  static const char* names[] = {"data-forwarding-not-possible"};
  return convert_enum_idx(names, 1, value, "data_forwarding_not_possible_e");
}

// PDUSessionType ::= ENUMERATED
const char* pdu_session_type_opts::to_string() const
{
  static const char* names[] = {"ipv4", "ipv6", "ipv4v6", "ethernet", "unstructured"};
  return convert_enum_idx(names, 5, value, "pdu_session_type_e");
}

// PDUSessionResourceSetupRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {130, 139, 126, 127, 134, 138, 129, 136, 166, 22, 195, 186, 190, 197, 318};
  return map_enum_number(names, 15, idx, "id");
}
bool pdu_session_res_setup_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {130, 139, 126, 127, 134, 138, 129, 136, 166, 22, 195, 186, 190, 197, 318};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 130:
      return crit_e::reject;
    case 139:
      return crit_e::reject;
    case 126:
      return crit_e::reject;
    case 127:
      return crit_e::reject;
    case 134:
      return crit_e::reject;
    case 138:
      return crit_e::reject;
    case 129:
      return crit_e::reject;
    case 136:
      return crit_e::reject;
    case 166:
      return crit_e::ignore;
    case 22:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 190:
      return crit_e::ignore;
    case 197:
      return crit_e::ignore;
    case 318:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_request_transfer_ies_o::value_c
pdu_session_res_setup_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 130:
      ret.set(value_c::types::pdu_session_aggr_max_bit_rate);
      break;
    case 139:
      ret.set(value_c::types::ul_ngu_up_tnl_info);
      break;
    case 126:
      ret.set(value_c::types::add_ul_ngu_up_tnl_info);
      break;
    case 127:
      ret.set(value_c::types::data_forwarding_not_possible);
      break;
    case 134:
      ret.set(value_c::types::pdu_session_type);
      break;
    case 138:
      ret.set(value_c::types::security_ind);
      break;
    case 129:
      ret.set(value_c::types::network_instance);
      break;
    case 136:
      ret.set(value_c::types::qos_flow_setup_request_list);
      break;
    case 166:
      ret.set(value_c::types::common_network_instance);
      break;
    case 22:
      ret.set(value_c::types::direct_forwarding_path_availability);
      break;
    case 195:
      ret.set(value_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 186:
      ret.set(value_c::types::add_redundant_ul_ngu_up_tnl_info);
      break;
    case 190:
      ret.set(value_c::types::redundant_common_network_instance);
      break;
    case 197:
      ret.set(value_c::types::redundant_pdu_session_info);
      break;
    case 318:
      ret.set(value_c::types::mbs_session_setup_request_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 130:
      return presence_e::optional;
    case 139:
      return presence_e::mandatory;
    case 126:
      return presence_e::optional;
    case 127:
      return presence_e::optional;
    case 134:
      return presence_e::mandatory;
    case 138:
      return presence_e::optional;
    case 129:
      return presence_e::optional;
    case 136:
      return presence_e::mandatory;
    case 166:
      return presence_e::optional;
    case 22:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 190:
      return presence_e::optional;
    case 197:
      return presence_e::optional;
    case 318:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_request_transfer_ies_o::value_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c = pdu_session_aggr_max_bit_rate_s{};
      break;
    case types::ul_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::add_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_list_l{};
      break;
    case types::data_forwarding_not_possible:
      c = data_forwarding_not_possible_e{};
      break;
    case types::pdu_session_type:
      c = pdu_session_type_e{};
      break;
    case types::security_ind:
      c = security_ind_s{};
      break;
    case types::network_instance:
      c = uint16_t{};
      break;
    case types::qos_flow_setup_request_list:
      c = qos_flow_setup_request_list_l{};
      break;
    case types::common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::direct_forwarding_path_availability:
      c = direct_forwarding_path_availability_e{};
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_list_l{};
      break;
    case types::redundant_common_network_instance:
      c = unbounded_octstring<true>{};
      break;
    case types::redundant_pdu_session_info:
      c = redundant_pdu_session_info_s{};
      break;
    case types::mbs_session_setup_request_list:
      c = mbs_session_setup_request_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
  }
}
pdu_session_aggr_max_bit_rate_s& pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate()
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
up_transport_layer_info_c& pdu_session_res_setup_request_transfer_ies_o::value_c::ul_ngu_up_tnl_info()
{
  assert_choice_type(types::ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l& pdu_session_res_setup_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
data_forwarding_not_possible_e& pdu_session_res_setup_request_transfer_ies_o::value_c::data_forwarding_not_possible()
{
  assert_choice_type(types::data_forwarding_not_possible, type_, "Value");
  return c.get<data_forwarding_not_possible_e>();
}
pdu_session_type_e& pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_type()
{
  assert_choice_type(types::pdu_session_type, type_, "Value");
  return c.get<pdu_session_type_e>();
}
security_ind_s& pdu_session_res_setup_request_transfer_ies_o::value_c::security_ind()
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
uint16_t& pdu_session_res_setup_request_transfer_ies_o::value_c::network_instance()
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
qos_flow_setup_request_list_l& pdu_session_res_setup_request_transfer_ies_o::value_c::qos_flow_setup_request_list()
{
  assert_choice_type(types::qos_flow_setup_request_list, type_, "Value");
  return c.get<qos_flow_setup_request_list_l>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_transfer_ies_o::value_c::common_network_instance()
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
direct_forwarding_path_availability_e&
pdu_session_res_setup_request_transfer_ies_o::value_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
up_transport_layer_info_c& pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_common_network_instance()
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
redundant_pdu_session_info_s& pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_pdu_session_info()
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Value");
  return c.get<redundant_pdu_session_info_s>();
}
mbs_session_setup_request_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::mbs_session_setup_request_list()
{
  assert_choice_type(types::mbs_session_setup_request_list, type_, "Value");
  return c.get<mbs_session_setup_request_list_l>();
}
const pdu_session_aggr_max_bit_rate_s&
pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate() const
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
const up_transport_layer_info_c& pdu_session_res_setup_request_transfer_ies_o::value_c::ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const data_forwarding_not_possible_e&
pdu_session_res_setup_request_transfer_ies_o::value_c::data_forwarding_not_possible() const
{
  assert_choice_type(types::data_forwarding_not_possible, type_, "Value");
  return c.get<data_forwarding_not_possible_e>();
}
const pdu_session_type_e& pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_type() const
{
  assert_choice_type(types::pdu_session_type, type_, "Value");
  return c.get<pdu_session_type_e>();
}
const security_ind_s& pdu_session_res_setup_request_transfer_ies_o::value_c::security_ind() const
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
const uint16_t& pdu_session_res_setup_request_transfer_ies_o::value_c::network_instance() const
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
const qos_flow_setup_request_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::qos_flow_setup_request_list() const
{
  assert_choice_type(types::qos_flow_setup_request_list, type_, "Value");
  return c.get<qos_flow_setup_request_list_l>();
}
const unbounded_octstring<true>& pdu_session_res_setup_request_transfer_ies_o::value_c::common_network_instance() const
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const direct_forwarding_path_availability_e&
pdu_session_res_setup_request_transfer_ies_o::value_c::direct_forwarding_path_availability() const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
const up_transport_layer_info_c&
pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const unbounded_octstring<true>&
pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_common_network_instance() const
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const redundant_pdu_session_info_s&
pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_pdu_session_info() const
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Value");
  return c.get<redundant_pdu_session_info_s>();
}
const mbs_session_setup_request_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::mbs_session_setup_request_list() const
{
  assert_choice_type(types::mbs_session_setup_request_list, type_, "Value");
  return c.get<mbs_session_setup_request_list_l>();
}
void pdu_session_res_setup_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      j.write_fieldname("PDUSessionAggregateMaximumBitRate");
      c.get<pdu_session_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::data_forwarding_not_possible:
      j.write_str("DataForwardingNotPossible", "data-forwarding-not-possible");
      break;
    case types::pdu_session_type:
      j.write_str("PDUSessionType", c.get<pdu_session_type_e>().to_string());
      break;
    case types::security_ind:
      j.write_fieldname("SecurityIndication");
      c.get<security_ind_s>().to_json(j);
      break;
    case types::network_instance:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::qos_flow_setup_request_list:
      j.start_array("QosFlowSetupRequestList");
      for (const auto& e1 : c.get<qos_flow_setup_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::redundant_pdu_session_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::mbs_session_setup_request_list:
      j.start_array("MBSSessionSetupRequestList");
      for (const auto& e1 : c.get<mbs_session_setup_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::data_forwarding_not_possible:
      HANDLE_CODE(c.get<data_forwarding_not_possible_e>().pack(bref));
      break;
    case types::pdu_session_type:
      HANDLE_CODE(c.get<pdu_session_type_e>().pack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().pack(bref));
      break;
    case types::network_instance:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_setup_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_setup_request_list_l>(), 1, 64, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::mbs_session_setup_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setup_request_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::data_forwarding_not_possible:
      HANDLE_CODE(c.get<data_forwarding_not_possible_e>().unpack(bref));
      break;
    case types::pdu_session_type:
      HANDLE_CODE(c.get<pdu_session_type_e>().unpack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().unpack(bref));
      break;
    case types::network_instance:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_setup_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_setup_request_list_l>(), bref, 1, 64, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::mbs_session_setup_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setup_request_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PDUSessionAggregateMaximumBitRate",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "DataForwardingNotPossible",
                                "PDUSessionType",
                                "SecurityIndication",
                                "INTEGER (1..256,...)",
                                "QosFlowSetupRequestList",
                                "OCTET STRING",
                                "DirectForwardingPathAvailability",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "OCTET STRING",
                                "RedundantPDUSessionInformation",
                                "MBSSessionSetupRequestList"};
  return convert_enum_idx(names, 15, value, "pdu_session_res_setup_request_transfer_ies_o::value_c::types");
}
uint8_t pdu_session_res_setup_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == network_instance) {
    return 1;
  }
  invalid_enum_number(value, "pdu_session_res_setup_request_transfer_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<pdu_session_res_setup_request_transfer_ies_o>;

SRSASN_CODE pdu_session_res_setup_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += add_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += data_forwarding_not_possible_present ? 1 : 0;
  nof_ies += security_ind_present ? 1 : 0;
  nof_ies += network_instance_present ? 1 : 0;
  nof_ies += common_network_instance_present ? 1 : 0;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_common_network_instance_present ? 1 : 0;
  nof_ies += redundant_pdu_session_info_present ? 1 : 0;
  nof_ies += mbs_session_setup_request_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (pdu_session_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)130, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdu_session_aggr_max_bit_rate.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)139, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)126, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ul_ngu_up_tnl_info, 1, 3, true));
  }
  if (data_forwarding_not_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)127, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(data_forwarding_not_possible.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)134, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdu_session_type.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)138, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_ind.pack(bref));
  }
  if (network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)129, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, network_instance, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)136, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_setup_request_list, 1, 64, true));
  }
  if (common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)166, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(common_network_instance.pack(bref));
  }
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)22, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)195, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)186, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_ul_ngu_up_tnl_info, 1, 3, true));
  }
  if (redundant_common_network_instance_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)190, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_common_network_instance.pack(bref));
  }
  if (redundant_pdu_session_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)197, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_pdu_session_info.pack(bref));
  }
  if (mbs_session_setup_request_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)318, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_setup_request_list, 1, 32, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 130: {
        pdu_session_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 139: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 126: {
        add_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_ul_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 127: {
        data_forwarding_not_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_forwarding_not_possible.unpack(bref));
        break;
      }
      case 134: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_type.unpack(bref));
        break;
      }
      case 138: {
        security_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_ind.unpack(bref));
        break;
      }
      case 129: {
        network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(network_instance, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 136: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flow_setup_request_list, bref, 1, 64, true));
        break;
      }
      case 166: {
        common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(common_network_instance.unpack(bref));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.unpack(bref));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 186: {
        add_redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_ul_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 190: {
        redundant_common_network_instance_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_common_network_instance.unpack(bref));
        break;
      }
      case 197: {
        redundant_pdu_session_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_pdu_session_info.unpack(bref));
        break;
      }
      case 318: {
        mbs_session_setup_request_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_setup_request_list, bref, 1, 32, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_aggr_max_bit_rate_present) {
    j.write_int("id", 130);
    j.write_str("criticality", "reject");
    pdu_session_aggr_max_bit_rate.to_json(j);
  }
  j.write_int("id", 139);
  j.write_str("criticality", "reject");
  ul_ngu_up_tnl_info.to_json(j);
  if (add_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 126);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : add_ul_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_not_possible_present) {
    j.write_int("id", 127);
    j.write_str("criticality", "reject");
    j.write_str("Value", "data-forwarding-not-possible");
  }
  j.write_int("id", 134);
  j.write_str("criticality", "reject");
  j.write_str("Value", pdu_session_type.to_string());
  if (security_ind_present) {
    j.write_int("id", 138);
    j.write_str("criticality", "reject");
    security_ind.to_json(j);
  }
  if (network_instance_present) {
    j.write_int("id", 129);
    j.write_str("criticality", "reject");
    j.write_int("Value", network_instance);
  }
  j.write_int("id", 136);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : qos_flow_setup_request_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (common_network_instance_present) {
    j.write_int("id", 166);
    j.write_str("criticality", "ignore");
    j.write_str("Value", common_network_instance.to_string());
  }
  if (direct_forwarding_path_availability_present) {
    j.write_int("id", 22);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "direct-path-available");
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 195);
    j.write_str("criticality", "ignore");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 186);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : add_redundant_ul_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redundant_common_network_instance_present) {
    j.write_int("id", 190);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redundant_common_network_instance.to_string());
  }
  if (redundant_pdu_session_info_present) {
    j.write_int("id", 197);
    j.write_str("criticality", "ignore");
    redundant_pdu_session_info.to_json(j);
  }
  if (mbs_session_setup_request_list_present) {
    j.write_int("id", 318);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : mbs_session_setup_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PDUSessionResourceSetupResponseTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_resp_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {193, 184, 198, 27, 309, 312, 310};
  return map_enum_number(names, 7, idx, "id");
}
bool pdu_session_res_setup_resp_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {193, 184, 198, 27, 309, 312, 310};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_resp_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 193:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    case 312:
      return crit_e::ignore;
    case 310:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c
pdu_session_res_setup_resp_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 193:
      ret.set(ext_c::types::redundant_dl_qos_flow_per_tnl_info);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 198:
      ret.set(ext_c::types::used_r_sn_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    case 312:
      ret.set(ext_c::types::mbs_session_setup_resp_list);
      break;
    case 310:
      ret.set(ext_c::types::mbs_session_failedto_setup_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 193:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 198:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    case 312:
      return presence_e::optional;
    case 310:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      c = qos_flow_per_tnl_info_s{};
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c = qos_flow_per_tnl_info_list_l{};
      break;
    case types::used_r_sn_info:
      c = redundant_pdu_session_info_s{};
      break;
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::mbs_support_ind:
      c = mbs_support_ind_e{};
      break;
    case types::mbs_session_setup_resp_list:
      c = mbs_session_setup_resp_list_l{};
      break;
    case types::mbs_session_failedto_setup_list:
      c = mbs_session_failedto_setup_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
  }
}
qos_flow_per_tnl_info_s& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
qos_flow_per_tnl_info_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
redundant_pdu_session_info_s& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::used_r_sn_info()
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
global_ran_node_id_c& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
mbs_support_ind_e& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
mbs_session_setup_resp_list_l& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_setup_resp_list()
{
  assert_choice_type(types::mbs_session_setup_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
mbs_session_failedto_setup_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setup_list()
{
  assert_choice_type(types::mbs_session_failedto_setup_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
const qos_flow_per_tnl_info_s&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
const qos_flow_per_tnl_info_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const redundant_pdu_session_info_s& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::used_r_sn_info() const
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const global_ran_node_id_c& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const mbs_support_ind_e& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const mbs_session_setup_resp_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_setup_resp_list() const
{
  assert_choice_type(types::mbs_session_setup_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
const mbs_session_failedto_setup_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setup_list() const
{
  assert_choice_type(types::mbs_session_failedto_setup_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
void pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      j.write_fieldname("QosFlowPerTNLInformation");
      c.get<qos_flow_per_tnl_info_s>().to_json(j);
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::used_r_sn_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    case types::mbs_session_setup_resp_list:
      j.start_array("MBSSessionSetupResponseList");
      for (const auto& e1 : c.get<mbs_session_setup_resp_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_failedto_setup_list:
      j.start_array("MBSSessionFailedtoSetupList");
      for (const auto& e1 : c.get<mbs_session_failedto_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    case types::mbs_session_setup_resp_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setup_resp_list_l>(), 1, 32, true));
      break;
    case types::mbs_session_failedto_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_failedto_setup_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    case types::mbs_session_setup_resp_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setup_resp_list_l>(), bref, 1, 32, true));
      break;
    case types::mbs_session_failedto_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_failedto_setup_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosFlowPerTNLInformation",
                                "QosFlowPerTNLInformationList",
                                "RedundantPDUSessionInformation",
                                "GlobalRANNodeID",
                                "MBS-SupportIndicator",
                                "MBSSessionSetupResponseList",
                                "MBSSessionFailedtoSetupList"};
  return convert_enum_idx(names, 7, value, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_setup_resp_transfer_ext_ies_o>;

SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += used_r_sn_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  nof_ies += mbs_session_setup_resp_list_present ? 1 : 0;
  nof_ies += mbs_session_failedto_setup_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)193, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)184, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (used_r_sn_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)198, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(used_r_sn_info.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)309, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }
  if (mbs_session_setup_resp_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)312, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_setup_resp_list, 1, 32, true));
  }
  if (mbs_session_failedto_setup_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)310, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_session_failedto_setup_list, 1, 32, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 193: {
        redundant_dl_qos_flow_per_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
        break;
      }
      case 198: {
        used_r_sn_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(used_r_sn_info.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.unpack(bref));
        break;
      }
      case 312: {
        mbs_session_setup_resp_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_setup_resp_list, bref, 1, 32, true));
        break;
      }
      case 310: {
        mbs_session_failedto_setup_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_session_failedto_setup_list, bref, 1, 32, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_int("id", 193);
    j.write_str("criticality", "ignore");
    redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_int("id", 184);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (used_r_sn_info_present) {
    j.write_int("id", 198);
    j.write_str("criticality", "ignore");
    used_r_sn_info.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_int("id", 27);
    j.write_str("criticality", "ignore");
    global_ran_node_id.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_int("id", 309);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (mbs_session_setup_resp_list_present) {
    j.write_int("id", 312);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_session_setup_resp_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_session_failedto_setup_list_present) {
    j.write_int("id", 310);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_session_failedto_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PDUSessionResourceSetupResponseTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_dl_qos_flow_per_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(security_result_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_setup_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.pack(bref));
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.pack(bref));
  }
  if (qos_flow_failed_to_setup_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_setup_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool add_dl_qos_flow_per_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_dl_qos_flow_per_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(security_result_present, 1));
  bool qos_flow_failed_to_setup_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_setup_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.unpack(bref));
  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.unpack(bref));
  }
  if (qos_flow_failed_to_setup_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_setup_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dLQosFlowPerTNLInformation");
  dl_qos_flow_per_tnl_info.to_json(j);
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    j.start_array("additionalDLQosFlowPerTNLInformation");
    for (const auto& e1 : add_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (security_result_present) {
    j.write_fieldname("securityResult");
    security_result.to_json(j);
  }
  if (qos_flow_failed_to_setup_list.size() > 0) {
    j.start_array("qosFlowFailedToSetupList");
    for (const auto& e1 : qos_flow_failed_to_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowParametersItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_params_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {187, 188, 279};
  return map_enum_number(names, 3, idx, "id");
}
bool qos_flow_params_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {187, 188, 279};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_params_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 187:
      return crit_e::ignore;
    case 188:
      return crit_e::ignore;
    case 279:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_params_item_ext_ies_o::ext_c qos_flow_params_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 187:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 188:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    case 279:
      ret.set(ext_c::types::burst_arrival_time_dl);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_params_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 187:
      return presence_e::optional;
    case 188:
      return presence_e::optional;
    case 279:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_params_item_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c = uint32_t{};
      break;
    case types::cn_packet_delay_budget_ul:
      c = uint32_t{};
      break;
    case types::burst_arrival_time_dl:
      c = unbounded_octstring<true>{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
  }
}
uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& qos_flow_params_item_ext_ies_o::ext_c::burst_arrival_time_dl()
{
  assert_choice_type(types::burst_arrival_time_dl, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& qos_flow_params_item_ext_ies_o::ext_c::burst_arrival_time_dl() const
{
  assert_choice_type(types::burst_arrival_time_dl, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
void qos_flow_params_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::burst_arrival_time_dl:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_params_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::burst_arrival_time_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_params_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::burst_arrival_time_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_params_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..65535,...)", "INTEGER (1..65535,...)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "qos_flow_params_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_params_item_ext_ies_o>;

SRSASN_CODE qos_flow_params_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  nof_ies += burst_arrival_time_dl_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)187, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_dl, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)188, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_ul, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (burst_arrival_time_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)279, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(burst_arrival_time_dl.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_params_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 187: {
        cn_packet_delay_budget_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_dl, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 188: {
        cn_packet_delay_budget_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_ul, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 279: {
        burst_arrival_time_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(burst_arrival_time_dl.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_params_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cn_packet_delay_budget_dl_present) {
    j.write_int("id", 187);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_dl);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_int("id", 188);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_ul);
  }
  if (burst_arrival_time_dl_present) {
    j.write_int("id", 279);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", burst_arrival_time_dl.to_string());
  }
  j.end_obj();
}

// QosFlowParametersItem ::= SEQUENCE
SRSASN_CODE qos_flow_params_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(alt_qos_para_set_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (alt_qos_para_set_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, alt_qos_para_set_list, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_params_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool alt_qos_para_set_list_present;
  HANDLE_CODE(bref.unpack(alt_qos_para_set_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (alt_qos_para_set_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(alt_qos_para_set_list, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_params_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (alt_qos_para_set_list.size() > 0) {
    j.start_array("alternativeQoSParaSetList");
    for (const auto& e1 : alt_qos_para_set_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestAcknowledgeTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t path_switch_request_ack_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {154, 195, 185, 277};
  return map_enum_number(names, 4, idx, "id");
}
bool path_switch_request_ack_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {154, 195, 185, 277};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ack_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 154:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 185:
      return crit_e::ignore;
    case 277:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ack_transfer_ext_ies_o::ext_c
path_switch_request_ack_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 154:
      ret.set(ext_c::types::add_ngu_up_tnl_info);
      break;
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 185:
      ret.set(ext_c::types::add_redundant_ngu_up_tnl_info);
      break;
    case 277:
      ret.set(ext_c::types::qos_flow_params_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ack_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 154:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 185:
      return presence_e::optional;
    case 277:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void path_switch_request_ack_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c = up_transport_layer_info_pair_list_l{};
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c = up_transport_layer_info_pair_list_l{};
      break;
    case types::qos_flow_params_list:
      c = qos_flow_params_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
  }
}
up_transport_layer_info_pair_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
up_transport_layer_info_c& path_switch_request_ack_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_pair_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
qos_flow_params_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::qos_flow_params_list()
{
  assert_choice_type(types::qos_flow_params_list, type_, "Extension");
  return c.get<qos_flow_params_list_l>();
}
const up_transport_layer_info_pair_list_l&
path_switch_request_ack_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const up_transport_layer_info_c& path_switch_request_ack_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_pair_list_l&
path_switch_request_ack_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const qos_flow_params_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::qos_flow_params_list() const
{
  assert_choice_type(types::qos_flow_params_list, type_, "Extension");
  return c.get<qos_flow_params_list_l>();
}
void path_switch_request_ack_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flow_params_list:
      j.start_array("QosFlowParametersList");
      for (const auto& e1 : c.get<qos_flow_params_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ack_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::qos_flow_params_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_params_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::qos_flow_params_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_params_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ack_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformationPairList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationPairList",
                                "QosFlowParametersList"};
  return convert_enum_idx(names, 4, value, "path_switch_request_ack_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<path_switch_request_ack_transfer_ext_ies_o>;

SRSASN_CODE path_switch_request_ack_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += qos_flow_params_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)154, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ngu_up_tnl_info, 1, 3, true));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)195, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)185, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_ngu_up_tnl_info, 1, 3, true));
  }
  if (qos_flow_params_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)277, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_params_list, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 154: {
        add_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 185: {
        add_redundant_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_ngu_up_tnl_info, bref, 1, 3, true));
        break;
      }
      case 277: {
        qos_flow_params_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(qos_flow_params_list, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_ack_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_ngu_up_tnl_info_present) {
    j.write_int("id", 154);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_int("id", 195);
    j.write_str("criticality", "ignore");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    j.write_int("id", 185);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_ngu_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_params_list_present) {
    j.write_int("id", 277);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : qos_flow_params_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PathSwitchRequestAcknowledgeTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_ack_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(security_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(security_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_ack_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_ngu_up_tnl_info_present) {
    j.write_fieldname("uL-NGU-UP-TNLInformation");
    ul_ngu_up_tnl_info.to_json(j);
  }
  if (security_ind_present) {
    j.write_fieldname("securityIndication");
    security_ind.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestSetupFailedTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_setup_failed_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_setup_failed_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_setup_failed_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowAcceptedItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_accepted_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_accepted_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_accepted_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_accepted_item_ext_ies_o::ext_c qos_flow_accepted_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_accepted_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_accepted_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_accepted_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_accepted_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_accepted_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_accepted_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_accepted_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "qos_flow_accepted_item_ext_ies_o::ext_c::types");
}

// DL-NGU-TNLInformationReused ::= ENUMERATED
const char* dl_ngu_tnl_info_reused_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "dl_ngu_tnl_info_reused_e");
}

// QosFlowAcceptedItem ::= SEQUENCE
SRSASN_CODE qos_flow_accepted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_accepted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_accepted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PathSwitchRequestTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t path_switch_request_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {155, 192, 191, 184, 198, 27, 309};
  return map_enum_number(names, 7, idx, "id");
}
bool path_switch_request_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {155, 192, 191, 184, 198, 27, 309};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 155:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 191:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_transfer_ext_ies_o::ext_c path_switch_request_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 155:
      ret.set(ext_c::types::add_dl_qos_flow_per_tnl_info);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    case 191:
      ret.set(ext_c::types::redundant_dl_ngu_tnl_info_reused);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 198:
      ret.set(ext_c::types::used_r_sn_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 155:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 191:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 198:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void path_switch_request_transfer_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      c = qos_flow_per_tnl_info_list_l{};
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c = up_transport_layer_info_c{};
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      c = dl_ngu_tnl_info_reused_e{};
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c = qos_flow_per_tnl_info_list_l{};
      break;
    case types::used_r_sn_info:
      c = redundant_pdu_session_info_s{};
      break;
    case types::global_ran_node_id:
      c = global_ran_node_id_c{};
      break;
    case types::mbs_support_ind:
      c = mbs_support_ind_e{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
  }
}
qos_flow_per_tnl_info_list_l& path_switch_request_transfer_ext_ies_o::ext_c::add_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
up_transport_layer_info_c& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
dl_ngu_tnl_info_reused_e& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_tnl_info_reused()
{
  assert_choice_type(types::redundant_dl_ngu_tnl_info_reused, type_, "Extension");
  return c.get<dl_ngu_tnl_info_reused_e>();
}
qos_flow_per_tnl_info_list_l& path_switch_request_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
redundant_pdu_session_info_s& path_switch_request_transfer_ext_ies_o::ext_c::used_r_sn_info()
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
global_ran_node_id_c& path_switch_request_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
mbs_support_ind_e& path_switch_request_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const qos_flow_per_tnl_info_list_l& path_switch_request_transfer_ext_ies_o::ext_c::add_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const up_transport_layer_info_c& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const dl_ngu_tnl_info_reused_e& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_tnl_info_reused() const
{
  assert_choice_type(types::redundant_dl_ngu_tnl_info_reused, type_, "Extension");
  return c.get<dl_ngu_tnl_info_reused_e>();
}
const qos_flow_per_tnl_info_list_l&
path_switch_request_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const redundant_pdu_session_info_s& path_switch_request_transfer_ext_ies_o::ext_c::used_r_sn_info() const
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const global_ran_node_id_c& path_switch_request_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const mbs_support_ind_e& path_switch_request_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
void path_switch_request_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      j.write_str("DL-NGU-TNLInformationReused", "true");
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::used_r_sn_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      HANDLE_CODE(c.get<dl_ngu_tnl_info_reused_e>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      HANDLE_CODE(c.get<dl_ngu_tnl_info_reused_e>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosFlowPerTNLInformationList",
                                "UPTransportLayerInformation",
                                "DL-NGU-TNLInformationReused",
                                "QosFlowPerTNLInformationList",
                                "RedundantPDUSessionInformation",
                                "GlobalRANNodeID",
                                "MBS-SupportIndicator"};
  return convert_enum_idx(names, 7, value, "path_switch_request_transfer_ext_ies_o::ext_c::types");
}

// UserPlaneSecurityInformation ::= SEQUENCE
SRSASN_CODE user_plane_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(security_result.pack(bref));
  HANDLE_CODE(security_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_plane_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(security_result.unpack(bref));
  HANDLE_CODE(security_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void user_plane_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("securityResult");
  security_result.to_json(j);
  j.write_fieldname("securityIndication");
  security_ind.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<path_switch_request_transfer_ext_ies_o>;

SRSASN_CODE path_switch_request_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_tnl_info_reused_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += used_r_sn_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)155, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)192, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_dl_ngu_tnl_info_reused_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)191, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redundant_dl_ngu_tnl_info_reused.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)184, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_redundant_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (used_r_sn_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)198, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(used_r_sn_info.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)309, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 155: {
        add_dl_qos_flow_per_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.unpack(bref));
        break;
      }
      case 191: {
        redundant_dl_ngu_tnl_info_reused_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_tnl_info_reused.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_redundant_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
        break;
      }
      case 198: {
        used_r_sn_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(used_r_sn_info.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dl_qos_flow_per_tnl_info_present) {
    j.write_int("id", 155);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_int("id", 192);
    j.write_str("criticality", "ignore");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_dl_ngu_tnl_info_reused_present) {
    j.write_int("id", 191);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_int("id", 184);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_redundant_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (used_r_sn_info_present) {
    j.write_int("id", 198);
    j.write_str("criticality", "ignore");
    used_r_sn_info.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_int("id", 27);
    j.write_str("criticality", "ignore");
    global_ran_node_id.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_int("id", 309);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// PathSwitchRequestTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_ngu_tnl_info_reused_present, 1));
  HANDLE_CODE(bref.pack(user_plane_security_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (dl_ngu_tnl_info_reused_present) {
    HANDLE_CODE(dl_ngu_tnl_info_reused.pack(bref));
  }
  if (user_plane_security_info_present) {
    HANDLE_CODE(user_plane_security_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_accepted_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_ngu_tnl_info_reused_present, 1));
  HANDLE_CODE(bref.unpack(user_plane_security_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (dl_ngu_tnl_info_reused_present) {
    HANDLE_CODE(dl_ngu_tnl_info_reused.unpack(bref));
  }
  if (user_plane_security_info_present) {
    HANDLE_CODE(user_plane_security_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_accepted_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (dl_ngu_tnl_info_reused_present) {
    j.write_str("dL-NGU-TNLInformationReused", "true");
  }
  if (user_plane_security_info_present) {
    j.write_fieldname("userPlaneSecurityInformation");
    user_plane_security_info.to_json(j);
  }
  j.start_array("qosFlowAcceptedList");
  for (const auto& e1 : qos_flow_accepted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecondaryRATDataUsageReportTransfer ::= SEQUENCE
SRSASN_CODE secondary_rat_data_usage_report_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(secondary_rat_usage_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(secondary_rat_usage_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(secondary_rat_usage_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (secondary_rat_usage_info_present) {
    j.write_fieldname("secondaryRATUsageInformation");
    secondary_rat_usage_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SourceNodeID ::= CHOICE
void source_node_id_c::destroy_()
{
  switch (type_) {
    case types::sourceen_gnb_id:
      c.destroy<global_gnb_id_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<source_node_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void source_node_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sourceen_gnb_id:
      c.init<global_gnb_id_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<source_node_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }
}
source_node_id_c::source_node_id_c(const source_node_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sourceen_gnb_id:
      c.init(other.c.get<global_gnb_id_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }
}
source_node_id_c& source_node_id_c::operator=(const source_node_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sourceen_gnb_id:
      c.set(other.c.get<global_gnb_id_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }

  return *this;
}
global_gnb_id_s& source_node_id_c::set_sourceen_gnb_id()
{
  set(types::sourceen_gnb_id);
  return c.get<global_gnb_id_s>();
}
protocol_ie_single_container_s<source_node_id_ext_ies_o>& source_node_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>();
}
void source_node_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sourceen_gnb_id:
      j.write_fieldname("sourceengNB-ID");
      c.get<global_gnb_id_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }
  j.end_obj();
}
SRSASN_CODE source_node_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sourceen_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE source_node_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sourceen_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* source_node_id_c::types_opts::to_string() const
{
  static const char* names[] = {"sourceengNB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "source_node_id_c::types");
}

// UEHistoryInformationFromTheUE ::= CHOICE
void ue_history_info_from_the_ue_c::destroy_()
{
  switch (type_) {
    case types::nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_history_info_from_the_ue_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
}
ue_history_info_from_the_ue_c::ue_history_info_from_the_ue_c(const ue_history_info_from_the_ue_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
}
ue_history_info_from_the_ue_c& ue_history_info_from_the_ue_c::operator=(const ue_history_info_from_the_ue_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_history_info_from_the_ue_c::set_nr()
{
  set(types::nr);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>& ue_history_info_from_the_ue_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
}
void ue_history_info_from_the_ue_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_str("nR", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_history_info_from_the_ue_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_history_info_from_the_ue_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_history_info_from_the_ue_c::types_opts::to_string() const
{
  static const char* names[] = {"nR", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "ue_history_info_from_the_ue_c::types");
}

// SourceNGRANNode-ToTargetNGRANNode-TransparentContainer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {182, 253, 286, 288, 323, 328, 355};
  return map_enum_number(names, 7, idx, "id");
}
bool source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {182, 253, 286, 288, 323, 328, 355};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 182:
      return crit_e::ignore;
    case 253:
      return crit_e::ignore;
    case 286:
      return crit_e::ignore;
    case 288:
      return crit_e::ignore;
    case 323:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 355:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 182:
      ret.set(ext_c::types::s_gnb_ue_x2ap_id);
      break;
    case 253:
      ret.set(ext_c::types::ue_history_info_from_the_ue);
      break;
    case 286:
      ret.set(ext_c::types::source_node_id);
      break;
    case 288:
      ret.set(ext_c::types::ue_context_ref_at_source);
      break;
    case 323:
      ret.set(ext_c::types::mbs_active_session_info_sourceto_target_list);
      break;
    case 328:
      ret.set(ext_c::types::q_mcc_onfig_info);
      break;
    case 355:
      ret.set(ext_c::types::ngap_ie_support_info_request_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 182:
      return presence_e::optional;
    case 253:
      return presence_e::optional;
    case 286:
      return presence_e::optional;
    case 288:
      return presence_e::optional;
    case 323:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 355:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      c = uint64_t{};
      break;
    case types::ue_history_info_from_the_ue:
      c = ue_history_info_from_the_ue_c{};
      break;
    case types::source_node_id:
      c = source_node_id_c{};
      break;
    case types::ue_context_ref_at_source:
      c = uint64_t{};
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      c = mbs_active_session_info_sourceto_target_list_l{};
      break;
    case types::q_mcc_onfig_info:
      c = q_mcc_onfig_info_s{};
      break;
    case types::ngap_ie_support_info_request_list:
      c = ngap_ie_support_info_request_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
}
uint64_t& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::s_gnb_ue_x2ap_id()
{
  assert_choice_type(types::s_gnb_ue_x2ap_id, type_, "Extension");
  return c.get<uint64_t>();
}
ue_history_info_from_the_ue_c&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_history_info_from_the_ue()
{
  assert_choice_type(types::ue_history_info_from_the_ue, type_, "Extension");
  return c.get<ue_history_info_from_the_ue_c>();
}
source_node_id_c& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::source_node_id()
{
  assert_choice_type(types::source_node_id, type_, "Extension");
  return c.get<source_node_id_c>();
}
uint64_t& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_context_ref_at_source()
{
  assert_choice_type(types::ue_context_ref_at_source, type_, "Extension");
  return c.get<uint64_t>();
}
mbs_active_session_info_sourceto_target_list_l& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::
    ext_c::mbs_active_session_info_sourceto_target_list()
{
  assert_choice_type(types::mbs_active_session_info_sourceto_target_list, type_, "Extension");
  return c.get<mbs_active_session_info_sourceto_target_list_l>();
}
q_mcc_onfig_info_s& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Extension");
  return c.get<q_mcc_onfig_info_s>();
}
ngap_ie_support_info_request_list_l&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_request_list()
{
  assert_choice_type(types::ngap_ie_support_info_request_list, type_, "Extension");
  return c.get<ngap_ie_support_info_request_list_l>();
}
const uint64_t& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::s_gnb_ue_x2ap_id() const
{
  assert_choice_type(types::s_gnb_ue_x2ap_id, type_, "Extension");
  return c.get<uint64_t>();
}
const ue_history_info_from_the_ue_c&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_history_info_from_the_ue() const
{
  assert_choice_type(types::ue_history_info_from_the_ue, type_, "Extension");
  return c.get<ue_history_info_from_the_ue_c>();
}
const source_node_id_c&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::source_node_id() const
{
  assert_choice_type(types::source_node_id, type_, "Extension");
  return c.get<source_node_id_c>();
}
const uint64_t&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_context_ref_at_source() const
{
  assert_choice_type(types::ue_context_ref_at_source, type_, "Extension");
  return c.get<uint64_t>();
}
const mbs_active_session_info_sourceto_target_list_l&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::
    mbs_active_session_info_sourceto_target_list() const
{
  assert_choice_type(types::mbs_active_session_info_sourceto_target_list, type_, "Extension");
  return c.get<mbs_active_session_info_sourceto_target_list_l>();
}
const q_mcc_onfig_info_s&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Extension");
  return c.get<q_mcc_onfig_info_s>();
}
const ngap_ie_support_info_request_list_l&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_request_list() const
{
  assert_choice_type(types::ngap_ie_support_info_request_list, type_, "Extension");
  return c.get<ngap_ie_support_info_request_list_l>();
}
void source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_history_info_from_the_ue:
      j.write_fieldname("UEHistoryInformationFromTheUE");
      c.get<ue_history_info_from_the_ue_c>().to_json(j);
      break;
    case types::source_node_id:
      j.write_fieldname("SourceNodeID");
      c.get<source_node_id_c>().to_json(j);
      break;
    case types::ue_context_ref_at_source:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      j.start_array("MBS-ActiveSessionInformation-SourcetoTargetList");
      for (const auto& e1 : c.get<mbs_active_session_info_sourceto_target_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::ngap_ie_support_info_request_list:
      j.start_array("NGAPIESupportInformationRequestList");
      for (const auto& e1 : c.get<ngap_ie_support_info_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_history_info_from_the_ue:
      HANDLE_CODE(c.get<ue_history_info_from_the_ue_c>().pack(bref));
      break;
    case types::source_node_id:
      HANDLE_CODE(c.get<source_node_id_c>().pack(bref));
      break;
    case types::ue_context_ref_at_source:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_active_session_info_sourceto_target_list_l>(), 1, 256, true));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::ngap_ie_support_info_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngap_ie_support_info_request_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_history_info_from_the_ue:
      HANDLE_CODE(c.get<ue_history_info_from_the_ue_c>().unpack(bref));
      break;
    case types::source_node_id:
      HANDLE_CODE(c.get<source_node_id_c>().unpack(bref));
      break;
    case types::ue_context_ref_at_source:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_active_session_info_sourceto_target_list_l>(), bref, 1, 256, true));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::ngap_ie_support_info_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngap_ie_support_info_request_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "UEHistoryInformationFromTheUE",
                                "SourceNodeID",
                                "INTEGER (0..4294967295)",
                                "MBS-ActiveSessionInformation-SourcetoTargetList",
                                "QMCConfigInfo",
                                "NGAPIESupportInformationRequestList"};
  return convert_enum_idx(
      names, 7, value, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o>;

SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += s_gnb_ue_x2ap_id_present ? 1 : 0;
  nof_ies += ue_history_info_from_the_ue_present ? 1 : 0;
  nof_ies += source_node_id_present ? 1 : 0;
  nof_ies += ue_context_ref_at_source_present ? 1 : 0;
  nof_ies += mbs_active_session_info_sourceto_target_list_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += ngap_ie_support_info_request_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (s_gnb_ue_x2ap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)182, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, s_gnb_ue_x2ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ue_history_info_from_the_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)253, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_history_info_from_the_ue.pack(bref));
  }
  if (source_node_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)286, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_node_id.pack(bref));
  }
  if (ue_context_ref_at_source_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)288, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ue_context_ref_at_source, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (mbs_active_session_info_sourceto_target_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)323, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_active_session_info_sourceto_target_list, 1, 256, true));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)328, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (ngap_ie_support_info_request_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)355, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ngap_ie_support_info_request_list, 1, 32, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 182: {
        s_gnb_ue_x2ap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(s_gnb_ue_x2ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 253: {
        ue_history_info_from_the_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_history_info_from_the_ue.unpack(bref));
        break;
      }
      case 286: {
        source_node_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_node_id.unpack(bref));
        break;
      }
      case 288: {
        ue_context_ref_at_source_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ue_context_ref_at_source, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 323: {
        mbs_active_session_info_sourceto_target_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_active_session_info_sourceto_target_list, bref, 1, 256, true));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.unpack(bref));
        break;
      }
      case 355: {
        ngap_ie_support_info_request_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ngap_ie_support_info_request_list, bref, 1, 32, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (s_gnb_ue_x2ap_id_present) {
    j.write_int("id", 182);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", s_gnb_ue_x2ap_id);
  }
  if (ue_history_info_from_the_ue_present) {
    j.write_int("id", 253);
    j.write_str("criticality", "ignore");
    ue_history_info_from_the_ue.to_json(j);
  }
  if (source_node_id_present) {
    j.write_int("id", 286);
    j.write_str("criticality", "ignore");
    source_node_id.to_json(j);
  }
  if (ue_context_ref_at_source_present) {
    j.write_int("id", 288);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", ue_context_ref_at_source);
  }
  if (mbs_active_session_info_sourceto_target_list_present) {
    j.write_int("id", 323);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_active_session_info_sourceto_target_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (q_mcc_onfig_info_present) {
    j.write_int("id", 328);
    j.write_str("criticality", "ignore");
    q_mcc_onfig_info.to_json(j);
  }
  if (ngap_ie_support_info_request_list_present) {
    j.write_int("id", 355);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : ngap_ie_support_info_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// SourceNGRANNode-ToTargetNGRANNode-TransparentContainer ::= SEQUENCE
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_res_info_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(erab_info_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(idx_to_rfsp_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.pack(bref));
  if (pdu_session_res_info_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_info_list, 1, 256, true));
  }
  if (erab_info_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, erab_info_list, 1, 256, true));
  }
  HANDLE_CODE(target_cell_id.pack(bref));
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, ue_history_info, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool pdu_session_res_info_list_present;
  HANDLE_CODE(bref.unpack(pdu_session_res_info_list_present, 1));
  bool erab_info_list_present;
  HANDLE_CODE(bref.unpack(erab_info_list_present, 1));
  HANDLE_CODE(bref.unpack(idx_to_rfsp_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.unpack(bref));
  if (pdu_session_res_info_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_info_list, bref, 1, 256, true));
  }
  if (erab_info_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(erab_info_list, bref, 1, 256, true));
  }
  HANDLE_CODE(target_cell_id.unpack(bref));
  if (idx_to_rfsp_present) {
    HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(ue_history_info, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void source_ngran_node_to_target_ngran_node_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rRCContainer", rrc_container.to_string());
  if (pdu_session_res_info_list.size() > 0) {
    j.start_array("pDUSessionResourceInformationList");
    for (const auto& e1 : pdu_session_res_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (erab_info_list.size() > 0) {
    j.start_array("e-RABInformationList");
    for (const auto& e1 : erab_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_fieldname("targetCell-ID");
  target_cell_id.to_json(j);
  if (idx_to_rfsp_present) {
    j.write_int("indexToRFSP", idx_to_rfsp);
  }
  j.start_array("uEHistoryInformation");
  for (const auto& e1 : ue_history_info) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetNGRANNode-ToSourceNGRANNode-FailureTransparentContainer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {356};
  return map_enum_number(names, 1, idx, "id");
}
bool target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 356 == id;
}
crit_e target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 356) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 356) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 356) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("NGAPIESupportInformationResponseList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 32, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 32, true));
  return SRSASN_SUCCESS;
}

const char*
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NGAPIESupportInformationResponseList"};
  return convert_enum_idx(
      names, 1, value, "target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::types");
}

// TargetNGRANNode-ToSourceNGRANNode-FailureTransparentContainer ::= SEQUENCE
SRSASN_CODE target_ngran_node_to_source_ngran_node_fail_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cell_cag_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (cell_cag_info_present) {
    HANDLE_CODE(cell_cag_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_fail_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cell_cag_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cell_cag_info_present) {
    HANDLE_CODE(cell_cag_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void target_ngran_node_to_source_ngran_node_fail_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cell_cag_info_present) {
    j.write_fieldname("cell-CAGInformation");
    cell_cag_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// TargetNGRANNode-ToSourceNGRANNode-TransparentContainer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {267, 22, 324, 356};
  return map_enum_number(names, 4, idx, "id");
}
bool target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {267, 22, 324, 356};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 267:
      return crit_e::ignore;
    case 22:
      return crit_e::ignore;
    case 324:
      return crit_e::ignore;
    case 356:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 267:
      ret.set(ext_c::types::daps_resp_info_list);
      break;
    case 22:
      ret.set(ext_c::types::direct_forwarding_path_availability);
      break;
    case 324:
      ret.set(ext_c::types::mbs_active_session_info_targetto_source_list);
      break;
    case 356:
      ret.set(ext_c::types::ngap_ie_support_info_resp_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 267:
      return presence_e::optional;
    case 22:
      return presence_e::optional;
    case 324:
      return presence_e::optional;
    case 356:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::set(types::options e)
{
  type_ = e;
  switch (type_) {
    case types::daps_resp_info_list:
      c = daps_resp_info_list_l{};
      break;
    case types::direct_forwarding_path_availability:
      c = direct_forwarding_path_availability_e{};
      break;
    case types::mbs_active_session_info_targetto_source_list:
      c = mbs_active_session_info_targetto_source_list_l{};
      break;
    case types::ngap_ie_support_info_resp_list:
      c = ngap_ie_support_info_resp_list_l{};
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
}
daps_resp_info_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::daps_resp_info_list()
{
  assert_choice_type(types::daps_resp_info_list, type_, "Extension");
  return c.get<daps_resp_info_list_l>();
}
direct_forwarding_path_availability_e&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Extension");
  return c.get<direct_forwarding_path_availability_e>();
}
mbs_active_session_info_targetto_source_list_l& target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::
    ext_c::mbs_active_session_info_targetto_source_list()
{
  assert_choice_type(types::mbs_active_session_info_targetto_source_list, type_, "Extension");
  return c.get<mbs_active_session_info_targetto_source_list_l>();
}
ngap_ie_support_info_resp_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_resp_list()
{
  assert_choice_type(types::ngap_ie_support_info_resp_list, type_, "Extension");
  return c.get<ngap_ie_support_info_resp_list_l>();
}
const daps_resp_info_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::daps_resp_info_list() const
{
  assert_choice_type(types::daps_resp_info_list, type_, "Extension");
  return c.get<daps_resp_info_list_l>();
}
const direct_forwarding_path_availability_e&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::direct_forwarding_path_availability()
    const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Extension");
  return c.get<direct_forwarding_path_availability_e>();
}
const mbs_active_session_info_targetto_source_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::
    mbs_active_session_info_targetto_source_list() const
{
  assert_choice_type(types::mbs_active_session_info_targetto_source_list, type_, "Extension");
  return c.get<mbs_active_session_info_targetto_source_list_l>();
}
const ngap_ie_support_info_resp_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_resp_list() const
{
  assert_choice_type(types::ngap_ie_support_info_resp_list, type_, "Extension");
  return c.get<ngap_ie_support_info_resp_list_l>();
}
void target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::daps_resp_info_list:
      j.start_array("DAPSResponseInfoList");
      for (const auto& e1 : c.get<daps_resp_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::mbs_active_session_info_targetto_source_list:
      j.start_array("MBS-ActiveSessionInformation-TargettoSourceList");
      for (const auto& e1 : c.get<mbs_active_session_info_targetto_source_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ngap_ie_support_info_resp_list:
      j.start_array("NGAPIESupportInformationResponseList");
      for (const auto& e1 : c.get<ngap_ie_support_info_resp_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::daps_resp_info_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<daps_resp_info_list_l>(), 1, 32, true));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::mbs_active_session_info_targetto_source_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_active_session_info_targetto_source_list_l>(), 1, 256, true));
      break;
    case types::ngap_ie_support_info_resp_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngap_ie_support_info_resp_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::daps_resp_info_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<daps_resp_info_list_l>(), bref, 1, 32, true));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::mbs_active_session_info_targetto_source_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_active_session_info_targetto_source_list_l>(), bref, 1, 256, true));
      break;
    case types::ngap_ie_support_info_resp_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngap_ie_support_info_resp_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DAPSResponseInfoList",
                                "DirectForwardingPathAvailability",
                                "MBS-ActiveSessionInformation-TargettoSourceList",
                                "NGAPIESupportInformationResponseList"};
  return convert_enum_idx(
      names, 4, value, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o>;

SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += daps_resp_info_list_present ? 1 : 0;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  nof_ies += mbs_active_session_info_targetto_source_list_present ? 1 : 0;
  nof_ies += ngap_ie_support_info_resp_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (daps_resp_info_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)267, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, daps_resp_info_list, 1, 32, true));
  }
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)22, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  if (mbs_active_session_info_targetto_source_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)324, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_active_session_info_targetto_source_list, 1, 256, true));
  }
  if (ngap_ie_support_info_resp_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)356, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ngap_ie_support_info_resp_list, 1, 32, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 267: {
        daps_resp_info_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(daps_resp_info_list, bref, 1, 32, true));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.unpack(bref));
        break;
      }
      case 324: {
        mbs_active_session_info_targetto_source_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(mbs_active_session_info_targetto_source_list, bref, 1, 256, true));
        break;
      }
      case 356: {
        ngap_ie_support_info_resp_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ngap_ie_support_info_resp_list, bref, 1, 32, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (daps_resp_info_list_present) {
    j.write_int("id", 267);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : daps_resp_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (direct_forwarding_path_availability_present) {
    j.write_int("id", 22);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "direct-path-available");
  }
  if (mbs_active_session_info_targetto_source_list_present) {
    j.write_int("id", 324);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : mbs_active_session_info_targetto_source_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ngap_ie_support_info_resp_list_present) {
    j.write_int("id", 356);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : ngap_ie_support_info_resp_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// TargetNGRANNode-ToSourceNGRANNode-TransparentContainer ::= SEQUENCE
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_ngran_node_to_source_ngran_node_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rRCContainer", rrc_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEContextResumeRequestTransfer ::= SEQUENCE
SRSASN_CODE ue_context_resume_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_failed_to_resume_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_resume_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool qos_flow_failed_to_resume_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_resume_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_resume_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_resume_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_flow_failed_to_resume_list.size() > 0) {
    j.start_array("qosFlowFailedToResumeList");
    for (const auto& e1 : qos_flow_failed_to_resume_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEContextResumeResponseTransfer ::= SEQUENCE
SRSASN_CODE ue_context_resume_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_failed_to_resume_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_resume_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool qos_flow_failed_to_resume_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_resume_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_resume_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_flow_failed_to_resume_list.size() > 0) {
    j.start_array("qosFlowFailedToResumeList");
    for (const auto& e1 : qos_flow_failed_to_resume_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SuspendIndicator ::= ENUMERATED
const char* suspend_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "suspend_ind_e");
}

// UEContextSuspendRequestTransfer ::= SEQUENCE
SRSASN_CODE ue_context_suspend_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(suspend_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (suspend_ind_present) {
    HANDLE_CODE(suspend_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(suspend_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (suspend_ind_present) {
    HANDLE_CODE(suspend_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (suspend_ind_present) {
    j.write_str("suspendIndicator", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}
